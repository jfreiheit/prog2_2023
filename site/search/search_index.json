{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren II \u00b6 Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8 - 9.30 bzw. 14-15.30 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt! Grober Inhalt (kann sich noch \u00e4ndern) \u00b6 Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 10.-14.04.2023 Organisatorisches , Wiederholung , Aufz\u00e4hlungstypen , Einstieg - - - 1. 17.-21.04.2023 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2023 2. 24.-28.04.2023 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2023 3. 01.-05.05.2023 Exceptions II \u00dcbung 3 Aufgabe 3 16.05.2023 4. 08.-12.05.2023 Collections (List und Set) \u00dcbung 4 Aufgabe 4 23.05.2023 5. 15.-19.05.2023 - - - - 6. 22.-26.05.2023 Collections (Map) \u00dcbung 5 Aufgabe 5 30.05.2023 7. 29.-02.06.2023 Abstrakte Klassen \u00dcbung 6 Aufgabe 6 06.06.2023 8. 05.-09.06.2023 Interfaces \u00dcbung 7 Aufgabe 7 20.06.2023 9. 12.-16.06.2023 GUI Einf\u00fchrung \u00dcbung 8 Aufgabe 8 27.06.2023 10. 19.-23.06.2023 JUnit und Layout-Manager \u00dcbung 9 Aufgabe 9 04.07.2023 12. 26.-30.06.2023 GUI Ereignisse \u00dcbung 10 Aufgabe 10 11.07.2023 13. 03.-07.07.2023 ActionListener \u00dcbung 11 - - 14. 10.-14.07.2023 Mausereignisse \u00dcbung 12 - - 28.07.2023 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 29.09.2023 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - - Inhalte \u00b6 14.04.2023 - Einf\u00fchrung und Organisatorisches + Wiederholung + enum + Einstieg siehe Organisatorisches siehe Wiederholung siehe Aufz\u00e4hlungstypen siehe Einstieg siehe Aufgabe 1 Code aus der Vorlesung Programmklasse.java StaticLesson.java Weekday.java Konto.java package vorlesungen.vorlesung0414 ; import javax.swing.JOptionPane ; public class Programmklasse { public static void printIrgendwas ( String ausgabe ) { System . out . println ( ausgabe ); } public static void printDay ( int day ) { switch ( day ) { case 0 -> System . out . println ( \"Montag\" ); case 1 -> System . out . println ( \"Dienstag\" ); case 2 -> System . out . println ( \"Mittwoch\" ); case 3 -> System . out . println ( \"Donnerstag\" ); case 4 -> System . out . println ( \"Freitag\" ); case 5 -> System . out . println ( \"Samstag\" ); case 6 -> System . out . println ( \"Sonntag\" ); default -> System . out . println ( \"kein Tag\" ); } } public static void printDay ( String day ) { switch ( day ) { case \"Mo\" -> System . out . println ( \"Montag\" ); case \"Di\" -> System . out . println ( \"Dienstag\" ); case \"Mi\" -> System . out . println ( \"Mittwoch\" ); case \"Do\" -> System . out . println ( \"Donnerstag\" ); case \"Fr\" -> System . out . println ( \"Freitag\" ); case \"Sa\" -> System . out . println ( \"Samstag\" ); case \"So\" -> System . out . println ( \"Sonntag\" ); default -> System . out . println ( \"kein Tag\" ); } } public static void printDay ( Weekday day ) { switch ( day ) { case MO -> System . out . println ( \"Montag\" ); case DI -> System . out . println ( \"Dienstag\" ); case MI -> System . out . println ( \"Mittwoch\" ); case DO -> System . out . println ( \"Donnerstag\" ); case FR -> System . out . println ( \"Freitag\" ); case SA -> System . out . println ( \"Samstag\" ); case SO -> System . out . println ( \"Sonntag\" ); } } public static void main ( String [] args ) { printIrgendwas ( \"Endlich wieder Programmieren!\" ); StaticLesson . print (); Math . abs ( - 5 ); System . out . println ( StaticLesson . PI ); Konto k1 = new Konto (); Konto k2 = new Konto (); Konto k3 = new Konto (); Konto k4 = new Konto (); System . out . println ( k4 . knr ); Konto [] konten = new Konto [ 5 ] ; for ( int i = 0 ; i < konten . length ; i ++ ) { konten [ i ] = new Konto (); } for ( Konto element : konten ) { System . out . println ( element . knr ); } for ( int i = 0 ; i < konten . length ; i ++ ) { System . out . println ( konten [ i ] . knr ); } /* int result = JOptionPane.showConfirmDialog(null, \"Wirklich beenden?\", \"Mein Titel\", JOptionPane.YES_NO_CANCEL_OPTION); if(result == JOptionPane.NO_OPTION) { System.out.println(\"Nein geklickt\"); } else if(result == JOptionPane.YES_OPTION) { System.out.println(\"Ja geklickt\"); } else if(result == JOptionPane.CANCEL_OPTION) { System.out.println(\"Abbrechen geklickt\"); } String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl :\"); System.out.println(\"Sie haben \" + eingabe + \" eingegeben\"); */ printDay ( 5 ); printDay ( \"hallo\" ); printDay ( Weekday . FR ); Weekday day = Weekday . FR ; } } package vorlesungen.vorlesung0414 ; public class StaticLesson { public static final double PI = 3.14 ; public static void print () { System . out . println ( \"Hallo FIW\" ); } } package vorlesungen.vorlesung0414 ; public enum Weekday { MO , DI , MI , DO , FR , SA , SO } package vorlesungen.vorlesung0414 ; public class Konto { int knr ; static int anzKonten = 0 ; Konto () { this . knr = anzKonten ++ ; } }","title":"Home"},{"location":"#programmieren-ii","text":"Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren II"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8 - 9.30 bzw. 14-15.30 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!","title":"Organisatorisches"},{"location":"#grober-inhalt-kann-sich-noch-andern","text":"Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 10.-14.04.2023 Organisatorisches , Wiederholung , Aufz\u00e4hlungstypen , Einstieg - - - 1. 17.-21.04.2023 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2023 2. 24.-28.04.2023 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2023 3. 01.-05.05.2023 Exceptions II \u00dcbung 3 Aufgabe 3 16.05.2023 4. 08.-12.05.2023 Collections (List und Set) \u00dcbung 4 Aufgabe 4 23.05.2023 5. 15.-19.05.2023 - - - - 6. 22.-26.05.2023 Collections (Map) \u00dcbung 5 Aufgabe 5 30.05.2023 7. 29.-02.06.2023 Abstrakte Klassen \u00dcbung 6 Aufgabe 6 06.06.2023 8. 05.-09.06.2023 Interfaces \u00dcbung 7 Aufgabe 7 20.06.2023 9. 12.-16.06.2023 GUI Einf\u00fchrung \u00dcbung 8 Aufgabe 8 27.06.2023 10. 19.-23.06.2023 JUnit und Layout-Manager \u00dcbung 9 Aufgabe 9 04.07.2023 12. 26.-30.06.2023 GUI Ereignisse \u00dcbung 10 Aufgabe 10 11.07.2023 13. 03.-07.07.2023 ActionListener \u00dcbung 11 - - 14. 10.-14.07.2023 Mausereignisse \u00dcbung 12 - - 28.07.2023 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 29.09.2023 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - -","title":"Grober Inhalt (kann sich noch \u00e4ndern)"},{"location":"#inhalte","text":"14.04.2023 - Einf\u00fchrung und Organisatorisches + Wiederholung + enum + Einstieg siehe Organisatorisches siehe Wiederholung siehe Aufz\u00e4hlungstypen siehe Einstieg siehe Aufgabe 1 Code aus der Vorlesung Programmklasse.java StaticLesson.java Weekday.java Konto.java package vorlesungen.vorlesung0414 ; import javax.swing.JOptionPane ; public class Programmklasse { public static void printIrgendwas ( String ausgabe ) { System . out . println ( ausgabe ); } public static void printDay ( int day ) { switch ( day ) { case 0 -> System . out . println ( \"Montag\" ); case 1 -> System . out . println ( \"Dienstag\" ); case 2 -> System . out . println ( \"Mittwoch\" ); case 3 -> System . out . println ( \"Donnerstag\" ); case 4 -> System . out . println ( \"Freitag\" ); case 5 -> System . out . println ( \"Samstag\" ); case 6 -> System . out . println ( \"Sonntag\" ); default -> System . out . println ( \"kein Tag\" ); } } public static void printDay ( String day ) { switch ( day ) { case \"Mo\" -> System . out . println ( \"Montag\" ); case \"Di\" -> System . out . println ( \"Dienstag\" ); case \"Mi\" -> System . out . println ( \"Mittwoch\" ); case \"Do\" -> System . out . println ( \"Donnerstag\" ); case \"Fr\" -> System . out . println ( \"Freitag\" ); case \"Sa\" -> System . out . println ( \"Samstag\" ); case \"So\" -> System . out . println ( \"Sonntag\" ); default -> System . out . println ( \"kein Tag\" ); } } public static void printDay ( Weekday day ) { switch ( day ) { case MO -> System . out . println ( \"Montag\" ); case DI -> System . out . println ( \"Dienstag\" ); case MI -> System . out . println ( \"Mittwoch\" ); case DO -> System . out . println ( \"Donnerstag\" ); case FR -> System . out . println ( \"Freitag\" ); case SA -> System . out . println ( \"Samstag\" ); case SO -> System . out . println ( \"Sonntag\" ); } } public static void main ( String [] args ) { printIrgendwas ( \"Endlich wieder Programmieren!\" ); StaticLesson . print (); Math . abs ( - 5 ); System . out . println ( StaticLesson . PI ); Konto k1 = new Konto (); Konto k2 = new Konto (); Konto k3 = new Konto (); Konto k4 = new Konto (); System . out . println ( k4 . knr ); Konto [] konten = new Konto [ 5 ] ; for ( int i = 0 ; i < konten . length ; i ++ ) { konten [ i ] = new Konto (); } for ( Konto element : konten ) { System . out . println ( element . knr ); } for ( int i = 0 ; i < konten . length ; i ++ ) { System . out . println ( konten [ i ] . knr ); } /* int result = JOptionPane.showConfirmDialog(null, \"Wirklich beenden?\", \"Mein Titel\", JOptionPane.YES_NO_CANCEL_OPTION); if(result == JOptionPane.NO_OPTION) { System.out.println(\"Nein geklickt\"); } else if(result == JOptionPane.YES_OPTION) { System.out.println(\"Ja geklickt\"); } else if(result == JOptionPane.CANCEL_OPTION) { System.out.println(\"Abbrechen geklickt\"); } String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl :\"); System.out.println(\"Sie haben \" + eingabe + \" eingegeben\"); */ printDay ( 5 ); printDay ( \"hallo\" ); printDay ( Weekday . FR ); Weekday day = Weekday . FR ; } } package vorlesungen.vorlesung0414 ; public class StaticLesson { public static final double PI = 3.14 ; public static void print () { System . out . println ( \"Hallo FIW\" ); } } package vorlesungen.vorlesung0414 ; public enum Weekday { MO , DI , MI , DO , FR , SA , SO } package vorlesungen.vorlesung0414 ; public class Konto { int knr ; static int anzKonten = 0 ; Konto () { this . knr = anzKonten ++ ; } }","title":"Inhalte"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Aufgabe 1 (W\u00fcrfelspiel) \u00b6 Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! Aufgabe 2 (MyInteger) \u00b6 Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-wurfelspiel","text":"Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 1 (W\u00fcrfelspiel)"},{"location":"aufgaben/#aufgabe-2-myinteger","text":"Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 2 (MyInteger)"},{"location":"einstieg/","text":"Einstieg \u00b6 Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe23 // SoSe23 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION Beispiel showConfirmDialog() \u00b6 Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters. Beispiel mit YES_NO_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } Beispiel mit YES_NO_CANCEL_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster: Beispiel showInputDialog() \u00b6 Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig. Ausblick \u00b6 Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Einstieg"},{"location":"einstieg/#einstieg","text":"Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe23 // SoSe23 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION","title":"Einstieg"},{"location":"einstieg/#beispiel-showconfirmdialog","text":"Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters.","title":"Beispiel showConfirmDialog()"},{"location":"einstieg/#beispiel-mit-yes_no_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt }","title":"Beispiel mit YES_NO_OPTION"},{"location":"einstieg/#beispiel-mit-yes_no_cancel_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster:","title":"Beispiel mit YES_NO_CANCEL_OPTION"},{"location":"einstieg/#beispiel-showinputdialog","text":"Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig.","title":"Beispiel showInputDialog()"},{"location":"einstieg/#ausblick","text":"Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Ausblick"},{"location":"enum/","text":"Aufz\u00e4hlungstypen (enum) \u00b6 Motivation \u00b6 Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar Erster Verbesserungsversuch: Konstanten \u00b6 Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; // Feld ist leer static final int RED = 1 ; // auf das Feld hat rot gesetzt static final int BLACK = 2 ; // auf das Feld hat schwarz gesetzt TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; // hier wird auf das Feld rot oder schwarz gesetzt } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich Der Aufz\u00e4hlungstyp enum \u00b6 Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich Details: \u00b6 alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; } Weiteres: \u00b6 auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen noch ein Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } } N\u00fctzliche Links f\u00fcr enums \u00b6 Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"Aufz\u00e4hlungstypen"},{"location":"enum/#aufzahlungstypen-enum","text":"","title":"Aufz\u00e4hlungstypen (enum)"},{"location":"enum/#motivation","text":"Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar","title":"Motivation"},{"location":"enum/#erster-verbesserungsversuch-konstanten","text":"Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; // Feld ist leer static final int RED = 1 ; // auf das Feld hat rot gesetzt static final int BLACK = 2 ; // auf das Feld hat schwarz gesetzt TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; // hier wird auf das Feld rot oder schwarz gesetzt } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich","title":"Erster Verbesserungsversuch: Konstanten"},{"location":"enum/#der-aufzahlungstyp-enum","text":"Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich","title":"Der Aufz\u00e4hlungstyp enum"},{"location":"enum/#details","text":"alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; }","title":"Details:"},{"location":"enum/#weiteres","text":"auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen noch ein Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } }","title":"Weiteres:"},{"location":"enum/#nutzliche-links-fur-enums","text":"Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"N\u00fctzliche Links f\u00fcr enums"},{"location":"exceptions/","text":"Exceptions \u00b6 Motivation Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt? Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. try-catch \u00b6 Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. Beispiel ohne try-catch \u00b6 Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. Beispiel mit try-catch \u00b6 Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an: Ablauf einer Ausnahmesituation \u00b6 Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird. Ein weiteres Beispiel \u00b6 Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigens k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet. Beispiel mit mehreren Exceptions \u00b6 Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wandeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an: Die Vererbungshierarchie der Klasse Exception \u00b6 Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen. try-catch-finally \u00b6 Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren. throws - eine Exception weiterreichen \u00b6 Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. Sch\u00f6ner Code \u00b6 Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. throw - eigene Exceptions erzeugen \u00b6 Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Triangle im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ). throw new IllegalArgumentException \u00b6 Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen. Eigene Exception-Klasse definieren \u00b6 Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"Motivation Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt? Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt.","title":"Exceptions"},{"location":"exceptions/#try-catch","text":"Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren.","title":"try-catch"},{"location":"exceptions/#beispiel-ohne-try-catch","text":"Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten.","title":"Beispiel ohne try-catch"},{"location":"exceptions/#beispiel-mit-try-catch","text":"Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:","title":"Beispiel mit try-catch"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","text":"Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird.","title":"Ablauf einer Ausnahmesituation"},{"location":"exceptions/#ein-weiteres-beispiel","text":"Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigens k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet.","title":"Ein weiteres Beispiel"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","text":"Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wandeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an:","title":"Beispiel mit mehreren Exceptions"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","text":"Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen.","title":"Die Vererbungshierarchie der Klasse Exception"},{"location":"exceptions/#try-catch-finally","text":"Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren.","title":"try-catch-finally"},{"location":"exceptions/#throws-eine-exception-weiterreichen","text":"Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln.","title":"throws - eine Exception weiterreichen"},{"location":"exceptions/#schoner-code","text":"Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an.","title":"Sch\u00f6ner Code"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","text":"Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Triangle im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ).","title":"throw - eigene Exceptions erzeugen"},{"location":"exceptions/#throw-new-illegalargumentexception","text":"Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.","title":"throw new IllegalArgumentException"},{"location":"exceptions/#eigene-exception-klasse-definieren","text":"Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Eigene Exception-Klasse definieren"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbung 1 (Codereview und static) \u00b6 Was ist an diesem Code alles falsch? package uebungen.uebung1 ; /* * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius) * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit) */ public class Konvertierung { private double celsius ; private double fahrenheit ; public Konvertierung ( double celsius ) { this . celsius = celsius ; this . fahrenheit = celsius * 1.8 + 32 ; } public Konvertierung ( double fahrenheit ) { this . celsius = fahrenheit - 32 * 5 / 9 ; this . fahrenheit = fahrenheit ; } public void print () { System . out . println ( this . celsius + \"\\u00B0C = \" + this . fahrenheit + \"\\u00B0F\" ); } } Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 package uebungen.uebung1 ; /* * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius) * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit) */ public class Konvertierung { private Konvertierung () { } public static double celsiusToFahrenheit ( double celsius ) { final double FACTOR_CELSIUS_TO_FAHRENHEIT = 1.8 ; final int DIFFERENCE_CELSIUS_TO_FAHRENHEIT = 32 ; double fahrenheit = celsius * FACTOR_CELSIUS_TO_FAHRENHEIT + DIFFERENCE_CELSIUS_TO_FAHRENHEIT ; return fahrenheit ; } public static double fahrenheitToCelsius ( double fahrenheit ) { final double FACTOR_FAHRENHEIT_TO_CELSIUS = 5.0 / 9.0 ; final int DIFFERENCE_FAHRENHEIT_TO_CELSIUS = 32 ; double celsius = ( fahrenheit - DIFFERENCE_FAHRENHEIT_TO_CELSIUS ) * FACTOR_FAHRENHEIT_TO_CELSIUS ; return celsius ; } } \u00dcbung 2 (String und algorithmisches Denken) \u00b6 \u00dcbung 2 Erstellen Sie im Paket uebungen.uebung2 eine Java-Klasse Uebung2 mit main() -Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String . \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten. Implementieren Sie eine Methode static boolean isBinaryNumber(String s) . Diese Methode \u00fcberpr\u00fcft, ob der String s einer Bin\u00e4rzahl entspricht, d.h. ob er nur 0 und 1 enth\u00e4lt. Testen Sie die Methode isBinaryNumber(String s) z.B. mit den folgenden Aufrufen: System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false Implementieren Sie eine Methode static int binaryToDecimal(String s) . Diese Methode wandelt den String s in eine Dezimalzahl um, wenn s einer Bin\u00e4rzahl entspricht. Wenn s keiner Bin\u00e4rzahl entspricht, wird -1 zur\u00fcckgegeben. Testen Sie die Methode binaryToDecimal(String s) z.B. mit den folgenden Aufrufen: System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 Implementieren Sie eine Methode static String toLowerCase(String input) . Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an. Testen Sie die Methode toLowerCase(String input) z.B. mit den folgenden Aufrufen: System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% Zusatz: Implementieren Sie eine Methode static boolean isPalindrome(String input) . Diese Methode pr\u00fcft, ob es sich bei input um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus String ist dabei wahrscheinlich n\u00fctzlich! Testen Sie die Methode isPalindrome(String input) z.B. mit den folgenden Aufrufen: System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false Angenommen, Sie sollen f\u00fcr einen gegebenen String angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: ((()))()(()) // korrekt ((()) // nicht korrekt (())) // nicht korrekt ())( // nicht korrekt","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubung-1-codereview-und-static","text":"Was ist an diesem Code alles falsch? package uebungen.uebung1 ; /* * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius) * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit) */ public class Konvertierung { private double celsius ; private double fahrenheit ; public Konvertierung ( double celsius ) { this . celsius = celsius ; this . fahrenheit = celsius * 1.8 + 32 ; } public Konvertierung ( double fahrenheit ) { this . celsius = fahrenheit - 32 * 5 / 9 ; this . fahrenheit = fahrenheit ; } public void print () { System . out . println ( this . celsius + \"\\u00B0C = \" + this . fahrenheit + \"\\u00B0F\" ); } } Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 package uebungen.uebung1 ; /* * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius) * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit) */ public class Konvertierung { private Konvertierung () { } public static double celsiusToFahrenheit ( double celsius ) { final double FACTOR_CELSIUS_TO_FAHRENHEIT = 1.8 ; final int DIFFERENCE_CELSIUS_TO_FAHRENHEIT = 32 ; double fahrenheit = celsius * FACTOR_CELSIUS_TO_FAHRENHEIT + DIFFERENCE_CELSIUS_TO_FAHRENHEIT ; return fahrenheit ; } public static double fahrenheitToCelsius ( double fahrenheit ) { final double FACTOR_FAHRENHEIT_TO_CELSIUS = 5.0 / 9.0 ; final int DIFFERENCE_FAHRENHEIT_TO_CELSIUS = 32 ; double celsius = ( fahrenheit - DIFFERENCE_FAHRENHEIT_TO_CELSIUS ) * FACTOR_FAHRENHEIT_TO_CELSIUS ; return celsius ; } }","title":"\u00dcbung 1 (Codereview und static)"},{"location":"uebungen/#ubung-2-string-und-algorithmisches-denken","text":"\u00dcbung 2 Erstellen Sie im Paket uebungen.uebung2 eine Java-Klasse Uebung2 mit main() -Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String . \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten. Implementieren Sie eine Methode static boolean isBinaryNumber(String s) . Diese Methode \u00fcberpr\u00fcft, ob der String s einer Bin\u00e4rzahl entspricht, d.h. ob er nur 0 und 1 enth\u00e4lt. Testen Sie die Methode isBinaryNumber(String s) z.B. mit den folgenden Aufrufen: System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false Implementieren Sie eine Methode static int binaryToDecimal(String s) . Diese Methode wandelt den String s in eine Dezimalzahl um, wenn s einer Bin\u00e4rzahl entspricht. Wenn s keiner Bin\u00e4rzahl entspricht, wird -1 zur\u00fcckgegeben. Testen Sie die Methode binaryToDecimal(String s) z.B. mit den folgenden Aufrufen: System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 Implementieren Sie eine Methode static String toLowerCase(String input) . Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an. Testen Sie die Methode toLowerCase(String input) z.B. mit den folgenden Aufrufen: System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% Zusatz: Implementieren Sie eine Methode static boolean isPalindrome(String input) . Diese Methode pr\u00fcft, ob es sich bei input um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus String ist dabei wahrscheinlich n\u00fctzlich! Testen Sie die Methode isPalindrome(String input) z.B. mit den folgenden Aufrufen: System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false Angenommen, Sie sollen f\u00fcr einen gegebenen String angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: ((()))()(()) // korrekt ((()) // nicht korrekt (())) // nicht korrekt ())( // nicht korrekt","title":"\u00dcbung 2 (String und algorithmisches Denken)"},{"location":"wiederholung/","text":"Wiederholung \u00b6 Datentypen \u00b6 Wertetypen \u00b6 es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!! Referenztypen \u00b6 es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? } Datenstrukturen \u00b6 Variablen \u00b6 einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden } Arrays \u00b6 Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0 Literale \u00b6 sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5 Ausdr\u00fccke \u00b6 kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, . Anweisungen \u00b6 Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; } Methoden \u00b6 wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); } Vererbung \u00b6 Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden Konstruktoren \u00b6 besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 } Access Controller (Zugriffsmodifizierer) \u00b6 Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse \"Kleinigkeiten\", die wir nicht betrachtet haben \u00b6 Das Schl\u00fcsselwort static \u00b6 Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen. Die for-each -Schleife \u00b6 Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ). Die Klasse java.util.Arrays \u00b6 Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Wiederholung"},{"location":"wiederholung/#wiederholung","text":"","title":"Wiederholung"},{"location":"wiederholung/#datentypen","text":"","title":"Datentypen"},{"location":"wiederholung/#wertetypen","text":"es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!!","title":"Wertetypen"},{"location":"wiederholung/#referenztypen","text":"es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? }","title":"Referenztypen"},{"location":"wiederholung/#datenstrukturen","text":"","title":"Datenstrukturen"},{"location":"wiederholung/#variablen","text":"einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden }","title":"Variablen"},{"location":"wiederholung/#arrays","text":"Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0","title":"Arrays"},{"location":"wiederholung/#literale","text":"sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5","title":"Literale"},{"location":"wiederholung/#ausdrucke","text":"kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, .","title":"Ausdr\u00fccke"},{"location":"wiederholung/#anweisungen","text":"Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; }","title":"Anweisungen"},{"location":"wiederholung/#methoden","text":"wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); }","title":"Methoden"},{"location":"wiederholung/#vererbung","text":"Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden","title":"Vererbung"},{"location":"wiederholung/#konstruktoren","text":"besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 }","title":"Konstruktoren"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","text":"Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse","title":"Access Controller (Zugriffsmodifizierer)"},{"location":"wiederholung/#kleinigkeiten-die-wir-nicht-betrachtet-haben","text":"","title":"\"Kleinigkeiten\", die wir nicht betrachtet haben"},{"location":"wiederholung/#das-schlusselwort-static","text":"Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen.","title":"Das Schl\u00fcsselwort static"},{"location":"wiederholung/#die-for-each-schleife","text":"Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ).","title":"Die for-each-Schleife"},{"location":"wiederholung/#die-klasse-javautilarrays","text":"Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Die Klasse java.util.Arrays"},{"location":"wrapper/","text":"Wrapper-Klassen \u00b6 Motivation Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen String zu einem int (oder double ) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen . In Programmierung I haben wir am Anfang die Datentypen int , boolean , double , char , long usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen , welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character Objekterzeugung \u00b6 Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen. Verwendung des Kontruktors - deprecated \u00b6 F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden. Die valueOf() -Methoden \u00b6 Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenname.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich. Auto-Boxing \u00b6 Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 ); Werte extrahieren \u00b6 H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse<WrapperTyp> -Methode verwendet wird. Strings in Wertetypen \u00b6 Wir wissen jetzt schon, dass wir uns mithilfe der valueOf(String s) -Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von intValue() k\u00f6nnte man z.B. aus einem Intger -Objekt den int -Wert extrahieren. Das ginge auch mit Auto-Unboxing . F\u00fcr die Umwandlung von String nach int verwendet man aber am besten die parseInt() -Methode. String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); int zahl = Integer . parseInt ( eingabe ); F\u00fcr double steht uns daf\u00fcr Double.parseDouble(String s) zur Verf\u00fcgung usw. Success Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen String in einen int umwandeln! Wir kennen nun Wrapper-Klassen und deren parseXXX(String) -Methoden. Links zu den Java-Docs \u00b6 Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die parseInt(String) -Methode werfen? Ausblick \u00b6 Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?","title":"Wrapper-Klassen"},{"location":"wrapper/#wrapper-klassen","text":"Motivation Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen String zu einem int (oder double ) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen . In Programmierung I haben wir am Anfang die Datentypen int , boolean , double , char , long usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen , welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character","title":"Wrapper-Klassen"},{"location":"wrapper/#objekterzeugung","text":"Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen.","title":"Objekterzeugung"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","text":"F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden.","title":"Verwendung des Kontruktors - deprecated"},{"location":"wrapper/#die-valueof-methoden","text":"Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenname.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich.","title":"Die valueOf()-Methoden"},{"location":"wrapper/#auto-boxing","text":"Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 );","title":"Auto-Boxing"},{"location":"wrapper/#werte-extrahieren","text":"H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse<WrapperTyp> -Methode verwendet wird.","title":"Werte extrahieren"},{"location":"wrapper/#strings-in-wertetypen","text":"Wir wissen jetzt schon, dass wir uns mithilfe der valueOf(String s) -Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von intValue() k\u00f6nnte man z.B. aus einem Intger -Objekt den int -Wert extrahieren. Das ginge auch mit Auto-Unboxing . F\u00fcr die Umwandlung von String nach int verwendet man aber am besten die parseInt() -Methode. String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); int zahl = Integer . parseInt ( eingabe ); F\u00fcr double steht uns daf\u00fcr Double.parseDouble(String s) zur Verf\u00fcgung usw. Success Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen String in einen int umwandeln! Wir kennen nun Wrapper-Klassen und deren parseXXX(String) -Methoden.","title":"Strings in Wertetypen"},{"location":"wrapper/#links-zu-den-java-docs","text":"Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die parseInt(String) -Methode werfen?","title":"Links zu den Java-Docs"},{"location":"wrapper/#ausblick","text":"Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?","title":"Ausblick"}]}