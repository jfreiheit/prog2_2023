{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programmieren II","text":"<p>Herzlich willkommen zur Programmieren II-Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben:</p> <ol> <li>L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben!</li> <li>Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen!</li> <li>Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. </li> <li>Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren...</li> <li>Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens.</li> <li>Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid!</li> </ol> <p>Viel Erfolg! Und viel Spa\u00df!</p>"},{"location":"#organisatorisches","title":"Organisatorisches","text":"<p>Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt:</p> <ul> <li>Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht.</li> <li>Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt.</li> <li>Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. </li> <li>Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen.</li> <li>Die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8 - 9.30 bzw. 14-15.30 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen.</li> <li>Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben.</li> <li>Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu</li> </ul> <p>Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren.</p> <p>Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. </p> <p>Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen, die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen.  </p> <p>F\u00fcr die Kommunikation untereinander verwenden wir Slack. Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!</p>"},{"location":"#grober-inhalt-kann-sich-noch-andern","title":"Grober Inhalt (kann sich noch \u00e4ndern)","text":"<p>Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln.  </p> <p>Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). </p> Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 10.-14.04.2023 Organisatorisches, Wiederholung, Aufz\u00e4hlungstypen, Einstieg - \u00a0- - 1. 17.-21.04.2023 Wrapper-Klassen (boxing und unboxing)Exceptions I \u00dcbung 1 Aufgabe 1 27.04.2023 2. 24.-28.04.2023 Exceptions II \u00dcbung 2 Aufgabe 2 04.05.2023 3. 01.-05.05.2023 Collections (List und Set) \u00dcbung 3 Aufgabe 3 18.05.2023 4. 08.-12.05.2023 Collections (Map) und Abstrakte Klassen \u00dcbung 4 Aufgabe 4 25.05.2023 5. 15.-19.05.2023 - - - - 6. 22.-26.05.2023 Interfaces \u00dcbung 5 Aufgabe 5 01.06.2023 7. 29.-02.06.2023 GUI Einf\u00fchrung \u00dcbung 6 Aufgabe 6 08.06.2023 8. 05.-09.06.2023 GUI Ereignisse \u00dcbung 7 Aufgabe 7 15.06.2023 9. 12.-16.06.2023 ActionListener \u00dcbung 8 Aufgabe 8 22.06.2023 10. 19.-23.06.2023 Mausereignisse \u00dcbung 9 Aufgabe 9 29.06.2023 12. 26.-30.06.2023 Graphics \u00dcbung 10 Aufgabe 10 06.07.2023 13. 03.-07.07.2023 JUnit \u00dcbung 11 \u00a0- - 14. 10.-14.07.2023 REST-API mit SpringBoot \u00dcbung 12 \u00a0- - 28.07.2023 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 29.09.2023 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - -"},{"location":"#inhalte","title":"Inhalte","text":"14.04.2023 - Einf\u00fchrung und Organisatorisches + Wiederholung + enum + Einstieg <ul> <li>siehe Organisatorisches</li> <li>siehe Wiederholung</li> <li>siehe Aufz\u00e4hlungstypen</li> <li>siehe Einstieg</li> <li>siehe Aufgabe 1</li> </ul> Code aus der Vorlesung Programmklasse.javaStaticLesson.javaWeekday.javaKonto.java <pre><code>package vorlesungen.vorlesung0414;\n\nimport javax.swing.JOptionPane;\n\npublic class Programmklasse {\n\npublic static void printIrgendwas(String ausgabe) {\nSystem.out.println(ausgabe);\n}\n\npublic static void printDay(int day) {\nswitch(day) {\ncase 0 -&gt; System.out.println(\"Montag\");\ncase 1 -&gt; System.out.println(\"Dienstag\");\ncase 2 -&gt; System.out.println(\"Mittwoch\");\ncase 3 -&gt; System.out.println(\"Donnerstag\");\ncase 4 -&gt; System.out.println(\"Freitag\");\ncase 5 -&gt; System.out.println(\"Samstag\");\ncase 6 -&gt; System.out.println(\"Sonntag\");\ndefault -&gt; System.out.println(\"kein Tag\");\n}\n}\n\n\npublic static void printDay(String day) {\nswitch(day) {\ncase \"Mo\" -&gt; System.out.println(\"Montag\");\ncase \"Di\" -&gt; System.out.println(\"Dienstag\");\ncase \"Mi\" -&gt; System.out.println(\"Mittwoch\");\ncase \"Do\" -&gt; System.out.println(\"Donnerstag\");\ncase \"Fr\" -&gt; System.out.println(\"Freitag\");\ncase \"Sa\" -&gt; System.out.println(\"Samstag\");\ncase \"So\" -&gt; System.out.println(\"Sonntag\");\ndefault -&gt; System.out.println(\"kein Tag\");\n}\n}\n\n\npublic static void printDay(Weekday day) {\nswitch(day) {\ncase MO -&gt; System.out.println(\"Montag\");\ncase DI -&gt; System.out.println(\"Dienstag\");\ncase MI -&gt; System.out.println(\"Mittwoch\");\ncase DO -&gt; System.out.println(\"Donnerstag\");\ncase FR -&gt; System.out.println(\"Freitag\");\ncase SA -&gt; System.out.println(\"Samstag\");\ncase SO -&gt; System.out.println(\"Sonntag\");\n}\n}\n\npublic static void main(String[] args) {\nprintIrgendwas(\"Endlich wieder Programmieren!\");\n\nStaticLesson.print();\n\nMath.abs(-5);\n\nSystem.out.println(StaticLesson.PI);\n\nKonto k1 = new Konto();\nKonto k2 = new Konto();\nKonto k3 = new Konto();\nKonto k4 = new Konto();\nSystem.out.println(k4.knr);\n\nKonto[] konten = new Konto[5];\nfor(int i = 0; i &lt; konten.length; i++) {\nkonten[i] = new Konto();\n}\n\nfor(Konto element : konten) {\nSystem.out.println(element.knr);\n}\n\nfor(int i = 0; i &lt; konten.length; i++) {\nSystem.out.println(konten[i].knr);\n}\n\n/*\n        int result = JOptionPane.showConfirmDialog(null, \"Wirklich beenden?\", \"Mein Titel\", JOptionPane.YES_NO_CANCEL_OPTION);\n        if(result == JOptionPane.NO_OPTION) {\n            System.out.println(\"Nein geklickt\");\n        } else if(result == JOptionPane.YES_OPTION) {\n            System.out.println(\"Ja geklickt\");\n        } else if(result == JOptionPane.CANCEL_OPTION) {\n            System.out.println(\"Abbrechen geklickt\");\n        }\n\n        String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl :\");\n        System.out.println(\"Sie haben \" + eingabe + \" eingegeben\");\n*/\n\nprintDay(5);\nprintDay(\"hallo\");\n\nprintDay(Weekday.FR);\n\nWeekday day = Weekday.FR;\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0414;\n\npublic class StaticLesson {\n\npublic static final double PI = 3.14;\n\npublic static void print() {\nSystem.out.println(\"Hallo FIW\");\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0414;\n\npublic enum Weekday {\nMO, DI, MI, DO, FR, SA, SO\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0414;\n\npublic class Konto {\n\nint knr;\nstatic int anzKonten = 0;\n\nKonto() {\nthis.knr = anzKonten++;\n}\n\n}\n</code></pre> 21.04.2023 - Wrapper-Klassen und Exceptions I <ul> <li>siehe Wrapper-Klassen</li> <li>siehe Exceptions I</li> <li>siehe Aufgabe 2</li> </ul> Code aus der Vorlesung WrapperKlassen.java <pre><code>package vorlesungen.vorlesung0421;\n\nimport javax.swing.JOptionPane;\n\npublic class WrapperKlassen {\n\npublic static void main(String[] args) {\n\n\n// Wertetyp --&gt; Referenztyp\n\n// Kontruktoren deprecated -- nicht verwenden!\nInteger i1 = new Integer(100);\nInteger i2 = new Integer(\"100\");\n\nDouble d1 = new Double(5.5);\nDouble d2 = new Double(\"5.5\");\n\n// erste Moeglichkeit zur Objekterzeugung\nInteger i3 = Integer.valueOf(101);\nInteger i4 = Integer.valueOf(\"101\");\n\nCharacter c1 = Character.valueOf('a');\n//Character c2 = Character.valueOf(\"a\");\n\nBoolean b1 = Boolean.valueOf(true);\nBoolean b2 = Boolean.valueOf(\"true\");\n\n// zweite Moeglichkeit - Auto-Boxing\nInteger i5 = 5000;\nInteger i6 = 5000;\nInteger i7 = 5001;\n// Integer i6 = \"5000\";\n\nBoolean b3 = true;\n\n\n// Referenztyp --&gt; Wertetyp\n\n// erste Moeglichkeit xxxValue()\n\nint i10 = i3.intValue();\nboolean b10 = b1.booleanValue();\n\n// zweite Moeglichkeit Auto-Unboxing\n\nint i11 = i5;\nSystem.out.println(i5 == i6);   // false wegen Referenzvergleich\nSystem.out.println(i7 &gt; i6);    // true wegen Auto-Unboxing\nboolean eingabeOk = false;\nString message = \"Geben Sie eine Zahl ein : \";\nwhile(!eingabeOk) {\n\nString eingabe = JOptionPane.showInputDialog(message);\nSystem.out.println(\"Sie haben \" + eingabe + \" eingegeben.\");\n\ntry {\n//double nr2 = Double.parseDouble(eingabe);\n//System.out.println(\"double-Zahl \" + nr2);\nint number = Integer.parseInt(eingabe);\nint nr1 = 5;\nint result = nr1 / number;\nSystem.out.println(nr1 + \"/\" + number + \" = \" + result);\neingabeOk = true;\n} catch(NumberFormatException e) {\nmessage = \"Eingabe war keine Zahl!\";\n}\ncatch(ArithmeticException e) {\nmessage = \"Durch 0 kann nicht dividiert werden!\";\n}\n\n}\n\nSystem.out.println(\"Ende\");\n\n\n}\n\n}\n</code></pre> Video der Vorlesung 28.04.2023 - Exceptions II <ul> <li>siehe Exceptions II</li> <li>siehe Aufgabe 3</li> </ul> Code aus der Vorlesung Ausnahmen.javaTriangle.javaIllegalSideLengthException.javaIllegalTriangleException.java <pre><code>package vorlesungen.vorlesung0428;\n\npublic class Ausnahmen {\n\nstatic int getValueAtIndex(int[] field, int index) throws ArrayIndexOutOfBoundsException\n{\nreturn field[index];\n}\n\nstatic char getValueAtIndex(String input, int index) throws StringIndexOutOfBoundsException\n{\nreturn input.charAt(index);\n}\n\npublic static void main(String[] args) {\nString[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\ndouble result= 0;\n\nfor(int index = 0; index &lt;= basen.length; index++) {\n\ntry {\nString basisString = basen[index];\n\nint basis = Integer.parseInt(basisString);\n\nfor(int exp = 0; exp&lt;6; exp++) {\nresult = Math.pow(basis, exp);\nSystem.out.printf(\"%d ^ %d = %.0f %n\", basis, exp, result);\n}\n\n}catch(NumberFormatException e)\n{\nSystem.out.println(\"keine Zahl!\");\n}catch(ArrayIndexOutOfBoundsException e)\n{\nSystem.out.println(\"kein korrekter Index!\");\n}\n\n}\n\nint[] arr = {1, 2, 3, 4, 5 };\n\ntry {\ngetValueAtIndex(arr, 5);\n} catch (ArrayIndexOutOfBoundsException e) {\n// TODO Auto-generated catch block\n//e.printStackTrace();\n}\n\nTriangle t1 = new Triangle(0, 4, 3);\nSystem.out.println(t1.area());\n\n\nSystem.out.println(\"Ende\");\n}\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0428;\n\npublic class Triangle {\nprivate int a;\nprivate int b;\nprivate int c;\n\npublic Triangle(int a, int b, int c) throws IllegalSideLengthException, IllegalTriangleException\n{\nif(a &lt;= 0 || b&lt;= 0 || c &lt;= 0) {\nthrow new IllegalSideLengthException();\n} else if(a &gt;= (b+c) || b &gt;= (a+c) || c &gt;= (a+b)) {\nthrow new IllegalTriangleException();\n}\nelse {\nthis.a = a;\nthis.b = b;\nthis.c = c;\n}\n}\n\npublic int circumference()\n{\nreturn this.a + this.b + this.c;\n}\n\npublic double area()\n{\ndouble area = 0.0;\ndouble s = 0.5 * (this.a+this.b+this.c);\narea = Math.sqrt(s * (s-this.a) * (s-this.b) * (s-this.c));\nreturn area;\n}\n\npublic boolean equilateral()\n{\nreturn this.a==this.b &amp;&amp; this.b==this.c;\n}\n\npublic boolean isosceles()\n{\nreturn this.a==this.b || this.b==this.c || this.c==this.a;\n}\n\npublic void print()\n{\nSystem.out.println(\"Seiten          : a=\" + this.a + \", b=\" + this.b + \", c=\" + this.c);\nSystem.out.println(\"Umfang          : \" + this.circumference());\nSystem.out.println(\"Flaecheninhalt  : \" + this.area());\nif(this.equilateral())\n{\nSystem.out.println(\"Das Dreieck ist gleichseitig.\");\n}\nelse\n{\nif(this.isosceles())\n{\nSystem.out.println(\"Das Dreieck ist gleichschenklig.\");\n}\nelse\n{\nSystem.out.println(\"Das Dreieck ist unregelmaessig.\");\n}\n}\nif(this.isRightAngled())\n{\nSystem.out.println(\"Das Dreieck ist rechtwinklig.\");\n}\nelse\n{\nSystem.out.println(\"Das Dreieck ist nicht rechtwinklig.\");\n}\nSystem.out.println();\n}\n\npublic boolean sameCircumference(Triangle t)\n{\nreturn this.circumference()==t.circumference();\n}\n\npublic boolean sidesAreEqual(Triangle t)\n{\nreturn (this.a==t.a &amp;&amp; this.b==t.b &amp;&amp; this.c==t.c) ||\n(this.a==t.b &amp;&amp; this.b==t.c &amp;&amp; this.c==t.a) ||\n(this.a==t.c &amp;&amp; this.b==t.a &amp;&amp; this.c==t.b);\n}\n\npublic boolean isRightAngled()\n{\nreturn ((this.a*this.a == (this.b*this.b + this.c*this.c)) ||\n(this.b*this.b == (this.a*this.a + this.c*this.c)) ||\n(this.c*this.c == (this.b*this.b + this.a*this.a)));\n}\n\npublic boolean isSmaller(Triangle t)\n{\nreturn this.area() &lt; t.area();\n}\n\npublic boolean isBigger(Triangle t)\n{\nreturn this.area() &gt; t.area();\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0428;\n\npublic class IllegalSideLengthException extends RuntimeException\n{\npublic IllegalSideLengthException(String s)\n{\nsuper(s);\n}\n\npublic IllegalSideLengthException()\n{\nsuper(\"All sides must be greater than zero!\");\n}\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0428;\n\npublic class IllegalTriangleException extends RuntimeException\n{\npublic IllegalTriangleException(String s)\n{\nsuper(s);\n}\n\npublic IllegalTriangleException()\n{\nsuper(\"No side greater than the sum of the other sides!\");\n}\n}\n</code></pre> 12.05.2023 - Maps und Abstrakte Klassen <ul> <li>siehe Collections (Map)</li> <li>siehe Abstrakte Klassen</li> <li>siehe Aufgabe 5</li> </ul> Code aus der Vorlesung Maps.javaShape.javaRectangle.javaCircle.java <pre><code>package vorlesungen.vorlesung0512;\n\nimport java.util.*;\n\n\npublic class Maps {\npublic static void printShape(Shape s)\n{\nSystem.out.println(\"Area      : \" + s.area());\nSystem.out.println(\"Perimeter : \" + s.perimeter());\n}\n\npublic static void main(String[] args) {\nMap&lt;Integer, String&gt; table = new HashMap&lt;&gt;();\ntable.put(12459, \"Berlin\");\ntable.put(10435, \"Berlin\");\ntable.put(18055, \"Rostock\");\ntable.put(15711, \"KW\");\ntable.put(15711, \"Koenigs Wusterhausen\");\n\nSystem.out.printf(\"%n%n--------- alle keys ---------%n%n\");\n\nSet&lt;Integer&gt; keys = table.keySet();\nfor(Integer key : keys)\n{\nSystem.out.println(key);\n}\n\nSystem.out.printf(\"%n%n--------- alle values ---------%n%n\");\n\nCollection&lt;String&gt; values = table.values();\nfor(String value : values)\n{\nSystem.out.println(value);\n}\n\nSystem.out.printf(\"%n%n--------- alle entries ---------%n%n\");\nSet&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = table.entrySet();\nfor(Map.Entry&lt;Integer, String&gt; entry : entries)\n{\nSystem.out.println(\"PLZ: \" + entry.getKey() + \" Ort : \" + entry.getValue());\n}\n\nSystem.out.printf(\"%n%n--------- Shape ---------%n%n\");\nShape s1 = new Rectangle(10, 20);\nSystem.out.println(\"Area      : \" + s1.area());\nSystem.out.println(\"Perimeter : \" + s1.perimeter());\n\nShape s2 = new Circle(5.0);\nprintShape(s1);\nprintShape(s2);\n\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0512;\n\npublic abstract class Shape {\n\npublic abstract double perimeter();\npublic abstract double area();\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0512;\n\npublic class Rectangle extends Shape\n{\nprivate int width, height;\n\n\npublic Rectangle(int width, int height) {\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {\nreturn 2 * (this.width + this.height);\n}\n\n@Override\npublic double area() {\nreturn this.width * this.height;\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0512;\n\npublic class Circle extends Shape\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n}\n</code></pre> 26.05.2023 - Interfaces <ul> <li>siehe Interfaces</li> <li>siehe \u00dcbung 6</li> <li>siehe Aufgabe 6</li> </ul> Code aus der Vorlesung Testklasse.javaShape.javaRectangle.javaCircle.javaPrintable.java <pre><code>package vorlesungen.vorlesung0526;\n\npublic class Testklasse {\n\npublic static void sortieren(Comparable[] unsortiert)\n{\nfor(int bubble=1; bubble &lt; unsortiert.length; bubble++)\n{\nfor(int index = 0; index &lt; unsortiert.length-bubble; index++)\n{\nif(unsortiert[index].compareTo(unsortiert[index+1]) &gt; 0)\n{\nComparable tmp = unsortiert[index];\nunsortiert[index] = unsortiert[index + 1];\nunsortiert[index + 1] = tmp;\n}\n}\n}\n}\n\npublic static void printArray(Printable[] arr)\n{\nfor(Printable p : arr)\n{\np.print();\n}\n}\n\npublic static void main(String[] args) {   System.out.printf(\"%n%n------------------------ Rectangle --------------------------%n%n\");\nRectangle[] rectArr = new Rectangle[6];\nrectArr[0] = new Rectangle(9, 13);\nrectArr[1] = new Rectangle(4, 17);\nrectArr[2] = new Rectangle(12, 5);\nrectArr[3] = new Rectangle(8, 9);\nrectArr[4] = new Rectangle(10, 11);\nrectArr[5] = new Rectangle(5, 15);\nSystem.out.println(rectArr[5] instanceof Rectangle);\nSystem.out.println(rectArr[5] instanceof Object);\nSystem.out.println(rectArr[5] instanceof Shape);\nSystem.out.println(rectArr[5] instanceof Comparable);\nSystem.out.println(rectArr[5] instanceof Printable);\n\nfor(Rectangle r : rectArr)\n{\nSystem.out.println(r);\n}\n\nsortieren(rectArr);\nSystem.out.println();\n\nprintArray(rectArr);\n\nSystem.out.println();\nprintArray(rectArr);\n\nSystem.out.printf(\"%n%n------------------------ Shape --------------------------%n%n\");\nCircle[] circArr = new Circle[6];\ncircArr[0] = new Circle(5.0);\ncircArr[1] = new Circle(5.5);\ncircArr[2] = new Circle(4.0);\ncircArr[3] = new Circle(2.5);\ncircArr[4] = new Circle(7.0);\ncircArr[5] = new Circle(1.0);\nfor(Circle c : circArr)\n{\nSystem.out.println(c);\n}\n\nsortieren(circArr);\nSystem.out.println();\n\nfor(Circle c : circArr)\n{\nSystem.out.println(c);\n}\n\nSystem.out.println();\nprintArray(circArr);\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0526;\n\npublic abstract class Shape {\n\npublic abstract double perimeter();\npublic abstract double area();\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0526;\n\npublic class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;, Printable\n{\nprivate int width, height;\n\n\npublic Rectangle(int width, int height) {\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {\nreturn 2 * (this.width + this.height);\n}\n\n@Override\npublic double area() {\nreturn this.width * this.height;\n}\n\n@Override\npublic String toString()\n{\nString s = String.format(\"[ %3d x %3d = %7.2f ]\", this.width, this.height, this.area());\nreturn s;\n}\n\n@Override\npublic int compareTo(Rectangle o) {\nreturn (this.width + this.height) - (o.width + o.height);\n}\n\n@Override\npublic void print() {\nSystem.out.println(this.toString());\n\n}\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0526;\n\npublic class Circle extends Shape implements Comparable&lt;Circle&gt;, Printable\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n@Override\npublic String toString()\n{\nString s = String.format(\"( radius: %.2f x --&gt; area: %7.2f ]\", this.radius, this.area());\nreturn s;\n}\n\n@Override\npublic int compareTo(Circle o) {\nreturn (int)((this.radius - o.radius)* 10000);\n}\n\n@Override\npublic void print() {\nSystem.out.println(this.toString());\n}\n\n\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0526;\n\npublic interface Printable {\n\npublic void print();\n\n}\n</code></pre> 02.06.2023 - Graphical User Interfaces <ul> <li>siehe GUI Einf\u00fchrung</li> <li>siehe \u00dcbung 7</li> <li>siehe Aufgabe 7</li> </ul> Code aus der Vorlesung MyFirstWindow.javaTestklasse.java <pre><code>package vorlesungen.vorlesung0602;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.FlowLayout;\nimport java.awt.GridLayout;\n\nimport javax.swing.*;\n\n\npublic class MyFirstWindow extends JFrame\n{\npublic MyFirstWindow()\n{\nsuper();\nthis.setTitle(\"Mein erstes Fenster\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.setSize(800, 600);\nthis.setLocation(300, 500);\nJPanel mainPanel = this.initContent();\nthis.getContentPane().add(mainPanel);\nthis.setVisible(true);\n}\n\npublic JPanel initContent()\n{\nJPanel content = new JPanel();\n//content.setLayout(new FlowLayout(FlowLayout.CENTER, 120, 140));\n//content.setLayout(new GridLayout(3, 2, 20, 40));\ncontent.setLayout(new BorderLayout());\n/*\n        JLabel label = new JLabel(\"Name langer Text: \"); \n        content.add(label);\n\n        JTextField input = new JTextField(30);\n        content.add(input);\n        */\n\nJButton button1 = new JButton(\"Button1\");\ncontent.add(button1, BorderLayout.NORTH);\nJButton button2 = new JButton(\"Button2\");\ncontent.add(button2, BorderLayout.EAST);\nJButton button3 = new JButton(\"Button3\");\ncontent.add(button3, BorderLayout.SOUTH);\nJButton button4 = new JButton(\"Button4\");\ncontent.add(button4, BorderLayout.WEST);\nJButton button5 = new JButton(\"Button5\");\ncontent.add(button5, BorderLayout.CENTER);\n\n/*\n        JButton button6 = new JButton(\"Button6\");\n        content.add(button6, BorderLayout.NORTH);\n\n        JButton button7 = new JButton(\"Button7\");\n        content.add(button7);\n        */\n\nreturn content;\n}\n}\n</code></pre> <pre><code>package vorlesungen.vorlesung0602;\n\npublic class Testklasse {\n\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n}\n</code></pre> 09.06.2023 - Ereignisbehandlung <ul> <li>siehe GUI Ereignisse</li> <li>siehe \u00dcbung 8</li> <li>siehe Aufgabe 8</li> </ul> Code aus der Vorlesung Ereignisbehandlung.java <pre><code>package vorlesungen.vorlesung0609;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame\n{\nJLabel output;\nInteger anzKlicks = 0;\n\nEreignisbehandlung()\n{\nsuper();\nthis.setTitle(\"Ereignisbehandlung\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\nJPanel content = createContent();\nthis.getContentPane().add(content);\n\nthis.setSize(300, 200);\nthis.setLocation(200,100);\nthis.setVisible(true);\n}\n\nJPanel createContent()\n{\nJPanel mainPanel = new JPanel();\nmainPanel.setLayout(new BorderLayout());\n\nJPanel oben = new JPanel();\nJButton minus = new JButton(\"-\");\nJButton plus = new JButton(\"+\");\noben.add(minus);\noben.add(plus);\nminus.setActionCommand(\"minus\");\nplus.setActionCommand(\"plus\");\nminus.addActionListener(new ActionHandler());\nplus.addActionListener(new ActionHandler());\nmainPanel.add(oben, BorderLayout.NORTH);\n\n/*\n        JButton button = new JButton(\"Klick mich\");\n        button.addActionListener(this);\n        mainPanel.add(button, BorderLayout.NORTH);\n        */\n\nthis.output = new JLabel(this.anzKlicks.toString());\nthis.output.setHorizontalAlignment(JLabel.CENTER);\nthis.output.setFont(new Font (\"Helvetica\", Font.BOLD, 24));\nmainPanel.add(this.output, BorderLayout.CENTER);\nreturn mainPanel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n\nInteger i1 = 120;\nInteger i2 = 120;\nInteger i3 = 5001;\nInteger i4 = 5001;\nSystem.out.println(i1 == i2);\nSystem.out.println(i3 == i4);\n}\n\n/*\n    @Override\n    public void actionPerformed(ActionEvent e) \n    {\n        Object source = e.getSource();\n        if(source instanceof JButton) \n        {\n            JButton srcBtn = (JButton)source;\n            System.out.println(\"Button \" + srcBtn.getText() + \" geklickt\");\n            if(srcBtn.getActionCommand().equals(\"minus\")) {\n                this.anzKlicks--;\n            } else if(srcBtn.getActionCommand().equals(\"plus\")) {\n                this.anzKlicks++;\n            }\n            if(this.anzKlicks &lt; 0) this.output.setForeground(Color.RED);\n            else this.output.setForeground(Color.BLACK);\n            this.output.setText(this.anzKlicks.toString());\n        }\n\n    }\n    */\n\nclass ActionHandler implements ActionListener\n{\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nObject source = e.getSource();\nif(source instanceof JButton)\n{\nJButton srcBtn = (JButton)source;\nSystem.out.println(\"Button \" + srcBtn.getText() + \" geklickt\");\nif(srcBtn.getActionCommand().equals(\"minus\")) {\nEreignisbehandlung.this.anzKlicks--;\n} else if(srcBtn.getActionCommand().equals(\"plus\")) {\n\n}\n\n}\n\n}\n\n}\n}\n</code></pre> 16.06.2023 - Ereignisbehandlung <ul> <li>siehe ActionListener</li> <li>siehe \u00dcbung 9</li> <li>siehe Aufgabe 9</li> </ul>"},{"location":"abstrakt/","title":"Abstrakte Klassen","text":"<p>Abstrakte Klassen  haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von <code>Collection</code> anschauen, dann finden wir darin</p> <ul> <li>Interfaces: die Klassen <code>Collection</code>, <code>List</code>, <code>Set</code>, <code>SortedSet</code> und <code>NavigableSet</code> sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und</li> <li>Abtrakte Klassen: die Klassen <code>AbstractCollection</code>, <code>AbstractList</code> und <code>AbstractSet</code> sind solche abstrakten Klassen (die schauen wir uns jetzt an)</li> </ul> <p></p>"},{"location":"abstrakt/#klassen-allgemein","title":"Klassen - allgemein","text":"<p>Wir haben uns bis jetzt Klassen erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um</li> <li>daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt.  </li> </ol> <p>Angenommen, in der Klasse wurde eine Methode implementiert</p> <pre><code>public void eineImplementierteMethode()\n{\n// Anweisungen\n}\n</code></pre> <p>, dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren <code>refVariable.eineImplementierteMethode();</code>. </p>"},{"location":"abstrakt/#klassen-abstrakt","title":"Klassen - abstrakt","text":"<p>Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen. Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen alle Eigenschaften erben zu lassen. </li> </ol> <p>Der dritte obere Punkt gilt nicht! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen. </p> <p>Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse.</p>"},{"location":"abstrakt/#abstrakte-methoden","title":"Abstrakte Methoden","text":"<p>Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon):</p> <pre><code>public abstract void eineAbstrakteMethode();\n</code></pre> <p>Das Schl\u00fcsselwort <code>abstract</code> gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, </p> <ul> <li>wie der Name der Methode lautet,</li> <li>welche Parameter die Methode erwartet,</li> <li>wie der R\u00fcckgabetyp der Methode ist und</li> <li>wie der Sichtbarkeitsmodifizierer dieser Methode ist.</li> </ul> <p>Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort <code>abstract</code> im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf haben, also keine <code>{ }</code>. Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon!</p>"},{"location":"abstrakt/#verwendung-abstrakter-klassen","title":"Verwendung abstrakter Klassen","text":"<p>Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen </p> <ol> <li>als Typ und </li> <li>als Basisklasse, d.h. von abstrakten Klassen wird geerbt.</li> </ol> <p>Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)!</p>"},{"location":"abstrakt/#ein-beispiel-die-abstrakte-klasse-shape","title":"Ein Beispiel - die abstrakte Klasse <code>Shape</code>","text":"<p>Wir erstellen uns eine abstrakte Klasse <code>Shape</code>, welche zwei abstrakte Methoden enth\u00e4lt, <code>perimeter()</code> und <code>area()</code>. </p> <pre><code>public abstract class Shape {   public abstract double perimeter();\npublic abstract double area();\n\n}\n</code></pre> <p>Beachten Sie, dass eine Klasse selbst als <code>abstract</code> deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile <code>1</code> ebanfalls das Schl\u00fcsselwort <code>abstract</code>. Sie lie\u00dfe sich auch sonst gar nicht compilieren. </p>"},{"location":"abstrakt/#rectangle-erbt-von-shape","title":"<code>Rectangle</code> erbt von <code>Shape</code>","text":"<p><code>Shape</code> kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse <code>Shape</code> erzeugen. Vielmehr ist die Klasse <code>Shape</code> auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse <code>Rectangle</code>, die von <code>Shape</code> erbt. </p> <p>Wenn wir nun schreiben:</p> <pre><code>public class Rectangle extends Shape\n{\n\n}\n</code></pre> <p>dann ist <code>Rectangle</code> rot unterstrichen und Eclipse bietet uns zwei <code>QuickFixes</code> an:</p> <ol> <li><code>Add unimplemnted methods</code> oder</li> <li><code>Make type Rectangle abstract</code></li> </ol> <p>Durch das Erben von <code>Shape</code> haben wir auch die beiden abstrakten Methoden <code>perimeter()</code> und <code>area()</code> geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse <code>Rectangle</code> ist selbst eine abstrakte Klasse. Wir w\u00e4hlen <code>QuickFix 1</code> und lassen die Methoden hinzuf\u00fcgen: </p> <pre><code>public class Rectangle extends Shape\n{\n\n@Override\npublic double perimeter() {\n// TODO Auto-generated method stub\nreturn 0;\n}\n\n@Override\npublic double area() {\n// TODO Auto-generated method stub\nreturn 0;\n}\n\n}\n</code></pre> <p>Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als <code>public</code> und mit R\u00fcckgabetyp <code>double</code> sowie den in <code>Shape</code> definierten Namen). Nun sind die beiden Methoden aber jeweils implementiert (aber noch nicht richtig - <code>TODO</code>). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen <code>6-9</code> und <code>13-16</code>), sind sie nicht mehr abstrakt und somit ist auch die Klasse <code>Rectangle</code> keine abstrakte Klasse. </p> <p>Eine sinnvolle Implementierung der Klasse <code>Rectangle</code> sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden <code>perimeter()</code> und <code>area()</code> sinnvoll implementieren: </p> <pre><code>public class Rectangle extends Shape\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n}\n</code></pre> <p>Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch geeignete Implementierungen f\u00fcr mindestens die von <code>Object</code> geerbten Methoden <code>equals()</code> und <code>toString()</code> enthalten. </p>"},{"location":"abstrakt/#circle-erbt-von-shape","title":"<code>Circle</code> erbt von <code>Shape</code>","text":"<p>Wir k\u00f6nnen beliebig oft von der Klasse <code>Shape</code> erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse <code>Shape</code> erben. F\u00fcr jede dieser Klassen gilt nun:</p> <ul> <li>ein Objekt dieser Klasse (z.B. ein Objekt der Klasse <code>Rectangle</code>) \"besitzt\" die Methoden <code>perimeter()</code> und <code>area()</code>,</li> <li>ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ <code>Shape</code>. </li> </ul> <p>Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: </p> <pre><code>public class Circle extends Shape\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2.0 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n}\n</code></pre>"},{"location":"abstrakt/#testen-der-klassen","title":"Testen der Klassen","text":"<p>Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein <code>Shape</code> als Parameter verwendet wird und die f\u00fcr dieses <code>Shape</code> die Methode <code>perimeter()</code> oder <code>area()</code> aufruft. Es ist ja sicher, dass jedes Objekt vom Typ <code>Shape</code> diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende <code>TestklasseShape</code>:</p> <pre><code>public class TestklasseShape {\n\npublic static void printPerimeter(Shape s)\n{\nSystem.out.printf(\"perimeter : %.2f cm%n\", s.perimeter());\n}\n\npublic static void printArea(Shape s)\n{\nSystem.out.printf(\"area      : %.2f cm%n\", s.area());\n}\n\npublic static double sumPerimeters(Shape[] shapes)\n{\ndouble sum = 0.0;\nfor(Shape s : shapes)\n{\nsum += s.perimeter();\n}\nreturn sum;\n}\n\npublic static double sumAreas(Shape[] shapes)\n{\ndouble sum = 0.0;\nfor(Shape s : shapes)\n{\nsum += s.area();\n}\nreturn sum;\n}\n\npublic static void main(String[] args) {\nShape s1 = new Rectangle(10, 20);\nShape s2 = new Circle(6.0);\nprintPerimeter(s1);\nprintPerimeter(s2);\nprintArea(s1);\nprintArea(s2);\n\nShape[] shapes = new Shape[4];\nshapes[0] = s1;\nshapes[1] = s2;\nshapes[2] = new Rectangle(5,15);\nshapes[3] = new Circle(10.0);\nSystem.out.printf(\"sum of perimeters : %.2f cm%n\", sumPerimeters(shapes));\nSystem.out.printf(\"sum of areas      : %.2f cm%n\", sumAreas(shapes));\n}\n}\n</code></pre> <p>In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ <code>Shape</code> oder vom Typ <code>Shape[]</code> erwarten. Von Objekten, die vom (Laufzeit-)Typ <code>Shape</code> sind, wissen wir, dass sie die Methoden <code>perimeter()</code> bzw. <code>area()</code> als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die <code>Shape</code>-Objekte aufrufen. </p> <p>Abstrakte Klassen fungieren also ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. <code>Rectangle</code> oder <code>Circle</code>), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden <code>perimeter()</code> und <code>area()</code> verf\u00fcgen. </p>"},{"location":"abstrakt/#beispiele-aus-den-java-paketen","title":"Beispiele aus den Java-Paketen","text":"<p>In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben. </p>"},{"location":"abstrakt/#die-abstrakte-klasse-number","title":"Die abstrakte Klasse <code>Number</code>","text":"<p>Die Klasse Number aus dem <code>java.lang</code>-Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: </p> <ul> <li><code>abstract double doubleValue()</code></li> <li><code>abstract float  floatValue()</code></li> <li><code>abstract int    intValue()</code></li> <li><code>abstract long   longValue()</code></li> </ul> <p>Alle numerischen Wrapper-Klassen erben von <code>Number</code>, d.h. die Klassen <code>Byte</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code>, <code>Long</code> und <code>Short</code> sind von <code>Number</code> abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ <code>Number</code> sind und somit die Methoden <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code> und <code>longValue()</code> als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen. </p>"},{"location":"abstrakt/#abstrakte-klassen-fur-collections","title":"Abstrakte Klassen f\u00fcr Collections","text":"<p>Beispiele f\u00fcr abstrakte Klassen finden wir auch im <code>java.util</code>-Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. <code>add()</code>, <code>addAll()</code>, <code>clear()</code>, <code>contains()</code>, <code>isEmpty()</code>, <code>iterator()</code>, <code>remove()</code> usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen <code>AbstractList</code> und <code>AbstractSet</code> ebenfalls abstrakt sind! Von <code>AbstractSet</code> erben z.B. die Klassen <code>HashSet</code>, <code>TreeSet</code> und <code>EnumSet</code>. Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in <code>AbstractCollection</code> definierten Methoden. </p> <p>Success</p> <p>Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.</p>"},{"location":"aufgaben/","title":"Aufgaben","text":""},{"location":"aufgaben/#aufgabe-1-wurfelspiel","title":"Aufgabe 1 (W\u00fcrfelspiel)","text":"Aufgabe 1 <p>Vorbereitung (siehe Einstieg)</p> <ol> <li>Informieren Sie sich \u00fcber die Klasse <code>JOptionPane</code> aus dem Paket <code>javax.swing</code> (z.B. hier oder hier oder hier)  Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei <code>module-info.java</code> haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung <code>requires java.desktop;</code> einf\u00fcgen - das ist das Modul, in dem sich das Paket <code>javax.swing</code> befindet. </li> <li>Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch <code>Yes</code> und <code>No</code> stehen) und pr\u00fcfen Sie, ob der <code>Nein</code>- oder der <code>Ja</code>-Button gedr\u00fcckt wurde (im Beispiel steht <code>A</code> f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten):     </li> </ol> <p>Aufgabe</p> <ol> <li>Implementieren Sie folgendes W\u00fcrfelspiel:<ul> <li>An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen.</li> <li>Die Spieler sind nacheinander an der Reihe.</li> <li>Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch.</li> <li>In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder<ul> <li>eine 6 w\u00fcrfelt oder er</li> <li>den Versuch freiwillig beendet.  </li> </ul> </li> <li>Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit <code>0</code> Punkten bewertet.</li> <li>Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert).</li> </ul> </li> <li>Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. <code>20</code>) erreicht hat, hat gewonnen.      Beispiel mit zwei Spielern <code>A</code> und <code>B</code> bis Gesamtpunktzahl <code>20</code>:     </li> <li>Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!</li> </ol>"},{"location":"aufgaben/#aufgabe-2-myinteger","title":"Aufgabe 2 (MyInteger)","text":"Aufgabe 2 <p>Vorbereitung (Selbstudium)</p> <ol> <li>Eine statische Variable wird mit dem Schl\u00fcsselwort <code>static</code> deklariert, also z.B. <code>static int myVariable = 0;</code>. Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable <code>myVariable</code> wurde in der Klasse <code>MyClass</code> deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber <code>MyClass.myVariable</code>. F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable.</li> <li>Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort <code>static</code> deklariert, also z.B. <code>public static void myMethod() {}</code>. Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode <code>myMethod()</code> wurde in der Klasse <code>MyClass</code> deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber <code>MyClass.myMethod()</code>. Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse <code>Math</code> statisch und wir k\u00f6nnen sie z.B. mit <code>Math.sqrt(value)</code> oder <code>Math.abs(value)</code> aufrufen. </li> <li>siehe z.B. hier oder hier oder hier</li> </ol> <p>Info: Die Klasse <code>MyInteger</code> ist eine sogenannte Wrapper-Klasse. Die Idee ist, dass <code>MyInteger</code> eine objektorientierte H\u00fclle um den <code>int</code>-Typ darstellt. Implementieren Sie die Klasse <code>MyInteger</code>. Diese Klasse hat folgende Eigenschaften:</p> <ol> <li>Statische Konstanten vom Typ <code>int</code> <code>MAX_VALUE</code> und <code>MIN_VALUE</code>, welche als Wert die gr\u00f6\u00dfte bzw. kleinste <code>int</code>-Zahl enthalten.</li> <li>Eine private Objektvariable <code>value</code> vom Typ <code>int</code>. (Dieser <code>value</code> hat jetzt eine \"objektorientierte\" H\u00fclle: <code>MyInteger</code>).</li> <li>Eine statische Methode <code>parseInt(String s)</code>, die den \u00fcbergebenen <code>String s</code> als <code>int</code>-Zahl zur\u00fcckgibt, wenn <code>s</code> einer Zahl entspricht. Wenn nicht, wirft die Methode eine <code>IllegalArgumentException</code>. Beachten Sie:     a.  <code>s</code> kann mit <code>+</code> oder <code>\u2013</code> beginnen,     b.  <code>s</code> kann f\u00fchrende Nullen aufweisen,     c.  die L\u00e4nge von <code>s</code> kann mit <code>s.length()</code> ermittelt und jedes einzelne Zeichen aus <code>s</code> kann mit <code>s.charAt(index)</code> betrachtet werden.      d.  Ist <code>s</code> leer, wird eine <code>IllegalArgumentException</code> geworfen und wenn <code>s</code> keiner Zahl entspricht auch.     e.  Die Exception wird nur weitergereicht, nicht hier behandelt.</li> <li>Zwei Konstruktoren <code>MyInteger(int value)</code> und <code>MyInteger(String s)</code>, die jeweils die Objektvariable <code>value</code> initialisieren. Der zweite Konstruktor verwendet <code>parseInt(String)</code> und kann ebenfalls eine <code>IllegalArgumentException</code> werfen (reicht die Exception von <code>parseInt(String)</code> weiter). </li> <li>Eine Objektmethode <code>intValue()</code>, die den Wert von <code>value</code> zur\u00fcckgibt.</li> <li>Eine Objektmethode <code>doubleValue()</code>, die den Wert von <code>value</code> als <code>double</code> zur\u00fcckgibt.</li> <li>Eine statische Methode <code>valueOf(String s)</code>, die ein Objekt von <code>MyInteger</code> erzeugt und zur\u00fcckgibt (und evtl. eine <code>IllegalArgumentException</code> wirft).</li> <li>Eine statische Methode <code>valueOf(int value)</code>, die ein Objekt von <code>MyInteger</code> erzeugt und zur\u00fcckgibt.</li> <li>\u00dcberschreiben Sie au\u00dferdem die Methoden <code>equals()</code> und <code>toString()</code> (Zusatz:  auch <code>hashCode()</code> \u00fcberschreiben).</li> <li>Testen Sie Ihre Klasse ausf\u00fchrlich in einer <code>Testklasse</code> mit <code>main()</code>-Methode.</li> <li>Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!</li> </ol>"},{"location":"aufgaben/#aufgabe-3-solitaire","title":"Aufgabe 3 (Solitaire)","text":"Aufgabe 3 <p>Information und Vorbereitung</p> <p>Wir wenden Aufz\u00e4hlungstypen und mehrdimensionale Arrays an. </p> <p>Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. </p> <p>Teil der Aufgabe ist es auch, \"fremden\" Code zu lesen und zu verstehen, denn einige Klassen sind bereits gegeben:</p> Klasse Point.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * ein Point repreasentiert eine Position\n * im Spielfeld, bestehend aus der Nummer \n * fuer die Zeile (row) und der Nummer\n * fuer die Spalte (col)\n */\npublic class Point {\nprivate int row;\nprivate int col;\n\n/*\n     * Konstruktor zur Erzeugung einer \n     * Position bestehend aus row und col\n     */\npublic Point(int row, int col)\n{\nthis.row = row;\nthis.col = col;\n}\n\npublic int getRow() {\nreturn this.row;\n}\n\npublic int getCol() {\nreturn this.col;\n}\n\n@Override\npublic String toString()\n{\nreturn \"(\"+ this.row + \",\" + this.col + \")\";\n}\n}\n</code></pre> Klasse Move.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * diese Klasse repraesentiert einen Zug\n * Variablen sind Point from\n * und Point to\n * es wird nicht geprueft, ob der Zug ueberhaupt\n * moeglich ist\n */\npublic class Move {\nprivate Point from;\nprivate Point to;\n\n/*\n     * ein Zug von dem from-Point (fromRow,fromCol)\n     * zum to-Point (toRow,toCol)\n     */\npublic Move(int fromRow, int fromCol, int toRow, int toCol)\n{\nthis.from = new Point(fromRow, fromCol);\nthis.to = new Point(toRow, toCol);\n}\n\n/*\n     * in dem Konstruktor werden in this.from und this.to nicht einfach\n     * die Referenzen von from und to gespeichert, sondern davon Kopien\n     * erstellt, damit das Programm robuster gegen das Aendern von\n     * Referenzen ist\n     */\npublic Move(Point from, Point to)\n{\nthis.from = new Point(from.getRow(), from.getCol());\nthis.to = new Point(to.getRow(), to.getCol());\n}\n\n/*\n     * der Getter fuer den Point from gibt keine Referenz auf\n     * den Point from zurueck, sondern eine Kopie (einen Klon)\n     * von from --&gt; Referenzen koennen \"verbogen\" werden, aber\n     * die Kopien bleiben unveraendert\n     */\npublic Point getFrom()\n{\nreturn new Point(this.from.getRow(), this.from.getCol());\n}\n\n/*\n     * der Getter fuer den Point to gibt keine Referenz auf\n     * den Point to zurueck, sondern eine Kopie (einen Klon)\n     * von to --&gt; Referenzen koennen \"verbogen\" werden, aber\n     * die Kopien bleiben unveraendert\n     */\npublic Point getTo()\n{\nreturn new Point(this.to.getRow(), this.to.getCol());\n}\n\n}\n</code></pre> Klasse Moves.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * diese Klasse repraesentiert eine Folge \n * von Zuegen (Move), die in einem Array\n * moves gespeichert sind\n */\npublic class Moves {\nprivate Move[] moves;\n\n/*\n     * der Konstruktor erstellt ein leeres moves-Array\n     * (d.h. noch keine Zuege (Moves) gespeichert)\n     */\npublic Moves()\n{\nthis.moves = new Move[0];\n}\n\n/*\n     * der Konstruktor erstellt ein moves-Array mit einem\n     * Move - dem erste Zug (firstMove) \n     */\npublic Moves(Move firstMove)\n{\nthis.moves = new Move[1];\nthis.moves[0] = firstMove;\n}\n\n/*\n     * Anzahl der bisher gespeicherten Zuege\n     */\npublic int getLength()\n{\nreturn this.moves.length;\n}\n\n/*\n     * fuegt einen Zug (nextMove) zum moves-Array hinzu\n     * dazu muss das moves-Array um 1 laenger sein als zuvor\n     * es wird eine Kopie aller Zuege erstellt und dann\n     * der nextMove hinzugefuegt\n     */\npublic void addMove(Move nextMove)\n{\nMove[] newMoves = new Move[this.moves.length + 1];\nfor (int index = 0; index &lt; this.moves.length; index++) {\nnewMoves[index] = this.moves[index];\n}\nnewMoves[newMoves.length - 1] = new Move(nextMove.getFrom(), nextMove.getTo());\nthis.moves = newMoves;\n}\n\n/*\n     * gibt den Move zurueck, der im moves-Array unter dem Index index\n     * gespeichert ist;\n     * kann sein, dass index kein korrekter Index im moves-Array ist, \n     * dann wird eine IllegalArgumentException geworfen\n     */\npublic Move getMoveAtIndex(int index) throws IllegalArgumentException\n{\ntry {\nreturn this.moves[index];\n}\ncatch(ArrayIndexOutOfBoundsException e)\n{\nthrow new IllegalArgumentException(\"kein gueltiger Index!\");\n}\n}\n\n/*\n     * Ausgabe aller im moves-Array gespeicherten Zuege\n     * wird nur zum Debuggen benoetigt\n     */\npublic void printMoves()\n{\nSystem.out.printf(\"%n---%n\");\nfor (int index = 0; index &lt; this.moves.length; index++) {\nMove move = this.moves[index];\nPoint from = move.getFrom();\nPoint to = move.getTo();\nSystem.out.println(from.toString() + \" --&gt; \" + to.toString());\n}\nSystem.out.printf(\"%n---%n%n\");\n}\n}\n</code></pre> enum State.java <pre><code>package aufgaben.aufgabe3;\n\n/*\n * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf\n * USED - der Platz ist ein Spielfeld mit Spielstein drauf\n * NOT  - der Platz gehoert nicht zum Spielfeld\n */\npublic enum State {\nFREE, USED, NOT\n}       </code></pre> <p>Aufgabe</p> <p>Bef\u00fcllen Sie die Klasse <code>Solitaire.java</code>, wie in den Kommentaren beschrieben:</p> Klasse Solitaire.java <pre><code>package aufgaben.aufgabe3.loesung;\n\npublic class Solitaire {\nprivate Moves game;\nprivate State[][] field;\n\npublic Solitaire()\n{\nthis.game = new Moves();\nthis.field = new State[7][7];\nfor(int row = 0; row &lt; this.field.length; row++)\n{\nfor(int col = 0; col &lt; this.field[row].length; col++)\n{\nif((row &lt; 2 || row &gt; 4) &amp;&amp; (col &lt; 2 || col &gt; 4))\n{\nthis.field[row][col] = State.NOT;\n}\nelse\n{\nthis.field[row][col] = State.USED;\n}\n}\n}\nthis.field[3][3] = State.FREE;\n}\n\n/*\n     * Geben Sie das Spielfeld aus! Am Anfang sollte auf der\n     * Konsole so ein Bild erscheinen:\n     *     o o o     \n     *     o o o     \n     * o o o o o o o \n     * o o o   o o o \n     * o o o o o o o \n     *     o o o     \n     *     o o o \n     * \n     */\npublic void print()\n{\n\n}\n\n/*\n     * diese Methode gibt ein true zurueck, wenn von der\n     * uebergebenen Position (row,col) ein Zug moeglich ist\n     * d.h. \n     * 1. auf der angegebenen Position muss ein Stein sein\n     * 2. zwei Steine weiter (oben, unten, rechts oder links)\n     *      darf kein Stein sein\n     * 3. dazwischen muss ein Stein sein\n     */\npublic boolean possibleFrom(int row, int col)\n{\n\nreturn false;\n}\n\n/*\n     * diese Methode gibt alle Positionen (Point) zurueck,\n     * AUF die von (fromRow,fromCol) aus gesprungen werden\n     * kann\n     */\npublic Point[] possibleTo(int fromRow, int fromCol)\n{\nif(!possibleFrom(fromRow, fromCol)) return new Point[0];\n\n/* \n         * naechste Zeile muss entfernt werden!\n         * sttatdessen muessen Sie alle Point-Objekte ermitteln AUF die\n         * gesprungen werden kann. Diese Point-Objekte werden in einem \n         * Point-Array gespeichert, welches zur\u00fcckgegeben wird.\n         */\nreturn null;\n}\n\n/* \n     * diese Methode erzeugt ein Moves-Objekt\n     * in dieses Moves-Objekt werden mithilfe der\n     * Objektmethode addMove() (aus Moves) alle\n     * moeglichen Zuege hinzugefuegt\n     * (moeglich im aktuellen Zustand von field[][])\n     */\npublic Moves possibleMoves()\n{\nMoves possibleMoves = new Moves();\n\n// next line for debugging\npossibleMoves.printMoves();\nreturn possibleMoves;\n}\n\n/*\n     * gibt ein true zurueck, wenn im aktuellen Zustand \n     * von field[][] ueberhaupt noch ein Zug moeglich ist\n     * sonst false\n     */\npublic boolean movePossible()\n{\n\nreturn false;\n}\n\n/*\n     * ruft die Methode move(Move move) auf,\n     * wenn ein Zug moeglich ist (dann true zurueck)\n     * sonst false\n     */\npublic boolean moveFirstPossible()\n{\nif(!movePossible()) return false;\n/*\n         *  hier einen moeglichen Zug ausfuehren\n         *  den ersten, den Sie finden (siehe\n         *  possibleMoves() )\n         */\nreturn true;\n}\n\n/*\n     * hier wird der Zug Move move ausgefuehrt\n     * nach dem Zug ist \n     * 1. die from-Position leer\n     * 2. die to-Position mit einem Stein besetzt\n     * 3. dazwischen leer (Stein wird \"entfernt\")\n     * falls Zug nicht moeglich, wird eine \n     * IllegalArgumentException geworfen \n     */\npublic void move(Move move) throws IllegalArgumentException\n{\n\n}\n\n}\n</code></pre> <p>Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. </p> <p>Testen Sie Ihr Spiel in einer <code>Testklasse</code>. F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen:</p> m\u00f6gliche Konsolenausgaben <pre><code>    o o o     o o o     \no o o o o o o \no o o   o o o \no o o o o o o o o o     o o o     \n\n\n---\n(1,3) --&gt; (3,3)\n(3,1) --&gt; (3,3)\n(3,5) --&gt; (3,3)\n(5,3) --&gt; (3,3)\n\n---\n\n    o o o     o   o     \no o o   o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(2,1) --&gt; (2,3)\n(2,5) --&gt; (2,3)\n(4,3) --&gt; (2,3)\n\n---\n\n    o o o     o   o     \no     o o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(0,2) --&gt; (2,2)\n(2,4) --&gt; (2,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n(4,2) --&gt; (2,2)\n\n---\n\n      o o     o     \no   o o o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(0,4) --&gt; (0,2)\n(2,3) --&gt; (2,1)\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n\n---\n\n    o         o     \no   o o o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(2,3) --&gt; (2,1)\n(2,4) --&gt; (0,4)\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (1,3)\n(4,1) --&gt; (2,1)\n\n---\n\n    o         o     \no o     o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(2,0) --&gt; (2,2)\n(2,4) --&gt; (0,4)\n(2,5) --&gt; (2,3)\n(4,2) --&gt; (2,2)\n(4,3) --&gt; (2,3)\n\n---\n\n    o         o     o   o o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(2,4) --&gt; (0,4)\n(2,5) --&gt; (2,3)\n(3,2) --&gt; (1,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n\n---\n\n    o   o     o     o o \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(2,6) --&gt; (2,4)\n(3,2) --&gt; (1,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,4) --&gt; (2,4)\n\n---\n\n    o   o     o   o     \no o o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(3,2) --&gt; (1,2)\n(3,4) --&gt; (1,4)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n\n---\n\n    o   o     o         o     \no o   o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(0,2) --&gt; (2,2)\n(3,0) --&gt; (3,2)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     o   o     \no o   o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(3,0) --&gt; (3,2)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,0) --&gt; (2,0)\n(4,1) --&gt; (2,1)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     o   o     o o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(3,2) --&gt; (1,2)\n(3,3) --&gt; (3,1)\n(3,4) --&gt; (1,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n\n---\n\n        o     o         o     o o o o \no o o o o o o o o o     o o o     \n\n\n---\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n\n---\n\n        o     o   o     o   o o \no o o o o o o o o o     o o o     \n\n\n---\n(0,4) --&gt; (2,4)\n(3,6) --&gt; (3,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         o     o   o o \no o o o o o o o o o     o o o     \n\n\n---\n(3,6) --&gt; (3,4)\n(4,3) --&gt; (2,3)\n(4,5) --&gt; (2,5)\n(4,6) --&gt; (2,6)\n(5,2) --&gt; (3,2)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         o     o o     \no o o o o o o o o o     o o o     \n\n\n---\n(3,3) --&gt; (3,5)\n(3,4) --&gt; (1,4)\n(3,4) --&gt; (3,2)\n(4,3) --&gt; (2,3)\n(5,2) --&gt; (3,2)\n\n---\n\n\n    o         o     o   \no o o o o o o o o o     o o o     \n\n\n---\n(4,5) --&gt; (2,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         o o   \n\no o o o o   o o o o     o o o     \n\n\n---\n(2,4) --&gt; (2,6)\n(2,5) --&gt; (2,3)\n(4,3) --&gt; (4,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         o \n\no o o o o   o o o o     o o o     \n\n\n---\n(4,3) --&gt; (4,5)\n(5,2) --&gt; (3,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n\n---\n\n\n    o         o \n\no o o     o o o o o     o o o     \n\n\n---\n(4,1) --&gt; (4,3)\n(4,6) --&gt; (4,4)\n(5,2) --&gt; (3,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         o \n\no     o   o o o o o     o o o     \n\n\n---\n(4,6) --&gt; (4,4)\n(5,3) --&gt; (3,3)\n(6,2) --&gt; (4,2)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         o \n\no     o o     o o o     o o o     \n\n\n---\n(4,3) --&gt; (4,5)\n(4,4) --&gt; (4,2)\n(5,3) --&gt; (3,3)\n(5,4) --&gt; (3,4)\n(6,2) --&gt; (4,2)\n\n---\n\n\n    o         o \n\no         o   o o o     o o o     \n\n\n---\n(6,2) --&gt; (4,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n\n---\n\n\n    o         o \n\no   o     o   o o     o o     \n\n\n---\n(5,4) --&gt; (5,2)\n(6,3) --&gt; (4,3)\n(6,4) --&gt; (4,4)\n(6,4) --&gt; (6,2)\n\n---\n\n\n    o         o \n\no   o     o   o         o o     \n\n\n---\n(4,2) --&gt; (6,2)\n(5,2) --&gt; (3,2)\n(6,4) --&gt; (6,2)\n\n---\n\n\n    o         o \n\no         o   o o o     o         o \n\no         o   o o o     </code></pre> <p>Dabei steht z.B.  <pre><code>    ---\n    (1,3) --&gt; (3,3)\n(3,1) --&gt; (3,3)\n(3,5) --&gt; (3,3)\n(5,3) --&gt; (3,3)\n\n---\n</code></pre> f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge.  </p>"},{"location":"aufgaben/#aufgabe-4-operationen-uber-mengen","title":"Aufgabe 4 (Operationen \u00fcber Mengen)","text":"Aufgabe 4 <p>Implementieren Sie eine Klasse <code>SetOperations</code>. </p> <ol> <li>Erstellen Sie drei Objektvariablen (z.B. <code>numbers1</code>, <code>numbers2</code> und <code>both</code>) vom Typ <code>Set&lt;Integer&gt;</code>. Erzeugen Sie f\u00fcr diese Objektvariablen <code>TreeSet</code>-Objekte.</li> <li>Erstellen Sie eine Objektmethode <code>fill()</code>. In dieser Methode sollen die beiden Sets <code>numbers1</code> und <code>numbers2</code> mit Zufallszahlen aus dem Wertebereich <code>0..99</code> bef\u00fcllt werden. Erzeugen Sie jeweils <code>100</code> Zufallszahlen (die <code>number</code>s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.)  Beachten Sie, dass die <code>nextInt()</code>-Methode ein <code>int</code> zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein <code>Integer</code>-Objekt umgewandelt werden (<code>Integer.valueOf(int)</code>) und dieses <code>Integer</code>-Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist).</li> <li>Erstellen Sie eine Objektmethode <code>fillBothUnion()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> einer Vereinigung der Mengen <code>numbers1</code> und <code>numbers2</code> entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html.</li> <li>Erstellen Sie eine Objektmethode <code>fillBothIntersection()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> einem Schnitt der Mengen <code>numbers1</code> und <code>numbers2</code> entspricht. </li> <li>Erstellen Sie eine Objektmethode <code>fillBothDifference()</code>. In dieser Methode wird die <code>both</code>-Menge derart bef\u00fcllt, dass <code>both</code> der Differenz der Menge <code>numbers1</code> minus der Menge <code>numbers2</code> entspricht. </li> <li>Schreiben Sie eine Methode <code>print()</code> so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen (<code>o, *, #, x, ...</code>) verwenden).  Gestalten Sie die Ausgabe so, dass die drei Mengen <code>numbers1</code>, <code>numbers2</code> und <code>both</code> nebeneinander auf der Konsole erscheinen. </li> <li> <p>Testen Sie alle drei Methoden <code>fillBothUnion()</code>, <code>fillBothIntersection()</code> und <code>fillBothDifference()</code>. Die Ausgabe k\u00f6nnte wie folgt sein (<code>A</code> stellt die Menge <code>numbers1</code> dar, <code>B</code> die Menge <code>numbers2</code> und rechts ist jeweils die <code>both</code>-Menge dargestellt): </p> <p></p> <p></p> <p></p> </li> </ol> <p>Tipps: </p> <ul> <li>F\u00fcr die schwarzen Punkte habe ich das Character <code>'\\u25cf'</code> verwendet (ein passendes Leerzeichen dazu ist <code>'\\u2009'</code>). Das Zeichen f\u00fcr die Vereinigung ist <code>'\\u222a'</code> und f\u00fcr den Schnitt <code>'\\u2229'</code>. </li> <li>Schauen Sie sich auch im Skript Mengenoperationen an. </li> </ul>"},{"location":"aufgaben/#aufgabe-5-maps","title":"Aufgabe 5 (Maps)","text":"Aufgabe 5 <ol> <li> <p>Gegeben ist die Klasse <code>StringPi</code>. Sie enth\u00e4lt nur eine einzige Konstante <code>PI</code> vom Typ <code>String</code>. Dieser String enth\u00e4lt die ersten <code>100 000</code> Nachkommastellen von \u03c0. Die Klasse <code>StringPi.java</code> k\u00f6nnen Sie  hier herunterladen. Sie k\u00f6nnen den Wert der Variable in Ihrer IDE an der linken Seite \"zuklappen\" (wie Methoden). Dann st\u00f6rt er sie nicht die ganze Zeit. </p> Klasse StringPi mit der Konstanten PI <pre><code>public class StringPi {\npublic static final String PI = new StringBuilder(\"3\" + \"141592653589793238462643383279502884197169399375105820974944592307816406286\" +\n\"208998628034825342117067982148086513282306647093844609550582231725359408128481\" +\n\"117450284102701938521105559644622948954930381964428810975665933446128475648233\" +\n\"786783165271201909145648566923460348610454326648213393607260249141273724587006\" +\n\"606315588174881520920962829254091715364367892590360011330530548820466521384146\" +\n\"951941511609433057270365759591953092186117381932611793105118548074462379962749\" +\n\"567351885752724891227938183011949129833673362440656643086021394946395224737190\" +\n\"702179860943702770539217176293176752384674818467669405132000568127145263560827\" +\n\"785771342757789609173637178721468440901224953430146549585371050792279689258923\" +\n\"542019956112129021960864034418159813629774771309960518707211349999998372978049\" +\n\"951059731732816096318595024459455346908302642522308253344685035261931188171010\" +\n\"003137838752886587533208381420617177669147303598253490428755468731159562863882\" +\n\"353787593751957781857780532171226806613001927876611195909216420198938095257201\" +\n\"065485863278865936153381827968230301952035301852968995773622599413891249721775\" +\n\"283479131515574857242454150695950829533116861727855889075098381754637464939319\" +\n\"255060400927701671139009848824012858361603563707660104710181942955596198946767\" +\n\"837449448255379774726847104047534646208046684259069491293313677028989152104752\" +\n\"162056966024058038150193511253382430035587640247496473263914199272604269922796\" +\n\"782354781636009341721641219924586315030286182974555706749838505494588586926995\" +\n\"690927210797509302955321165344987202755960236480665499119881834797753566369807\" +\n\"426542527862551818417574672890977772793800081647060016145249192173217214772350\" +\n\"141441973568548161361157352552133475741849468438523323907394143334547762416862\" +\n\"518983569485562099219222184272550254256887671790494601653466804988627232791786\" +\n\"085784383827967976681454100953883786360950680064225125205117392984896084128488\" +\n\"626945604241965285022210661186306744278622039194945047123713786960956364371917\" +\n\"287467764657573962413890865832645995813390478027590099465764078951269468398352\" +\n\"595709825822620522489407726719478268482601476990902640136394437455305068203496\" +\n\"252451749399651431429809190659250937221696461515709858387410597885959772975498\" +\n\"930161753928468138268683868942774155991855925245953959431049972524680845987273\" +\n\"644695848653836736222626099124608051243884390451244136549762780797715691435997\" +\n\"700129616089441694868555848406353422072225828488648158456028506016842739452267\" +\n\"467678895252138522549954666727823986456596116354886230577456498035593634568174\" +\n\"324112515076069479451096596094025228879710893145669136867228748940560101503308\" +\n\"617928680920874760917824938589009714909675985261365549781893129784821682998948\" +\n\"722658804857564014270477555132379641451523746234364542858444795265867821051141\" +\n\"354735739523113427166102135969536231442952484937187110145765403590279934403742\" +\n\"007310578539062198387447808478489683321445713868751943506430218453191048481005\" +\n\"370614680674919278191197939952061419663428754440643745123718192179998391015919\" +\n\"561814675142691239748940907186494231961567945208095146550225231603881930142093\" +\n\"762137855956638937787083039069792077346722182562599661501421503068038447734549\" +\n\"202605414665925201497442850732518666002132434088190710486331734649651453905796\" +\n\"268561005508106658796998163574736384052571459102897064140110971206280439039759\" +\n\"515677157700420337869936007230558763176359421873125147120532928191826186125867\" +\n\"321579198414848829164470609575270695722091756711672291098169091528017350671274\" +\n\"858322287183520935396572512108357915136988209144421006751033467110314126711136\" +\n\"990865851639831501970165151168517143765761835155650884909989859982387345528331\" +\n\"635507647918535893226185489632132933089857064204675259070915481416549859461637\" +\n\"180270981994309924488957571282890592323326097299712084433573265489382391193259\" +\n\"746366730583604142813883032038249037589852437441702913276561809377344403070746\" +\n\"921120191302033038019762110110044929321516084244485963766983895228684783123552\" +\n\"658213144957685726243344189303968642624341077322697802807318915441101044682325\" +\n\"271620105265227211166039666557309254711055785376346682065310989652691862056476\" +\n\"931257058635662018558100729360659876486117910453348850346113657686753249441668\" +\n\"039626579787718556084552965412665408530614344431858676975145661406800700237877\" +\n\"659134401712749470420562230538994561314071127000407854733269939081454664645880\" +\n\"797270826683063432858785698305235808933065757406795457163775254202114955761581\" +\n\"400250126228594130216471550979259230990796547376125517656751357517829666454779\" +\n\"174501129961489030463994713296210734043751895735961458901938971311179042978285\" +\n\"647503203198691514028708085990480109412147221317947647772622414254854540332157\" +\n\"185306142288137585043063321751829798662237172159160771669254748738986654949450\" +\n\"114654062843366393790039769265672146385306736096571209180763832716641627488880\" +\n\"078692560290228472104031721186082041900042296617119637792133757511495950156604\" +\n\"963186294726547364252308177036751590673502350728354056704038674351362222477158\" +\n\"915049530984448933309634087807693259939780541934144737744184263129860809988868\" +\n\"741326047215695162396586457302163159819319516735381297416772947867242292465436\" +\n\"680098067692823828068996400482435403701416314965897940924323789690706977942236\" +\n\"250822168895738379862300159377647165122893578601588161755782973523344604281512\" +\n\"627203734314653197777416031990665541876397929334419521541341899485444734567383\" +\n\"162499341913181480927777103863877343177207545654532207770921201905166096280490\" +\n\"926360197598828161332316663652861932668633606273567630354477628035045077723554\" +\n\"710585954870279081435624014517180624643626794561275318134078330336254232783944\" +\n\"975382437205835311477119926063813346776879695970309833913077109870408591337464\" +\n\"144282277263465947047458784778720192771528073176790770715721344473060570073349\" +\n\"243693113835049316312840425121925651798069411352801314701304781643788518529092\" +\n\"854520116583934196562134914341595625865865570552690496520985803385072242648293\" +\n\"972858478316305777756068887644624824685792603953527734803048029005876075825104\" +\n\"747091643961362676044925627420420832085661190625454337213153595845068772460290\" +\n\"161876679524061634252257719542916299193064553779914037340432875262888963995879\" +\n\"475729174642635745525407909145135711136941091193932519107602082520261879853188\" +\n\"770584297259167781314969900901921169717372784768472686084900337702424291651300\" +\n\"500516832336435038951702989392233451722013812806965011784408745196012122859937\" +\n\"162313017114448464090389064495444006198690754851602632750529834918740786680881\" +\n\"833851022833450850486082503930213321971551843063545500766828294930413776552793\" +\n\"975175461395398468339363830474611996653858153842056853386218672523340283087112\" +\n\"328278921250771262946322956398989893582116745627010218356462201349671518819097\" +\n\"303811980049734072396103685406643193950979019069963955245300545058068550195673\" +\n\"022921913933918568034490398205955100226353536192041994745538593810234395544959\" +\n\"778377902374216172711172364343543947822181852862408514006660443325888569867054\" +\n\"315470696574745855033232334210730154594051655379068662733379958511562578432298\" +\n\"827372319898757141595781119635833005940873068121602876496286744604774649159950\" +\n\"549737425626901049037781986835938146574126804925648798556145372347867330390468\" +\n\"838343634655379498641927056387293174872332083760112302991136793862708943879936\" +\n\"201629515413371424892830722012690147546684765357616477379467520049075715552781\" +\n\"965362132392640616013635815590742202020318727760527721900556148425551879253034\" +\n\"351398442532234157623361064250639049750086562710953591946589751413103482276930\" +\n\"624743536325691607815478181152843667957061108615331504452127473924544945423682\" +\n\"886061340841486377670096120715124914043027253860764823634143346235189757664521\" +\n\"641376796903149501910857598442391986291642193994907236234646844117394032659184\" +\n\"044378051333894525742399508296591228508555821572503107125701266830240292952522\" +\n\"011872676756220415420516184163484756516999811614101002996078386909291603028840\" +\n\"026910414079288621507842451670908700069928212066041837180653556725253256753286\" +\n\"129104248776182582976515795984703562226293486003415872298053498965022629174878\" +\n\"820273420922224533985626476691490556284250391275771028402799806636582548892648\" +\n\"802545661017296702664076559042909945681506526530537182941270336931378517860904\" +\n\"070866711496558343434769338578171138645587367812301458768712660348913909562009\" +\n\"939361031029161615288138437909904231747336394804575931493140529763475748119356\" +\n\"709110137751721008031559024853090669203767192203322909433467685142214477379393\" +\n\"751703443661991040337511173547191855046449026365512816228824462575916333039107\" +\n\"225383742182140883508657391771509682887478265699599574490661758344137522397096\" +\n\"834080053559849175417381883999446974867626551658276584835884531427756879002909\" +\n\"517028352971634456212964043523117600665101241200659755851276178583829204197484\" +\n\"423608007193045761893234922927965019875187212726750798125547095890455635792122\" +\n\"103334669749923563025494780249011419521238281530911407907386025152274299581807\" +\n\"247162591668545133312394804947079119153267343028244186041426363954800044800267\" +\n\"049624820179289647669758318327131425170296923488962766844032326092752496035799\" +\n\"646925650493681836090032380929345958897069536534940603402166544375589004563288\" +\n\"225054525564056448246515187547119621844396582533754388569094113031509526179378\" +\n\"002974120766514793942590298969594699556576121865619673378623625612521632086286\" +\n\"922210327488921865436480229678070576561514463204692790682120738837781423356282\" +\n\"360896320806822246801224826117718589638140918390367367222088832151375560037279\" +\n\"839400415297002878307667094447456013455641725437090697939612257142989467154357\" +\n\"846878861444581231459357198492252847160504922124247014121478057345510500801908\" +\n\"699603302763478708108175450119307141223390866393833952942578690507643100638351\" +\n\"983438934159613185434754649556978103829309716465143840700707360411237359984345\" +\n\"225161050702705623526601276484830840761183013052793205427462865403603674532865\" +\n\"105706587488225698157936789766974220575059683440869735020141020672358502007245\" +\n\"225632651341055924019027421624843914035998953539459094407046912091409387001264\" +\n\"560016237428802109276457931065792295524988727584610126483699989225695968815920\" +\n\"560010165525637567856672279661988578279484885583439751874454551296563443480396\" +\n\"642055798293680435220277098429423253302257634180703947699415979159453006975214\" +\n\"829336655566156787364005366656416547321704390352132954352916941459904160875320\" +\n\"186837937023488868947915107163785290234529244077365949563051007421087142613497\" +\n\"459561513849871375704710178795731042296906667021449863746459528082436944578977\" +\n\"233004876476524133907592043401963403911473202338071509522201068256342747164602\" +\n\"433544005152126693249341967397704159568375355516673027390074972973635496453328\" +\n\"886984406119649616277344951827369558822075735517665158985519098666539354948106\" +\n\"887320685990754079234240230092590070173196036225475647894064754834664776041146\" +\n\"323390565134330684495397907090302346046147096169688688501408347040546074295869\" +\n\"913829668246818571031887906528703665083243197440477185567893482308943106828702\" +\n\"722809736248093996270607472645539925399442808113736943388729406307926159599546\" +\n\"262462970706259484556903471197299640908941805953439325123623550813494900436427\" +\n\"852713831591256898929519642728757394691427253436694153236100453730488198551706\" +\n\"594121735246258954873016760029886592578662856124966552353382942878542534048308\" +\n\"330701653722856355915253478445981831341129001999205981352205117336585640782648\" +\n\"494276441137639386692480311836445369858917544264739988228462184490087776977631\" +\n\"279572267265556259628254276531830013407092233436577916012809317940171859859993\" +\n\"384923549564005709955856113498025249906698423301735035804408116855265311709957\" +\n\"089942732870925848789443646005041089226691783525870785951298344172953519537885\" +\n\"534573742608590290817651557803905946408735061232261120093731080485485263572282\" +\n\"576820341605048466277504500312620080079980492548534694146977516493270950493463\" +\n\"938243222718851597405470214828971117779237612257887347718819682546298126868581\" +\n\"705074027255026332904497627789442362167411918626943965067151577958675648239939\" +\n\"176042601763387045499017614364120469218237076488783419689686118155815873606293\" +\n\"860381017121585527266830082383404656475880405138080163363887421637140643549556\" +\n\"186896411228214075330265510042410489678352858829024367090488711819090949453314\" +\n\"421828766181031007354770549815968077200947469613436092861484941785017180779306\" +\n\"810854690009445899527942439813921350558642219648349151263901280383200109773868\" +\n\"066287792397180146134324457264009737425700735921003154150893679300816998053652\" +\n\"027600727749674584002836240534603726341655425902760183484030681138185510597970\" +\n\"566400750942608788573579603732451414678670368809880609716425849759513806930944\" +\n\"940151542222194329130217391253835591503100333032511174915696917450271494331515\" +\n\"588540392216409722910112903552181576282328318234254832611191280092825256190205\" +\n\"263016391147724733148573910777587442538761174657867116941477642144111126358355\" +\n\"387136101102326798775641024682403226483464176636980663785768134920453022408197\" +\n\"278564719839630878154322116691224641591177673225326433568614618654522268126887\" +\n\"268445968442416107854016768142080885028005414361314623082102594173756238994207\" +\n\"571362751674573189189456283525704413354375857534269869947254703165661399199968\" +\n\"262824727064133622217892390317608542894373393561889165125042440400895271983787\" +\n\"386480584726895462438823437517885201439560057104811949884239060613695734231559\" +\n\"079670346149143447886360410318235073650277859089757827273130504889398900992391\" +\n\"350337325085598265586708924261242947367019390772713070686917092646254842324074\" +\n\"855036608013604668951184009366860954632500214585293095000090715105823626729326\" +\n\"453738210493872499669933942468551648326113414611068026744663733437534076429402\" +\n\"668297386522093570162638464852851490362932019919968828517183953669134522244470\" +\n\"804592396602817156551565666111359823112250628905854914509715755390024393153519\" +\n\"090210711945730024388017661503527086260253788179751947806101371500448991721002\" +\n\"220133501310601639154158957803711779277522597874289191791552241718958536168059\" +\n\"474123419339842021874564925644346239253195313510331147639491199507285843065836\" +\n\"193536932969928983791494193940608572486396883690326556436421664425760791471086\" +\n\"998431573374964883529276932822076294728238153740996154559879825989109371712621\" +\n\"828302584811238901196822142945766758071865380650648702613389282299497257453033\" +\n\"283896381843944770779402284359883410035838542389735424395647555684095224844554\" +\n\"139239410001620769363684677641301781965937997155746854194633489374843912974239\" +\n\"143365936041003523437770658886778113949861647874714079326385873862473288964564\" +\n\"359877466763847946650407411182565837887845485814896296127399841344272608606187\" +\n\"245545236064315371011274680977870446409475828034876975894832824123929296058294\" +\n\"861919667091895808983320121031843034012849511620353428014412761728583024355983\" +\n\"003204202451207287253558119584014918096925339507577840006746552603144616705082\" +\n\"768277222353419110263416315714740612385042584598841990761128725805911393568960\" +\n\"143166828317632356732541707342081733223046298799280490851409479036887868789493\" +\n\"054695570307261900950207643349335910602454508645362893545686295853131533718386\" +\n\"826561786227363716975774183023986006591481616404944965011732131389574706208847\" +\n\"480236537103115089842799275442685327797431139514357417221975979935968525228574\" +\n\"526379628961269157235798662057340837576687388426640599099350500081337543245463\" +\n\"596750484423528487470144354541957625847356421619813407346854111766883118654489\" +\n\"377697956651727966232671481033864391375186594673002443450054499539974237232871\" +\n\"249483470604406347160632583064982979551010954183623503030945309733583446283947\" +\n\"630477564501500850757894954893139394489921612552559770143685894358587752637962\" +\n\"559708167764380012543650237141278346792610199558522471722017772370041780841942\" +\n\"394872540680155603599839054898572354674564239058585021671903139526294455439131\" +\n\"663134530893906204678438778505423939052473136201294769187497519101147231528932\" +\n\"677253391814660730008902776896311481090220972452075916729700785058071718638105\" +\n\"496797310016787085069420709223290807038326345345203802786099055690013413718236\" +\n\"837099194951648960075504934126787643674638490206396401976668559233565463913836\" +\n\"318574569814719621084108096188460545603903845534372914144651347494078488442377\" +\n\"217515433426030669883176833100113310869042193903108014378433415137092435301367\" +\n\"763108491351615642269847507430329716746964066653152703532546711266752246055119\" +\n\"958183196376370761799191920357958200759560530234626775794393630746305690108011\" +\n\"494271410093913691381072581378135789400559950018354251184172136055727522103526\" +\n\"803735726527922417373605751127887218190844900617801388971077082293100279766593\" +\n\"583875890939568814856026322439372656247277603789081445883785501970284377936240\" +\n\"782505270487581647032458129087839523245323789602984166922548964971560698119218\" +\n\"658492677040395648127810217991321741630581055459880130048456299765112124153637\" +\n\"451500563507012781592671424134210330156616535602473380784302865525722275304999\" +\n\"883701534879300806260180962381516136690334111138653851091936739383522934588832\" +\n\"255088706450753947395204396807906708680644509698654880168287434378612645381583\" +\n\"428075306184548590379821799459968115441974253634439960290251001588827216474500\" +\n\"682070419376158454712318346007262933955054823955713725684023226821301247679452\" +\n\"264482091023564775272308208106351889915269288910845557112660396503439789627825\" +\n\"001611015323516051965590421184494990778999200732947690586857787872098290135295\" +\n\"661397888486050978608595701773129815531495168146717695976099421003618355913877\" +\n\"781769845875810446628399880600616229848616935337386578773598336161338413385368\" +\n\"421197893890018529569196780455448285848370117096721253533875862158231013310387\" +\n\"766827211572694951817958975469399264219791552338576623167627547570354699414892\" +\n\"904130186386119439196283887054367774322427680913236544948536676800000106526248\" +\n\"547305586159899914017076983854831887501429389089950685453076511680333732226517\" +\n\"566220752695179144225280816517166776672793035485154204023817460892328391703275\" +\n\"425750867655117859395002793389592057668278967764453184040418554010435134838953\" +\n\"120132637836928358082719378312654961745997056745071833206503455664403449045362\" +\n\"756001125018433560736122276594927839370647842645676338818807565612168960504161\" +\n\"139039063960162022153684941092605387688714837989559999112099164646441191856827\" +\n\"700457424343402167227644558933012778158686952506949936461017568506016714535431\" +\n\"581480105458860564550133203758645485840324029871709348091055621167154684847780\" +\n\"394475697980426318099175642280987399876697323769573701580806822904599212366168\" +\n\"902596273043067931653114940176473769387351409336183321614280214976339918983548\" +\n\"487562529875242387307755955595546519639440182184099841248982623673771467226061\" +\n\"633643296406335728107078875816404381485018841143188598827694490119321296827158\" +\n\"884133869434682859006664080631407775772570563072940049294030242049841656547973\" +\n\"670548558044586572022763784046682337985282710578431975354179501134727362577408\" +\n\"021347682604502285157979579764746702284099956160156910890384582450267926594205\" +\n\"550395879229818526480070683765041836562094555434613513415257006597488191634135\" +\n\"955671964965403218727160264859304903978748958906612725079482827693895352175362\" +\n\"185079629778514618843271922322381015874445052866523802253284389137527384589238\" +\n\"442253547265309817157844783421582232702069028723233005386216347988509469547200\" +\n\"479523112015043293226628272763217790884008786148022147537657810581970222630971\" +\n\"749507212724847947816957296142365859578209083073323356034846531873029302665964\" +\n\"501371837542889755797144992465403868179921389346924474198509733462679332107268\" +\n\"687076806263991936196504409954216762784091466985692571507431574079380532392523\" +\n\"947755744159184582156251819215523370960748332923492103451462643744980559610330\" +\n\"799414534778457469999212859999939961228161521931488876938802228108300198601654\" +\n\"941654261696858678837260958774567618250727599295089318052187292461086763995891\" +\n\"614585505839727420980909781729323930106766386824040111304024700735085782872462\" +\n\"713494636853181546969046696869392547251941399291465242385776255004748529547681\" +\n\"479546700705034799958886769501612497228204030399546327883069597624936151010243\" +\n\"655535223069061294938859901573466102371223547891129254769617600504797492806072\" +\n\"126803922691102777226102544149221576504508120677173571202718024296810620377657\" +\n\"883716690910941807448781404907551782038565390991047759414132154328440625030180\" +\n\"275716965082096427348414695726397884256008453121406593580904127113592004197598\" +\n\"513625479616063228873618136737324450607924411763997597461938358457491598809766\" +\n\"744709300654634242346063423747466608043170126005205592849369594143408146852981\" +\n\"505394717890045183575515412522359059068726487863575254191128887737176637486027\" +\n\"660634960353679470269232297186832771739323619200777452212624751869833495151019\" +\n\"864269887847171939664976907082521742336566272592844062043021411371992278526998\" +\n\"469884770232382384005565551788908766136013047709843861168705231055314916251728\" +\n\"373272867600724817298763756981633541507460883866364069347043720668865127568826\" +\n\"614973078865701568501691864748854167915459650723428773069985371390430026653078\" +\n\"398776385032381821553559732353068604301067576083890862704984188859513809103042\" +\n\"359578249514398859011318583584066747237029714978508414585308578133915627076035\" +\n\"639076394731145549583226694570249413983163433237897595568085683629725386791327\" +\n\"505554252449194358912840504522695381217913191451350099384631177401797151228378\" +\n\"546011603595540286440590249646693070776905548102885020808580087811577381719174\" +\n\"177601733073855475800605601433774329901272867725304318251975791679296996504146\" +\n\"070664571258883469797964293162296552016879730003564630457930884032748077181155\" +\n\"533090988702550520768046303460865816539487695196004408482065967379473168086415\" +\n\"645650530049881616490578831154345485052660069823093157776500378070466126470602\" +\n\"145750579327096204782561524714591896522360839664562410519551052235723973951288\" +\n\"181640597859142791481654263289200428160913693777372229998332708208296995573772\" +\n\"737566761552711392258805520189887620114168005468736558063347160373429170390798\" +\n\"639652296131280178267971728982293607028806908776866059325274637840539769184808\" +\n\"204102194471971386925608416245112398062011318454124478205011079876071715568315\" +\n\"407886543904121087303240201068534194723047666672174986986854707678120512473679\" +\n\"247919315085644477537985379973223445612278584329684664751333657369238720146472\" +\n\"367942787004250325558992688434959287612400755875694641370562514001179713316620\" +\n\"715371543600687647731867558714878398908107429530941060596944315847753970094398\" +\n\"839491443235366853920994687964506653398573888786614762944341401049888993160051\" +\n\"207678103588611660202961193639682134960750111649832785635316145168457695687109\" +\n\"002999769841263266502347716728657378579085746646077228341540311441529418804782\" +\n\"543876177079043000156698677679576090996693607559496515273634981189641304331166\" +\n\"277471233881740603731743970540670310967676574869535878967003192586625941051053\" +\n\"358438465602339179674926784476370847497833365557900738419147319886271352595462\" +\n\"518160434225372996286326749682405806029642114638643686422472488728343417044157\" +\n\"348248183330164056695966886676956349141632842641497453334999948000266998758881\" +\n\"593507357815195889900539512085351035726137364034367534714104836017546488300407\" +\n\"846416745216737190483109676711344349481926268111073994825060739495073503169019\" +\n\"731852119552635632584339099822498624067031076831844660729124874754031617969941\" +\n\"139738776589986855417031884778867592902607004321266617919223520938227878880988\" +\n\"633599116081923535557046463491132085918979613279131975649097600013996234445535\" +\n\"014346426860464495862476909434704829329414041114654092398834443515913320107739\" +\n\"441118407410768498106634724104823935827401944935665161088463125678529776973468\" +\n\"430306146241803585293315973458303845541033701091676776374276210213701354854450\" +\n\"926307190114731848574923318167207213727935567952844392548156091372812840633303\" +\n\"937356242001604566455741458816605216660873874804724339121295587776390696903707\" +\n\"882852775389405246075849623157436917113176134783882719416860662572103685132156\" +\n\"647800147675231039357860689611125996028183930954870905907386135191459181951029\" +\n\"732787557104972901148717189718004696169777001791391961379141716270701895846921\" +\n\"434369676292745910994006008498356842520191559370370101104974733949387788598941\" +\n\"743303178534870760322198297057975119144051099423588303454635349234982688362404\" +\n\"332726741554030161950568065418093940998202060999414021689090070821330723089662\" +\n\"119775530665918814119157783627292746156185710372172471009521423696483086410259\" +\n\"288745799932237495519122195190342445230753513380685680735446499512720317448719\" +\n\"540397610730806026990625807602029273145525207807991418429063884437349968145827\" +\n\"337207266391767020118300464819000241308350884658415214899127610651374153943565\" +\n\"721139032857491876909441370209051703148777346165287984823533829726013611098451\" +\n\"484182380812054099612527458088109948697221612852489742555551607637167505489617\" +\n\"301680961380381191436114399210638005083214098760459930932485102516829446726066\" +\n\"613815174571255975495358023998314698220361338082849935670557552471290274539776\" +\n\"214049318201465800802156653606776550878380430413431059180460680083459113664083\" +\n\"488740800574127258670479225831912741573908091438313845642415094084913391809684\" +\n\"025116399193685322555733896695374902662092326131885589158083245557194845387562\" +\n\"878612885900410600607374650140262782402734696252821717494158233174923968353013\" +\n\"617865367376064216677813773995100658952887742766263684183068019080460984980946\" +\n\"976366733566228291513235278880615776827815958866918023894033307644191240341202\" +\n\"231636857786035727694154177882643523813190502808701857504704631293335375728538\" +\n\"660588890458311145077394293520199432197117164223500564404297989208159430716701\" +\n\"985746927384865383343614579463417592257389858800169801475742054299580124295810\" +\n\"545651083104629728293758416116253256251657249807849209989799062003593650993472\" +\n\"158296517413579849104711166079158743698654122234834188772292944633517865385673\" +\n\"196255985202607294767407261676714557364981210567771689348491766077170527718760\" +\n\"119990814411305864557791052568430481144026193840232247093924980293355073184589\" +\n\"035539713308844617410795916251171486487446861124760542867343670904667846867027\" +\n\"409188101424971114965781772427934707021668829561087779440504843752844337510882\" +\n\"826477197854000650970403302186255614733211777117441335028160884035178145254196\" +\n\"432030957601869464908868154528562134698835544456024955666843660292219512483091\" +\n\"060537720198021831010327041783866544718126039719068846237085751808003532704718\" +\n\"565949947612424811099928867915896904956394762460842406593094862150769031498702\" +\n\"067353384834955083636601784877106080980426924713241000946401437360326564518456\" +\n\"679245666955100150229833079849607994988249706172367449361226222961790814311414\" +\n\"660941234159359309585407913908720832273354957208075716517187659944985693795623\" +\n\"875551617575438091780528029464200447215396280746360211329425591600257073562812\" +\n\"638733106005891065245708024474937543184149401482119996276453106800663118382376\" +\n\"163966318093144467129861552759820145141027560068929750246304017351489194576360\" +\n\"789352855505317331416457050499644389093630843874484783961684051845273288403234\" +\n\"520247056851646571647713932377551729479512613239822960239454857975458651745878\" +\n\"771331813875295980941217422730035229650808917770506825924882232215493804837145\" +\n\"478164721397682096332050830564792048208592047549985732038887639160199524091893\" +\n\"894557676874973085695595801065952650303626615975066222508406742889826590751063\" +\n\"756356996821151094966974458054728869363102036782325018232370845979011154847208\" +\n\"761821247781326633041207621658731297081123075815982124863980721240786887811450\" +\n\"165582513617890307086087019897588980745664395515741536319319198107057533663373\" +\n\"803827215279884935039748001589051942087971130805123393322190346624991716915094\" +\n\"854140187106035460379464337900589095772118080446574396280618671786101715674096\" +\n\"766208029576657705129120990794430463289294730615951043090222143937184956063405\" +\n\"618934251305726829146578329334052463502892917547087256484260034962961165413823\" +\n\"007731332729830500160256724014185152041890701154288579920812198449315699905918\" +\n\"201181973350012618772803681248199587707020753240636125931343859554254778196114\" +\n\"293516356122349666152261473539967405158499860355295332924575238881013620234762\" +\n\"466905581643896786309762736550472434864307121849437348530060638764456627218666\" +\n\"170123812771562137974614986132874411771455244470899714452288566294244023018479\" +\n\"120547849857452163469644897389206240194351831008828348024924908540307786387516\" +\n\"591130287395878709810077271827187452901397283661484214287170553179654307650453\" +\n\"432460053636147261818096997693348626407743519992868632383508875668359509726557\" +\n\"481543194019557685043724800102041374983187225967738715495839971844490727914196\" +\n\"584593008394263702087563539821696205532480321226749891140267852859967340524203\" +\n\"109179789990571882194939132075343170798002373659098537552023891164346718558290\" +\n\"685371189795262623449248339249634244971465684659124891855662958932990903523923\" +\n\"333364743520370770101084388003290759834217018554228386161721041760301164591878\" +\n\"053936744747205998502358289183369292233732399948043710841965947316265482574809\" +\n\"948250999183300697656936715968936449334886474421350084070066088359723503953234\" +\n\"017958255703601693699098867113210979889707051728075585519126993067309925070407\" +\n\"024556850778679069476612629808225163313639952117098452809263037592242674257559\" +\n\"989289278370474445218936320348941552104459726188380030067761793138139916205806\" +\n\"270165102445886924764924689192461212531027573139084047000714356136231699237169\" +\n\"484813255420091453041037135453296620639210547982439212517254013231490274058589\" +\n\"206321758949434548906846399313757091034633271415316223280552297297953801880162\" +\n\"859073572955416278867649827418616421878988574107164906919185116281528548679417\" +\n\"363890665388576422915834250067361245384916067413734017357277995634104332688356\" +\n\"950781493137800736235418007061918026732855119194267609122103598746924117283749\" +\n\"312616339500123959924050845437569850795704622266461900010350049018303415354584\" +\n\"283376437811198855631877779253720116671853954183598443830520376281944076159410\" +\n\"682071697030228515225057312609304689842343315273213136121658280807521263154773\" +\n\"060442377475350595228717440266638914881717308643611138906942027908814311944879\" +\n\"941715404210341219084709408025402393294294549387864023051292711909751353600092\" +\n\"197110541209668311151632870542302847007312065803262641711616595761327235156666\" +\n\"253667271899853419989523688483099930275741991646384142707798870887422927705389\" +\n\"122717248632202889842512528721782603050099451082478357290569198855546788607946\" +\n\"280537122704246654319214528176074148240382783582971930101788834567416781139895\" +\n\"475044833931468963076339665722672704339321674542182455706252479721997866854279\" +\n\"897799233957905758189062252547358220523642485078340711014498047872669199018643\" +\n\"882293230538231855973286978092225352959101734140733488476100556401824239219269\" +\n\"506208318381454698392366461363989101210217709597670490830508185470419466437131\" +\n\"229969235889538493013635657618610606222870559942337163102127845744646398973818\" +\n\"856674626087948201864748767272722206267646533809980196688368099415907577685263\" +\n\"986514625333631245053640261056960551318381317426118442018908885319635698696279\" +\n\"503673842431301133175330532980201668881748134298868158557781034323175306478498\" +\n\"321062971842518438553442762012823457071698853051832617964117857960888815032960\" +\n\"229070561447622091509473903594664691623539680920139457817589108893199211226007\" +\n\"392814916948161527384273626429809823406320024402449589445612916704950823581248\" +\n\"739179964864113348032475777521970893277226234948601504665268143987705161531702\" +\n\"669692970492831628550421289814670619533197026950721437823047687528028735412616\" +\n\"639170824592517001071418085480063692325946201900227808740985977192180515853214\" +\n\"739265325155903541020928466592529991435379182531454529059841581763705892790690\" +\n\"989691116438118780943537152133226144362531449012745477269573939348154691631162\" +\n\"492887357471882407150399500944673195431619385548520766573882513963916357672315\" +\n\"100555603726339486720820780865373494244011579966750736071115935133195919712094\" +\n\"896471755302453136477094209463569698222667377520994516845064362382421185353488\" +\n\"798939567318780660610788544000550827657030558744854180577889171920788142335113\" +\n\"866292966717964346876007704799953788338787034871802184243734211227394025571769\" +\n\"081960309201824018842705704609262256417837526526335832424066125331152942345796\" +\n\"556950250681001831090041124537901533296615697052237921032570693705109083078947\" +\n\"999900499939532215362274847660361367769797856738658467093667958858378879562594\" +\n\"646489137665219958828693380183601193236857855855819555604215625088365020332202\" +\n\"451376215820461810670519533065306060650105488716724537794283133887163139559690\" +\n\"583208341689847606560711834713621812324622725884199028614208728495687963932546\" +\n\"428534307530110528571382964370999035694888528519040295604734613113826387889755\" +\n\"178856042499874831638280404684861893818959054203988987265069762020199554841265\" +\n\"000539442820393012748163815853039643992547020167275932857436666164411096256633\" +\n\"730540921951967514832873480895747777527834422109107311135182804603634719818565\" +\n\"557295714474768255285786334934285842311874944000322969069775831590385803935352\" +\n\"135886007960034209754739229673331064939560181223781285458431760556173386112673\" +\n\"478074585067606304822940965304111830667108189303110887172816751957967534718853\" +\n\"722930961614320400638132246584111115775835858113501856904781536893813771847281\" +\n\"475199835050478129771859908470762197460588742325699582889253504193795826061621\" +\n\"184236876851141831606831586799460165205774052942305360178031335726326705479033\" +\n\"840125730591233960188013782542192709476733719198728738524805742124892118347087\" +\n\"662966720727232565056512933312605950577772754247124164831283298207236175057467\" +\n\"387012820957554430596839555568686118839713552208445285264008125202766555767749\" +\n\"596962661260456524568408613923826576858338469849977872670655519185446869846947\" +\n\"849573462260629421962455708537127277652309895545019303773216664918257815467729\" +\n\"200521266714346320963789185232321501897612603437368406719419303774688099929687\" +\n\"758244104787812326625318184596045385354383911449677531286426092521153767325886\" +\n\"672260404252349108702695809964759580579466397341906401003636190404203311357933\" +\n\"654242630356145700901124480089002080147805660371015412232889146572239314507607\" +\n\"167064355682743774396578906797268743847307634645167756210309860409271709095128\" +\n\"086309029738504452718289274968921210667008164858339553773591913695015316201890\" +\n\"888748421079870689911480466927065094076204650277252865072890532854856143316081\" +\n\"269300569378541786109696920253886503457718317668688592368148847527649846882194\" +\n\"973972970773718718840041432312763650481453112285099002074240925585925292610302\" +\n\"106736815434701525234878635164397623586041919412969769040526483234700991115424\" +\n\"260127343802208933109668636789869497799400126016422760926082349304118064382913\" +\n\"834735467972539926233879158299848645927173405922562074910530853153718291168163\" +\n\"721939518870095778818158685046450769934394098743351443162633031724774748689791\" +\n\"820923948083314397084067308407958935810896656477585990556376952523265361442478\" +\n\"023082681183103773588708924061303133647737101162821461466167940409051861526036\" +\n\"009252194721889091810733587196414214447865489952858234394705007983038853886083\" +\n\"103571930600277119455802191194289992272235345870756624692617766317885514435021\" +\n\"828702668561066500353105021631820601760921798468493686316129372795187307897263\" +\n\"735371715025637873357977180818487845886650433582437700414771041493492743845758\" +\n\"710715973155943942641257027096512510811554824793940359768118811728247215825010\" +\n\"949609662539339538092219559191818855267806214992317276316321833989693807561685\" +\n\"591175299845013206712939240414459386239880938124045219148483164621014738918251\" +\n\"010909677386906640415897361047643650006807710565671848628149637111883219244566\" +\n\"394581449148616550049567698269030891118568798692947051352481609174324301538368\" +\n\"470729289898284602223730145265567989862776796809146979837826876431159883210904\" +\n\"371561129976652153963546442086919756737000573876497843768628768179249746943842\" +\n\"746525631632300555130417422734164645512781278457777245752038654375428282567141\" +\n\"288583454443513256205446424101103795546419058116862305964476958705407214198521\" +\n\"210673433241075676757581845699069304604752277016700568454396923404171108988899\" +\n\"341635058515788735343081552081177207188037910404698306957868547393765643363197\" +\n\"978680367187307969392423632144845035477631567025539006542311792015346497792906\" +\n\"624150832885839529054263768766896880503331722780018588506973623240389470047189\" +\n\"761934734430843744375992503417880797223585913424581314404984770173236169471976\" +\n\"571535319775499716278566311904691260918259124989036765417697990362375528652637\" +\n\"573376352696934435440047306719886890196814742876779086697968852250163694985673\" +\n\"021752313252926537589641517147955953878427849986645630287883196209983049451987\" +\n\"439636907068276265748581043911223261879405994155406327013198989570376110532360\" +\n\"629867480377915376751158304320849872092028092975264981256916342500052290887264\" +\n\"692528466610466539217148208013050229805263783642695973370705392278915351056888\" +\n\"393811324975707133102950443034671598944878684711643832805069250776627450012200\" +\n\"352620370946602341464899839025258883014867816219677519458316771876275720050543\" +\n\"979441245990077115205154619930509838698254284640725554092740313257163264079293\" +\n\"418334214709041254253352324802193227707535554679587163835875018159338717423606\" +\n\"155117101312352563348582036514614187004920570437201826173319471570086757853933\" +\n\"607862273955818579758725874410254207710547536129404746010009409544495966288148\" +\n\"691590389907186598056361713769222729076419775517772010427649694961105622059250\" +\n\"242021770426962215495872645398922769766031052498085575947163107587013320886146\" +\n\"326641259114863388122028444069416948826152957762532501987035987067438046982194\" +\n\"205638125583343642194923227593722128905642094308235254408411086454536940496927\" +\n\"149400331978286131818618881111840825786592875742638445005994422956858646048103\" +\n\"301538891149948693543603022181094346676400002236255057363129462629609619876056\" +\n\"425996394613869233083719626595473923462413459779574852464783798079569319865081\" +\n\"597767535055391899115133525229873611277918274854200868953965835942196333150286\" +\n\"956119201229888988700607999279541118826902307891310760361763477948943203210277\" +\n\"335941690865007193280401716384064498787175375678118532132840821657110754952829\" +\n\"497493621460821558320568723218557406516109627487437509809223021160998263303391\" +\n\"546949464449100451528092508974507489676032409076898365294065792019831526541065\" +\n\"813682379198409064571246894847020935776119313998024681340520039478194986620262\" +\n\"400890215016616381353838151503773502296607462795291038406868556907015751662419\" +\n\"298724448271942933100485482445458071889763300323252582158128032746796200281476\" +\n\"243182862217105435289834820827345168018613171959332471107466222850871066611770\" +\n\"346535283957762599774467218571581612641114327179434788599089280848669491413909\" +\n\"771673690027775850268664654056595039486784111079011610400857274456293842549416\" +\n\"759460548711723594642910585090995021495879311219613590831588262068233215615308\" +\n\"683373083817327932819698387508708348388046388478441884003184712697454370937329\" +\n\"836240287519792080232187874488287284372737801782700805878241074935751488997891\" +\n\"173974612932035108143270325140903048746226294234432757126008664250833318768865\" +\n\"075642927160552528954492153765175149219636718104943531785838345386525565664065\" +\n\"725136357506435323650893679043170259787817719031486796384082881020946149007971\" +\n\"513771709906195496964007086766710233004867263147551053723175711432231741141168\" +\n\"062286420638890621019235522354671166213749969326932173704310598722503945657492\" +\n\"461697826097025335947502091383667377289443869640002811034402608471289900074680\" +\n\"776484408871134135250336787731679770937277868216611786534423173226463784769787\" +\n\"514433209534000165069213054647689098505020301504488083426184520873053097318949\" +\n\"291642532293361243151430657826407028389840984160295030924189712097160164926561\" +\n\"341343342229882790992178604267981245728534580133826099587717811310216734025656\" +\n\"274400729683406619848067661580502169183372368039902793160642043681207990031626\" +\n\"444914619021945822969099212278855394878353830564686488165556229431567312827439\" +\n\"082645061162894280350166133669782405177015521962652272545585073864058529983037\" +\n\"918035043287670380925216790757120406123759632768567484507915114731344000183257\" +\n\"034492090971243580944790046249431345502890068064870429353403743603262582053579\" +\n\"011839564908935434510134296961754524957396062149028872893279252069653538639644\" +\n\"322538832752249960598697475988232991626354597332444516375533437749292899058117\" +\n\"578635555562693742691094711700216541171821975051983178713710605106379555858890\" +\n\"556885288798908475091576463907469361988150781468526213325247383765119299015610\" +\n\"918977792200870579339646382749068069876916819749236562422608715417610043060890\" +\n\"437797667851966189140414492527048088197149880154205778700652159400928977760133\" +\n\"075684796699295543365613984773806039436889588764605498387147896848280538470173\" +\n\"087111776115966350503997934386933911978988710915654170913308260764740630571141\" +\n\"109883938809548143782847452883836807941888434266622207043872288741394780101772\" +\n\"139228191199236540551639589347426395382482960903690028835932774585506080131798\" +\n\"840716244656399794827578365019551422155133928197822698427863839167971509126241\" +\n\"054872570092407004548848569295044811073808799654748156891393538094347455697212\" +\n\"891982717702076661360248958146811913361412125878389557735719498631721084439890\" +\n\"142394849665925173138817160266326193106536653504147307080441493916936326237376\" +\n\"777709585031325599009576273195730864804246770121232702053374266705314244820816\" +\n\"813030639737873664248367253983748769098060218278578621651273856351329014890350\" +\n\"988327061725893257536399397905572917516009761545904477169226580631511102803843\" +\n\"601737474215247608515209901615858231257159073342173657626714239047827958728150\" +\n\"509563309280266845893764964977023297364131906098274063353108979246424213458374\" +\n\"090116939196425045912881340349881063540088759682005440836438651661788055760895\" +\n\"689672753153808194207733259791727843762566118431989102500749182908647514979400\" +\n\"316070384554946538594602745244746681231468794344161099333890899263841184742525\" +\n\"704457251745932573898956518571657596148126602031079762825416559050604247911401\" +\n\"695790033835657486925280074302562341949828646791447632277400552946090394017753\" +\n\"633565547193100017543004750471914489984104001586794617924161001645471655133707\" +\n\"407395026044276953855383439755054887109978520540117516974758134492607943368954\" +\n\"378322117245068734423198987884412854206474280973562580706698310697993526069339\" +\n\"213568588139121480735472846322778490808700246777630360555123238665629517885371\" +\n\"967303463470122293958160679250915321748903084088651606111901149844341235012464\" +\n\"692802880599613428351188471544977127847336176628506216977871774382436256571177\" +\n\"945006447771837022199910669502165675764404499794076503799995484500271066598781\" +\n\"360380231412683690578319046079276529727769404361302305178708054651154246939526\" +\n\"512710105292707030667302444712597393995051462840476743136373997825918454117641\" +\n\"332790646063658415292701903027601733947486696034869497654175242930604072700505\" +\n\"903950314852292139257559484507886797792525393176515641619716844352436979444735\" +\n\"596426063339105512682606159572621703669850647328126672452198906054988028078288\" +\n\"142979633669674412480598219214633956574572210229867759974673812606936706913408\" +\n\"155941201611596019023775352555630060624798326124988128819293734347686268921923\" +\n\"977783391073310658825681377717232831532908252509273304785072497713944833389255\" +\n\"208117560845296659055394096556854170600117985729381399825831929367910039184409\" +\n\"928657560599359891000296986446097471471847010153128376263114677420914557404181\" +\n\"590880006494323785583930853082830547607679952435739163122188605754967383224319\" +\n\"565065546085288120190236364471270374863442172725787950342848631294491631847534\" +\n\"753143504139209610879605773098720135248407505763719925365047090858251393686346\" +\n\"386336804289176710760211115982887553994012007601394703366179371539630613986365\" +\n\"549221374159790511908358829009765664730073387931467891318146510931676157582135\" +\n\"142486044229244530411316065270097433008849903467540551864067734260358340960860\" +\n\"553374736276093565885310976099423834738222208729246449768456057956251676557408\" +\n\"841032173134562773585605235823638953203853402484227337163912397321599544082842\" +\n\"166663602329654569470357718487344203422770665383738750616921276801576618109542\" +\n\"009770836360436111059240911788954033802142652394892968643980892611463541457153\" +\n\"519434285072135345301831587562827573389826889852355779929572764522939156747756\" +\n\"667605108788764845349363606827805056462281359888587925994094644604170520447004\" +\n\"631513797543173718775603981596264750141090665886616218003826698996196558058720\" +\n\"863972117699521946678985701179833244060181157565807428418291061519391763005919\" +\n\"431443460515404771057005433900018245311773371895585760360718286050635647997900\" +\n\"413976180895536366960316219311325022385179167205518065926351803625121457592623\" +\n\"836934822266589557699466049193811248660909979812857182349400661555219611220720\" +\n\"309227764620099931524427358948871057662389469388944649509396033045434084210246\" +\n\"240104872332875008174917987554387938738143989423801176270083719605309438394006\" +\n\"375611645856094312951759771393539607432279248922126704580818331376416581826956\" +\n\"210587289244774003594700926866265965142205063007859200248829186083974373235384\" +\n\"908396432614700053242354064704208949921025040472678105908364400746638002087012\" +\n\"666420945718170294675227854007450855237772089058168391844659282941701828823301\" +\n\"497155423523591177481862859296760504820386434310877956289292540563894662194826\" +\n\"871104282816389397571175778691543016505860296521745958198887868040811032843273\" +\n\"986719862130620555985526603640504628215230615459447448990883908199973874745296\" +\n\"981077620148713400012253552224669540931521311533791579802697955571050850747387\" +\n\"475075806876537644578252443263804614304288923593485296105826938210349800040524\" +\n\"840708440356116781717051281337880570564345061611933042444079826037795119854869\" +\n\"455915205196009304127100727784930155503889536033826192934379708187432094991415\" +\n\"959339636811062755729527800425486306005452383915106899891357882001941178653568\" +\n\"214911852820785213012551851849371150342215954224451190020739353962740020811046\" +\n\"553020793286725474054365271759589350071633607632161472581540764205302004534018\" +\n\"357233829266191530835409512022632916505442612361919705161383935732669376015691\" +\n\"442994494374485680977569630312958871916112929468188493633864739274760122696415\" +\n\"884890096571708616059814720446742866420876533479985822209061980217321161423041\" +\n\"947775499073873856794118982466091309169177227420723336763503267834058630193019\" +\n\"324299639720444517928812285447821195353089891012534297552472763573022628138209\" +\n\"180743974867145359077863353016082155991131414420509144729353502223081719366350\" +\n\"934686585865631485557586244781862010871188976065296989926932817870557643514338\" +\n\"206014107732926106343152533718224338526352021773544071528189813769875515757454\" +\n\"693972715048846979361950047772097056179391382898984532742622728864710888327017\" +\n\"372325881824465843624958059256033810521560620615571329915608489206434030339526\" +\n\"226345145428367869828807425142256745180618414956468611163540497189768215422772\" +\n\"247947403357152743681940989205011365340012384671429655186734415374161504256325\" +\n\"671343024765512521921803578016924032669954174608759240920700466934039651017813\" +\n\"485783569444076047023254075555776472845075182689041829396611331016013111907739\" +\n\"863246277821902365066037404160672496249013743321724645409741299557052914243820\" +\n\"807609836482346597388669134991978401310801558134397919485283043673901248208244\" +\n\"481412809544377389832005986490915950532285791457688496257866588599917986752055\" +\n\"455809900455646117875524937012455321717019428288461740273664997847550829422802\" +\n\"023290122163010230977215156944642790980219082668986883426307160920791408519769\" +\n\"523555348865774342527753119724743087304361951139611908003025587838764420608504\" +\n\"473063129927788894272918972716989057592524467966018970748296094919064876469370\" +\n\"275077386643239191904225429023531892337729316673608699622803255718530891928440\" +\n\"380507103006477684786324319100022392978525537237556621364474009676053943983823\" +\n\"576460699246526008909062410590421545392790441152958034533450025624410100635953\" +\n\"003959886446616959562635187806068851372346270799732723313469397145628554261546\" +\n\"765063246567662027924520858134771760852169134094652030767339184114750414016892\" +\n\"412131982688156866456148538028753933116023229255561894104299533564009578649534\" +\n\"093511526645402441877594931693056044868642086275720117231952640502309977456764\" +\n\"783848897346431721598062678767183800524769688408498918508614900343240347674268\" +\n\"624595239589035858213500645099817824463608731775437885967767291952611121385919\" +\n\"472545140030118050343787527766440276261894101757687268042817662386068047788524\" +\n\"288743025914524707395054652513533945959878961977891104189029294381856720507096\" +\n\"460626354173294464957661265195349570186001541262396228641389779673332907056737\" +\n\"696215649818450684226369036784955597002607986799626101903933126376855696876702\" +\n\"929537116252800554310078640872893922571451248113577862766490242516199027747109\" +\n\"033593330930494838059785662884478744146984149906712376478958226329490467981208\" +\n\"998485716357108783119184863025450162092980582920833481363840542172005612198935\" +\n\"366937133673339246441612522319694347120641737549121635700857369439730597970971\" +\n\"972666664226743111776217640306868131035189911227133972403688700099686292254646\" +\n\"500638528862039380050477827691283560337254825579391298525150682996910775425764\" +\n\"748832534141213280062671709400909822352965795799780301828242849022147074811112\" +\n\"401860761341515038756983091865278065889668236252393784527263453042041880250844\" +\n\"236319038331838455052236799235775292910692504326144695010986108889991465855188\" +\n\"187358252816430252093928525807796973762084563748211443398816271003170315133440\" +\n\"230952635192958868069082135585368016100021374085115448491268584126869589917414\" +\n\"913382057849280069825519574020181810564129725083607035685105533178784082900004\" +\n\"155251186577945396331753853209214972052660783126028196116485809868458752512999\" +\n\"740409279768317663991465538610893758795221497173172813151793290443112181587102\" +\n\"351874075722210012376872194474720934931232410706508061856237252673254073332487\" +\n\"575448296757345001932190219911996079798937338367324257610393898534927877747398\" +\n\"050808001554476406105352220232540944356771879456543040673589649101761077594836\" +\n\"454082348613025471847648518957583667439979150851285802060782055446299172320202\" +\n\"822291488695939972997429747115537185892423849385585859540743810488262464878805\" +\n\"330427146301194158989632879267832732245610385219701113046658710050008328517731\" +\n\"177648973523092666123458887310288351562644602367199664455472760831011878838915\" +\n\"114934093934475007302585581475619088139875235781233134227986650352272536717123\" +\n\"075686104500454897036007956982762639234410714658489578024140815840522953693749\" +\n\"971066559489445924628661996355635065262340533943914211127181069105229002465742\" +\n\"360413009369188925586578466846121567955425660541600507127664176605687427420032\" +\n\"957716064344860620123982169827172319782681662824993871499544913730205184366907\" +\n\"672357740005393266262276032365975171892590180110429038427418550789488743883270\" +\n\"306328327996300720069801224436511639408692222074532024462412115580435454206421\" +\n\"512158505689615735641431306888344318528085397592773443365538418834030351782294\" +\n\"625370201578215737326552318576355409895403323638231921989217117744946940367829\" +\n\"618592080340386757583411151882417743914507736638407188048935825686854201164503\" +\n\"135763335550944031923672034865101056104987272647213198654343545040913185951314\" +\n\"518127643731043897250700498198705217627249406521461995923214231443977654670835\" +\n\"171474936798618655279171582408065106379950018429593879915835017158075988378496\" +\n\"225739851212981032637937621832245659423668537679911314010804313973233544909082\" +\n\"491049914332584329882103398469814171575601082970658306521134707680368069532297\" +\n\"199059990445120908727577622535104090239288877942463048328031913271049547859918\" +\n\"019696783532146444118926063152661816744319355081708187547705080265402529410921\" +\n\"826485821385752668815558411319856002213515888721036569608751506318753300294211\" +\n\"868222189377554602722729129050429225978771066787384000061677215463844129237119\" +\n\"352182849982435092089180168557279815642185819119749098573057033266764646072875\" +\n\"743056537260276898237325974508447964954564803077159815395582777913937360171742\" +\n\"299602735310276871944944491793978514463159731443535185049141394155732938204854\" +\n\"212350817391254974981930871439661513294204591938010623142177419918406018034794\" +\n\"988769105155790555480695387854006645337598186284641990522045280330626369562649\" +\n\"091082762711590385699505124652999606285544383833032763859980079292284665950355\" +\n\"121124528408751622906026201185777531374794936205549640107300134885315073548735\" +\n\"390560290893352640071327473262196031177343394367338575912450814933573691166454\" +\n\"128178817145402305475066713651825828489809951213919399563324133655677709800308\" +\n\"191027204099714868741813466700609405102146269028044915964654533010775469541308\" +\n\"871416531254481306119240782118869005602778182423502269618934435254763357353648\" +\n\"561936325441775661398170393063287216690572225974520919291726219984440964615826\" +\n\"945638023950283712168644656178523556516412771282691868861557271620147493405227\" +\n\"694659571219831494338162211400693630743044417328478610177774383797703723179525\" +\n\"543410722344551255558999864618387676490397246116795901810003509892864120419516\" +\n\"355110876320426761297982652942588295114127584126273279079880755975185157684126\" +\n\"474220947972184330935297266521001566251455299474512763155091763673025946213293\" +\n\"019040283795424632325855030109670692272022707486341900543830265068121414213505\" +\n\"715417505750863990767394633514620908288893493837643939925690060406731142209331\" +\n\"219593620298297235116325938677224147791162957278075239505625158160313335938231\" +\n\"150051862689053065836812998810866326327198061127154885879809348791291370749823\" +\n\"057592909186293919501472119758606727009254771802575033773079939713453953264619\" +\n\"526999659638565491759045833358579910201271320458390320085387888163363768518208\" +\n\"372788513117522776960978796214237216254521459128183179821604411131167140691482\" +\n\"717098101545778193920231156387195080502467972579249760577262591332855972637121\" +\n\"120190572077140914864507409492671803581515757151405039761096384675556929897038\" +\n\"354731410022380258346876735012977541327953206097115450648421218593649099791776\" +\n\"687477448188287063231551586503289816422828823274686610659273219790716238464215\" +\n\"348985247621678905026099804526648392954235728734397768049577409144953839157556\" +\n\"548545905897649519851380100795801078375994577529919670054760225255203445398871\" +\n\"253878017196071816407812484784725791240782454436168234523957068951427226975043\" +\n\"187363326301110305342333582160933319121880660826834142891041517324721605335584\" +\n\"999322454873077882290525232423486153152097693846104258284971496347534183756200\" +\n\"301491570327968530186863157248840152663983568956363465743532178349319982554211\" +\n\"730846774529708583950761645822963032442432823773745051702856069806788952176819\" +\n\"815671078163340526675953942492628075696832610749532339053622309080708145591983\" +\n\"735537774874202903901814293731152933464446815121294509759653430628421531944572\" +\n\"711861490001765055817709530246887526325011970520947615941676872778447200019278\" +\n\"913725184162285778379228443908430118112149636642465903363419454065718354477191\" +\n\"244662125939265662030688852005559912123536371822692253178145879259375044144893\" +\n\"398160865790087616502463519704582889548179375668104647461410514249887025213993\" +\n\"687050937230544773411264135489280684105910771667782123833281026218558775131272\" +\n\"117934444820144042574508306394473836379390628300897330624138061458941422769474\" +\n\"793166571762318247216835067807648757342049155762821758397297513447899069658953\" +\n\"254894033561561316740327647246921250575911625152965456854463349811431767025729\" +\n\"566184477548746937846423373723898192066204851189437886822480727935202250179654\" +\n\"534375727416391079197295295081294292220534771730418447791567399173841831171036\" +\n\"252439571615271466900581470000263301045264354786590329073320546833887207873544\" +\n\"476264792529769017091200787418373673508771337697768349634425241994995138831507\" +\n\"487753743384945825976556099655595431804092017849718468549737069621208852437701\" +\n\"385375768141663272241263442398215294164537800049250726276515078908507126599703\" +\n\"670872669276430837722968598516912230503746274431085293430527307886528397733524\" +\n\"601746352770320593817912539691562106363762588293757137384075440646896478310070\" +\n\"458061344673127159119460843593582598778283526653115106504162329532904777217408\" +\n\"355934972375855213804830509000964667608830154061282430874064559443185341375522\" +\n\"016630581211103345312074508682433943215904359443031243122747138584203039010607\" +\n\"094031523555617276799416002039397509989762933532585557562480899669182986422267\" +\n\"750236019325797472674257821111973470940235745722227121252685238429587427350156\" +\n\"366009318804549333898974157149054418255973808087156528143010267046028431681923\" +\n\"039253529779576586241439270154974087927313105163611913757700892956482332364829\" +\n\"826302460797587576774537716010249080462430185652416175665560016085912153455626\" +\n\"760219268998285537787258314514408265458348440947846317877737479465358016996077\" +\n\"940556870119232860804113090462935087182712593466871276669487389982459852778649\" +\n\"956916546402945893506496433580982476596516514209098675520380830920323048734270\" +\n\"346828875160407154665383461961122301375945157925269674364253192739003603860823\" +\n\"645076269882749761872357547676288995075211480485252795084503395857083813047693\" +\n\"788132112367428131948795022806632017002246033198967197064916374117585485187848\" +\n\"401205484467258885140156272501982171906696081262778548596481836962141072171421\" +\n\"498636191877475450965030895709947093433785698167446582826791194061195603784539\" +\n\"785583924076127634410576675102430755981455278616781594965706255975507430652108\" +\n\"530159790807334373607943286675789053348366955548680391343372015649883422089339\" +\n\"997164147974693869690548008919306713805717150585730714881564992071408675825960\" +\n\"287605645978242377024246980532805663278704192676846711626687946348695046450742\" +\n\"021937394525926266861355294062478136120620263649819999949840514386828525895634\" +\n\"226432870766329930489172340072547176418868535137233266787792173834754148002280\" +\n\"339299735793615241275582956927683723123479898944627433045456679006203242051639\" +\n\"628258844308543830720149567210646053323853720314324211260742448584509458049408\" +\n\"182092763914000854042202355626021856434899414543995041098059181794888262805206\" +\n\"644108631900168856815516922948620301073889718100770929059048074909242714101893\" +\n\"354281842999598816966099383696164438152887721408526808875748829325873580990567\" +\n\"075581701794916190611400190855374488272620093668560447559655747648567400817738\" +\n\"170330738030547697360978654385938218722058390234444350886749986650604064587434\" +\n\"600533182743629617786251808189314436325120510709469081358644051922951293245007\" +\n\"883339878842933934243512634336520438581291283434529730865290978330067126179813\" +\n\"031679438553572629699874035957045845223085639009891317947594875212639707837594\" +\n\"486113945196028675121056163897600888009274611586080020780334159145179707303683\" +\n\"519697776607637378533301202412011204698860920933908536577322239241244905153278\" +\n\"095095586645947763448226998607481329730263097502881210351772312446509534965369\" +\n\"309001863776409409434983731325132186208021480992268550294845466181471555744470\" +\n\"966953017769043427203189277060471778452793916047228153437980353967986142437095\" +\n\"668322149146543801459382927739339603275404800955223181666738035718393275707714\" +\n\"204672383862461780397629237713120958078936384144792980258806552212926209362393\" +\n\"063731349664018661951081158347117331202580586672763999276357907806381881306915\" +\n\"636627412543125958993611964762610140556350339952314032311381965623632719896183\" +\n\"725484533370206256346422395276694356837676136871196292181875457608161705303159\" +\n\"072882870071231366630872275491866139577373054606599743781098764980241401124214\" +\n\"277366808275139095931340415582626678951084677611866595766016599817808941498575\" +\n\"497628438785610026379654317831363402513581416115190209649913354873313111502270\" +\n\"068193013592959597164019719605362503355847998096348871803911161281359596856547\" +\n\"886832585643789617315976200241962155289629790481982219946226948713746244472909\" +\n\"345647002853769495885959160678928249105441251599630078136836749020937491573289\" +\n\"627002865682934443134234735123929825916673950342599586897069726733258273590312\" +\n\"128874666045146148785034614282776599160809039865257571726308183349444182019353\" +\n\"338507129234577437557934406217871133006310600332405399169368260374617663856575\" +\n\"887758020122936635327026710068126182517291460820254189288593524449107013820621\" +\n\"155382779356529691457650204864328286555793470720963480737269214118689546732276\" +\n\"775133569019015372366903686538916129168888787640752549349424973342718117889275\" +\n\"993159671935475898809792452526236365903632007085444078454479734829180208204492\" +\n\"667063442043755532505052752283377888704080403353192340768563010934777212563908\" +\n\"864041310107381785333831603813528082811904083256440184205374679299262203769871\" +\n\"801806112262449090924264198582086175117711378905160914038157500336642415609521\" +\n\"632819712233502316742260056794128140621721964184270578432895980288233505982820\" +\n\"819666624903585778994033315227481777695284368163008853176969478369058067106482\" +\n\"808359804669884109813515865490693331952239436328792399053481098783027450017206\" +\n\"543369906611778455436468772363184446476806914282800455107468664539280539940910\" +\n\"875493916609573161971503316696830992946634914279878084225722069714887558063748\" +\n\"030886299511847318712477729191007022758889348693945628951580296537215040960310\" +\n\"776128983126358996489341024703603664505868728758905140684123812424738638542790\" +\n\"828273382797332688550493587430316027474906312957234974261122151741715313361862\" +\n\"241091386950068883589896234927631731647834007746088665559873338211382992877691\" +\n\"149549218419208777160606847287467368188616750722101726110383067178785669481294\" +\n\"878504894306308616994879870316051588410828235127415353851336589533294862949449\" +\n\"506186851477910580469603906937266267038651290520113781085861618888694795760741\" +\n\"358553458515176805197333443349523012039577073962377131603024288720053732099825\" +\n\"300897761897312981788194467173116064723147624845755192873278282512718244680782\" +\n\"421521646956781929409823892628494376024885227900362021938669648221562809360537\" +\n\"317804086372726842669642192994681921490870170753336109479138180406328738759384\" +\n\"826953558307739576144799727000347288018278528138950321798634521611106660883931\" +\n\"405322694490545552786789441757920244002145078019209980446138254780585804844241\" +\n\"640477503153605490659143007815837243012313751156228401583864427089071828481675\" +\n\"752712384678245953433444962201009607105137060846180118754312072549133499424761\" +\n\"711563332140893460915656155060031738421870157022610310191660388706466143889773\" +\n\"631878094071152752817468957640158104701696524755774089164456867771715850058326\" +\n\"994340167720215676772406812836656526412298243946513319735919970940327593850266\" +\n\"955747023181320324371642058614103360652453693916005064495306016126782264894243\" +\n\"739716671766123104897503188573216555498834212180284691252908610148552781527762\" +\n\"562375045637576949773433684601560772703550962904939248708840628106794362241870\" +\n\"474700836884267102255830240359984164595112248527263363264511401739524808619463\" +\n\"584078375355688562231711552094722306543709260679735100056554938122457548372854\" +\n\"571179739361575616764169289580525729752233855861138832217110736226581621884244\" +\n\"317885748879810902665379342666421699091405653643224930133486798815488662866505\" +\n\"234699723557473842483059042367714327879231642240387776433019260019228477831383\" +\n\"763253612102533693581262408686669973827597736568222790721583247888864236934639\" +\n\"616436330873013981421143030600873066616480367898409133592629340230432497492688\" +\n\"783164360268101130957071614191283068657732353263965367739031766136131596555358\" +\n\"499939860056515592193675997771793301974468814837110320650369319289452140265091\" +\n\"546518430993655349333718342529843367991593941746622390038952767381333061774762\" +\n\"957494386871697845376721949350659087571191772087547710718993796089477451265475\" +\n\"750187119487073873678589020061737332107569330221632062843206567119209695058576\" +\n\"117396163232621770894542621460985841023781321581772760222273813349541048100307\" +\n\"327510779994899197796388353073444345753297591426376840544226478421606312276964\" +\n\"696715647399904371590332390656072664411643860540483884716191210900870101913072\" +\n\"607104411414324197679682854788552477947648180295973604943970047959604029274629\" +\n\"920357209976195014034831538094771460105633344699882082212058728151072918297121\" +\n\"191787642488035467231691654185225672923442918712816323259696541354858957713320\" +\n\"833991128877591722611527337901034136208561457799239877832508355073019981845902\" +\n\"595835598926055329967377049172245493532968330000223018151722657578752405883224\" +\n\"908582128008974790932610076257877042865600699617621217684547899644070506624171\" +\n\"021332748679623743022915535820078014116534806564748823061500339206898379476625\" +\n\"503654982280532966286211793062843017049240230198571997894883689718304380518217\" +\n\"441914766042975243725168343541121703863137941142209529588579806015293875275379\" +\n\"903093887168357209576071522190027937929278630363726876582268124199338480816602\" +\n\"160372215471014300737753779269906958712128928801905203160128586182549441335382\" +\n\"078488346531163265040764242839087012101519423196165226842200371123046430067344\" +\n\"206474771802135307012409886035339915266792387110170622186588357378121093517977\" +\n\"560442563469499978725112544085452227481091487430725986960204027594117894258128\" +\n\"188215995235965897918114407765335432175759525553615812800116384672031934650729\" +\n\"680799079396371496177431211940202129757312516525376801735910155733815377200195\" +\n\"244454362007184847566341540744232862106099761324348754884743453966598133871746\" +\n\"609302053507027195298394327142537115576660002578442303107342955153394506048622\" +\n\"276496668762407932435319299263925373107689213535257232108088981933916866827894\" +\n\"828117047262450194840970097576092098372409007471797334078814182519584259809624\" +\n\"174761013825264395513525931188504563626418830033853965243599741693132289471987\" +\n\"830842760040136807470390409723847394583489618653979059411859931035616843686921\" +\n\"948538205578039577388136067954990008512325944252972448666676683464140218991594\" +\n\"456530942344065066785194841776677947047204195882204329538032631053749488312218\" +\n\"039127967844610013972675389219511911783658766252808369005324900459741094706877\" +\n\"291232821430463533728351995364827432583311914445901780960778288358373011185754\" +\n\"365995898272453192531058811502630754257149394302445393187017992360816661130542\" +\n\"625399583389794297160207033876781503301028012009599725222228080142357109476035\" +\n\"192554443492998676781789104555906301595380976187592035893734197896235893112598\" +\n\"390259831026719330418921510968915622506965911982832345550305908173073519550372\" +\n\"166587028805399213857603703537710517802128012956684198414036287272562321442875\" +\n\"430221090947272107347413497551419073704331827662617727599688882602722524713368\" +\n\"335345281669277959132886138176634985772893690096574956228710302436259077241221\" +\n\"909430087175569262575806570991201665962243608024287002454736203639484125595488\" +\n\"172727247365346778364720191830399871762703751572464992228946793232269361917764\" +\n\"161461879561395669956778306829031658969943076733350823499079062410020250613405\" +\n\"734430069574547468217569044165154063658468046369262127421107539904218871612761\" +\n\"778701425886482577522388918459952337629237791558574454947736129552595222657863\" +\n\"646211837759847370034797140820699414558071908021359073226923310083175951065901\" +\n\"912129479540860364075735875020589020870457967000705526250581142066390745921527\" +\n\"330940682364944159089100922029668052332526619891131184201629163107689408472356\" +\n\"436680818216865721968826835840278550078280404345371018365109695178233574303050\" +\n\"485265373807353107418591770561039739506264035544227515610110726177937063472380\" +\n\"499066692216197119425912044508464174638358993823994651739550900085947999013602\" +\n\"667426149429006646711506717542217703877450767356374215478290591101261915755587\" +\n\"023895700140511782264698994491790830179547587676016809410013583761357859135692\" +\n\"445564776446417866711539195135769610486492249008344671548638305447791433009768\" +\n\"048687834818467273375843689272431044740680768527862558516509208826381323362314\" +\n\"873333671476452045087662761495038994950480956046098960432912335834885999029452\" +\n\"640028499428087862403981181488476730121675416110662999555366819312328742570206\" +\n\"373835202008686369131173346973174121915363324674532563087134730279217495622701\" +\n\"468732586789173455837996435135880095935087755635624881049385299900767513551352\" +\n\"779241242927748856588856651324730251471021057535251651181485090275047684551825\" +\n\"209633189906852761443513821366215236889057878669943228881602837748203550601602\" +\n\"989400911971385017987168363374413927597364401700701476370665570350433812111357\" +\n\"641501845182141361982349515960106475271257593518530433287553778305750956742544\" +\n\"268471221961870917856078393614451138333564910325640573389866717812397223751931\" +\n\"643061701385953947436784339267098671245221118969084023632741149660124348309892\" +\n\"994173803058841716661307304006758838043211155537944060549772170594282151488616\" +\n\"567277124090338772774562909711013488518437411869565544974573684521806698291104\" +\n\"505800429988795389902780438359628240942186055628778842880212755388480372864001\" +\n\"944161425749990427200959520465417059810498996750451193647117277222043610261407\" +\n\"975080968697517660023718774834801612031023468056711264476612374762785219024120\" +\n\"256994353471622666089367521983311181351114650385489502512065577263614547360442\" +\n\"685949807439693233129712737715734709971395229118265348515558713733662912024271\" +\n\"430250376326950135091161295299378586468130722648600827088133353819370368259886\" +\n\"789332123832705329762585738279009782646054559855513183668884462826513379849166\" +\n\"783940976135376625179825824966345877195012438404035914084920973375464247448817\" +\n\"618407002356958017741017769692507781489338667255789856458985105689196092439884\" +\n\"156928069698335224022563457049731224526935419383700484318335719651662672157552\" +\n\"419340193309901831930919658292096965624766768365964701959575473934551433741370\" +\n\"876151732367720422738567427917069820454995309591887243493952409444167899884631\" +\n\"984550485239366297207977745281439941825678945779571255242682608994086331737153\" +\n\"889626288962940211210888442737656862452761213037101730078513571540453304150795\" +\n\"944777614359743780374243664697324713841049212431413890357909241603640631403814\" +\n\"983148190525172093710396402680899483257229795456404270175772290417323479607361\" +\n\"878788991331830584306939482596131871381642346721873084513387721908697510494284\" +\n\"376932502498165667381626061594176825250999374167288395174406693254965340310145\" +\n\"222531618900923537648637848288134420987004809622717122640748957193900291857330\" +\n\"746010436072919094576799461492929042798168772942648772995285843464777538690695\" +\n\"014898413392454039414468026362540211861431703125111757764282991464453340892097\" +\n\"696169909837265236176874560589470496817013697490952307208268288789073019001825\" +\n\"342580534342170592871393173799314241085264739094828459641809361413847583113613\" +\n\"057610846236683723769591349261582451622155213487924414504175684806412063652017\" +\n\"038633012953277769902311864802006755690568229501635493199230591424639621702532\" +\n\"974757311409422018019936803502649563695586642590676268568737211033915679383989\" +\n\"576556519317788300024161353956243777784080174881937309502069990089089932808839\" +\n\"743036773659552489130015663329407790713961546453408879151030065132193448667324\" +\n\"827590794680787981942501958262232039513125201410996053126069655540424867054998\" +\n\"678692302174698900954785072567297879476988883109348746442640071818316033165551\" +\n\"153427615562240547447337804924621495213325852769884733626918264917433898782478\" +\n\"927846891882805466998230368993978341374758702580571634941356843392939606819206\" +\n\"177333179173820856243643363535986349449689078106401967407443658366707158692452\" +\n\"118299789380407713750129085864657890577142683358276897855471768718442772612050\" +\n\"926648610205153564284063236848180728794071712796682006072755955590404023317874\" +\n\"944734645476062818954151213916291844429765106694796935401686601005519607768733\" +\n\"539651161493093757096855455938151378956903925101495326562814701199832699220006\" +\n\"639287537471313523642158926512620407288771657835840521964605410543544364216656\" +\n\"224456504299901025658692727914275293117208279393775132610605288123537345106837\" +\n\"293989358087124386938593438917571337630072031976081660446468393772580690923729\" +\n\"752348670291691042636926209019960520412102407764819031601408586355842760953708\" +\n\"655816427399534934654631450404019952853725200495780525465625115410925243799132\" +\n\"626271360909940290226206283675213230506518393405745011209934146491843332364656\" +\n\"937172591448932415900624202061288573292613359680872650004562828455757459659212\" +\n\"053034131011182750130696150983551563200431078460190656549380654252522916199181\" +\n\"995960275232770224985573882489988270746593635576858256051806896428537685077201\" +\n\"222034792099393617926820659014216561592530673794456894907085326356819683186177\" +\n\"226824991147261573203580764629811624401331673789278868922903259334986179702199\" +\n\"498192573961767307583441709855922217017182571277753449150820527843090461946083\" +\n\"521740200583867284970941102326695392144546106621500641067474020700918991195137\" +\n\"646690448126725369153716229079138540393756007783515337416774794210038400230895\" +\n\"185099454877903934612222086506016050035177626483161115332558770507354127924990\" +\n\"985937347378708119425305512143697974991495186053592040383023571635272763087469\" +\n\"321962219006426088618367610334600225547747781364101269190656968649501268837629\" +\n\"690723396127628722304114181361006026404403003599698891994582739762411461374480\" +\n\"405969706257676472376606554161857469052722923822827518679915698339074767114610\" +\n\"302277660602006124687647772881909679161335401988140275799217416767879923160396\" +\n\"356949285151363364721954061117176738737255572852294005436178517650230754469386\" +\n\"930787349911035218253292972604455321079788771144989887091151123725060423875373\" +\n\"484125708606406905205845212275453384800820530245045651766951857691320004281675\" +\n\"805492481178051983264603244579282973012910531838563682120621553128866856495651\" +\n\"261389226136706409395333457052698695969235035309422454386527867767302754040270\" +\n\"224638448355323991475136344104405009233036127149608135549053153902100229959575\" +\n\"658370538126196568314428605795669662215472169562087001372776853696084070483332\" +\n\"513279311223250714863020695124539500373572334680709465648308920980153487870563\" +\n\"349109236605755405086411152144148143463043727327104502776866195310785832333485\" +\n\"784029716092521532609255893265560067212435946425506599677177038844539618163287\" +\n\"961446081778927217183690888012677820743010642252463480745430047649288555340906\" +\n\"218515365435547412547615276977266776977277705831580141218568801170502836527554\" +\n\"321480348800444297999806215790456416195721278450892848980642649742709057912906\" +\n\"921780729876947797511244730599140605062994689428093103421641662993561482813099\" +\n\"887074529271604843363081840412646963792584309418544221635908457614607855856247\" +\n\"381493142707826621518554160387020687698046174740080832434366538235455510944949\" +\n\"843109349475994467267366535251766270677219418319197719637801570216993367508376\" +\n\"005716345464367177672338758864340564487156696432104128259564534984138841289042\" +\n\"068204700761559691684303899934836679354254921032811336318472259230555438305820\" +\n\"694167562999201337317548912203723034907268106853445403599356182357631283776764\" +\n\"063101312533521214199461186935083317658785204711236433122676512996417132521751\" +\n\"355326186768194233879036546890800182713528358488844411176123410117991870923650\" +\n\"718485785622102110400977699445312179502247957806950653296594038398736990724079\" +\n\"767904082679400761872954783596349279390457697366164340535979221928587057495748\" +\n\"169669406233427261973351813662606373598257555249650980726012366828360592834185\" +\n\"584802695841377255897088378994291054980033111388460340193916612218669605849157\" +\n\"148573356828614950001909759112521880039641976216355937574371801148055944229873\" +\n\"041819680808564726571354761283162920044988031540210553059707666636274932830891\" +\n\"688093235929008178741198573831719261672883491840242972129043496552694272640255\" +\n\"964146352591434840067586769035038232057293413298159353304444649682944136732344\" +\n\"215838076169483121933311981906109614295220153617029857510559432646146850545268\" +\n\"497576480780800922133581137819774927176854507553832876887447459159373116247060\" +\n\"109124460982942484128752022446259447763874949199784044682925736096853454984326\" +\n\"653686284448936570411181779380644161653122360021491876876946739840751717630751\" +\n\"684985635920148689294310594020245796962292456664488196757629434953532638217161\" +\n\"339575779076637076456957025973880043841580589433613710655185998760075492418721\" +\n\"171488929522173772114608115434498266547987258005667472405112200738345927157572\" +\n\"771521858994694811794064446639943237004429114074721818022482583773601734668530\" +\n\"074498556471542003612359339731291445859152288740871950870863221883728826282288\" +\n\"463184371726190330577714765156414382230679184738603914768310814135827575585364\" +\n\"359772165002827780371342286968878734979509603110889919614338666406845069742078\" +\n\"770028050936720338723262963785603865321643234881555755701846908907464787912243\" +\n\"637555666867806761054495501726079114293083128576125448194444947324481909379536\" +\n\"900820638463167822506480953181040657025432760438570350592281891987806586541218\" +\n\"429921727372095510324225107971807783304260908679427342895573555925272380551144\" +\n\"043800123904168771644518022649168164192740110645162243110170005669112173318942\" +\n\"340054795968466980429801736257040673328212996215368488140410219446342464622074\" +\n\"557564396045298531307140908460849965376780379320189914086581466217531933766597\" +\n\"011433060862500982956691763884605676297293146491149370462446935198403953444913\" +\n\"514119366793330193661766365255514917498230798707228086085962611266050428929696\" +\n\"653565251668888557211227680277274370891738963977225756489053340103885593112567\" +\n\"999151658902501648696142720700591605616615970245198905183296927893555030393468\" +\n\"121976158218398048396056252309146263844738629603984892438618729850777592879272\" +\n\"206855480721049781765328621018747676689724884113956034948037672703631692100735\" +\n\"083407386526168450748249644859742813493648037242611670426687083192504099761531\" +\n\"907685577032742178501000644198412420739640013960360158381056592841368457411910\" +\n\"273642027416372348821452410134771652960312840865841978795111651152982781462037\" +\n\"913985500639996032659124852530849369031313010079997719136223086601109992914287\" +\n\"124938854161203802041134018888721969347790449752745428807280350930582875442075\" +\n\"513481666092787935356652125562013998824962847872621443236285367650259145046837\" +\n\"763528258765213915648097214192967554938437558260025316853635673137926247587804\" +\n\"944594418342917275698837622626184636545274349766241113845130548144983631178978\" +\n\"448973207671950878415861887969295581973325069995140260151167552975057543781024\" +\n\"223895792578656212843273120220071673057406928686936393018676595825132649914595\" +\n\"026091706934751940897535746401683081179884645247361895605647942635807056256328\" +\n\"118926966302647953595109712765913623318086692153578860781275991053717140220450\" +\n\"618607537486630635059148391646765672320571451688617079098469593223672494673758\" +\n\"309960704258922048155079913275208858378111768521426933478692189524062265792104\" +\n\"362034885292626798401395321645879115157905046057971083898337186403802441751134\" +\n\"722647254701079479399695355466961972676325522991465493349966323418595145036098\" +\n\"034409221220671256769872342794070885707047429317332918852389672197135392449242\" +\n\"617864118863779096281448691786946817759171715066911148002075943201206196963779\" +\n\"510322708902956608556222545260261046073613136886900928172106819861855378098201\" +\n\"847115416363032626569928342415502360097804641710852553761272890533504550613568\" +\n\"414377585442967797701466029438768722511536380119175815402812081825560648541078\" +\n\"793359892106442724489861896162941341800129513068363860929410008313667337215300\" +\n\"835269623573717533073865333820484219030818644918409372394403340524490955455801\" +\n\"640646076158101030176748847501766190869294609876920169120218168829104087070956\" +\n\"095147041692114702741339005225334083481287035303102391969997859741390859360543\" +\n\"359969707560446013424245368249609877258131102473279856207212657249900346829388\" +\n\"687230489556225320446360263985422525841646432427161141981780248259556354490721\" +\n\"922658386366266375083594431487763515614571074552801615967704844271419443518327\" +\n\"569840755267792641126176525061596523545718795667317091331935876162825592078308\" +\n\"018520689015150471334038610031005591481785211038475454293338918844412051794396\" +\n\"997019411269511952656491959418997541839323464742429070271887522353439367363366\" +\n\"320030723274703740712398256202466265197409019976245205619855762576000870817308\" +\n\"328834438183107005451449354588542267857855191537229237955549433341017442016960\" +\n\"009069641561273229777022121795186837635908225512881647002199234886404395915301\" +\n\"846400471432118636062252701154112228380277853891109849020134274101412155976996\" +\n\"543887719748537643115822983853312307175113296190455900793806427669581901484262\" +\n\"799122179294798734890186847167650382732855205908298452980625925035212845192592\" +\n\"798659350613296194679625237397256558415785374456755899803240549218696288849033\" +\n\"256085145534439166022625777551291620077279685262938793753045418108072928589198\" +\n\"971538179734349618723292761474785019261145041327487324297058340847111233374627\" +\n\"461727462658241532427105932250625530231473875925172478732288149145591560503633\" +\n\"457542423377916037495250249302235148196138116256391141561032684495807250827343\" +\n\"176594405409826976526934457986347970974312449827193311386387315963636121862349\" +\n\"726140955607992062831699942007205481152535339394607685001990988655386143349578\" +\n\"165008996164907967814290114838764568217491407562376761845377514403147541120676\" +\n\"016072646055685925779932207033733339891636950434669069482843662998003741452762\" +\n\"771654762382554617088318981086880684785370553648046935095881802536052974079353\" +\n\"867651119507937328208314626896007107517552061443378411454995013643244632819334\" +\n\"638905093654571450690086448344018042836339051357815727397333453728426337217406\" +\n\"577577107983051755572103679597690188995849413019599957301790124019390868135658\" +\n\"553966194137179448763207986880037160730322054742357226689680188212342439188598\" +\n\"416897227765219403249322731479366923400484897605903795809469604175427961378255\" +\n\"378122394764614783292697654516229028170110043784603875654415173943396004891531\" +\n\"881757665050095169740241564477129365661425394936888423051740012992055685428985\" +\n\"389794266995677702708914651373689220610441548166215680421983847673087178759027\" +\n\"920917590069527345668202651337311151800018143412096260165862982107666352336177\" +\n\"400783778342370915264406305407180784335806107296110555002041513169637304684921\" +\n\"335683726540030750982908936461204789111475303704989395283345782408281738644132\" +\n\"271000296831194020332345642082647327623383029463937899837583655455991934086623\" +\n\"509096796113400486702712317652666371077872511186035403755448741869351973365662\" +\n\"177235922939677646325156202348757011379571209623772343137021203100496515211197\" +\n\"601317641940820343734851285260291333491512508311980285017785571072537314913921\" +\n\"570910513096505988599993156086365547740355189816673353588004821466509974143376\" +\n\"118277772335191074121757284159258087259131507460602563490377726337391446137703\" +\n\"802131834744730111303267029691733504770163210661622783002726928336558401179141\" +\n\"944780874825336071440329625228577500980859960904093631263562132816207145340610\" +\n\"422411208301000858726425211226248014264751942618432585338675387405474349107271\" +\n\"004975428115946601713612259044015899160022982780179603519408004651353475269877\" +\n\"760952783998436808690898919783969353217998013913544255271791022539701081063214\" +\n\"304851137829149851138196914304349750018998068164441212327332830719282436240673\" +\n\"319655469267785119315277511344646890550424811336143498460484905125834568326644\" +\n\"152848971397237604032821266025351669391408204994732048602162775979177123475109\" +\n\"750240307893575993771509502175169355582707253391189233407022383207758580213717\" +\n\"477837877839101523413209848942345961369234049799827930414446316270721479611745\" +\n\"697571968123929191374098292580556195520743424329598289898052923336641541925636\" +\n\"738068949420147124134052507220406179435525255522500874879008656831454283516775\" +\n\"054229480327478304405643858159195266675828292970522612762871104013480178722480\" +\n\"178968405240792436058274246744307672164527031345135416764966890127478680101029\" +\n\"513386269864974821211862904033769156857624069929637249309720162870720018983542\" +\n\"369036414927023696193854737248032985504511208919287982987446786412915941753167\" +\n\"560253343531062674525450711418148323988060729714023472552071349079839898235526\" +\n\"872395090936566787899238371257897624875599044322889538837731734894112275707141\" +\n\"095979004791930104674075041143538178246463079598955563899188477378134134707024\" +\n\"674736211204898622699188851745625173251934135203811586335012391305444191007362\" +\n\"844756751416105041097350585276204448919097890198431548528053398577784431393388\" +\n\"399431044446566924455088594631408175122033139068159659251054685801313383815217\" +\n\"641821043342978882611963044311138879625874609022613090084997543039577124323061\" +\n\"690626291940392143974027089477766370248815549932245882597902063125743691094639\" +\n\"325280624164247686849545532493801763937161563684785982371590238542126584061536\" +\n\"722860713170267474013114526106376538339031592194346981760535838031061288785205\" +\n\"154693363924108846763200956708971836749057816308515813816196688222204757043759\" +\n\"061433804072585386208356517699842677452319582418268369827016023741493836349662\" +\n\"935157685406139734274647089968561817016055110488097155485911861718966802597354\" +\n\"170542398513556001872033507906094642127114399319604652742405088222535977348151\" +\n\"913543857125325854049394601086579379805862014336607882521971780902581737087091\" +\n\"646045272797715350991034073642502038638671822052287969445838765294795104866071\" +\n\"739022932745542678566977686593992341683412227466301506215532050265534146099524\" +\n\"935605085492175654913483095890653617569381763747364418337897422970070354520666\" +\n\"317092960759198962773242309025239744386101426309868773391388251868431650102796\" +\n\"491149773758288891345034114886594867021549210108432808078342808941729800898329\" +\n\"753694064496990312539986391958160146899522088066228540841486427478628197554662\" +\n\"927881462160717138188018084057208471586890683691939338186427845453795671927239\" +\n\"797236465166759201105799566396259853551276355876814021340982901629687342985079\" +\n\"247184605687482833138125916196247615690287590107273310329914062386460833337863\" +\n\"825792630239159000355760903247728133888733917809696660146961503175422675112599\" +\n\"331552967421333630022296490648093458200818106180210022766458040027821333675857\" +\n\"301901137175467276305904435313131903609248909724642792845554991349000518029570\" +\n\"708291905255678188991389962513866231938005361134622429461024895407240485712325\" +\n\"662888893172211643294781619055486805494344103409068071608802822795968695013364\" +\n\"381426825217047287086301013730115523686141690837567574763723976318575703810944\" +\n\"339056456446852418302814810799837691851212720193504404180460472162693944578837\" +\n\"709010597469321972055811407877598977207200968938224930323683051586265728111463\" +\n\"799698313751793762321511125234973430524062210524423435373290565516340666950616\" +\n\"589287821870775679417608071297378133518711793165003315552382248773065344417945\" +\n\"341539520242444970341012087407218810938826816751204229940494817944947273289477\" +\n\"011157413944122845552182842492224065875268917227278060711675404697300803703961\" +\n\"878779669488255561467438439257011582954666135867867189766129731126720007297155\" +\n\"361302750355616781776544228744211472988161480270524380681765357327557860250584\" +\n\"708401320883793281600876908130049249147368251703538221961903901499952349538710\" +\n\"599735114347829233949918793660869230137559636853237380670359114424326856151210\" +\n\"940425958263930167801712866923928323105765885171402021119695706479981403150563\" +\n\"304514156441462316376380990440281625691757648914256971416359843931743327023781\" +\n\"233693804301289262637538266779503416933432360750024817574180875038847509493945\" +\n\"489620974048544263563716499594992098088429479036366629752600324385635294584472\" +\n\"894454716620929749549661687741412088213047702281611645604400723635158114972973\" +\n\"921896673738264720472264222124201656015028497130633279581430251601369482556701\" +\n\"478093579088965713492615816134690180696508955631012121849180584792272069187169\" +\n\"631633004485802010286065785859126997463766174146393415956953955420331462802651\" +\n\"895116793807457331575984608617370268786760294367778050024467339133243166988035\" +\n\"407323238828184750105164133118953703648842269027047805274249060349208295475505\" +\n\"400345716018407257453693814553117535421072655783561549987444748042732345788006\" +\n\"187314934156604635297977945507535930479568720931672453654720838168585560604380\" +\n\"197703076424608348987610134570939487700294617579206195254925575710903852517148\" +\n\"852526567104534981341980339064152987634369542025608027761442191431892139390883\" +\n\"454313176968510184010384447234894886952098194353190650655535461733581404554483\" +\n\"788475252625394966586999205841765278012534103389646981864243003414679138061902\" +\n\"805960785488801078970551694621522877309010446746249797999262712095168477956848\" +\n\"258334140226647721084336243759374161053673404195473896419789542533503630186140\" +\n\"095153476696147625565187382329246854735693580289601153679178730355315937836308\" +\n\"224861517777054157757656175935851201669294311113886358215966761883032610416465\" +\n\"171484697938542262168716140012237821377977413126897726671299202592201740877007\" +\n\"695628347393220108815935628628192856357189338495885060385315817976067947984087\" +\n\"836097596014973342057270460352179060564760328556927627349518220323614411258418\" +\n\"242624771201203577638889597431823282787131460805353357449429762179678903456816\" +\n\"988955351850447832561638070947695169908624710001974880920500952194363237871976\" +\n\"487033922381154036347548862684595615975519376541011501406700122692747439388858\" +\n\"994385973024541480106123590803627458528849356325158538438324249325266608758890\" +\n\"831870070910023737710657698505643392885433765834259675065371500533351448990829\" +\n\"388773735205145933304962653141514138612443793588507094468804548697535817021290\" +\n\"849078734780681436632332281941582734567135644317153796781805819585246484008403\" +\n\"290998194378171817730231700398973305049538735611626102399943325978012689343260\" +\n\"558471027876490107092344388463401173555686590358524491937018104162620850429925\" +\n\"869743581709813389404593447193749387762423240985283276226660494238512970945324\" +\n\"558625210360082928664972417491914198896612955807677097959479530601311915901177\" +\n\"394310420904907942444886851308684449370590902600612064942574471035354765785924\" +\n\"270813041061854621988183009063458818703875585627491158737542106466795134648758\" +\n\"677154383801852134828191581246259933516019893559516796893285220582479942103451\" +\n\"271587716334522299541883968044883552975336128683722593539007920166694133909116\" +\n\"875880398882886921600237325736158820716351627133281051818760210485218067552664\" +\n\"867390890090719513805862673512431221569163790227732870541084203784152568328871\" +\n\"804698795251307326634027851905941733892035854039567703561132935448258562828761\" +\n\"061069822972142096199350933131217118789107876687204454887608941017479864713788\" +\n\"246215395593333327556200943958043453791978228059039595992743691379377866494096\" +\n\"404877784174833643268402628293240626008190808180439091455635193685606304508914\" +\n\"228964521998779884934747772913279726602765840166789013649050874114212686196986\" +\n\"204412696528298108704547986155954533802120115564697997678573892018624359932677\" +\n\"768945406050821883822790983362716712449002676117849826437703300208184459000971\" +\n\"723520433199470824209877151444975101705564302954282181967000920251561584417420\" +\n\"593365814813490269311151709387226002645863056132560579256092733226557934628080\" +\n\"568344392137368840565043430739657406101777937014142461549307074136080544210029\" +\n\"560009566358897789926763051771878194370676149821756418659011616086540863539151\" +\n\"303920131680576903417259645369235080641744656235152392905040947995318407486215\" +\n\"121056183385456617665260639371365880252166622357613220194170137266496607325201\" +\n\"077194793126528276330241380516490717456596485374835466919452358031530196916048\" +\n\"099460681490403781982973236093008713576079862142542209641900436790547904993007\" +\n\"837242158195453541837112936865843055384271762803527912882112930835157565659994\" +\n\"474178843838156514843422985870424559243469329523282180350833372628379183021659\" +\n\"183618155421715744846577842013432998259456688455826617197901218084948033244878\" +\n\"725818377480552226815101137174536841787028027445244290547451823467491956418855\" +\n\"124442133778352142386597992598820328708510933838682990657199461490629025742768\" +\n\"603885051103263854454041918495886653854504057132362968106914681484786965916686\" +\n\"184275679846004186876229805556296304595322792305161672159196867584952363529893\" +\n\"578850774608153732145464298479231051167635774949462295256949766035947396243099\" +\n\"534331040499420967788382700271447849406903707324910644415169605325656058677875\" +\n\"741747211082743577431519406075798356362914332639781221894628744779811980722564\" +\n\"671466405485013100965678631488009030374933887536418316513498254669467331611812\" +\n\"336485439764932502617954935720430540218297487125110740401161140589991109306249\" +\n\"231281311634054926257135672181862893278613883371802853505650359195274140086951\" +\n\"092616754147679266803210923746708721360627833292238641361959412133927803611827\" +\n\"632410600474097111104814000362334271451448333464167546635469973149475664342365\" +\n\"949349684588455152415075637660508663282742479413606287604129064491382851945640\" +\n\"264315322585862404314183866959063324506300039221319264762596269151090445769530\" +\n\"144405461803785750303668621246227863975274666787012100339298487337501447560032\" +\n\"210062235802934377495503203701273846816306102657030087227546296679688089058712\" +\n\"767636106622572235222973920644309352432722810085997309513252863060110549791564\" +\n\"479184500461804676240892892568091293059296064235702106152464620502324896659398\" +\n\"732493396737695202399176089847457184353193664652912584806448019652016283879518\" +\n\"949933675924148562613699594530728725453246329152911012876377060557060953137752\" +\n\"775186792329213495524513308986796916512907384130216757323863757582008036357572\" +\n\"800275449032795307990079944254110872569318801466793559583467643286887696661009\" +\n\"739574996783659339784634695994895061049038364740950469522606385804675807306991\" +\n\"229047408987916687211714752764471160440195271816950828973353714853092893704638\" +\n\"442089329977112585684084660833993404568902678751600877546126798801546585652206\" +\n\"121095349079670736553970257619943137663996060606110640695933082817187642604357\" +\n\"342536175694378484849525010826648839515970049059838081210522111109194332395113\" +\n\"605144645983421079905808209371646452312770402316007213854372346126726099787038\" +\n\"565709199850759563461324846018840985019428768790226873455650051912154654406382\" +\n\"925385127631766392205093834520430077301702994036261543400132276391091298832786\" +\n\"392041230044555168405488980908077917463609243933491264116424009388074635660726\" +\n\"233669584276458369826873481588196105857183576746200965052606592926354829149904\" +\n\"576830721089324585707370166071739819448502884260396366074603118478622583105658\" +\n\"087087030556759586134170074540296568763477417643105175103673286924555858208237\" +\n\"203860178173940517513043799486882232004437804310317092103426167499800007301609\" +\n\"481458637448877852227307633049538394434538277060876076354209844500830624763025\" +\n\"357278103278346176697054428715531534001649707665719598504174819908720149087568\" +\n\"603778359199471934335277294728553792578768483230110185936580071729118696761765\" +\n\"505377503029303383070644891281141202550615089641100762382457448865518258105814\" +\n\"034532012475472326908754750707857765973254284445935304499207001453874894822655\" +\n\"644222369636554419422544133821222547749753549462482768053333698328415613869236\" +\n\"344335855386847111143049824839899180316545863828935379913053522283343013795337\" +\n\"295401625762322808113849949187614414132293376710656349252881452823950620902235\" +\n\"787668465011666009738275366040544694165342223905210831458584703552935221992827\" +\n\"276057482126606529138553034554974455147034493948686342945965843102419078592368\" +\n\"022456076393678416627051855517870290407355730462063969245330779578224594971042\" +\n\"018804300018388142900817303945050734278701312446686009277858181104091151172937\" +\n\"487362788787490746528556543474888683106411005102302087510776891878152562273525\" +\n\"155037953244485778727761700196485370355516765520911933934376286628461984402629\" +\n\"525218367852236747510880978150709897841308624588152266096355140187449583692691\" +\n\"779904712072649490573726428600521140358123107600669951853612486274675637589622\" +\n\"529911649606687650826173417848478933729505673900787861792535144062104536625064\" +\n\"046372881569823231750059626108092195521115085930295565496753886261297233991462\" +\n\"835847604862762702730973920200143224870758233735491524608560821032888297418390\" +\n\"647886992327369136004883743661522351705843770554521081551336126214291181561530\" +\n\"175888257359489250710887926212864139244330938379733386780613179523731526677382\" +\n\"085802470143352700924380326695174211950767088432634644274912755890774686358216\" +\n\"216604274131517021245858605623363149316464691394656249747174195835421860774871\" +\n\"105733845843368993964591374060338215935224359475162623918868530782282176398323\" +\n\"730618020424656047752794310479618972429953302979249748168405289379104494700459\" +\n\"086499187272734541350810198388186467360939257193051196864560185578245021823106\" +\n\"588943798652243205067737996619695547244058592241795300682045179537004347245176\" +\n\"289356677050849021310773662575169733552746230294303120359626095342357439724965\" +\n\"921101065781782610874531887480318743082357369919515634095716270099244492974910\" +\n\"548985151965866474014822510633536794973714251022934188258511737199449911509758\" +\n\"374613010550506419772153192935487537119163026203032858865852848019350922587577\" +\n\"559742527658401172134232364808402714335636754204637518255252494432965704386138\" +\n\"786590196573880286840189408767281671413703366173265012057865391578070308871426\" +\n\"151907500149257611292767519309672845397116021360630309054224396632067432358279\" +\n\"788933232440577919927848463333977773765590187057480682867834796562414610289950\" +\n\"848739969297075043275302997287229732793444298864641272534816060377970729829917\" +\n\"302929630869580199631241330493935049332541235507105446118259114111645453471032\" +\n\"988104784406778013807713146540009938630648126661433085820681139583831916954555\" +\n\"825942689576984142889374346708410794631893253910696395578070602124597489829356\" +\n\"461356078898347241997947856436204209461341238761319886535235831299686226894860\" +\n\"840845665560687695450127448663140505473535174687300980632278046891224682146080\" +\n\"672762770840240226615548502400895289165711761743902033758487784291128962324705\" +\n\"919187469104200584832614067733375102719565399469716251724831223063391932870798\" +\n\"380074848572651612343493327335666447335855643023528088392434827876088616494328\" +\n\"939916639921048830784777704804572849145630335326507002958890626591549850940797\" +\n\"276756712979501009822947622896189159144152003228387877348513097908101912926722\" +\n\"710377889805396415636236416915498576840839846886168437540706512103906250612810\" +\n\"766379904790887967477806973847317047525344215639038720123880632368803701794930\" +\n\"895490077633152306354837425681665336160664198003018828712376748189833024683637\" +\n\"148830925928337590227894258806008728603885916884973069394802051122176635913825\" +\n\"152427867009440694235512020156837777885182467002565170850924962374772681369428\" +\n\"435006293881442998790530105621737545918267997321773502936892806521002539626880\" +\n\"749809264345801165571588670044350397650532347828732736884086354000274067678382\" +\n\"196352222653929093980736739136408289872201777674716811819585613372158311905468\" +\n\"293608323697611345028175783020293484598292500089568263027126329586629214765314\" +\n\"223335179309338795135709534637718368409244442209631933129562030557551734006797\" +\n\"374061416210792363342380564685009203716715264255637185388957141641977238742261\" +\n\"059666739699717316816941543509528319355641770566862221521799115135563970714331\" +\n\"289365755384464832620120642433801695586269856102246064606933079384785881436740\" +\n\"700059976970364901927332882613532936311240365069865216063898725026723808740339\" +\n\"674439783025829689425689674186433613497947524552629142652284241924308338810358\" +\n\"005378702399954217211368655027534136221169314069466951318692810257479598560514\" +\n\"500502171591331775160995786555198188619321128211070944228724044248115340605589\" +\n\"595835581523201218460582056359269930347885113206862662758877144603599665610843\" +\n\"072569650056306448918759946659677284717153957361210818084154727314266174893313\" +\n\"417463266235422207260014601270120693463952056444554329166298666078308906811879\" +\n\"009081529506362678207561438881578135113469536630387841209234694286873083932043\" +\n\"233387277549680521030282154432472338884521534372725012858974769146080831440412\" +\n\"586818154004918777228786980185345453700652665564917091542952275670922221747411\" +\n\"206272065662298980603289167206874365494824610869736722554740481288924247185432\" +\n\"360575341167285075755205713115669795458488739874222813588798584078313506054829\" +\n\"055148278529489112190538319562422871948475940785939804790109419407067176443903\" +\n\"273071213588738504999363883820550168340277749607027684488028191222063688863681\" +\n\"104356952930065219552826152699127163727738841899328713056346468822739828876319\" +\n\"864570983630891778648708667618548568004767255267541474285102814580740315299219\" +\n\"781455775684368111018531749816701642664788409026268282444825802753209454991510\" +\n\"451851771654631180490456798571325752811791365627815811128881656228587603087597\" +\n\"496384943527567661216895926148503078536204527450775295063101248034180458405943\" +\n\"292607985443562009370809182152392037179067812199228049606973823874331262673030\" +\n\"679594396095495718957721791559730058869364684557667609245090608820221223571925\" +\n\"453671519183487258742391941089044411595993276004450655620646116465566548759424\" +\n\"736925233695599303035509581762617623184956190649483967300203776387436934399982\" +\n\"943020914707361894793269276244518656023955905370512897816345542332011497599489\" +\n\"627842432748378803270141867695262118097500640514975588965029300486760520801049\" +\n\"153788541390942453169171998762894127722112946456829486028149318156024967788794\" +\n\"981377721622935943781100444806079767242927624951078415344642915084276452000204\" +\n\"276947069804177583220909702029165734725158290463091035903784297757265172087724\" +\n\"474095226716630600546971638794317119687348468873818665675127929857501636341131\" +\n\"462753049901913564682380432997069577015078933772865803571279091376742080565549\" +  \"362541\").toString();\n}\n</code></pre> </li> <li> <p>Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge <code>123456</code> allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor.</p> </li> <li> <p>Erstellen Sie eine <code>TreeMap</code>, in der die Schl\u00fcssel vom Typ <code>String</code> und die Werte vom Typ <code>Intger</code> sind. Als Schl\u00fcssel nutzen Sie alle 4-stelligen Zifferkombinationen <code>\"0000\"</code>, <code>\"0001\"</code> bis <code>\"9999\"</code>. Als Werte sollen dazu jeweils die Anzahl der Vorkommen dieser Ziffernkombinationen in dem obigen <code>String PI</code> gespeichert werden. </p> </li> <li> <p>Erstellen Sie eine <code>ArrayList</code>, in der die Ziffernkombinationen gespeichert sind, die am h\u00e4ufigsten in dem obigen <code>String PI</code> gespeichert sind. Wieviele und welche Ziffernkombinationen sind das?</p> Tipps <ul> <li> <p>Schauen Sie sich dazu die Klasse String genauer an!</p> </li> <li> <p>\u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also <code>\"0000\", \"0001\", \"0002\", ... \"9999\"</code>).  </p> </li> <li> <p>Schreiben Sie sich eine Methode <code>int nrOfOccurences(String sub, String str)</code>, die die Anzahl des Vorkommens von <code>sub</code> in <code>str</code> z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie <code>sub=\"0000\"</code> setzen und <code>str=pi</code> \u2192 <code>\"0000\"</code> kommt 9 Mal in <code>pi</code> vor. Testen Sie auch <code>sub=\"2541\"</code> und <code>str=pi</code>, denn <code>\"2541\"</code> ist der allerletzte <code>substring</code> in unserem <code>pi</code> und kommt 8 Mal vor. </p> </li> </ul> </li> </ol>"},{"location":"aufgaben/#aufgabe-6-interfaces","title":"Aufgabe 6 (Interfaces)","text":"Aufgabe 6 <ol> <li> <p>Das Observer-Entwurfsmuster geh\u00f6rt zu den am meisten verwendeten Designmustern/Designpattern/Pattern in der Programmierung. Es wird auch Beobachter-Muster oder Publisher-Pattern genannt. Wir werden dieses Muster in K\u00fcrze sehr h\u00e4ufig anwenden, wenn wir Nutzerereignisse  in grafischen Oberfl\u00e4chen behandeln. Man kann sich dieses Pattern so vorstellen, dass der Publisher eine Zeitung oder auch Slack ist und dass Listener diese Zeitung (oder Slack) \"abonnieren\". Immer, wenn eine Nachricht ver\u00f6ffentlicht wird, dann erfahren alle Abonnenten davon. Wir werden eine (einfache) Implementierung dieses Entwurfsmusters durchf\u00fchren.</p> </li> <li> <p>Erstellen Sie ein Interface <code>Publisher</code> mit folgenden (abstrakten) Methoden:</p> <ul> <li><code>public boolean register(Listener listener);</code></li> <li><code>public boolean unregister(Listener listener);</code></li> <li><code>public void notifyListeners();</code> </li> <li><code>public String getUpdate(Listener listener);</code></li> </ul> </li> <li> <p>Erstellen Sie ein weiteres Interface <code>Listener</code> mit folgenden (abstrakten) Methoden:</p> <ul> <li><code>public void update();</code></li> <li><code>public void setPublisher(Publisher publisher);</code></li> <li><code>public void removePublisher(Publisher publisher);</code></li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Slack</code>, die das <code>Publisher</code>-Interface implementiert. Objektvariablen der Klasse sind</p> <ul> <li><code>private Set&lt;Listener&gt; listeners;</code> (speichert alle \"Abonnenten\"; kann gerne auch eine Liste sein)</li> <li> <p><code>private int nrOfMessages;</code> (speichert die aktuelle Nummer einer ver\u00f6ffentlichten Nachricht - die Nachrichten, die ver\u00f6ffentlicht werden, sollen fortlaufend nummeriert werden) </p> </li> <li> <p>Im parameterlosen Konstruktor werden die Menge (oder Liste) erzeugt und die <code>nrOfMessages</code> auf <code>0</code> gesetzt. </p> </li> <li> <p>In der Methode <code>register(Listener listener)</code> wird der <code>listener</code> in die Set <code>listeners</code> eingef\u00fcgt. Geben Sie ein <code>true</code> zur\u00fcck, wenn <code>listener</code> tats\u00e4chlich eingef\u00fcgt wurde und <code>false</code> sonst (falls er schon in der Menge (oder Liste) war.</p> </li> <li> <p>In der Methode <code>unregister(Listener listener)</code> wird der <code>listener</code> wieder aus der Set <code>listeners</code> gel\u00f6scht. Geben Sie ein <code>true</code> zur\u00fcck, wenn <code>listener</code> tats\u00e4chlich gel\u00f6scht wurde und <code>false</code> sonst (falls er nicht in der Menge (oder Liste) war.</p> </li> <li> <p>In der Methode <code>notifyListeners()</code> wird f\u00fcr alle <code>listener</code> aus der Menge <code>listeners</code> die <code>update()</code>-Methode aufgerufen (siehe <code>Listener</code> und <code>Student</code>). </p> </li> <li> <p>Die Methode <code>getUpdate(Listener obj)</code> liefert einfach folgenden String zur\u00fcck: <code>\"Breaking News \" + this.nrOfMessages</code>.</p> </li> <li> <p>Erstellen Sie eine Methode <code>public void publishNews()</code>, in der die <code>nrOfMessages</code> um 1 erh\u00f6ht und die  Methode <code>notifyListeners()</code> aufgerufen wird. </p> </li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Student</code>, die das <code>Listener</code>-Interface implementiert. Objektvariablen der Klasse sind</p> <ul> <li><code>private String name;</code> (speichert den Namen von <code>Student</code>)</li> <li> <p><code>private Publisher publisher;</code> (speichert den <code>Publisher</code>, an den sich <code>Student</code> anmeldet) </p> </li> <li> <p>Im parametrisierten Konstruktor <code>public Student(String name)</code> wird der Name initalisiert. </p> </li> <li> <p>In der Methode <code>setPublisher(Publisher publisher)</code> wird die <code>register()</code>-Methode des <code>publisher</code> aufgerufen und der Wert der Objektvariable <code>publisher</code> gesetzt. Geben Sie bei erfolgreicher Anmeldung an den <code>publisher</code> auf die Konsole <code>this.name + \" registered!\"</code> aus. </p> </li> <li> <p>In der Methode <code>removePublisher(Publisher publisher)</code> meldet sich <code>Student</code> wieder vom <code>publisher</code> ab (Aufruf von <code>unregister()</code> und Ausgabe auf die Konsole <code>this.name + \" deregistered!\"</code>.</p> </li> <li> <p>In der Methode <code>update()</code> wird die <code>getUpdate()</code>-Methode des <code>publisher</code> aufgerufen und die zur\u00fcckgegebene Nachricht <code>msg</code> wie folgt auf die Konsole ausgegben: <code>this.name + \" received \" + msg</code>. </p> </li> <li> <p>Implementieren Sie f\u00fcr <code>Student</code> auch die Methoden <code>equals()</code> und <code>hashCode()</code>. </p> </li> </ul> </li> <li> <p>Wenn Sie Ihre Implementierung mit folgender Klasse testen:</p> <pre><code>public class Testklasse {\n\npublic static void main(String[] args) {       final int NR_OF_STUDENTS = 5;\nSlack slack = new Slack();\n\nStudent[] students = new Student[NR_OF_STUDENTS];\nCharacter c = 'A';\nfor(int index=0; index &lt; students.length; index++)\n{\nstudents[index] = new Student(c.toString());\nc++;\nstudents[index].setPublisher(slack);\n}\nslack.publishNews();\n\nSystem.out.println();\nstudents[1].removePublisher(slack);\nstudents[3].removePublisher(slack);\nSystem.out.println();\nslack.publishNews();\n\nSystem.out.println();\nstudents[1].setPublisher(slack);\nstudents[2].removePublisher(slack);\nstudents[4].removePublisher(slack); System.out.println();\nslack.publishNews();\n\nSystem.out.println();\nstudents[0].removePublisher(slack);\nstudents[1].removePublisher(slack);\nstudents[3].setPublisher(slack);\nSystem.out.println();\nslack.publishNews();\n}\n\n}\n</code></pre> <p>dann sollte die Ausgabe ungef\u00e4hr so sein: </p> <pre><code>A registered!\nB registered!\nC registered!\nD registered!\nE registered!\nD received Breaking News 1\nC received Breaking News 1\nB received Breaking News 1\nA received Breaking News 1\nE received Breaking News 1\n\nB deregistered!\nD deregistered!\n\nC received Breaking News 2\nA received Breaking News 2\nE received Breaking News 2\n\nB registered!\nC deregistered!\nE deregistered!\n\nB received Breaking News 3\nA received Breaking News 3\n\nA deregistered!\nB deregistered!\nD registered!\n\nD received Breaking News 4\n</code></pre> </li> </ol>"},{"location":"aufgaben/#aufgabe-7-gui","title":"Aufgabe 7 (GUI)","text":"Aufgabe 7 <ol> <li> <p>Erstellen Sie die GUI f\u00fcr einen solchen Taschenrechner:</p> <p></p> <p>Kann auch schicker sein :-) Viel Spa\u00df!</p> </li> </ol>"},{"location":"aufgaben/#aufgabe-8-ereignisbehandlung","title":"Aufgabe 8 (Ereignisbehandlung)","text":"Aufgabe 8 <ol> <li>Implementieren Sie f\u00fcr den Taschenrechner aus Aufgabe 7 das <code>ActionListener</code>-Interface, so dass der Taschenrechner \u00fcber m\u00f6glichst viel Funktionalit\u00e4t verf\u00fcgt. </li> <li>Minimumanforderung ist, dass durch die Eingabe von Ziffern Zahlen entstehen und dass die Buttons <code>+</code>, <code>-</code>, <code>/</code>, <code>+</code> und <code>=</code> insofern funktionieren, dass dadurch tats\u00e4chlich gerechnet wird, auch wenn die Regel \"Punktrechnung geht vor Strichrechnung\" nicht eingehalten wird. </li> <li>Eine erste Verbesserung (ist schon Zusatz) w\u00e4re, dass die Regel \"Punktrechnung geht vor Strichrechnung\" eingehalten wird.</li> <li>Ab dann ist alles Zusatz und bedarf in vielen F\u00e4llen der Erweiterung der GUI: Verwendung und Beachten von Klammern (ist aber sehr schwer!), Speichern von Zwischenergebnissen, komplexere Operationen durch zu\u00e4tzliche Tasten (Wurzel, Potenzieren, ...). Alles, was Sie m\u00f6chten - Viel Spa\u00df!</li> </ol>"},{"location":"aufgaben/#aufgabe-9-schiebepuzzle","title":"Aufgabe 9 (Schiebepuzzle)","text":"Aufgabe 9 <ol> <li> <p>Implementieren Sie folgendes Puzzle: </p> <p></p> <ul> <li>obige Abbildung zeigt den Anfangszustand des Puzzles (<code>2</code> \u00fcber <code>1</code> links)</li> </ul> <p></p> <ul> <li> <p>obige Abbildung zeigt den Endzustand des Puzzles (<code>1</code> \u00fcber <code>2</code> links)</p> </li> <li> <p>Das Puzzle besteht aus 5 \u201eKacheln\u201c, 3 gelben und 2 roten. Die roten Kacheln sind mit einer <code>1</code> und einer <code>2</code> nummeriert. Am Anfang steht die rote Kachel mit der <code>2</code> \u00fcber der roten Kachel mit der <code>1</code>. (siehe erste Abb.) Ziel des Puzzles ist es, die beiden roten Kacheln zu vertauschen. Wenn links die <code>1</code> \u00fcber der <code>2</code> steht, ist das Puzzle beendet. Wo die gelben Kacheln im Endzustand sind, ist egal (siehe zweite Abb.). Ein Feld ist stets frei (grau dargestellt). In dieses Feld kann eine benachbarte Kachel geschoben werden.</p> </li> <li> <p>Zeigen Sie oben die Anzahl der Z\u00fcge an. Wenn der Endzustand erreicht ist, kann nicht mehr gezogen werden! Der Button <code>Neustart</code> setzt alles wieder auf Anfang. </p> </li> <li> <p>Die Programmierung bleibt ganz Ihnen \u00fcberlassen. Zum Schieben einer Kachel auf das leere Feld, klickt man auf die Kachel selbst. Diese \u201ebewegt\u201c sich dann auf das leere (graue) Feld und hinterl\u00e4sst ein leeres (graues) Feld (siehe folgende Abb.)</p> </li> </ul> <p></p> </li> <li> <p>Tipps: </p> <ul> <li> <p>Sie ben\u00f6tigen keine <code>Canvas</code> und kein \u00dcberschreiben der <code>paintComponent()</code>-Methode!   </p> </li> <li> <p>Am einfachsten bekommt man ein Label in die Mitte eines Panels gesetzt, wenn das Panel im <code>GridLayout(1,1)</code> (oder sogar parameterlos) ist und Sie f\u00fcr das Label <code>label.setHorizontalAlignment(JLabel.CENTER);</code> definieren</p> </li> <li> <p>die (Schrift-)Farbe eines Labels setzt man mit <code>label.setForeground(Color);</code></p> </li> <li> <p>die (Hintergrund-Farbe eines Panels setzt man mit <code>panel.setBackground(Color);</code></p> </li> <li> <p>f\u00fcr das Identifizieren des entsprechenden Panels, auf das man geklickt hat, k\u00f6nnte es hilfreich sein, sich daf\u00fcr eine eigene Klasse zu schreiben (die von JPanel erbt). Muss aber nicht.</p> </li> <li> <p>wahrscheinlich ist es am einfachsten, ein zweidimensionales Array 2x3 als Datenstruktur f\u00fcr Ihr Puzzle zu verwenden</p> </li> </ul> </li> </ol>"},{"location":"aufgaben/#klausurvorbereitung","title":"Klausurvorbereitung","text":""},{"location":"aufgaben/#klausurvorbereitung-quadrat-zeichnen","title":"Klausurvorbereitung (Quadrat zeichnen)","text":"Klausurvorbereitung (Quadrat zeichnen) <ol> <li>Zeichnen Sie ein Quadrat. Passen Sie dieses Quadrat m\u00f6glichst passend in das Fenster. Da es sich um ein Quadrat handelt, kann es sich nur der H\u00f6he oder der Breite des Fensters anpassen, je nachdem, was kleiner ist. Wenn die H\u00f6he kleiner ist, als die Breite, dann soll das Quadrat ausgef\u00fcllt sein. Wenn die Breite kleiner als die H\u00f6he ist, dann soll das Quadrat nicht ausgef\u00fcllt sein, aber die Linienst\u00e4rke auf <code>5.0f</code> gesetzt werden. </li> <li> <p>Die Zeichenfarbe soll zuf\u00e4llig erzeugt werden - jedes Mal, wenn die <code>paintComponent()</code>-Methode aufgerufen wird.</p> <p></p> </li> <li> <p>Beobachten Sie anhand des Farbwechsels, wie oft die <code>paintComponent()</code>-Methode aufgerufen wird. </p> </li> </ol> eine m\u00f6gliche L\u00f6sung f\u00fcr Quadrat zeichnen Zeichnen.java <pre><code>package uebungen.zeichnen;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.util.Random;\nimport javax.swing.*;\npublic class Uebung10 extends JFrame\n{\npublic Uebung10()\n{\nsuper();\nthis.setTitle(\"\u00dcbung10\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\nthis.getContentPane().add(new Canvas());\nthis.setSize(400,300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n\n\n}\nprivate class Canvas extends JPanel\n{\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);\nGraphics2D g2 = (Graphics2D)g;\n//g2.drawRect(20, 130, 200, 100);\nint abstand = this.getHeight()/20;\nint hoehe = this.getHeight() - 2* abstand;\nint breite = this.getWidth() - 2* abstand;\n//Random Farben erzeugen:\nRandom r = new Random();\nint rot = r.nextInt(256);\nint gruen = r.nextInt(256);\nint blau = r.nextInt(256);\nColor c = new Color(rot, gruen, blau);\ng2.setColor(c); //rot-Gr\u00fcn-Blau 0 bis 255\n// Quadrat zeichnen\nif(hoehe &lt; breite)\n{\nint abstandLinks = (this.getWidth()- hoehe)/2;\ng2.fillRect(abstandLinks, abstand, hoehe, hoehe);\n}\nelse\n{\nint abstandOben = (this.getHeight()- breite)/2;\ng2.setStroke(new BasicStroke(5.0f)); //dicke Linien\ng2.drawRect(abstand, abstandOben, breite, breite);\n\n}\n}\n\n}\npublic static void main(String[] args)\n{\nnew Zeichnen();\n}\n}\n</code></pre>"},{"location":"aufgaben/#klausurvorbereitung-rechtecke-zeichnen","title":"Klausurvorbereitung (Rechtecke zeichnen)","text":"Klausurvorbereitung (Rechtecke zeichnen) <ol> <li> <p>Zeichnen Sie mithilfe der Maus farbige Rechtecke. Das Zeichnen soll folgenderma\u00dfen funktionieren:</p> <ul> <li>dort, wo sie mit der Maus in die Zeichenfl\u00e4che klicken, ist ein Eckpunkt des Rechtecks</li> <li>mit gedr\u00fcckter Maustaste ziehen Sie das Rechteck gro\u00df (w\u00e4hrenddessen soll das Rechteck dargestellt werden)</li> <li>durch Loslassen der Maustaste legen Sie die endg\u00fcltige Gr\u00f6\u00dfe des Rechtecks fest und speichern das Rechteck</li> <li>durch wiederholtes Zeichnen werden mehrere Rechtecke gezeichnet. Die zuvor gezeichneten Rechtecke bleiben dargestellt</li> <li>jedes Rechteck hat eine zuf\u00e4llig erzeugte Farbe </li> <li>beachten Sie, dass das Zeichnen eines Rechtecks nicht nur von links oben nach rechts unten, sondern in alle Richtungen m\u00f6glich sein soll</li> </ul> </li> <li> <p>Tipps: </p> <ul> <li>studieren Sie dieses Beispiel</li> <li>behandeln Sie die Mausereignisse in den Methoden <code>mousePressed()</code>, <code>mouseReleased()</code> (<code>MouseListener</code>) sowie aus dem <code>MouseMotionListener</code> <code>mouseDragged()</code></li> <li>erstellen Sie sich zun\u00e4chst eine Klasse, die Rechtecke repr\u00e4sentiert (Objektvariablen <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>, jweils <code>int</code>)</li> <li>speichern Sie die Rechtecke zusammen mit ihrer Farbe in einer <code>Map</code> (untersuchen Sie den Unterschied zwischen <code>HashMap</code> und <code>LinkedHashMap</code>)</li> <li>zeichnen Sie in <code>paintComponent()</code> alle Rechtecke aus der <code>Map</code> und das aktuelle Rechteck (das Sie gerade zeichnen)</li> </ul> <p></p> </li> </ol> eine m\u00f6gliche L\u00f6sung f\u00fcr Rechtecke zeichnen RechteckeZeichnen.javaRechteck.java <pre><code>package uebungen.uebung11;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class RechteckeZeichnen extends JFrame implements MouseListener, MouseMotionListener {\nCanvas canvas;\nRechteck aktRechteck;\nColor aktColor;\nMap&lt;Rechteck, Color&gt; rechtecke;\n\npublic RechteckeZeichnen()\n{\nsuper();\nthis.setTitle(\"Rechtecke zeichnen\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    this.rechtecke = new HashMap&lt;&gt;();\nthis.canvas = new Canvas();\nthis.canvas.addMouseListener(this);\nthis.canvas.addMouseMotionListener(this);\nthis.getContentPane().add(this.canvas);\n\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\nprivate class Canvas extends JPanel\n{\n// die View\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);        Graphics2D g2 = (Graphics2D)g;  if(RechteckeZeichnen.this.aktRechteck != null)\n{\ng2.setColor(aktColor);\nint x = RechteckeZeichnen.this.aktRechteck.getX();\nint y = RechteckeZeichnen.this.aktRechteck.getY();\nint width = RechteckeZeichnen.this.aktRechteck.getWidth();\nint height = RechteckeZeichnen.this.aktRechteck.getHeight();\n\ng2.fillRect(x, y, width, height);\n}\n\nfor(Map.Entry&lt;Rechteck, Color&gt; eintrag : RechteckeZeichnen.this.rechtecke.entrySet())\n{\nRechteck r = eintrag.getKey();\nColor c = eintrag.getValue();\n\ng2.setColor(c);\nint x = r.getX();\nint y = r.getY();\nint width = r.getWidth();\nint height = r.getHeight();\n\ng2.fillRect(x, y, width, height);\n}\n}\n}\n\npublic static void main(String[] args) {\nnew RechteckeZeichnen();\n}\n\n// der Controller\n@Override\npublic void mousePressed(MouseEvent e) {\nPoint p = e.getPoint();\nthis.aktRechteck = new Rechteck(p.x,p.y,0,0);\n\nRandom zuf = new Random();\nint r = zuf.nextInt(256);\nint g = zuf.nextInt(256);\nint b = zuf.nextInt(256);\n\nthis.aktColor = new Color(r,g,b);\n}\n\n@Override\npublic void mouseDragged(MouseEvent e) {\nPoint p = e.getPoint();\nif(p.x &gt; this.aktRechteck.getX()) // Maus nach rechts\n{\nint width = p.x - this.aktRechteck.getX();\nthis.aktRechteck.setWidth(width);\n}\nelse // Maus nach links\n{\nint width = (this.aktRechteck.getX() - p.x) + this.aktRechteck.getWidth();\nthis.aktRechteck.setWidth(width);\nthis.aktRechteck.setX(p.x);\n}\n\nif(p.y &gt; this.aktRechteck.getY()) // Maus nach unten\n{\nint height = p.y - this.aktRechteck.getY();\nthis.aktRechteck.setHeight(height);\n}\nelse // Maus nach oben\n{\nint height = (this.aktRechteck.getY() - p.y) + this.aktRechteck.getHeight();\nthis.aktRechteck.setHeight(height);\nthis.aktRechteck.setY(p.y);\n}\n\nthis.canvas.repaint();\n}\n\n@Override\npublic void mouseReleased(MouseEvent e) {\nPoint p = e.getPoint();\nthis.rechtecke.put(this.aktRechteck, this.aktColor);\n}\n\n@Override public void mouseClicked(MouseEvent e) {}\n@Override public void mouseEntered(MouseEvent e) {}\n@Override public void mouseExited(MouseEvent e) {}\n@Override public void mouseMoved(MouseEvent e) {}\n}\n</code></pre> <pre><code>package uebungen.uebung11;\n\npublic class Rechteck {\nprivate int x;\nprivate int y;\nprivate int width;\nprivate int height;\n\npublic Rechteck(int x, int y, int width, int height) {\nthis.x = x;\nthis.y = y;\nthis.width = width;\nthis.height = height;\n}\n\npublic int getX() {\nreturn x;\n}\n\npublic void setX(int x) {\nthis.x = x;\n}\n\npublic int getY() {\nreturn y;\n}\n\npublic void setY(int y) {\nthis.y = y;\n}\n\npublic int getWidth() {\nreturn width;\n}\n\npublic void setWidth(int width) {\nthis.width = width;\n}\n\npublic int getHeight() {\nreturn height;\n}\n\npublic void setHeight(int height) {\nthis.height = height;\n}\n\n}   </code></pre>"},{"location":"aufgaben/#klausurvorbereitung-graphen","title":"Klausurvorbereitung (Graphen)","text":"Klausurvorbereitung (Graphen) <ol> <li> <p>Erstellen Sie ein Fenster zum Zeichnen. Implementieren Sie den Mauslistener so, dass f\u00fcr jeden Mausklick an der Stelle des Mausklicks ein schwarzer ausgef\u00fcllter Kreis mit dem <code>DURCHMESSER = 30</code> angezeigt wird:</p> <p></p> <ul> <li> <p>F\u00fcr das Model gen\u00fcgt es, sich die Punkte in einer Collection zu merken (am einfachsten ist wohl eine <code>ArrayList</code>). </p> </li> <li> <p>F\u00fcr den Controller h\u00e4tten wir hier die Wahl zwischen <code>mouseClicked()</code> und <code>mousePressed()</code>. Wegen der sp\u00e4teren Erweiterung (Bewegen der Punkte), sollten wir hier <code>mouseClicked()</code> w\u00e4hlen. </p> </li> </ul> </li> <li> <p>Passen Sie die View nun so an, dass die Punkte durch Linien der Strichst\u00e4rke <code>2.0f</code> miteinander verbunden werden. </p> <p></p> <ul> <li>Sie k\u00f6nnen auch gleich (oder sp\u00e4ter) den ersten und letzten Punkt mit einer Linie verbinden (so wie in der Abbildung).</li> </ul> </li> <li> <p>Implementieren sie den <code>MouseMotionListener</code> so, dass wenn Sie mit der Maus auf einen Punkt (Kreis) klicken (oder knapp daneben) und bei gedr\u00fcckter Maustaste die Maus bewegen, sich auch der Punkt mitbewegt. </p> <ul> <li> <p>Zur Erinnerung: die Methode <code>mouseClicked()</code> wird aufgerufen, nachdem <code>mousePressed()</code> und <code>mouseReleased()</code> aufgerufen wurden. \u00c4ndert sich die Mausposition zwischen den Aufrufen von <code>mousePressed()</code> und <code>mouseReleased()</code>, wird <code>mouseClicked()</code> gar nicht aufgerufen. </p> </li> <li> <p>Es empfiehlt sich also, in <code>mousePressed()</code> zu bestimmen, ob durch den Mausklick ein Kreis getroffen wurde. Das muss nat\u00fcrlich kein genauer \"Treffer\" sein, bauen Sie ruhig eine Toleranz von z.B. <code>20</code> ein. Den Punkt, den Sie \"getroffen\" haben, sollten Sie sich merken, denn seine Koordinaten werden ja durch die Mausbewegung ver\u00e4ndert. </p> </li> <li> <p>Wenn Sie in <code>mousePressed()</code> einen Punkt \"getroffen\" haben, dann sollten Sie das Verschieben des Punktes in <code>mouseDragged()</code> behandeln. Beachten Sie, dass <code>mouseDragged()</code> (bei gedr\u00fcckter Maustaste) permanent aufgerufen wird. Wir k\u00f6nnen Sie die \u00c4nderung der Mausposition zwischen zwei Aufrufen von <code>mouseDragged()</code> ermitteln?</p> </li> </ul> </li> </ol> eine m\u00f6gliche L\u00f6sung f\u00fcr Klausurvorbereitung (Graphen) GraphenZeichnen.java <pre><code>package uebungen.uebung13;\n\nimport java.awt.BorderLayout;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class GraphenZeichnen extends JFrame implements MouseListener, MouseMotionListener{\nCanvas canvas;\nList&lt;Point&gt; points; //f\u00fcr uns = Java.util!\nPoint movepoint;\nPoint remember;\n\npublic GraphenZeichnen()\n{\nsuper();\nthis.setTitle(\"Uebung13\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.canvas = new Canvas();\nthis.getContentPane().add(this.canvas, BorderLayout.CENTER);\nthis.canvas.addMouseListener(this);//MOUSELISTENER ANMELDEN NICHT VERGESSEN!!!!\nthis.canvas.addMouseMotionListener(this);//MOUSEMOTIONLISTENER ANMELDEN NICHT VERGESSEN!!!!\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\nthis.points = new ArrayList&lt;&gt;();\n}\n\nprivate class Canvas extends JPanel\n{\nfinal static int DURCHM = 30;\nfinal static int RADIUS = DURCHM / 2;\n\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);            // Implementierung von JPanel aufrufen\nGraphics2D g2 = (Graphics2D)g;      // Methoden von Graphics2D nutzbar\n\n// hier zeichnen wir die Punkte:\nfor(Point p : Uebung13.this.points) // anstatt \"points\" = Uebung13.this.points\n{\nint x = p.x;\nint y = p.y;\ng2.fillOval(x, y, DURCHM, DURCHM);  }\n\nfor (int i = 0; i &lt; Uebung13.this.points.size()-1; i++)  //.size wegen Liste\n{\nPoint p1 = Uebung13.this.points.get(i);\nPoint p2 = Uebung13.this.points.get(i+1);   // \"i+1\" =&gt; Nachbarpunkt von p1\n\ng2.drawLine(p1.x + RADIUS, p1.y+ RADIUS, p2.x+ RADIUS, p2.y+ RADIUS); // \"+ Radius\" -&gt; damit die Linien ab der Mitte des Punktes beginnen\nif(i == Uebung13.this.points.size()-2)      // vorletzte Position=&gt; HIER verbinden wir den ersten und letzten Punkt\n{\nPoint p = Uebung13.this.points.get(0);\ng2.drawLine(p2.x + RADIUS, p2.y + RADIUS, p.x + RADIUS, p.y + RADIUS);\n}\n}\n}\n}\n\npublic static void main(String[] args)\n{\nnew GraphenZeichnen();\n}\n\n@Override\npublic void mouseClicked(MouseEvent e) //wir klicken -&gt; Kreis wird gezeichnet -&gt; Liste wird bef\u00fcllt\n{\nPoint p = e.getPoint();     // speichern den Punkt beim Ort des Klickens\nthis.points.add(p);         // in der Liste speichern\nthis.canvas.repaint();      // canvas wird nochmal gezeichnet-- wichtig!!\n\n}\n\n@Override\npublic void mousePressed(MouseEvent e) //ermitteln, ob wir punkt getroffen haben\n{\nint x = e.getX();\nint y = e.getY();\nfinal int ABSTAND = 20; //Abstand festlegen\nfor(Point p : this.points)\n{\nif(Math.abs(x-p.x)&lt; ABSTAND &amp;&amp; Math.abs(y-p.y)&lt; ABSTAND) // Abstand von Punkt ermitteln \n// MINUS den Punkt, den wir betrachten\n{\nthis.movepoint=p;\nthis.remember=e.getPoint();     // Speichern die Koordinate des Mausklicks\n}\n}\n\n}\n\n@Override public void mouseReleased(MouseEvent e) {}\n@Override public void mouseEntered(MouseEvent e) {}\n@Override public void mouseExited(MouseEvent e) {}\n\n@Override\npublic void mouseDragged(MouseEvent e) //Kreise bewegen:\n{\nint x = e.getX();\nint y = e.getY();\nint x1 = this.remember.x;\nint y1 = this.remember.y;\nint xDif = x-x1; //Wohin und um wie viel haben wir uns bewegt?\nint yDif = y-y1;\nthis.movepoint.x = this.movepoint.x+xDif;   // wir verschieben den Punkt um die Differenz, \nthis.movepoint.y = this.movepoint.y+yDif;   // die wir ermittelt haben\nthis.canvas.repaint();//WICHTIG\nthis.remember = e.getPoint();               // rememberPunkt wird gespeichert       \n}\n}\n</code></pre>"},{"location":"aufgaben/#klausurvorbereitung-quadrat","title":"Klausurvorbereitung (Quadrat)","text":"Klausurvorbereitung (Quadrat) <ol> <li> <p>Erstellen Sie ein Fenster zum Zeichnen. Passen Sie zun\u00e4chst ein Quadrat mit Strichst\u00e4rke <code>3.0f</code> in das Fenster ein und zwar so, dass es \u2153 von entweder der Breite der <code>canvas</code> oder der H\u00f6he der <code>canvas</code> gro\u00df ist, je nachdem, was kleiner ist. Es muss aber nicht mittig sein:</p> <p></p> <ul> <li>In der folgenden Abbildung ist die H\u00f6he kleiner als die Breite. Also ist die H\u00f6he korrekt gedrittelt, aber die gleiche L\u00e4nge wurde f\u00fcr <code>x</code> verwendet, also f\u00fcr den Abstand vom linken Rand zum Quadrat. Deshalb ist der Abstand vom Quadrat zum rechten Rand gr\u00f6\u00dfer. Sie k\u00f6nnen aber das Quadrat auch gerne komplett in die Mitte setzen.  </li> </ul> <p></p> </li> <li> <p>Wenn der <code>create square</code>-Button gedr\u00fcckt wird, erscheint ein farbiges Quadrat, das genau so gro\u00df ist, wie das zuvor gezeichnete nichtausgef\u00fcllte schwarze Quadrat. </p> <p></p> <ul> <li> <p>Die Position des Quadrates wird zuf\u00e4llig bestimmt. Es passt aber auf jeden Fall vollst\u00e4ndig in die Canvas!</p> </li> <li> <p>Auch die Farbe des Quadrates wird zuf\u00e4llig bestimmt. Es beh\u00e4lt die ganze Zeit \u00fcber seine Farbe. </p> </li> </ul> </li> <li> <p>Das farbige Quadrat kann nun durch Bewegen der Maus bei gedr\u00fcckter Maustaste bewegt werden. Wenn das Quadrat (fast) vollst\u00e4ndig in dem schwarzen Quadrat ist, dann bleibt es genau dort und kann nicht weiter bewegt werden.   </p> <p></p> </li> </ol> eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat) QuadratZeichnen.java <pre><code>import java.awt.BasicStroke;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.util.Random;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class QuadratZeichnen  extends JFrame implements MouseListener, MouseMotionListener\n{\nCanvas canvas;\nPoint posSquare;\nColor colorSquare;\nboolean move = false;\nPoint remember;\nboolean fixiert = false;\n\npublic QuadratZeichnen()\n{\nsuper();\nthis.setTitle(\"Quadrat\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    this.canvas = new Canvas();\nthis.canvas.addMouseListener(this);\nthis.canvas.addMouseMotionListener(this);\nthis.getContentPane().add(this.canvas, BorderLayout.CENTER);\n\n// von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert\nthis.getContentPane().add(this.initSouth(), BorderLayout.SOUTH);\n\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\n// start inner class\nprivate class Canvas extends JPanel\n{\n\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);        // Implementierung von JPanel aufrufen\nGraphics2D g2 = (Graphics2D)g;  // Methoden von Graphics2D nutzbar\n\nint width = this.getWidth();\nint height = this.getHeight();\n\n// int smaller = (width &lt; height) ? width : height;\nint smaller = 0;\nint length = 0;\nint x = 0;\nint y = 0;\nif(width &lt; height) {\nsmaller = width;\nlength = smaller/3;\nx = smaller/3;\ny = (height - length)/2;\n} else {\nsmaller = height;\nlength = smaller/3;\ny = smaller/3;\nx = (width - length)/2;\n}\n\ng2.setStroke(new BasicStroke(3.0f));\ng2.drawRect(x, y, length, length);\n\nif(Uebung14.this.posSquare != null  &amp;&amp; Uebung14.this.colorSquare != null) {\nint xSquare = Uebung14.this.posSquare.x;\nint ySquare = Uebung14.this.posSquare.y;\n\nColor cSquare = Uebung14.this.colorSquare;\n\ng2.setColor(cSquare);\ng2.fillRect(xSquare, ySquare, length, length);\n}\n}\n}\n// ende innere Klasse\n\n\nprivate JPanel initSouth() {\nJPanel south = new JPanel();\nJButton btnCreate = new JButton(\"create square\");\n\nbtnCreate.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nRandom r = new Random();\nint widthCanvas = Uebung14.this.canvas.getWidth();\nint heightCanvas = Uebung14.this.canvas.getHeight();\nint lengthSquare = (widthCanvas &lt; heightCanvas) ? widthCanvas/3 : heightCanvas/3;\n\nint x = r.nextInt(widthCanvas - lengthSquare);\nint y = r.nextInt(heightCanvas - lengthSquare);\nUebung14.this.posSquare = new Point(x,y);\n\nint rot = r.nextInt(256);\nint gruen = r.nextInt(256);\nint blau = r.nextInt(256);\nUebung14.this.colorSquare = new Color(rot, gruen, blau);\n\nUebung14.this.canvas.repaint();         }\n\n});\n\nsouth.add(btnCreate);\nreturn south;\n}\n\n\npublic static void main(String[] args) {\nnew QuadratZeichnen();\n}\n\n\n@Override\npublic void mouseDragged(MouseEvent e) {\nif(move)\n{\nint xMouse = e.getX();\nint yMouse = e.getY();\n\nint xLast = this.remember.x;\nint yLast = this.remember.y;\n\nint xDiff = xMouse - xLast;\nint yDiff = yMouse - yLast;\n\nthis.posSquare.x = this.posSquare.x + xDiff;\nthis.posSquare.y = this.posSquare.y + yDiff;\n\n\n// ab hier: im schwarzen Quadrat?\nint widthCanvas = this.canvas.getWidth();\nint heightCanvas = this.canvas.getHeight();\nint xBlack, yBlack; if(widthCanvas &lt; heightCanvas)\n{\nint lengthSquare = widthCanvas/3;\nxBlack = widthCanvas/3;\nyBlack = (heightCanvas - lengthSquare)/2;\n}\nelse\n{\nint lengthSquare = heightCanvas/3;\nyBlack = heightCanvas/3;\nxBlack = (widthCanvas - lengthSquare)/2;\n}\n\nint xSquare = this.posSquare.x;\nint ySquare = this.posSquare.y;\n\nfinal int ABSTAND = 20;\n\nif(Math.abs(xSquare-xBlack) &lt; ABSTAND &amp;&amp; Math.abs(ySquare-yBlack) &lt; ABSTAND)\n{\n// farbiges Quadrat genau im schwarzen\nSystem.out.println(\"im schwarzen\");\nthis.move = false;\nthis.posSquare.x = xBlack;\nthis.posSquare.y = yBlack;\n}\n\nthis.canvas.repaint();\nthis.remember = e.getPoint();\n}   }\n\n\n@Override\npublic void mouseMoved(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n\n@Override\npublic void mouseClicked(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n\n@Override\npublic void mousePressed(MouseEvent e) {\nint xMouse = e.getX();\nint yMouse = e.getY();\n\nif(!this.fixiert &amp;&amp; this.posSquare != null)\n{\nint xSquare = this.posSquare.x;\nint ySquare = this.posSquare.y;\n\nint widthCanvas = this.canvas.getWidth();\nint heightCanvas = this.canvas.getHeight();\n\nint lengthSquare = (widthCanvas &lt; heightCanvas) ? widthCanvas/3 : heightCanvas/3;\n\nif(xMouse &gt;= xSquare &amp;&amp; xMouse &lt;= (xSquare + lengthSquare) &amp;&amp; yMouse &gt;= ySquare &amp;&amp; yMouse &lt;= (ySquare + lengthSquare))\n{\nthis.move = true;\nthis.remember = e.getPoint();\nSystem.out.println(\"im Quadrat\");\n}\n}\n\n}\n\n\n@Override\npublic void mouseReleased(MouseEvent e) {\nthis.move = false;\n\n}\n\n\n@Override\npublic void mouseEntered(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n\n@Override\npublic void mouseExited(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n}\n</code></pre>"},{"location":"aufgaben/#klausurvorbereitung-quadrat-und-kreis","title":"Klausurvorbereitung (Quadrat und Kreis)","text":"Klausurvorbereitung (Quadrat und Kreis) <ol> <li> <p>Erstellen Sie folgendes Fenster zum Zeichnen:</p> <p></p> <p>Dabei sind folgende Dinge zu beachten:</p> <ul> <li> <p>Oben im Fenster ist ein <code>JPanel</code> dessen Hintergrundfarbe <code>LIGHT_GRAY</code> ist und das ein <code>JLabel</code> enth\u00e4lt. Die Beschriftung des <code>JLabels</code> sollten Sie in der <code>paintComponent()</code>-Methode vornehmen, denn das <code>JLabel</code> zeigt an, ob die Zeichenfl\u00e4che (Canvas) breiter als hoch ist (<code>breiter</code>) oder umgedreht (<code>hoeher</code>) und die Breite der Canvas sowie die H\u00f6he (<code>breite, hoehe</code>). Es gibt also diese beiden M\u00f6glichkeiten:</p> <p></p> <p>Achten Sie auch darauf, dass der Text des <code>JLabels</code> angepasst wird, wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern (ergibt sich aber automatisch, wenn Sie den Text des <code>JLabels</code> in der <code>paintComponent()</code>-Methode setzen).</p> </li> <li> <p>In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas).</p> <ul> <li> <p>Es wird eine Linie dargestellt. </p> </li> <li> <p>Diese Linie ist in Strichst\u00e4rke <code>2.0f</code>.</p> </li> <li> <p>Wenn die Canvas breiter als hoch ist, dann verl\u00e4uft die Linie in der Mitte der Breite vertikal. </p> </li> <li> <p>Wenn die Canvas h\u00f6her als breit ist, dann verl\u00e4uft die Linie in der Mitte der H\u00f6he horizontal. </p> </li> <li> <p>Der Fall H\u00f6he==Breite muss nicht extra behandelt werden.</p> </li> </ul> <p>Es gibt also diese beiden M\u00f6glichkeiten:</p> <p></p> </li> <li> <p>Unten im Fenster ist ein <code>JPanel</code>, </p> <ul> <li> <p>dessen Hintergrundfarbe <code>LIGHT_GRAY</code> ist und</p> </li> <li> <p>das ein <code>JButton</code> mit dem Text <code>new</code> enth\u00e4lt.</p> </li> </ul> </li> </ul> </li> <li> <p>Implementieren Sie eine Klasse <code>Figure</code> mit drei <code>privaten</code> Objektvariablen </p> <ul> <li> <p><code>int x</code></p> </li> <li> <p><code>int y</code></p> </li> <li> <p><code>int length</code></p> </li> <li> <p>Schreiben Sie einen parametrisierten Konstruktor <code>Figure(int x, int y, int length)</code>, der die Objektvariablen mit den Parameterwerten initialisiert. Schreiben Sie f\u00fcr alle drei Objektvariablen jeweils <code>Getter</code> und <code>Setter</code>.</p> </li> <li> <p>Implementieren Sie f\u00fcr den Button den <code>ActionListener</code> so, dass durch den Klick auf den Button </p> <ul> <li> <p>in die eine H\u00e4lfte der Canvas ein gelbes Quadrat (Farbe ist <code>YELLOW</code>) und</p> </li> <li> <p>in die andere H\u00e4lfte der Canvas ein gr\u00fcner Kreis (Farbe ist <code>GREEN</code>) gezeichnet wird.</p> </li> <li> <p>Beide Objekte sind vom Typ <code>Figure</code>.</p> </li> <li> <p><code>length</code> des Quadrates entspricht der Seitenl\u00e4nge, <code>length</code> des Kreises entspricht dem Durchmesser.</p> </li> <li> <p><code>x</code> und <code>y</code> sind jeweils die Koordinaten der linken oberen \u201eEcke\u201c.</p> </li> </ul> <p>Beachten Sie, dass <code>length</code> bei Kreis und Quadrat gleich sind und dass sich die L\u00e4nge m\u00f6glichst gut (ca. 90%) in die H\u00e4lfte der Canvas einpasst, d.h. Sie m\u00fcssen schauen, dass das Quadrat und der Kreis stets vollst\u00e4ndig in ihre H\u00e4lfte passen, aber bestm\u00f6glich. </p> <p>Au\u00dferdem sollen die beiden Figuren m\u00f6glichst mittig in ihrer jeweiligen H\u00e4lfte angeordnet sein.</p> <p></p> <p>Wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern, dann m\u00fcssen sich Quadrat und Kreis nicht mit\u00e4ndern! Wenn Sie dann aber wieder auf den <code>new</code>-Button klicken, dann werden die beiden Figuren wieder an die neuen Canvas-Dimensionen angepasst.</p> </li> </ul> </li> <li> <p>Implementieren Sie <code>MouseListener</code> und <code>MouseMotionListener</code> so, dass Sie entweder den Kreis oder das Quadrat bei gedr\u00fcckter Maustaste bewegen k\u00f6nnen, je nachdem, ob Sie auf das Quadrat oder auf den Kreis mit der Maus geklickt haben. </p> <p>Wenn Sie weder das Quadrat noch den Kreis durch den Mausklick getroffen haben, dann soll sich auch nichts bewegen. Bei Kreis betrachten Sie das Tangentenquadrat um den Kreis, um zu pr\u00fcfen, ob Sie den Kreis getroffen haben (also genauso, wie beim Quadrat).</p> <p>Sie k\u00f6nnen Kreis und Quadrat jeweils auch mehrmals hintereinander bewegen und/oder abwechselnd. Sie k\u00f6nnen nur nie beide Figuren zugleich bewegen (selbst wenn sie \u00fcbereinander sind). In der folgenden Abbildung wurde sowohl der Kreis als auch das Quadrat bereits (evtl. mehrfach) bewegt:</p> <p> </p> </li> <li> <p>Wenn Sie den Kreis fast vollst\u00e4ndig \u00fcber das Quadrat bewegt haben oder das Quadrat fast vollst\u00e4ndig \u00fcber den Kreis, dann wird das erkannt und der Kreis wird exakt in das Quadrat fixiert. Das bedeutet, es entsteht z.B. folgendes Bild:</p> <p> </p> <ul> <li> <p>Fast vollst\u00e4ndig bedeutet, dass sich die <code>x</code>- und <code>y</code>-Koordinaten der beiden Figuren um jeweils h\u00f6chsten <code>30</code> Punkte unterscheiden.</p> </li> <li> <p>Sind die Figuren innerhalb dieses Abstandes, dann werden Sie automatisch exakt \u00fcbereinandergelegt.</p> </li> <li> <p>Sind die beiden Figuren exakt \u00fcbereinander, kann keine der beiden Figuren mehr bewegt werden. </p> </li> <li> <p>Es kann nur noch der Button <code>new</code> geklickt werden, um die Ausgangssituation wieder herzustellen.</p> </li> <li> <p>Im Label oben erscheint <code>fixiert</code>. Der Text ist fettgedruckt (bold).</p> </li> </ul> </li> </ol> eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat und Kreis) Figure.javaQuadratUndKreis.java <pre><code>public class Figure {\nprivate int x;\nprivate int y;\nprivate int length;\n\npublic Figure(int x, int y, int length) {\nthis.x = x;\nthis.y = y;\nthis.length = length;\n}\n\npublic int getX() {\nreturn this.x;\n}\n\npublic void setX(int x) {\nthis.x = x;\n}\n\npublic int getY() {\nreturn this.y;\n}\n\npublic void setY(int y) {\nthis.y = y;\n}\n\npublic int getLength() {\nreturn this.length;\n}\n\npublic void setLength(int length) {\nthis.length = length;\n}\n\n}\n</code></pre> <pre><code>import java.awt.BasicStroke;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\nimport javax.swing.*;\n\npublic class QuadratUndKreis  extends JFrame implements MouseListener, MouseMotionListener\n{\nCanvas canvas;\nJLabel lOben;\nFigure circle;\nFigure square;\nboolean circleMoved = false;\nboolean squareMoved = false;\nPoint rememberLastPoint;\nboolean fixed = false;\n\n\npublic QuadratUndKreis()\n{\nsuper();\nthis.setTitle(\"Klausur\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    this.canvas = new Canvas();\nthis.canvas.addMouseListener(this);\nthis.canvas.addMouseMotionListener(this);\nthis.getContentPane().add(this.canvas, BorderLayout.CENTER);\n\n// von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert\nthis.getContentPane().add(this.initNorth(), BorderLayout.NORTH);\nthis.getContentPane().add(this.initSouth(), BorderLayout.SOUTH);\n\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\n// start inner class\nprivate class Canvas extends JPanel\n{\n\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);        // Implementierung von JPanel aufrufen\nGraphics2D g2 = (Graphics2D)g;  // Methoden von Graphics2D nutzbar\nint width = this.getWidth();\nint height = this.getHeight();\ng2.setStroke(new BasicStroke(2.0f));\nif(width &lt; height)\n{\nint mitteY = height/2;\ng2.drawLine(0, mitteY, width, mitteY);\n}\nelse\n{\nint mitteX = width/2;\ng2.drawLine(mitteX, 0, mitteX, height);\n}\n\nString message = (width &lt; height) ? \"hoeher : \" : \"breiter : \";\nmessage = message + \"( \" + width + \", \" + height + \" )\";\nif(QuadratUndKreis.this.fixed)\n{\nmessage = \"fixiert\";\nQuadratUndKreis.this.lOben.setFont(new Font(\"Verdana\", Font.BOLD, 14));\n}\nQuadratUndKreis.this.lOben.setText(message);\n\nif(QuadratUndKreis.this.square != null)\n{\ng2.setColor(Color.YELLOW);\nint x = QuadratUndKreis.this.square.getX();\nint y = QuadratUndKreis.this.square.getY();\nint length = QuadratUndKreis.this.square.getLength();\ng2.fillRect(x,y,length,length);\n}\nif(QuadratUndKreis.this.circle != null)\n{\ng2.setColor(Color.GREEN);\nint x = QuadratUndKreis.this.circle.getX();\nint y = QuadratUndKreis.this.circle.getY();\nint length = QuadratUndKreis.this.circle.getLength();\ng2.fillOval(x,y,length,length);\n}\n}\n}\n// ende innere Klasse\n\nprivate JPanel initNorth() {\nJPanel north = new JPanel();\nnorth.setBackground(Color.LIGHT_GRAY);\nthis.lOben = new JLabel();\nnorth.add(this.lOben);\nreturn north;\n}\n\nprivate JPanel initSouth() {\nJPanel south = new JPanel();\nsouth.setBackground(Color.LIGHT_GRAY);\nJButton btnNew = new JButton(\"new\");\nbtnNew.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nint width = QuadratUndKreis.this.canvas.getWidth();\nint height = QuadratUndKreis.this.canvas.getHeight();\nif(width &lt; height) // hoeher --&gt; untereinander\n{\nint height2 = height/2;\nint smallest = (height2 &lt; width) ? height2 : width;\nint length = (int)(smallest * 0.9);\nint oben = (height2-length)/2;\nint links = (width-length)/2;\n\nQuadratUndKreis.this.square = new Figure(links, oben, length);\nQuadratUndKreis.this.circle = new Figure(links, height2 + oben, length);\n}\nelse // breiter --&gt; nebeneinander\n{\nint width2 = width/2;\nint smallest = (width2 &lt; height) ? width2 : height;\nint length = (int)(smallest * 0.9);\nint links = (width2-length)/2;\nint oben = (height-length)/2;\nQuadratUndKreis.this.square = new Figure(links, oben, length);\nQuadratUndKreis.this.circle = new Figure(width2 + links, oben, length);                 }\nQuadratUndKreis.this.canvas.repaint();\n\nQuadratUndKreis.this.squareMoved = false;\nQuadratUndKreis.this.circleMoved = false;\nQuadratUndKreis.this.fixed = false;\nQuadratUndKreis.this.rememberLastPoint = null;\n}\n\n});\n\nsouth.add(btnNew);\n\nreturn south;\n}\n\npublic static void main(String[] args) {\nnew QuadratUndKreis();\n}\n\n@Override\npublic void mouseDragged(MouseEvent e) {\nif((QuadratUndKreis.this.circleMoved || QuadratUndKreis.this.squareMoved) &amp;&amp; !QuadratUndKreis.this.fixed)\n{\nint x = e.getX();\nint y = e.getY();\n\nint x1 = QuadratUndKreis.this.rememberLastPoint.x;\nint y1 = QuadratUndKreis.this.rememberLastPoint.y;\n\nint xDiff = x - x1;\nint yDiff = y - y1;\n\nif(QuadratUndKreis.this.circleMoved)\n{\nint newX = QuadratUndKreis.this.circle.getX() + xDiff;\nint newY = QuadratUndKreis.this.circle.getY() + yDiff;\n\nQuadratUndKreis.this.circle.setX(newX);\nQuadratUndKreis.this.circle.setY(newY);\n}\nelse if(QuadratUndKreis.this.squareMoved)\n{\nint newX = QuadratUndKreis.this.square.getX() + xDiff;\nint newY = QuadratUndKreis.this.square.getY() + yDiff;\n\nQuadratUndKreis.this.square.setX(newX);\nQuadratUndKreis.this.square.setY(newY);\n}\n\n// ab hier erkennen, ob uebereinander\n\nfinal int ABSTAND = 30;\n\nint xAbstand = Math.abs(QuadratUndKreis.this.square.getX() - QuadratUndKreis.this.circle.getX());\nint yAbstand = Math.abs(QuadratUndKreis.this.square.getY() - QuadratUndKreis.this.circle.getY());\n\nif(xAbstand &lt;= ABSTAND &amp;&amp; yAbstand &lt;= ABSTAND)\n{\nif(QuadratUndKreis.this.circleMoved)\n{\nint newX = QuadratUndKreis.this.square.getX();\nint newY = QuadratUndKreis.this.square.getY();\n\nQuadratUndKreis.this.circle.setX(newX);\nQuadratUndKreis.this.circle.setY(newY);\n}\nelse if(QuadratUndKreis.this.squareMoved)\n{\nint newX = QuadratUndKreis.this.circle.getX();\nint newY = QuadratUndKreis.this.circle.getY();\n\nQuadratUndKreis.this.square.setX(newX);\nQuadratUndKreis.this.square.setY(newY);\n}\nQuadratUndKreis.this.fixed = true;\n}\n\nQuadratUndKreis.this.canvas.repaint();\nQuadratUndKreis.this.rememberLastPoint = e.getPoint();\n}\n\n}\n\n@Override\npublic void mouseMoved(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseClicked(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mousePressed(MouseEvent e) {\nif(!QuadratUndKreis.this.fixed)\n{\nint x = e.getX();\nint y = e.getY();\n\nint xC = QuadratUndKreis.this.circle.getX();\nint yC = QuadratUndKreis.this.circle.getY();\n\nint xS = QuadratUndKreis.this.square.getX();\nint yS = QuadratUndKreis.this.square.getY();    int length = QuadratUndKreis.this.square.getLength();\n\nif(x &gt;= xC &amp;&amp; x &lt;= xC+length &amp;&amp; y &gt;= yC &amp;&amp; y &lt;= yC+length)\n{\nQuadratUndKreis.this.circleMoved = true;\nQuadratUndKreis.this.rememberLastPoint = e.getPoint();\n}\nelse if(x &gt;= xS &amp;&amp; x &lt;= xS+length &amp;&amp; y &gt;= yS &amp;&amp; y &lt;= yS+length)\n{\nQuadratUndKreis.this.squareMoved = true;\nQuadratUndKreis.this.rememberLastPoint = e.getPoint();\n}\n}\n}\n\n@Override\npublic void mouseReleased(MouseEvent e) {\nQuadratUndKreis.this.squareMoved = false;\nQuadratUndKreis.this.circleMoved = false;\nQuadratUndKreis.this.rememberLastPoint = null;\n}\n\n@Override\npublic void mouseEntered(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseExited(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n}\n</code></pre>"},{"location":"aufgaben/#klausurvorbereitung-figure","title":"Klausurvorbereitung (Figure)","text":"Klausurvorbereitung (Figure) <ol> <li> <p>Erstellen Sie folgendes Fenster zum Zeichnen:</p> <p></p> <p>Dabei ist zu beachten, dass es sich bei <code>Ellipse</code>, <code>-</code>, <code>+</code>, <code>L\u00f6schen</code> und <code>Farbe aendern</code> um Buttons handelt. W\u00e4hlen Sie die Layoutmanager der jeweiligen JPanels so, dass das gleiche Aussehen entsteht, also z.B. der Button <code>Ellipse</code> \u00fcber die gesamte Breite des Fensters geht und die Buttons <code>\u2013</code> und <code>+</code> jeweils die angezeigte H\u00f6he ausf\u00fcllen.  Abst\u00e4nde zwischen den Buttons m\u00fcssen nicht beachtet werden. In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas). </p> </li> <li> <p>Implementieren Sie eine Klasse <code>Figure mit folgenden 5 Objektvariablen (m\u00fcssen hier nicht</code>private<code>sein \u2013 Paketsichtbarkeit ist gut; wenn Sie sie</code>private<code>machen, ben\u00f6tigen Sie noch</code>Getter`!!!)</p> <ul> <li><code>Shape shape</code></li> <li><code>Color color</code></li> <li><code>Point start</code></li> <li><code>int width</code></li> <li><code>int height</code></li> </ul> <p><code>Shape</code> ist dabei ein <code>enum</code>, das sie gleich in der Klasse erstellen k\u00f6nnen (oder separat). Dieses <code>enum</code> hat folgende Werte: <code>OVAL</code> und <code>RECTANGLE</code>.</p> <p>Die Idee der Objektvariablen ist in der folgenden Abbildung dargestellt (<code>color</code> ist nicht gezeigt, damit soll die <code>Figure</code> ausgef\u00fcllt werden):</p> <p></p> <ul> <li> <p>Implementieren Sie eine Objektmethode <code>public void changeColor()</code>, in der der Wert von <code>color</code> zuf\u00e4llig (mithilfe von <code>Random</code>) auf einen neuen Wert gesetzt wird. </p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void setStartPoint(Point point)</code>, in der der Wert der Objektvariablen <code>point</code> auf den Parameterwert gesetzt wird. </p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void changeShape()</code>, in der der Wert der Objektvariablen <code>shape</code> auf den jeweils anderen Wert aus dem <code>Shape</code>-<code>enum</code> gesetzt wird (d.h. wenn der Wert <code>OVAL</code> war, dann soll er auf <code>RECTANGLE</code> gesetzt werden und andersherum). </p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void addSideLength(int xDiff, int yDiff)</code>. Die Werte von <code>xDiff</code> und <code>yDiff</code> geben an, um wieviel sich die Seitenl\u00e4ngen \u00e4ndern. </p> </li> </ul> <p>Erkl\u00e4rung: Diese Methode wird sp\u00e4ter aufgerufen, wenn Sie die <code>Figure</code> mit der Maus zeichnen (bei gedr\u00fcckter Maustaste). Entweder Sie ziehen nach rechts unten (dann sind <code>xDiff</code> und <code>yDiff</code> postiv) oder Sie ziehen nach links und/oder nach oben (dann sind <code>xDiff</code> und/oder <code>yDiff</code> entsprechend negativ).</p> <p>Beachten Sie(!):</p> <ul> <li> <p>Wenn <code>xDiff</code> und <code>yDiff</code> postiv sind, dann verh\u00e4lt sich die Sache relativ einfach, denn dann werden die Werte einfach auf die jeweiligen Seitenl\u00e4ngen addiert (siehe folgende Abbildung):</p> <p></p> </li> <li> <p>Wenn <code>xDiff</code> und/oder <code>yDiff</code> negativ sind/ist, dann ist es komplizierter, denn dann \u00e4ndern sich nicht nur die Seitenl\u00e4ngen, sondern es verschiebt sich auch der Startpunkt der <code>Figure</code> (siehe folgende Abbildung f\u00fcr den Fall, dass <code>xDiff</code> und <code>yDiff</code> negativ sind):</p> <p></p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void bigger()</code>, in der die <code>Figure</code> gr\u00f6\u00dfer skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten):</p> <p></p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void smaller()</code>, in der die <code>Figure</code> kleiner skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten):</p> <p></p> </li> </ul> </li> <li> <p>Implementieren Sie <code>MouseListener</code> und <code>MouseMotionListener</code> so, dass Sie bei gedr\u00fcckter Maustaste ein Objekt der Klasse <code>Figure</code> zeichnen k\u00f6nnen, d.h. bei Mausklick in die Canvas wird der <code>start</code>-Punkt der <code>Figure</code> erzeugt und bei gedr\u00fcckter Maustaste vergr\u00f6\u00dfern Sie die <code>Figure</code>. </p> <p>In der folgenden Abbildung steht der Pfeil f\u00fcr die gedr\u00fcckte Maus:</p> <p></p> <p>Wenn Sie die Maustaste loslassen, ist die <code>Figure fertig gezeichnet. Am Anfang handelt es sich bei der</code>Figure<code>um ein</code>RECTANGLE`.</p> </li> <li> <p>Implementieren Sie das Klick-Ereignis des Buttons <code>Ellipse</code> so, dass aus dem Rechteck eine Ellipse wird. Die Farbe der <code>Figure</code> bleibt gleich. Nutzen Sie dazu die Methode <code>changeShape()</code> aus der <code>Figure</code>-Klasse. </p> <p>Die Beschriftung des Buttons wechselt auf <code>Rechteck</code>. Wenn Sie den Button erneut dr\u00fccken, erscheint wieder das Rechteck und auf dem Button erscheint <code>Ellipse</code>. </p> <p></p> <ul> <li> <p>Implementieren Sie das Klick-Ereignis des Buttons <code>+</code> so, dass sich die <code>Figure</code> vergr\u00f6\u00dfert. Nutzen Sie dazu die Methode <code>bigger()</code> aus der <code>Figure</code>-Klasse. </p> <p></p> </li> <li> <p>Implementieren Sie das Klick-Ereignis des Buttons <code>-</code> so, dass sich die <code>Figure</code> verkleinert. Nutzen Sie dazu die Methode <code>smaller()</code> aus der <code>Figure</code>-Klasse. </p> <p></p> </li> <li> <p>Implementieren Sie das Klick-Ereignis des Buttons <code>Farbe aendern</code> so, dass sich die Farbe der <code>Figure</code> \u00e4ndert. Nutzen Sie dazu die Methode <code>changeColor()</code> aus der <code>Figure</code>-Klasse. </p> <p></p> </li> <li> <p>Implementieren Sie das Klick-Ereignis des Buttons <code>Loeschen</code> so, dass keine <code>Figure</code> mehr existiert und angezeigt wird.  </p> <p></p> </li> </ul> </li> </ol> eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Figure) Figure.javaFigureZeichnen.java <pre><code>import java.awt.Color;\nimport java.awt.Point;\nimport java.util.Random;\n\npublic class Figure {\n\nenum Shape {\nOVAL, RECTANGLE\n}\nShape shape;\nColor color;\nPoint start;\nint width;\nint height;\n\npublic Figure(Shape shape, Point start) {\nthis.shape = shape;\nthis.start = start;\nthis.width = 0;\nthis.height = 0;\nRandom r = new Random();\nint gelb = r.nextInt(256);\nint rot = r.nextInt(256);\nint blau = r.nextInt(256);\nthis.color = new Color(rot, gelb, blau);\n}\n\npublic void changeColor() {\nRandom r = new Random();\nint gelb = r.nextInt(256);\nint rot = r.nextInt(256);\nint blau = r.nextInt(256);\nthis.color = new Color(rot, gelb, blau);\n}\n\npublic void addSideLengths(int xDiff, int yDiff)\n{\nif(xDiff&lt;0 &amp;&amp; yDiff&lt;0) {\nPoint start = this.start;\nstart.x += xDiff;\nstart.y += yDiff;\nthis.width -= xDiff;\nthis.height -= yDiff;\nthis.setStartPoint(start);\n}\nelse if(xDiff&lt;0 &amp;&amp; yDiff&gt;=0) {\nPoint start = this.start;\nstart.x += xDiff;\nthis.width -= xDiff;\nthis.height += yDiff;\nthis.setStartPoint(start);\n}\nelse if(xDiff&gt;=0 &amp;&amp; yDiff&lt;0) {\nPoint start = this.start;\nstart.y += yDiff;\nthis.width += xDiff;\nthis.height -= yDiff;\nthis.setStartPoint(start);\n}\nelse {\nthis.width += xDiff;\nthis.height += yDiff;\n}\n}\n\npublic void setStartPoint(Point start) {\nthis.start = start;\n}\n\npublic void bigger() {\nint xScale = (int)(this.width * 0.1);\nint yScale = (int)(this.height * 0.1);\nPoint start = this.start;\nstart.x -= xScale;\nstart.y -= yScale;\nthis.width += 2*xScale;\nthis.height += 2*yScale;\nthis.setStartPoint(start);\n}\n\npublic void smaller() {\nint xScale = (int)(this.width * 0.1);\nint yScale = (int)(this.height * 0.1);\nPoint start = this.start;\nstart.x += xScale;\nstart.y += yScale;\nthis.width -= 2*xScale;\nthis.height -= 2*yScale;\nthis.setStartPoint(start);\n}\n\npublic void changeShape() {\nif(this.shape == Shape.OVAL) this.shape = Shape.RECTANGLE;\nelse this.shape = Shape.OVAL;\n}\n\n}\n</code></pre> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.GridLayout;\nimport java.awt.Point;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\nimport javax.swing.*;\n\npublic class FigureZeichnen  extends JFrame {\nCanvas canvas;\n\n\npublic FigureZeichnen()\n{\nsuper();\nthis.setTitle(\"Klausur\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    this.canvas = new Canvas();\nthis.canvas.addMouseListener(this.canvas);\nthis.canvas.addMouseMotionListener(this.canvas);\nthis.getContentPane().add(this.canvas, BorderLayout.CENTER);\n\n// von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert\nthis.getContentPane().add(this.initNorth(), BorderLayout.NORTH);\nthis.getContentPane().add(this.initSouth(), BorderLayout.SOUTH);\nthis.getContentPane().add(this.initWest(), BorderLayout.WEST);\nthis.getContentPane().add(this.initEast(), BorderLayout.EAST);\n\nthis.setSize(800, 600);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\n// start inner class\nprivate class Canvas extends JPanel implements MouseListener, MouseMotionListener\n{\nFigure figure;\nPoint remember;\nboolean finishedCreating = false;\n\n@Override\nprotected void paintComponent(Graphics g)\n{\nsuper.paintComponent(g);        // Implementierung von JPanel aufrufen\nGraphics2D g2 = (Graphics2D)g;  // Methoden von Graphics2D nutzbar\n\nif(this.figure != null)\n{\ng2.setColor(this.figure.color);\nPoint start = this.figure.start;\nint width = this.figure.width;\nint height = this.figure.height;\nif(this.figure.shape == Figure.Shape.RECTANGLE) {\ng2.fillRect(start.x, start.y, width, height);\n}\nelse if(this.figure.shape == Figure.Shape.OVAL) {\ng2.fillOval(start.x, start.y, width, height);\n}\n\n}\n}\n\n@Override\npublic void mouseDragged(MouseEvent e) {\nif(this.figure != null &amp;&amp; !this.finishedCreating) {\nPoint here = e.getPoint();\nint xDiff = here.x - this.remember.x;\nint yDiff = here.y - this.remember.y;\nthis.figure.addSideLengths(xDiff, yDiff);\nthis.remember = here;\n}\nSystem.out.println(this.figure.width + \", \" + this.figure.height);\nthis.repaint();\n\n}\n\n@Override\npublic void mouseMoved(MouseEvent e) {\n\n\n}\n\n@Override\npublic void mouseClicked(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mousePressed(MouseEvent e) {\nPoint here = e.getPoint();\nif(this.figure == null) {\nthis.figure = new Figure(Figure.Shape.RECTANGLE, here);\nthis.remember = here;\n}\nthis.repaint();\n}\n\n@Override\npublic void mouseReleased(MouseEvent e) {\nif(!this.finishedCreating) this.finishedCreating = true;\n\n}\n\n@Override\npublic void mouseEntered(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseExited(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n}\n// ende innere Klasse\n\nprivate JPanel initNorth() {\nJPanel north = new JPanel();\nnorth.setLayout(new GridLayout(1,1));\nJButton circle = new JButton(\"Ellipse\");\ncircle.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nKlausur2PZ.this.canvas.figure.changeShape();\nJButton circle = (JButton)e.getSource();\nif(circle.getActionCommand().equals(\"Ellipse\")) circle.setText(\"Rechteck\");\nelse circle.setText(\"Ellipse\");\nKlausur2PZ.this.canvas.repaint();\n}\n\n});\nnorth.add(circle);\nreturn north;\n}\n\nprivate JPanel initSouth() {\nJPanel south = new JPanel();\nsouth.setLayout(new GridLayout(1,2,10,10));\nJButton delete = new JButton(\"L\u00f6schen\");\ndelete.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nKlausur2PZ.this.canvas.figure = null;\nKlausur2PZ.this.canvas.finishedCreating = false;\nKlausur2PZ.this.canvas.remember = null;\nKlausur2PZ.this.canvas.repaint();\n}\n\n});\nsouth.add(delete);\nJButton farbe = new JButton(\"Farbe aendern\");\nfarbe.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nKlausur2PZ.this.canvas.figure.changeColor();;\nKlausur2PZ.this.canvas.repaint();\n}\n\n});\nsouth.add(farbe);\nreturn south;\n}\n\nprivate JPanel initWest() {\nJPanel west = new JPanel();\nwest.setLayout(new GridLayout(1,1));\nJButton minus = new JButton(\"-\");\nminus.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nKlausur2PZ.this.canvas.figure.smaller();\nKlausur2PZ.this.canvas.repaint();\n}\n\n});\nwest.add(minus);\nreturn west;\n}\n\nprivate JPanel initEast() {\nJPanel east = new JPanel();\neast.setLayout(new GridLayout(1,1));\nJButton plus = new JButton(\"+\");\nplus.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nKlausur2PZ.this.canvas.figure.bigger();\nKlausur2PZ.this.canvas.repaint();\n}\n\n});\neast.add(plus);\nreturn east;\n}\n\npublic static void main(String[] args) {\nnew Klausur2PZ();\n}\n}\n</code></pre>"},{"location":"collections/","title":"Collections","text":"<p>Diese Vorlesung (5.5.2023) findet nicht in Pr\u00e4senz statt! Arbeiten Sie diese Abschnitte</p> <ul> <li>Mengen und</li> <li>Listen</li> </ul> <p>selbst\u00e4ndig durch. Hier auch noch ein Video zu diesem Thema:</p> Video zu Mengen und Listen <p></p> Quellcode aus dem Video ListenUndMengen.java <pre><code>package vorlesungen.listenmengen;\n\nimport java.util.*;\n\n/*\n * Collections: aehnlich wie Arrays, viele Elemente speichern\n * keine feste Laenge\n * wir koennen nur Referenztypen speichern (also nicht int, boolean, char, double, ...)\n * Elemente verschiedenen Typs speicherbar --&gt; gar nicht gut, deshalb Typisieren\n * Arten von Collections: List (wie Arrays), Set (keine Doppelungen), Stack, Queue\n * Map (2-spaltige Tabellen Schl\u00fcssel-/Werte-Paare)\n */\npublic class ListenUndMengen {\n\npublic static void main(String[] args) {\n\nSystem.out.printf(\"%n%n-------------- Listen ------------------%n%n\");\nSet&lt;String&gt; set1 = new HashSet&lt;&gt;();\nSet&lt;String&gt; set2 = new TreeSet&lt;&gt;();\n\nString s1 = \"erster\";\nString s2 = \"zweiter\";\nString s3 = \"dritter\";\nString s4 = \"zweiter\";\n\nInteger i1 = 1;\n\nSystem.out.println(set1.add(s1));\nSystem.out.println(set1.add(s2));\nSystem.out.println(set1.add(s3));\nSystem.out.println(set1.add(s4));\n// System.out.println(set1.add(i1));\n\nSystem.out.println(set1.size());\n\nIterator&lt;String&gt; it = set1.iterator();\nwhile(it.hasNext())\n{\nSystem.out.println(it.next());\n}\n\nSystem.out.println();\n\nfor(String element : set1)\n{\nSystem.out.println(element);\n}\n\nSystem.out.println(set1.remove(\"erster\"));\nSystem.out.println(set1.remove(\"vierter\"));\n\nSystem.out.println();\n\nfor(String element : set1)\n{\nSystem.out.println(element);\n}\n\nSystem.out.printf(\"%n%n-------------- Listen ------------------%n%n\");\n\nList&lt;String&gt; l1 = new ArrayList&lt;&gt;();\nList&lt;String&gt; l2 = new LinkedList&lt;&gt;();\n\nl1.add(s1);\nl1.add(s2);\nl1.add(s3);\nl1.add(s4);\n\nfor(String s : l1)\n{\nSystem.out.println(s);\n}\n\nSystem.out.println(l1.size());\n\nSystem.out.println(l1.remove(\"zweiter\"));\nSystem.out.println(l1.remove(\"vierter\"));\n\n\nfor(String s : l1)\n{\nSystem.out.println(s);\n}\nSystem.out.println();\nSystem.out.println(\"geloescht : \" + l1.remove(1));\n\nfor(String s : l1)\n{\nSystem.out.println(s);\n}\n\nSystem.out.println();\n\nl2.add(\"neu\");\nl2.add(\"alt\");\n\nfor(String s : l2)\n{\nSystem.out.println(s);\n}\n\nSystem.out.println();\n\nl1.addAll(l2);\n\nfor(String s : l1)\n{\nSystem.out.println(s);\n}\n\n\nSystem.out.println();\n\n\nl1.removeAll(l2);\n\nfor(String s : l1)\n{\nSystem.out.println(s);\n}\n}\n\n}\n</code></pre> <p>Das Thema Mengenoperationen ist au\u00dferdem f\u00fcr Aufgabe 4 n\u00fctzlich! Stack und Queue sind nur f\u00fcr weiteres Interesse.</p> <p>Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections. </p> <p>Collections haben drei wesentliche Eigenschaften:</p> <ul> <li>Eine Collection hat keine festgelegte L\u00e4nge, d.h. es sind beliebig viele Elemente in einer Collection speicherbar.</li> <li>In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen (<code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper-Klassen kennenlernen. </li> <li>Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren, damit sie nur Elemente eines Typs speichern kann.</li> </ul>"},{"location":"collections/#arten-von-collections","title":"Arten von Collections","text":"<p>Es gibt unterschiedliche Arten von Collections, welche je nach Einsatzzweck verwendet werden:</p>  Typ  \u00a0Struktur  \u00a0Zugriff   Eigenschaften  <code>List</code>  Menge   wahlfrei (indexbasiert)  Iterator  kann Elemente mehrfach enthalten  <code>Set</code>  Menge   Iterator   keine doppelten Elemente  keine Ordnung der Elemente  <code>Map</code>  Schl\u00fcssel-Werte-Paare   schl\u00fcsselbasiert  Schl\u00fcssel ist eindeutig  Werte k\u00f6nnen mehrfach sein  <code>Stack</code>  Stapel/Stack   oberstes Element  last-in-first-out-Prinzip  <code>Queue</code>  Warteschlange   erstes und letztes Element   first-in-first-out-Prinzip  <p>Wir werden uns in diesem Semester aber nur mit den Collections <code>List</code>, <code>Set</code> und <code>Map</code> besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann (<code>pop</code>) und von dem man das oberste Element entfernen kann (<code>pop</code>). Mithilfe von <code>top</code> erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. </p> <p>Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head) der Warteschlange. </p> <p>Eine Liste (<code>List</code>) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente <code>e1</code> und <code>e2</code> gilt <code>e1.equals(e2) == true</code> (oder <code>e1.hashCode() == e2.hashCode()</code>). </p> <p>Eine Menge (<code>Set</code>) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die <code>add(element)</code>-Methode f\u00fcr eine Menge ein <code>boolean</code> zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde (<code>true</code>) oder nicht (<code>false</code>). </p> <p>Eine <code>Map</code> kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel <code>key</code> und in der rechten die Werte <code>value</code>. Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer <code>Map</code> sind eine <code>Set</code>). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). </p> <p>Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung:</p> <p></p>"},{"location":"collections/#der-collection-klassenbaum","title":"Der Collection-Klassenbaum","text":"<p>Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von <code>Collection</code> einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps.</p> <p></p> <p>Die \"Mutter-Klasse\" der Collections <code>List</code> und <code>Set</code> ist <code>Collection</code>. In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces. Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ <code>List</code> f\u00fcr die Listen und den Typ <code>Set</code> f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten <code>List</code>-Objekte bzw. keine konkreten <code>Set</code>-Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes <code>ArrayList</code>-Objekt erzeugen werden oder ein konkretes <code>HashSet</code>-Objekt. Hier einige Beispiele:</p> <pre><code>import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Collections {\n\npublic static void main(String[] args) {\nList l1 = new ArrayList();\nList l2 = new LinkedList();\n\nSet s1 = new HashSet();\nSet s2 = new TreeSet();\n}\n}\n</code></pre> <p>Beachten Sie, alle Klassen aus dem <code>java.util</code>-Paket zu importieren! Eine Klasse <code>List</code> gibt es z.B. auch im <code>java.awt</code>-Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben:</p> <pre><code>import java.util.*;\n</code></pre> <p>Der <code>*</code> ist eine Wildcard und importiert alle Klassen aus <code>java.util</code>. </p> <p>Zur Diskussion, wann <code>ArrayList</code> besser ist und wann <code>LinkedList</code>, siehe hier. Eine Diskussion \u00fcber die Unterschiede zwischen <code>HashSet</code> und <code>TreeSet</code> finden Sie z.B. hier. Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von <code>ArrayList</code> erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von <code>HashSet</code>.</p>"},{"location":"collections/#mengen-sets","title":"Mengen - Sets","text":"<p>Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\npublic static void main(String[] args) {\n\nSet menge = new HashSet();\n\nString s1 = \"erster\";\nString s2 = \"zweiter\";\nString s3 = \"dritter\";\nString s4 = \"zweiter\";\n\nSystem.out.println(menge.add(s1)); // true\nSystem.out.println(menge.add(s2)); // true\nSystem.out.println(menge.add(s3)); // true\nSystem.out.println(menge.add(s4)); // false\n\nSystem.out.println(menge.size()); // 3\n\nIterator it = menge.iterator();\nwhile(it.hasNext())\n{\nSystem.out.println(it.next());\n} }\n}\n</code></pre> <p>In Zeile <code>1</code> werden zun\u00e4chst alle verwendeten Klassen aus dem <code>java.util</code>-Paket geladen. Das sind f\u00fcr unser Beispiel <code>Set</code>, <code>HashSet</code> und <code>Iterator</code>. Die <code>Iterator</code>-Klasse wird verwendet, um durch unsere Menge <code>menge</code> zu laufen. Wir werden auf den <code>Iterator</code> gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. </p> <p>In Zeile <code>7</code> wird die Menge <code>menge</code> erzeugt. Wir deklarieren daf\u00fcr den Typ <code>Set</code> und erzeugen unter Verwendung des parameterlosen Konstruktors von <code>HashSet</code> ein <code>HashSet</code>-Objekt. Die <code>menge</code> hat also den Compilertyp <code>Set</code> und mindestens den Laufzeittyp <code>HashSet</code> (nat\u00fcrlich noch weitere Laufzeittypen, z.B. <code>Object</code>). </p> <p>In den Zeilen <code>14-17</code> werden der <code>menge</code> Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ <code>String</code>. Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode <code>add(element)</code>. Diese Methode gibt ein <code>boolean</code> zur\u00fcck. Wir lassen in den Zeilen <code>14-17</code> diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: </p> <pre><code>true\ntrue\ntrue\nfalse\n</code></pre> <p>Die <code>add()</code>-Methode gibt also 3x ein <code>true</code> zur\u00fcck und beim vierten Aufruf ein <code>false</code>. Das liegt daran, dass beim vierten Aufruf von <code>add()</code> (Zeile <code>17</code>) das \u00fcbergebene Element <code>s4</code> nicht in die Menge <code>menge</code> eingef\u00fcgt wird, da sich in dieser Menge bereits ein <code>String</code> mit dem Wert <code>\"zweiter\"</code> befindet und eine Menge keine Doppelungen enthalten darf. Da <code>s2.equals(s4)</code> den Wert <code>true</code> zur\u00fcckgibt, erkennt die <code>add()</code>-Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und <code>s4</code> wird deshalb nicht eingef\u00fcgt. </p> <p>In Zeile <code>19</code> lassen wir uns die Anzahl der Elemente in der Menge <code>menge</code> ausgeben. Dies erfolgt mithilfe der <code>size()</code>-Methode (in Collections ist es also nicht <code>length()</code>, auch nicht <code>length</code> und auch nicht <code>getLength()</code> oder <code>getSize()</code>, sondern <code>size()</code>). Der Wert von <code>size()</code> in unserem Beispiel ist <code>3</code>. </p>"},{"location":"collections/#der-iterator","title":"Der Iterator","text":"<p>Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. </p> <p>Die Klasse <code>Iterator</code> besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren):</p> <ul> <li><code>hasNext()</code>: liefert ein <code>true</code> zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann <code>false</code>,</li> <li><code>next()</code>: liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), </li> <li><code>remove()</code>: l\u00f6scht das mit <code>next()</code>zur\u00fcckgegebene Element.</li> </ul> <p>In Zeile <code>21</code> erzeugen wir zun\u00e4chst mit der <code>iterator()</code>-Methode aus <code>Set</code> ein Objekt von <code>Iterator</code>. Die Referenz auf dieses Objekt nennen wir hier <code>it</code>. </p> <p>Die <code>while()</code>-Schleife in den Zeilen <code>22-25</code> durchl\u00e4uft nun diese Iteration, indem sie mithilfe von <code>hasNext()</code> pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von <code>next()</code> aus der Iteration entnommen und in Zeile <code>24</code> auf die Konsole ausgegeben. </p> <p>Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben:</p> <pre><code>zweiter\ndritter\nerster\n</code></pre> <p>Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge <code>\"erster\"</code>, <code>\"zweiter\"</code>, <code>\"dritter\"</code> in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge <code>\"zweiter\"</code>, <code>\"dritter\"</code>, <code>\"erster\"</code>. Auf die Reihenfolge haben wir in Mengen keinen Einfluss!</p>"},{"location":"collections/#methoden-fur-mengen","title":"Methoden f\u00fcr Mengen","text":"<p>Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: <code>add()</code>, <code>size()</code> und <code>iterator()</code>. Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von <code>java.util.Collection</code> erben (erben ist hier eigentlich nicht ganz richtig, da es sich bei <code>java.util.Collection</code> um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection):</p>  Methode   Beschreibung  <code>boolean add(E element)</code>  F\u00fcgt Element <code>element</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>boolean addAll(Collection c)</code>  F\u00fcgt alle Elemente der Collection <code>c</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>void clear()</code>  Entfernt alle Elemente aus der Collection. <code>boolean contains(E element)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich <code>element</code> in der Collection befindet, sonst <code>false</code>. <code>boolean containsAll(Collection c)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich alle Elemente der Collection <code>c</code> in der Collection befinden, sonst <code>false</code>. <code>boolean isEmpty()</code>  Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst <code>false</code>. <code>Iterator iterator()  Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. <code>boolean remove(Object o)</code>  Entfernt <code>o</code> aus der Collection und gibt <code>true</code> zur\u00fcck, wenn ein Element entfernt wurde, sonst <code>false</code>. <code>boolean removeAll(Collection c)</code>  Entfernt alle Elemente aus c aus der Collection und gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst <code>false</code>. <code>int size()</code>  Gibt die Anzahl der Elemente in der Collection zur\u00fcck. <code>Object[] toArray()</code>  Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. <p>Der TyP <code>E</code> in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem <code>Iterator</code> sehen wir eine neue Syntax <code>&lt;E&gt;</code>. Diese lernen wir gleich kennen. <code>E</code> steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren. </p>"},{"location":"collections/#typisieren","title":"Typisieren","text":"<p>Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun:</p> <pre><code>    Set menge = new HashSet();\nmenge.add(new String(\"erster\"));        // String einf\u00fcgen\nmenge.add(new Power(2,4));              // Power einf\u00fcgen\nmenge.add(new Point(2,3));              // Point einf\u00fcgen\nmenge.add(new Konto());                 // Konto einf\u00fcgen\n</code></pre> <p>Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. </p> <p>Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. </p> <p>Das Typisieren einer Collection erfolgt mithilfe der Diamond-Syntax:  <code>Collection&lt;Typ&gt; name = new KonkreteKlasse&lt;&gt;();</code></p> <p>Wir typisieren die Menge <code>menge</code> aus dem eben gezeigten Beispiel:</p> <pre><code>    Set&lt;String&gt; menge = new HashSet&lt;&gt;();    // mit String typisiert - menge nimmt nur Strings auf\nmenge.add(new String(\"erster\"));        // String einf\u00fcgen\nmenge.add(new Power(2,4));              // Fehler - kein String\nmenge.add(new Point(2,3));              // Fehler - kein String\nmenge.add(new Konto());                 // Fehler - kein String\n</code></pre> <p>Wir haben <code>menge</code> typisiert und angegeben, dass <code>menge</code> nur Objekte vonm Typ <code>String</code> aufnehmen kann. Dazu geben wir bei der Typdeklaration <code>Set&lt;String&gt;</code> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt <code>new HashSet&lt;&gt;();</code>. Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). </p> <p>Der Versuch, Objekte eines anderen Typs als <code>String</code> in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. </p> <p>Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: </p> <pre><code>import java.util.*;\n\npublic class Collections {\n\npublic static void main(String[] args) {\n\nSet&lt;String&gt; menge = new HashSet&lt;&gt;();\n\nString s1 = \"erster\";\nString s2 = \"zweiter\";\nString s3 = \"dritter\";\nString s4 = \"zweiter\";\n\nSystem.out.println(menge.add(s1)); // true\nSystem.out.println(menge.add(s2)); // true\nSystem.out.println(menge.add(s3)); // true\nSystem.out.println(menge.add(s4)); // false\n\nSystem.out.println(menge.size()); // 3\n\nIterator&lt;String&gt; it = menge.iterator();\nwhile(it.hasNext())\n{\nSystem.out.println(it.next());\n} }\n}\n</code></pre> <p>Beachten Sie, dass auch der Iterator (Zeile <code>21</code>) typisiert wird.</p>"},{"location":"collections/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each-Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist:</p> <pre><code>for(TypElement element : collection)\n{\n\n}\n</code></pre> <p>F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\npublic static void main(String[] args) {\n\nSet&lt;String&gt; menge = new HashSet&lt;&gt;();\n\nString s1 = \"erster\";\nString s2 = \"zweiter\";\nString s3 = \"dritter\";\nString s4 = \"zweiter\";\n\nSystem.out.println(menge.add(s1)); // true\nSystem.out.println(menge.add(s2)); // true\nSystem.out.println(menge.add(s3)); // true\nSystem.out.println(menge.add(s4)); // false\n\nSystem.out.println(menge.size()); // 3\n\nfor(String s : menge)\n{\nSystem.out.println(s);\n}\n}\n}\n</code></pre> <p>\u00dcbrigens: anstelle der Collection (hier: <code>menge</code>) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each-Schleife verwenden. </p> \u00dcbung <p>Ersetzen Sie im oberen Beispiel <code>HashSet</code> durch <code>TreeSet</code>. Erkennen Sie einen Unterschied?</p>"},{"location":"collections/#listen","title":"Listen","text":"<p>Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von <code>java.util.Collection</code> abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\nstatic void fillList(List&lt;String&gt; list) {\nfor (int i = 0; i &lt; 10; i++) { list.add(String.valueOf(i)); }\n}\n\nstatic void printList(List&lt;String&gt; list) {\nIterator&lt;String&gt; it = list.iterator();\nwhile(it.hasNext()) {\nSystem.out.print(it.next() + \" \");\n}\nSystem.out.println();\nSystem.out.println(\"End of list\");\n}\n\npublic static void main(String[] args)\n{\nList&lt;String&gt; list1 = new ArrayList&lt;&gt;();\nfillList(list1);\nprintList(list1);\n\nList&lt;String&gt; list2 = new LinkedList&lt;&gt;();\nfillList(list2);\nlist2.remove(\"3\");      // Wert!\nlist2.remove(6);        // Index!\nlist1.removeAll(list2);\nprintList(list2);       // 0 1 2 4 5 6 8 9\nprintList(list1);       // 3 7\n}\n\n}\n</code></pre> <p>Wir erstellen uns zwei Listen <code>list1</code> (Zeile <code>26</code>) und <code>list2</code> (Zeile <code>30</code>). Beide sind vom Compilertyp List und beide sind typisiert mit <code>String</code>, d.h. sie k\u00f6nnen nur Strings aufnehmen. </p> <p>Die Methode <code>fillList()</code> (Zeilen <code>5-11</code>) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern <code>0...9</code>. Da die Liste Strings erwartet, werden die <code>int</code>-Ziffern mithilfe von <code>String.valueOf()</code> in einen <code>String</code> umgewandelt (Zeile <code>9</code>). Die <code>add()</code>-Methode f\u00fcgt die Strings hinzu (Zeile <code>9</code>).  </p> <p>Die Methode <code>printList()</code> (Zeilen <code>13-33</code>) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile <code>18</code>). </p> <p>Der Aufruf von <code>printList(list1);</code> in Zeile <code>28</code> f\u00fchrt zu folgender Ausgabe:</p> <pre><code>0 1 2 3 4 5 6 7 8 9 \nEnd of list\n</code></pre> <p>Die Liste <code>list2</code> wird zun\u00e4chst ebenfalls mit den Ziffern <code>0...9</code> (jeweils als <code>String</code>) bef\u00fcllt. Die Anweisung <code>list2.remove(\"3\");</code> in Zeile <code>32</code> bewirkt, dass der Wert <code>\"3\"</code> aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" </code></pre> <p>In Zeile <code>33</code> wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index <code>6</code> gespeichert ist. Das ist das Element <code>\"7\"</code>. Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" </code></pre> <p>Die Anweisung <code>list1.removeAll(list2);</code> in Zeile <code>34</code> bewirkt nun, dass aus <code>list1</code> alle Werte gel\u00f6scht werden, die (auch) in <code>list2</code> enthalten sind, also <code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\"</code>. Das bewirkt, dass in <code>list1</code> dann nur noch die Werte <code>\"3\" \"7\"</code> \u00fcbrig bleiben. </p> <p>Die Anweisung <code>printList(list2);</code> in Zeile <code>35</code> bewirkt folgende Ausgabe: </p> <pre><code>0 1 2 4 5 6 8 9 \nEnd of list\n</code></pre> <p>Die Anweisung <code>printList(list1);</code> in Zeile <code>36</code> bewirkt folgende Ausgabe: </p> <pre><code>3 7 \nEnd of list\n</code></pre> <p>Die Methode <code>printList()</code> h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each-Schleife implementiert werden k\u00f6nnen:</p> <pre><code>    static void printList(List&lt;String&gt; list) {\nfor(String s : list)\n{\nSystem.out.print(s + \" \");\n}\nSystem.out.println();\nSystem.out.println(\"End of list\");\n}\n</code></pre> \u00dcbung <p>Gegeben ist folgender Code: <pre><code>  Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;();\nSet&lt;Integer&gt; s2 = new HashSet&lt;&gt;();\n\nfor (int i = 10; i &gt;= 1; i--) { s1.add(i); }\nfor (int i = 9; i &lt;= 12; i++) { s2.add(i); }\u000bs1.addAll(s2); \u00a0 </code></pre></p> <ol> <li>Was ist der R\u00fcckgabewert von <code>s1.addAll(s2);</code> und warum?</li> <li>Implementieren Sie die Ausgabe aller Werte von <code>s1</code> und <code>s2</code>. </li> </ol>"},{"location":"collections/#mengenoperationen","title":"Mengenoperationen","text":"<p>Angenommen, wir haben drei Mengen <code>A</code>, <code>B</code> und <code>C</code>, wobei alle Elemente aus <code>C</code> auch Elemente in <code>A</code> sind. Mithilfe der Methoden <code>addAll()</code>, <code>removeAll()</code>, <code>retainAll()</code>  und <code>containsAll()</code> lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt:</p> <p></p>"},{"location":"collections/#stack-und-queue","title":"Stack und Queue","text":"<p>Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen:</p>"},{"location":"collections/#stack","title":"Stack","text":"<ul> <li>Last-In-First-Out-Prinzip</li> <li><code>push(E element)</code> zum Hinzuf\u00fcgen</li> <li><code>pop()</code> entfernt oberstes Element und gibt es zur\u00fcck</li> <li><code>empty()</code> pr\u00fcft, ob der Stack leer ist</li> </ul>"},{"location":"collections/#queue","title":"Queue","text":"<ul> <li>First-In-First-Out-Prinzip</li> <li><code>add()/offer()</code> zum Hinzuf\u00fcgen</li> <li><code>remove()/poll()</code> entfernt vorderstes Element und gibt es zur\u00fcck</li> <li><code>element()/peek()</code> pr\u00fcft, ob die Warteschlange leer ist</li> </ul>"},{"location":"collections/#wertetypen-in-collections","title":"Wertetypen in Collections","text":"<p>Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper-Klassen zur Verf\u00fcgung: <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code>, <code>Boolean</code>:</p> <pre><code>// Wertetypen k\u00f6nnen nicht als konkrete\u00a0\n// Typen in Collections verwendet werden\nList&lt;int&gt; l = new ArrayList&lt;&gt;();    // Fehler !!\n\n// Verwendung der Wrapper-Klassen + Auto-Boxing\nList&lt;Integer&gt; l = new ArrayList&lt;&gt;();\n\nl.add(100);\u00a0 \u00a0 \u00a0 \u00a0 // sogenanntes Auto-Boxing\n</code></pre> <p>Das obere beispiel zeigt in Zeile <code>3</code>, wie es nicht geht. Die <code>List l</code> kann nicht mit <code>int</code> typisiert werden. Stattdessen muss die Wrapper-Klasse <code>Integer</code> verwendet werden. Wir betrachten Wrapper-Klassen im n\u00e4chsten Abschnitt.</p>"},{"location":"einstieg/","title":"Einstieg","text":"<p>Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem <code>java.util</code>-Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane. </p> <p>Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse <code>JOptionPane</code> befindet sich im Paket <code>javax.swing</code>. Wenn Sie in Ihrem Java-Projekt eine Datei <code>module-info.java</code> haben, dann m\u00fcssen Sie darin <code>requires java.desktop;</code> eintragen, um \u00fcberhaupt Klassen aus dem <code>javax.swing</code>-Paket importieren zu k\u00f6nnen, das sich das Paket <code>javax.swing</code> im Modul <code>java.desktop</code> befindet:</p> module-info.java <pre><code>module SoSe23   // SoSe23 ist der Name des Java-Projektes\n{\nrequires java.desktop;\n}\n</code></pre> <p>Die interessanten Methoden zur Erzeugung der Dialoge sind</p> <ul> <li><code>showConfirmDialog()</code>,</li> <li><code>showInputDialog()</code>,</li> <li><code>showMessageDialog()</code> und</li> <li><code>showOptionDialog()</code> </li> </ul> <p>Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann (<code>showInputDialog()</code>) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen <code>String</code> zur\u00fcck und die anderen Dialoge geben ein <code>int</code> zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene <code>int</code>-Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen:</p> <ul> <li><code>JOptionPane.YES_OPTION</code>,</li> <li><code>JOptionPane.NO_OPTION</code>,</li> <li><code>JOptionPane.CANCEL_OPTION</code>,</li> <li><code>JOptionPane.OK_OPTION</code>,</li> <li><code>JOptionPane.CLOSED_OPTION</code></li> </ul>"},{"location":"einstieg/#beispiel-showconfirmdialog","title":"Beispiel <code>showConfirmDialog()</code>","text":"<p>Die <code>showConfirmDialog()</code>-Methode ist zwei Mal \u00fcberladen. Es gibt </p> <ul> <li><code>static int showConfirmDialog(Component parentComponent, Object message)</code> und </li> <li><code>static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType)</code></li> </ul> <p>Als <code>optionType</code> gibt es dabei die Auswahl zwischen </p> <ul> <li><code>JOptionPane.DEFAULT_OPTION</code>,</li> <li><code>JOptionPane.YES_NO_OPTION</code>,</li> <li><code>JOptionPane.YES_NO_CANCEL_OPTION</code>,</li> <li><code>JOptionPane.OK_CANCEL_OPTION</code></li> </ul> <p>Die <code>parentComponent</code> ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf <code>null</code> setzen. </p> <p>Der <code>String</code> <code>message</code> erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein <code>String</code> sein kann, sondern besipielsweise auch ein <code>Icon</code>, ist der Typ von <code>message</code> als <code>Object</code> deklariert.</p> <p>Der <code>String</code> <code>title</code> erscheint als Titel des Dialogfensters. </p>"},{"location":"einstieg/#beispiel-mit-yes_no_option","title":"Beispiel mit <code>YES_NO_OPTION</code>","text":"<pre><code>int auswahl = JOptionPane.showConfirmDialog(\nnull,                           // parentComponent\n\"Wollen Sie wirklich beenden?\", // message\n\"Programmende\",                 // title\nJOptionPane.YES_NO_OPTION       // optionType\n);\n</code></pre> <p>erzeugt z.B. folgendes Dialogfenster:</p> <p></p> <p>Wenn Sie nun auf einen der beiden Button <code>No</code> oder <code>Yes</code> klicken, dann schlie\u00dft sich das Fenster wieder und in dem <code>int</code> <code>auswahl</code> ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten:</p> <pre><code>if(auswahl == JOptionPane.NO_OPTION)\n{\n// es wurde auf NO geklickt\n}\nelse if(auswahl == JOptionPane.YES_OPTION)\n{\n// es wurde auf YES geklickt\n}\n</code></pre>"},{"location":"einstieg/#beispiel-mit-yes_no_cancel_option","title":"Beispiel mit <code>YES_NO_CANCEL_OPTION</code>","text":"<pre><code>int auswahl = JOptionPane.showConfirmDialog(null, \"Weitere Seiten scannen?\", \"Speichern\", JOptionPane.YES_NO_CANCEL_OPTION);\n\nif(auswahl == JOptionPane.NO_OPTION)\n{\n// es wurde auf NO geklickt\n}\nelse if(auswahl == JOptionPane.YES_OPTION)\n{\n// es wurde auf YES geklickt\n}\nelse if(auswahl == JOptionPane.CANCEL_OPTION)\n{\n// es wurde auf CANCEL geklickt\n}\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p>"},{"location":"einstieg/#beispiel-showinputdialog","title":"Beispiel <code>showInputDialog()</code>","text":"<p>Die Methode <code>showInputDialog()</code> \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode <code>showInputDialog()</code> ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form <code>showInputDialog(Object message)</code> oder, wenn wir noch einen <code>messageType</code> hinzuf\u00fcgen wollen, <code>showInputDialog(Component parentComponent, Object message, String title, int messageType)</code>. </p> <p>F\u00fcr den <code>messageType</code> gibt es folgende vordefinierte Konstanten:</p> <ul> <li><code>ERROR_MESSAGE</code>,</li> <li><code>INFORMATION_MESSAGE</code>,</li> <li><code>WARNING_MESSAGE</code>,</li> <li><code>QUESTION_MESSAGE</code>,</li> <li><code>PLAIN_MESSAGE</code></li> </ul> <p>Wichtig ist, dass die <code>showInputDialog()</code>-Methode den <code>String</code> zur\u00fcckgibt, der eingegeben wurde. </p> <pre><code>String eingabe = JOptionPane.showInputDialog(\"Ihre Eingabe : \");\nSystem.out.println(\"Sie haben \" + eingabe + \" eingegeben\");\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p> <p>Die Implementierung</p> <pre><code>String eingabe = JOptionPane.showInputDialog(null, \"Ihre Eingabe : \", \"Dialogtitel\", JOptionPane.ERROR_MESSAGE);\nSystem.out.println(\"Sie haben \" + eingabe + \" eingegeben\");\n</code></pre> <p>erzeugt folgendes Dialogfenster:</p> <p></p> <p>Die Ansicht der Fenster und auch der <code>messageType</code>-Icons sind betriebssystemabh\u00e4ngig. </p>"},{"location":"einstieg/#ausblick","title":"Ausblick","text":"<p>Angenommen, wir wollen <code>JOptionPane.showInputDialog()</code> verwenden, um eine Zahl einzugeben. Klar ist, dass <code>showInputDialog()</code> die Eingabe als <code>String</code> zur\u00fcckgibt. </p> <ol> <li> <p>Problem: Wie wandeln wir einen <code>String</code> zu einem <code>int</code> (oder <code>double</code>) um? </p> <p>Antwort: mit der Hilfe von Wrapper-Klassen </p> </li> <li> <p>Problem: Angenommen, wir haben eine L\u00f6sung, <code>String</code> nach <code>int</code> umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. <code>hallo</code>? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln.</p> <p>Antwort: mit der Behandlung von Exceptions</p> </li> </ol>"},{"location":"enum/","title":"Aufz\u00e4hlungstypen (enum)","text":""},{"location":"enum/#motivation","title":"Motivation","text":"<p>Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B.</p> <pre><code>String tag = \"MONTAG\"   // kann auch Werte \"Dienstag\" usw. annehmen\nint tag = 0;            // Magic Number f\u00fcr \"Montag\"\n</code></pre> <p>Das Problem:  - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. <code>Tag = \"hallo\"</code> oder <code>Tag=4711</code>, - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit</p> Beispiel TicTacToe <pre><code>public class TicTacToe {\nint[][] field;\n\nTicTacToe()\n{\nfield = new int[3][3];\nfor(int i=0; i&lt;field.length; i++)\nfor(int j=0; j&lt;field[i].length; j++)\nfield[i][j]=0;\n}\n\nvoid makeMove(int i, int j, int player)\n{\nif(field[i][j]==0 &amp;&amp; player==1 || player==2)    field[i][j]=player;\n}\n}\n</code></pre> <ul> <li>Zust\u00e4nde <code>EMPTY</code> (<code>0</code>), <code>RED</code> (<code>1</code>), <code>BLACK</code> (<code>2</code>) verschl\u00fcsselt \u2192 magic numbers</li> <li><code>field[i][j]</code> k\u00f6nnte auch beliebige andere <code>int</code>-Werte annehmen</li> <li>Code nahezu unlesbar</li> </ul>"},{"location":"enum/#erster-verbesserungsversuch-konstanten","title":"Erster Verbesserungsversuch: Konstanten","text":"Beispiel TicTacToe mit Konstanten <pre><code>public class TicTacToe {\nint[][] field;\nstatic final int EMPTY = 0;     // Feld ist leer\nstatic final int RED = 1;       // auf das Feld hat rot gesetzt\nstatic final int BLACK = 2;     // auf das Feld hat schwarz gesetzt\n\nTicTacToe()\n{\nfield = new int[3][3];\nfor(int i=0; i&lt;field.length; i++)\nfor(int j=0; j&lt;field[i].length; j++)\nfield[i][j]=EMPTY;\n}\n\nvoid makeMove(int i, int j, int player)\n{\nif(field[i][j]==EMPTY &amp;&amp; player==RED || player==BLACK)  field[i][j]=player;     // hier wird auf das Feld rot oder schwarz gesetzt\n}\n}\n</code></pre> <ul> <li>etwas besser, aber immer noch beliebige Werte f\u00fcr <code>field[i][j]</code> m\u00f6glich</li> </ul>"},{"location":"enum/#der-aufzahlungstyp-enum","title":"Der Aufz\u00e4hlungstyp <code>enum</code>","text":"<p>Anforderungen:</p> <ul> <li>eigener Datentyp</li> <li>endliche Anzahl an Zust\u00e4nden bzw. Werten</li> <li>leserliche Bezeichnung der Werte</li> </ul> <p>L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort <code>enum</code></p> <p>Syntax: <pre><code>    enum TypName {WERT1, WERT2, WERT3};\n</code></pre></p> <p>Verwendung: - <code>TypName</code> nun als Datentyp verwendbar, z.B. <code>TypName[][]</code> - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. <code>TypName.WERT1</code></p> Beispiel TicTacToe mit enum <pre><code>public class TicTacToe {\nenum State {EMPTY, RED, BLACK};\nState[][] field;\nTicTacToe()\n{\nfield = new State[3][3];\nfor(int i=0; i&lt;field.length; i++)\nfor(int j=0; j&lt;field[i].length; j++)\nfield[i][j]=State.EMPTY;\n}\n\nvoid makeMove(int i, int j, State player)\n{\nif(field[i][j]==State.EMPTY &amp;&amp; player!=State.EMPTY)     field[i][j]=player;\n}\n}\n</code></pre> <ul> <li>typsicher</li> <li>rot und schwarz \u00fcber <code>State.RED</code> und <code>State.BLACK</code> erreichbar</li> <li>andere Zust\u00e4nde nicht m\u00f6glich</li> </ul>"},{"location":"enum/#details","title":"Details:","text":"<ul> <li>alle <code>enum</code> erben implizit von <code>java.lang.Enum</code></li> <li><code>enum</code> sind Referenztypen</li> <li>die Konstanten (Werte) in <code>enum</code> sind automatisch <code>static</code> und <code>final</code></li> <li><code>==</code> kann verwendet werden (auch <code>switch()</code>); <code>equals()</code> gibt es aber auch</li> </ul> Beispiel enum <pre><code>State s = State.EMPTY;  // s = 0 oder s = \"rot\" oder so geht nicht \n//-&gt; typsicher\nswitch(s)\n{\ncase EMPTY:     System.out.println(\"leeres Feld\"); break;\ncase RED:   System.out.println(\"roter Stein\"); break;\ncase BLACK:     System.out.println(\"schwarzer Stein Feld\"); break;\n}\n</code></pre>"},{"location":"enum/#weiteres","title":"Weiteres:","text":"<ul> <li>auch Definition von Methoden m\u00f6glich</li> <li><code>toString()</code>, <code>equals()</code> usw. aus <code>Object</code> k\u00f6nnen \u00fcberschrieben werden</li> <li>Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig)</li> <li>Zugriff auf das Array von Konstanten mithilfe von <code>values()</code></li> </ul> Beispiel f\u00fcr Werte mit Attributennoch ein Beispiel f\u00fcr Werte mit Attributen <pre><code>enum Farben {\nKREUZ(12), PIK(11), HERZ(10), KARO(9);\nprivate int farbwert;\n\nprivate Farben(int wert)\n{\nthis.farbwert=wert;\n}   @Override\npublic String toString()\n{\nchar c = ' ';\nswitch(this)\n{\ncase KREUZ  : c ='\\u2663';  break;\ncase PIK    : c ='\\u2664';  break;\ncase HERZ   : c ='\\u2665';  break;\ncase KARO   : c ='\\u2666';  break;\n}\nreturn String.valueOf(c);\n}\n}\n</code></pre> <pre><code>enum Karten {\nAS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\nprivate int kartenwert;\n\nprivate Karten(int wert)\n{\nthis.kartenwert=wert;\n}\n\n@Override\npublic String toString()\n{\nString s = \"\";\nswitch(this)\n{\ncase AS     : s =\"A\";   break;\ncase ZEHN   : s =\"10\";  break;\ncase NEUN   : s =\"9\";   break;\ncase ACHT   : s =\"8\";   break;\ncase SIEBEN : s =\"7\";   break;\ncase K      : s =\"K\";   break;\ncase D      : s =\"D\";   break;\ncase B      : s =\"B\";   break;\n}\nreturn s;\n}\n}\n</code></pre> Ausf\u00fchrliches Beispiel - Skat.java <pre><code>package vorbereitungen.enums;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Skat {\nKarte[] p1;\nKarte[] p2;\nKarte[] p3;\nKarte[] skat;\n\nenum Karten {\nAS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\nprivate int kartenwert;\n\nprivate Karten(int wert)\n{\nthis.kartenwert=wert;\n}\n\n@Override\npublic String toString()\n{\nString s = \"\";\nswitch(this)\n{\ncase AS     : s =\"A\";   break;\ncase ZEHN   : s =\"10\";  break;\ncase NEUN   : s =\"9\";   break;\ncase ACHT   : s =\"8\";   break;\ncase SIEBEN : s =\"7\";   break;\ncase K      : s =\"K\";   break;\ncase D      : s =\"D\";   break;\ncase B      : s =\"B\";   break;\n}\nreturn s;\n}\n}\n\nenum Farben {\nKREUZ(12), PIK(11), HERZ(10), KARO(9);\nprivate int farbwert;\n\nprivate Farben(int wert)\n{\nthis.farbwert=wert;\n}   @Override\npublic String toString()\n{\nchar c = ' ';\nswitch(this)\n{\ncase KREUZ  : c ='\\u2663';  break;\ncase PIK    : c ='\\u2664';  break;\ncase HERZ   : c ='\\u2665';  break;\ncase KARO   : c ='\\u2666';  break;\n}\nreturn String.valueOf(c);\n}\n}\n\nclass Karte {\nKarten k;\nFarben f;\n\nKarte(Karten k, Farben f)\n{\nthis.k=k;\nthis.f=f;\n}\n\n@Override\npublic Karte clone()\n{\nreturn new Karte(this.k,this.f);\n}\n\n@Override\npublic String toString()\n{\nreturn f.toString()+k.toString()+\" \";\n}\n\n}\n\nclass Deck {\nKarte[] deck;\n\nDeck()\n{\ndeck = new Karte[32];\nint index = 0;\nfor(Farben f: Farben.values())\n{\nfor(Karten k:Karten.values())\n{\ndeck[index++] = new Karte(k,f);\n}\n}\n}\n\n@Override\npublic String toString()\n{\nString s = \"\";\nfor(int i=0; i&lt;deck.length; i++)\n{\ns += deck[i].f.toString() + deck[i].k.toString() +\" \";\nif(i==7 || i==15 || i==23 || i==31) s+=\"\\n\";\n}\nreturn s;\n}\n\npublic void print()\n{\nSystem.out.println(this.toString());\n}\n\n}\n\nSkat()\n{\np1 = new Karte[8];\np2 = new Karte[8];\np3 = new Karte[8];\nskat = new Karte[2];    }\n\nboolean existsFalse(boolean[] b)\n{\nfor(int i=0; i&lt;b.length; i++)\n{\nif(!b[i]) return true;\n}\nreturn false;\n}\n\npublic void geben()\n{\nDeck d = new Deck();\nRandom r = new Random();    boolean[] b = new boolean[32]; Arrays.fill(b, false);\nint indexP1 = 0, indexP2 = 0, indexP3 =0, indexSkat = 0;\nint zz = r.nextInt(32);\nwhile(existsFalse(b))\n{\nwhile(b[zz])\n{\nzz = r.nextInt(32);\n}\nb[zz] = true;\nif(indexP1&lt;8)\n{\np1[indexP1++] = d.deck[zz].clone();\n}\nelse if(indexP2&lt;8)\n{\np2[indexP2++] = d.deck[zz].clone();\n}\nelse if(indexP3&lt;8)\n{\np3[indexP3++] = d.deck[zz].clone();\n}\nelse if(indexSkat&lt;2)\n{\nskat[indexSkat++] = d.deck[zz].clone();\n}\n}\n}\n\npublic void sortieren()\n{\n\n}\n\npublic void print()\n{\nSystem.out.print(\"Spieler 1 : \");\nfor(Karte k : p1) System.out.print(k.toString()+\" \");\nSystem.out.println();\nSystem.out.print(\"Spieler 2 : \");\nfor(Karte k : p2) System.out.print(k.toString()+\" \");\nSystem.out.println();\nSystem.out.print(\"Spieler 3 : \");\nfor(Karte k : p3) System.out.print(k.toString()+\" \");\nSystem.out.println();\nSystem.out.print(\"Skat      : \");\nfor(Karte k : skat) System.out.print(k.toString()+\" \");\nSystem.out.println();\n}\n\npublic static void main(String[] args) {\nSkat s = new Skat();\ns.geben();\ns.print();\n\n}\n\n}\n</code></pre>"},{"location":"enum/#nutzliche-links-fur-enums","title":"N\u00fctzliche Links f\u00fcr enums","text":"<ul> <li>Oracle Docs</li> <li>W3Schools</li> <li>Java enums - so geht's</li> <li>Enums</li> <li>Java Tutorial - Enums (youtube)</li> </ul>"},{"location":"ereignisse/","title":"Ereignisse","text":"<p>Im vorangegangenen Kapitel haben wir gelernt, wie wir Grafische Nutzeroberfl\u00e4chen (GUI) erstellen k\u00f6nnen. Nun wollen wir uns anschauen, wie auf Ereignisse reagiert werden kann, die die Nutzerin auf dieser Grafischen Oberfl\u00e4che ausl\u00f6st. Wenn wir beispielsweise in unserem Taschenrechner auf einen Button klicken, dann soll entweder die Ziffer in dem Textfeld oben erscheinen oder es soll die Operation ausgef\u00fchrt werden, auf die wir geklickt haben. In grafischen Nutzeroberfl\u00e4chen gibt es nicht nur Buttons, auf deren Klick-Ereignisse wir reagieren wollen, es gibt auch Eingaben \u00fcber die Tastatur, das Fenster kann mit der Maus bewegt, vergr\u00f6\u00dfert oder verkleinert werden, es k\u00f6nnen Kontextdialoge durch das Dr\u00fccken der rechten Maustaste ge\u00f6ffnet werden usw. Wir lernen hier, welche unterschiedlichen Ereignisse es gibt und wie wir diese behandeln k\u00f6nnen, d.h. wie wir die Reaktion auf diese Ereignisse implementieren. </p> <p>Zun\u00e4chst \u00fcberlegen wir uns, wie es \u00fcberhaupt m\u00f6glich sein kann, dass Ereignisse (also Aktionen der Nutzerin) auf unserer grafischen Oberfl\u00e4che erkannt werden und auf diese Ereignisse entsprechend reagiert werden kann. Man k\u00f6nnte (in einer Schleife) permanent bei der Maus oder der Tastatur anfragen, ob eine Taste gedr\u00fcckt oder ob die Maus bewegt wurde. Das ist aber viel zu imperformant und w\u00fcrde das Programm blockieren. Diese Aufgabe wird n\u00e4mlich von der Laufzeitumgebung automatisch \u00fcbernommen. Im Hintergrund geschieht genau so etwas, aber wir m\u00fcssen uns gar nicht darum k\u00fcmmern. Wenn z.B. eine Maustaste gedr\u00fcckt wird, dann wird im Hintergrund durch die Laufzeitumgebung eine bestimmte Methode aufgerufen (<code>mouseClicked()</code>). Woher wissen wir, wie diese Methode hei\u00dft? Die Antwort sind nat\u00fcrlich: Interfaces!</p>"},{"location":"ereignisse/#interfaces-fur-ereignisse-listener","title":"Interfaces f\u00fcr Ereignisse - Listener","text":"<p>Die Idee ist die Folgende:</p> <ul> <li>Komponenten k\u00f6nnen unterschiedliche Ereignisse empfangen (Button angeklickt, Text eingegeben, Maus bewegt, Fenster geschlossen, ...).</li> <li>Die Anwendung registriert einen sogenannten Listener (ein Listener-Objekt) bei der Komponente f\u00fcr Ereignisse von Interesse.</li> <li>Tritt ein Ereignis, f\u00fcr das man sich beim Listener angemeldet hat, an der Komponente ein, wird eine bestimmte Methode am Listener-Objekt aufgerufen. </li> <li>Alle diese Methoden, die durch die Laufzeitumgebung f\u00fcr bestimmte Ereignisse aufgerufen werden k\u00f6nnen, sind in Interfaces definiert. </li> <li>Es gibt unterschiedliche Interfaces, die man implementieren muss, je nach den Ereignissen, auf die man reagieren m\u00f6chte (Mausereignisse, Tastaturereigniss, Ereignisse am Fenster, ...).</li> </ul> <p>Das Vorgehen kann man sich wie in der Abbildung gezeigt vorstellen:</p> <p></p> <p>Der Listener lauscht permanent auf Ereignisse. Sobald ein Ereignis aufritt, auf das der Listener lauscht, ruft er eine entsprechende Methode auf. Damit wir im Programm auf dieses Ereignis reagieren k\u00f6nnen (die Ereignisbehandlung implementieren), m\u00fcssen wir zwei Dinge tun:</p> <ol> <li>uns an dem Listener anmelden, der auf die Ereignisse lauscht, die uns interessieren (die wir behandeln wollen) und</li> <li>die Ereignisbehandlung in der vom Listener aufgerufenen Methode implementieren.  </li> </ol> <p>Die Methoden, die wir implementieren sind abstrakt in Interfaces festgelegt. Das bedeutet also, dass wir f\u00fcr die Ereignisbehandlung Interfaces implementieren. </p>"},{"location":"ereignisse/#erstes-beispiel-actionlistener","title":"Erstes Beispiel <code>ActionListener</code>","text":"<p>Wir starten mit einem ersten Beispiel. Dazu haben wir uns folgende GUI erstellt:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame{\n\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\n\nJButton oben = new JButton(\"Klick mich\");\n\nJLabel unten = new JLabel(\"0\");\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n}\n\n}\n</code></pre> <p>Die Ausf\u00fchrung des Programms zeigt folgendes kleines Fenster:</p> <p></p> <p>Es soll nun implementiert werden, dass sich durch einen Klick auf den Button die dargestellte Zahl um <code>1</code> erh\u00f6ht. Die Methode, die ausgel\u00f6st wird, wenn ein Button geklickt wird, hei\u00dft <code>actionPerformed()</code>. Diese ist in dem Interface <code>ActionListener</code> implementiert. Wir m\u00fcssen nun also</p> <ol> <li>das Interface <code>ActionListener</code> implementieren und</li> <li>uns beim <code>ActionListener</code> anmelden. </li> </ol>"},{"location":"ereignisse/#das-interface-actionlistener-implementieren","title":"Das Interface <code>ActionListener</code> implementieren","text":"<p>Interfaces implementieren k\u00f6nnen wir bereits - mithilfe von <code>implements</code>:</p> <ol> <li>Wir schreiben also: <code>public class Ereignisbehandlung extends JFrame implements ActionListener</code>.</li> <li>Das Interface <code>ActionListener</code> muss aus dem <code>java.awt.event</code>-Paket importiert werden. </li> <li>Wir klicken auf <code>Add unimplemented methods</code> und in der Klasse erscheint die folgende Methode: </li> </ol> <pre><code>    @Override\npublic void actionPerformed(ActionEvent e) {\n// TODO Auto-generated method stub\n\n}\n</code></pre> <p>Das Interface <code>ActionListener</code> enth\u00e4lt also nur genau eine Methode, die implmentiert werden muss. Dieser Methode wird ein <code>ActionEvent</code> als Parameter \u00fcbergeben. Diese Klasse muss ebenfalls aus dem <code>java.awt.event</code>-Paket importiert werden. </p> <p>Wenn unser Button gedr\u00fcckt wird, dann wird also \"automatisch\" (durch die Laufzeitumgebung) die Methode <code>actionPerformed()</code> aufgerufen. Alles, was passieren soll, wenn der Button geklickt wird, m\u00fcssen wir in dieser Methode implementieren. Wir beginnen mit einer ganz einfachen Implementierung, mit einer simplen Ausgabe auf die Konsole:</p> <pre><code>    @Override\npublic void actionPerformed(ActionEvent e) {\nSystem.out.println(\"Button gedrueckt!\");        }\n</code></pre> <p>Wenn wir nun auf den Button klicken, passiert aber noch nichts, denn wir m\u00fcssen den Button noch am <code>ActionListener</code> anmelden (siehe oben Punkt 2 in der Liste). </p>"},{"location":"ereignisse/#am-actionlistener-anmelden","title":"Am <code>ActionListener</code> anmelden","text":"<p>Damit das Klick-Ereignis auf den Button auch so behandelt wird, wie wir das in der <code>actionPerformed()</code>-Methode definiert haben, m\u00fcssen wir diesen Button an den <code>ActionListener</code> anmelden. Dazu existiert f\u00fcr einen <code>JButton</code> (f\u00fcr alle Komponenten <code>JComponent</code>) die Methode <code>addActionListener(ActionListener l)</code>. Dieser Methode muss nun ein <code>ActionListener</code>-Objekt \u00fcbergeben werden, also ein Objekt, das das Interface <code>ActionListener</code> implementiert hat. Da wir den <code>ActionListener</code> in unserer Fensterklasse implementiert haben, ist das Fenster ein solches Objekt, das den <code>ActionListener</code> implementiert hat. Wir verwenden also <code>this</code>. </p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame implements ActionListener\n{\n\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\n\nJButton oben = new JButton(\"Klick mich\");\noben.addActionListener(this);\nJLabel unten = new JLabel(\"0\");\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nSystem.out.println(\"Button gedrueckt!\");\n}\n}\n</code></pre> <p>Jedes mal, wenn wir nun auf den Button klicken, wird eine Ausgabe auf der Konsole erzeugt. Nach 5 Klicks also</p> <pre><code>Button gedrueckt!\nButton gedrueckt!\nButton gedrueckt!\nButton gedrueckt!\nButton gedrueckt!\n</code></pre> <p>Wir haben das erste Ereignis behandelt, das durch eine Nutzerinnenaktion ausgel\u00f6st wurde - das Klicken eines Buttons!</p>"},{"location":"ereignisse/#zugriff-auf-komponenten-in-actionperformed","title":"Zugriff auf Komponenten in <code>actionPerformed()</code>","text":"<p>Wenn wir nun aber die <code>actionPerformed()</code>-Methode so implementieren wollen, dass sich der Text des <code>JLabel</code>s <code>unten</code> \u00e4ndert, dann stellen wir fest, dass wir in <code>actionPerformed()</code> ja gar keinen Zugriff auf dieses <code>JLabel</code> haben, weil die Referenz darauf nur eine lokale Variable in der <code>init()</code>-Methode ist. Um in allen Methoden der Klasse <code>Ereignisbehandlung</code> Zugriff auf dieses <code>JLabel</code> zu erlangen, m\u00fcssen wir es global deklarieren (als Objektvariable der Klasse <code>Ereignisbehandlung</code>). </p> <p>Zus\u00e4tzlich erzeugen wir eine weitere Variable, die die Anzahl der bisherigen Klicks mitz\u00e4hlt, um diesen Wert dann im <code>JLabel</code> darzustellen.  </p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame implements ActionListener\n{\nJLabel unten;\nInteger anzKlicks = 0;\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\n\nJButton oben = new JButton(\"Klick mich\");\noben.addActionListener(this);\n\nthis.unten = new JLabel(this.anzKlicks.toString());\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nSystem.out.println(\"Button gedrueckt!\");\nthis.anzKlicks++;\nthis.unten.setText(this.anzKlicks.toString());\n}\n\n}\n</code></pre> <p>Nun \u00e4ndert sich mit jedem Button-Klick der angezeigte Wert.</p> <p></p>"},{"location":"ereignisse/#mehrere-buttons-actionevent","title":"Mehrere Buttons - <code>ActionEvent</code>","text":"<p>Wir \u00e4ndern unsere GUI, indem wir die <code>init()</code>-Methode \u00e4ndern:</p> <pre><code>    private JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\n\nJPanel oben = new JPanel();\nJButton minus = new JButton(\"-\");\nJButton plus = new JButton(\"+\");\noben.add(minus);\noben.add(plus);\nthis.unten = new JLabel(this.anzKlicks.toString());\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n</code></pre> <p>Die GUI sieht dadurch nun so aus:</p> <p></p> <p>Das hei\u00dft, wir haben zwei Buttons und wollen f\u00fcr diese Buttons das Klick-Ereignis unterschiedlich behandeln. Bei Klick auf den <code>-</code>-Button soll der Wert der Zahl dekrementiert werden, bei Klick auf den <code>+</code>-Button inkrementiert. Wir m\u00fcssen nun also innerhalb der <code>actionPerformed()</code>-Methode unterscheiden, welcher Button gedr\u00fcckt wurde, d.h. durch welchen Button das <code>ActionEvent</code> ausgel\u00f6st wurde, welches wir behandeln. Dabei hilft uns das <code>ActionEvent</code>-Objekt, das der <code>actionPerformed(ActionEvent e)</code>-Methode \u00fcbergeben wird. Die Klasse ActionEvent hat einige n\u00fctzliche Methoden. Wir verwenden jetzt zun\u00e4chst eine Methode, die die Klasse <code>ActionEvent</code> von der Klasse EventObject geerbt hat, die <code>getSource()</code>-Methode:</p> <pre><code>    @Override\npublic void actionPerformed(ActionEvent e) {\nObject quelle = e.getSource();\nif(quelle instanceof JButton )\n{\nJButton button = (JButton) quelle;\nif(button.getText().equals(\"+\"))\n{\nthis.anzKlicks++;\n}\nelse if(button.getText().equals(\"-\"))\n{\nthis.anzKlicks--;\n}\n}\nthis.unten.setText(this.anzKlicks.toString());\n}\n</code></pre> <p>Die <code>getSource()</code>-Methode von <code>ActionEvent</code> liefert die Komponente (als <code>Object</code>) zur\u00fcck, die das <code>ActionEvent</code> ausgel\u00f6st hat. Damit wir Objektmethoden (z.B. <code>getText()</code> - Zeilen <code>55</code> und <code>59</code>) von <code>JButton</code> verwenden k\u00f6nnen, m\u00fcssen wir dieses <code>Object</code> nach <code>JButton</code> konvertieren (Zeile <code>54</code>). Damit dies gelingt, m\u00fcssen wir zun\u00e4chst pr\u00fcfen, ob es sich bei der ausl\u00f6senden Komponente tats\u00e4chlich um einen <code>JButton</code> handelt. Das erledigen wir hier mit dem <code>instanceof</code>-Operator in Zeile <code>52</code>. </p> <p>Mithilfe der <code>getText()</code>-Methoden erfragen wir den Text, der auf den Buttons steht. Wir vergleichen diesen mithilfe der <code>equals()</code>-Methode und k\u00f6nnen somit unterscheiden, ob das <code>ActionEvent</code> durch den <code>+</code>- oder den <code>-</code>-Button ausgel\u00f6st wurde. </p> <p>Wir d\u00fcrfen nicht vergessen, die beiden Buttons an den <code>ActionListener</code> anzumelden:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame implements ActionListener\n{\nJLabel unten;\nInteger anzKlicks = 0;\n\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\n\nJPanel oben = new JPanel();\nJButton minus = new JButton(\"-\");\nJButton plus = new JButton(\"+\");\nminus.addActionListener(this);\nplus.addActionListener(this);\noben.add(minus);\noben.add(plus);\n\nthis.unten = new JLabel(this.anzKlicks.toString());\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nObject quelle = e.getSource();\nif(quelle instanceof JButton )\n{\nJButton button = (JButton) quelle;\nif(button.getText().equals(\"+\"))\n{\nthis.anzKlicks++;\n}\nelse if(button.getText().equals(\"-\"))\n{\nthis.anzKlicks--;\n}\n}\nthis.unten.setText(this.anzKlicks.toString());\n}\n\n}\n</code></pre> <p>Nun haben wir f\u00fcr die beiden Buttons eine unterschiedliche Ereignisbehandlung realisiert. </p>"},{"location":"ereignisse/#actioncommand","title":"ActionCommand","text":"<p>Die Abfrage des Textes auf den Buttons zur Unterscheidung der Buttons ist nicht clean code. Das hat mehrere Gr\u00fcnde:</p> <ol> <li>GUIs werden h\u00e4ufig f\u00fcr mehrere Sprachen zur Verf\u00fcgung gestellt. Je nach Einstellungen in den Konfigurationen kann die \"angezeigte\" Sprache der GUI ver\u00e4ndert werden. Somit w\u00fcrden auch die Buttons ihre Beschriftung \u00e4ndern und man m\u00fcsste in der <code>actionPerformed()</code>-Methode viele Varianten f\u00fcr die Textabfrage hinzuf\u00fcgen. </li> <li>Buttons k\u00f6nnen auch einfach nur Icons enthalten, d.h. gar keinen Text.</li> <li>Der auf Buttons angezeigte Text kann sehr \"kryptisch\" sein, also irgendwelche Sonderzeichen oder Schriftzeichen enthalten. Es kann z.B. auch HTML-Code sein. </li> </ol> <p>Das alles macht die Abfrage des Textes und insbesondere den Vergleich kompliziert bis gar unm\u00f6glich. Deshalb sollte man stattdessen besser das <code>ActionCommand</code> abfragen. Das <code>ActionCommand</code> wird mithilfe der <code>setActionCommand(String command)</code>-Methode gesetzt und mithilfe der <code>getActionCommand()</code>-Methode abgefragt. </p> <p>Wenn f\u00fcr einen Button nicht mithilfe der <code>setActionCommand()</code>-Methode ein <code>ActionCommand</code> definiert wurde, dann entspricht das <code>ActionCommand</code> dem Text auf dem Button. Das bedeutet, dass die <code>getActionCommand()</code>-Methode trotzdem verwendet werden k\u00f6nnte. </p> <p>Wir br\u00e4uchten also nur in der <code>actionPerformed()</code>-Methode <code>getText()</code> durch <code>getActionCommand()</code> ersetzen und h\u00e4tten das gleiche Ergebnis:</p> <pre><code>    @Override\npublic void actionPerformed(ActionEvent e) {\nObject quelle = e.getSource();\nif(quelle instanceof JButton )\n{\nJButton button = (JButton) quelle;\nif(button.getActionCommand().equals(\"+\"))\n{\nthis.anzKlicks++;\n}\nelse if(button.getActionCommand().equals(\"-\"))\n{\nthis.anzKlicks--;\n}\n}\nthis.unten.setText(this.anzKlicks.toString());\n}\n</code></pre> <p>Wenn wir allerdings eigene (andere) <code>ActionCommands</code> f\u00fcr die Buttons setzen, dann m\u00fcssen wir auch den Vergleich anpassen:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame implements ActionListener\n{\nJLabel unten;\nInteger anzKlicks = 0;\n\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\nJPanel oben = new JPanel();\nJButton minus = new JButton(\"-\");\nJButton plus = new JButton(\"+\");\nminus.setActionCommand(\"minus\");\nplus.setActionCommand(\"plus\");\nminus.addActionListener(this);\nplus.addActionListener(this);\noben.add(minus);\noben.add(plus);\n\nthis.unten = new JLabel(this.anzKlicks.toString());\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nObject quelle = e.getSource();\nif(quelle instanceof JButton )\n{\nJButton button = (JButton) quelle;\nif(button.getActionCommand().equals(\"plus\"))\n{\nthis.anzKlicks++;\n}\nelse if(button.getActionCommand().equals(\"minus\"))\n{\nthis.anzKlicks--;\n}\n}\nthis.unten.setText(this.anzKlicks.toString());\n}\n\n}\n</code></pre> <p>Success</p> <p>Wir kennen nun das Konzept, das hinter der Behandlung von Ereignissen steckt. Wir melden die Komponente, f\u00fcr die wir eine Ereignisbehandlung f\u00fcr ein Ereignis implementieren wollen, an den entsprechenden Listener an und wir implementieren das zugeh\u00f6rige Interface. Wir haben Buttons erfolgreich an den <code>ActionListener</code> angemeldet und das <code>ActionListener</code>-Interface implementiert. Dieses Interface enth\u00e4lt nur genau eine Methode, <code>actionPerformed()</code>. Wir k\u00f6nnen in dieser Methode auch bereits ermitteln, welche Komponente das <code>ActionEvent</code> ausgel\u00f6st hat, das gerade behandelt wird. Dadurch k\u00f6nnen wir in derselben <code>actionPerformed()</code>-Methode die (unterschiedliche) Ereignisbehandlung f\u00fcr mehrere Buttons implementieren. Damit k\u00f6nnen wir nun schonmal einen funktionsf\u00e4higen Taschenrechner bauen! Der L\u00f6sung f\u00fcr Aufgabe 8 steht nichts mehr im Wege!</p>"},{"location":"ereignisse/#innere-klassen","title":"Innere Klassen","text":"<p>Mit der Implementierung des <code>ActionListener</code> hat alles geklappt und funktional ist auch alles in Ordnung, aber so richtig sch\u00f6n ist es nicht - kein clean code. Daf\u00fcr gibt es mehrere Gr\u00fcnde:</p> <ol> <li>Unsere Klasse verst\u00f6\u00dft auf jeden Fall gegen das Single Responsibility Principle (SRP). Unsere Klasse ist einerseits ein Fenster und andererseits k\u00fcmmern wir uns in der Klasse auch um Funktionalit\u00e4ten. Bei der Erstellung von Anwendungen mit grafischen Nutzeroberfl\u00e4chen hat sich sogar eine Dreiteilung etabliert, das sogenannte Model-View-Controller-Pattern. Darin ist die Darstellung der GUI die View, das Verwalten und Manipulieren der Daten das Model und die Steuerung mittels Nutzeraktionen der Controller. Langfristig streben wir eine solche Dreiteilung ebenfalls an. </li> <li>Wenn wir sehr viele Buttons (und sp\u00e4ter auch noch Textfelder, Men\u00fcs usw.) haben, dann kann die <code>actionPerformed()</code>-Methode schon allein dadurch sehr lang werden, dass wir viele Fallunterscheidungen ben\u00f6tigen, um zu ermitteln, welche Komponente das <code>ActionEvent</code> \u00fcberhaupt ausgel\u00f6st hat. Wenn dann jeweils noch viel Funktionalit\u00e4t hinzukommt, wird die <code>actionPerformed()</code>-Methode viel zu lang. </li> <li>Wir haben bis jetzt nur ein einziges Interface, das <code>ActionListener</code>-Interface, implementiert und dieses enth\u00e4lt auch nur eine einzige Methode. Wenn wir nun auch noch auf Maus-, Mausbewegungs-, Tastatur- und Fenstereignisse reagieren wollen, dann implementieren wir mindestens vier weitere Interfaces, die jeweils bis zu sechs Methoden enthalten. Unsere Klasse w\u00fcrde sehr lang werden.</li> </ol> <p>Wir ben\u00f6tigen Ideen, wie wir diese Konflikte aufl\u00f6sen k\u00f6nnen. Dazu ben\u00f6tigen wir neue Strukturierungsm\u00f6glichkeiten. Ein erster Schritt dahin sind Innere Klassen. Wir betrachten Innere Klassen aber nur als einen Zwischenschritt hin zu anonymen Klassen. Wir werden uns ansonsten nicht weiter mit inneren Klassen auseinandersetzen. </p>"},{"location":"ereignisse/#begriffsbestimmung","title":"Begriffsbestimmung","text":"<p>Prinzipiell handelt es sich bei inneren Klassen um Klassen in einer Klasse. Der Oberbegriff f\u00fcr eine Klasse in einer Klasse ist nested class. In nested classes unterscheidet man zwischen</p> <ul> <li>statischen und</li> <li>nicht-statischen Klassen.</li> </ul> <p>Die nicht-statischen nested Klassen (also Klassen, wie wir sie bisher kennen - wir kennen noch gar keine statischen Klassen) hei\u00dfen innere Klassen. Wir wollen uns gar nicht mit statischen verschachtelten Klassen auseinandersetzen. Es sei an dieser Stelle aber der wesentliche Unterschied zwischen den statischen und den nicht-statischen verschachtelten Klassen genannt: nicht-statische Klassen (also innere Klassen) haben Zugriff auf die Eigenschaften der \u00e4u\u00dferen Klasse, statische verschachtelte Klassen haben diesen Zugriff nicht. Wenn wir schon bei Sachen sind, die uns nicht interessieren ;-) : sogenannte lokale Klassen sind Klassen in einer Methode. </p> <p>Innere Klassen sind aber n\u00fctzlich und sinnvoll. Wir kennen auch schon eine, n\u00e4mlich <code>Map.Entry</code> - die Klasse <code>Entry</code> ist eine innere Klasse von <code>Map</code> (ganz exakt handelt es sich bei beiden nicht um Klassen, sondern um Interfaces, das macht hier aber keinen Unterschied). In der Klasse <code>Integer</code> gibt es \u00fcbrigens auch eine innere Klasse. Die fungiert als ein Cache f\u00fcr h\u00e4ufig verwendete Zahlen. Wenn Sie ein <code>Integer</code>-Objekt mit einem Wert kleiner als <code>128</code> erstellen, dann kommt dieses Objekt in den Cache und wenn Sie ein weiteres Objekt mit dem gleichen Wert erzeugen, dann wird daf\u00fcr einfach das Objekt aus dem Cache verwendet. Das f\u00fchrt zu diesem \"komischen\" Verhalten:</p> <pre><code>        Integer i1 = Integer.valueOf(1001);\nInteger i2 = Integer.valueOf(1001);\nInteger i3 = Integer.valueOf(101);\nInteger i4 = Integer.valueOf(101);\nSystem.out.println(i1 == i2);       // false\nSystem.out.println(i3 == i4);       // true\n</code></pre> <p>Der erste Vergleich ist <code>false</code>, weil es sich bei <code>i1</code> und <code>i2</code> um Referenzen auf zwei verschiedene Objekte handelt. Der zweite Vergleich ist aber <code>true</code>, weil es sich bei <code>i3</code> und <code>i4</code> um Referenzen auf dasselbe Objekt (aus dem Cache) handelt. Aber das nur nebenbei, um zu erl\u00e4utern, dass es sinnvolle Verwendungen f\u00fcr innere Klassen gibt. </p>"},{"location":"ereignisse/#ereignisbehandlung-mit-innerer-klasse","title":"Ereignisbehandlung mit innerer Klasse","text":"<p>Wir verwenden unsere Klasse <code>Ereignisbehandlung</code> von oben. Aber wir lagern die eigentliche Behandlung des <code>ActionEvent</code>s in eine innere Klasse aus. Das hei\u00dft, wir trennen die Erstellung der GUI und die Behandlung der Ereignisse strukturell, in dem diese Dinge in zwei unterschiedlichen Klassen implementiert sind. Da es sich aber um die Ereignisbehandlung f\u00fcr genau die erstellte GUI handelt, ergibt es wenig Sinn, diese in eine \"normale\" Top-Level-Klasse zu \u00fcberf\u00fchren. Deshalb verwenden wir daf\u00fcr eine innere Klasse:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\nimport javax.swing.*;\n\npublic class Ereignisbehandlung extends JFrame\n{\nJLabel unten;\nInteger anzKlicks = 0;\n\npublic Ereignisbehandlung()\n{\nsuper();\nsetTitle(\"Ereignisbehandlung\");\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nJPanel mainPanel = init();\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\nsetSize(200,150);\nsetVisible(true);\n}\n\nprivate JPanel init()\n{\nJPanel panel = new JPanel();\npanel.setLayout(new BorderLayout());\nJPanel oben = new JPanel();\nJButton minus = new JButton(\"-\");\nJButton plus = new JButton(\"+\");\nminus.setActionCommand(\"minus\");\nplus.setActionCommand(\"plus\");\nminus.addActionListener(new ActionHandler());\nplus.addActionListener(new ActionHandler());\noben.add(minus);\noben.add(plus);\n\nthis.unten = new JLabel(this.anzKlicks.toString());\nunten.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nunten.setHorizontalAlignment(JLabel.CENTER);\n\npanel.add(oben, BorderLayout.NORTH);\npanel.add(unten, BorderLayout.CENTER);\n\nreturn panel;\n}\n\npublic static void main(String[] args) {\nnew Ereignisbehandlung();       }\n\nclass ActionHandler implements ActionListener\n{\n@Override\npublic void actionPerformed(ActionEvent e) {\nObject quelle = e.getSource();\nif(quelle instanceof JButton )\n{\nJButton button = (JButton) quelle;\nif(button.getActionCommand().equals(\"plus\"))\n{\nEreignisbehandlung.this.anzKlicks++;\n}\nelse if(button.getActionCommand().equals(\"minus\"))\n{\nEreignisbehandlung.this.anzKlicks--;\n}\n}\nEreignisbehandlung.this.unten.setText(Ereignisbehandlung.this.anzKlicks.toString());\n}\n}\n}\n</code></pre> <p>So viel hat sich gar nicht ge\u00e4ndert: </p> <ul> <li>Die Klasse <code>Ereignisbehandlung</code> implementiert jetzt nicht mehr selbst das Interface <code>ActionListener</code> (Zeile <code>8</code>).</li> <li>Das hat jetzt die neue (innere) Klasse <code>ActionHandler</code> \u00fcbernommen (Zeile <code>54</code>). </li> <li>Da der <code>ActionListener</code> nun nicht mehr in <code>Ereignisbehandlung</code> implementiert ist, sondern in <code>ActionHandler</code>, muss beim Anmelden an den <code>ActionListener</code> nun nicht mehr das <code>this</code>-Objekt, sondern ein Objekt von <code>ActionHandler</code> \u00fcbergeben werden (Zeilen <code>34</code> und <code>35</code>).</li> <li>Da sich die Methode <code>actionPerformed()</code> nun in der Klasse <code>ActionHandler</code> befindet, handelt es sich dort bei der <code>this</code>-referenz um eine Referenz auf ein <code>ActionHandler</code>-Objekt. Wir k\u00f6nnen also nicht mehr einfach <code>this.anzKlicks++;</code> schreiben, da es sich bei <code>anzKlicks</code> ja nicht um eine Eigenschaft der <code>ActionHandler</code>-Klasse, sondern um eine Eigenschaft der <code>Ereignisbehandlung</code>-Klasse handelt. Das Gleiche gilt auch f\u00fcr das <code>JLabel unten</code> (Zeilen <code>65</code>, <code>69</code> und <code>72</code>).</li> </ul> <p>Um auf die Eigenschaften der \u00e4u\u00dferen Klasse zuzugreifen, kann in der inneren Klasse \u00fcber den Klassennamen der \u00e4u\u00dferen Klasse auf die Eigenschaften der \u00e4u\u00dferen Klasse referenziert werden. Das hei\u00dft, wenn die \u00e4u\u00dfere Klasse <code>AeussereKlasse</code> hei\u00dft und eine Eigenschaft <code>eigenschaft_AeK</code> hat, dann kann aus der inneren Klasse heraus wie folgt auf diese Eigenschaft zugegriffen werden:</p> <p>AeussereKlasse.this.eigenschaft_AeK</p> <p>In unserem Fall bedeutet das, dass wir nun \u00fcber <code>Ereignisbehandlung.this.anzKlicks++;</code> und <code>Ereignisbehandlung.this.anzKlicks--;</code> den Wert der Eigenschaft <code>anzKlicks</code> der \u00e4u\u00dferen Klasse <code>Ereignisbehandlung</code> \u00e4ndern k\u00f6nnen (Zeilen <code>65</code> und <code>69</code>). Um auf das JPanel <code>unten</code> aus der inneren Eigenschaft zugreifen zu k\u00f6nnen, schreiben wir deshalb <code>Ereignisbehandlung.this.unten</code> (Zeile <code>72</code>). </p> <p>Beachten Sie, dass das <code>this</code> darin notwendig ist. Wenn wir schreiben w\u00fcrden</p> <pre><code>Ereignisbehandlung.anzKlicks++;\n</code></pre> <p>, dann w\u00fcrde das bedeuten, dass es sich bei <code>anzKlicks</code> um eine statische (Klassen-)Variable handeln w\u00fcrde. Um auf (nicht-statische) Objektvariablen zuzugreifen, verwenden wir in der Klasse ja die Referenz <code>this</code> und um also auf die Objektvariablen der \u00e4u\u00dferen Klasse zuzugreifen, schreiben wir</p> <pre><code>Ereignisbehandlung.this.anzKlicks++;\n</code></pre> <p>Dasselbe gilt f\u00fcr Methoden. </p> <p>Wir haben nun immerhin die Verantwortlichkeiten zur Erstellung der GUI und zur Behandlung der Ereignisse in zwei verschiedene Klassen aufgeteilt. Das Single Responsibility Principle ist somit erf\u00fcllt. Das ist schonmal gut! Wir haben aber eingangs erw\u00e4hnt, dass wir uns die inneren Klassen nur als ein Zwischenschritt anschauen. Dazu \u00fcberlegen wir uns nochmal Folgendes:</p> <ul> <li>Wir haben f\u00fcr die Ereignisbehandlung eine eigene Klasse <code>ActionHandler</code> geschrieben. </li> <li>Um sich an den <code>ActionListener</code> anzumelden, wurde der <code>addActionListener()</code>-Methode daf\u00fcr ein Objekt von <code>ActionHandler</code> \u00fcbergeben (siehe oben die Zeilen <code>34</code> und <code>35</code>).</li> </ul> <p>Nun machen wir etwas Verr\u00fccktes ;-) : wir \u00fcbergeben der <code>addActionListener()</code>-Methode auch wieder ein Objekt, in dem wir den <code>ActionListener</code> implementiert haben (implementieren), aber diese Implementierung erfolgt nicht in einer separaten Klasse, die einen Namen hat (<code>ActionHandler</code>), sondern die Implementierung erfolgt direkt dort, wo das Objekt \u00fcbergeben wird, daf\u00fcr ohne einen Klassennamen - eine anonyme Klasse. </p>"},{"location":"ereignisse/#ereignisbehandlung-mit-anonymer-klasse","title":"Ereignisbehandlung mit anonymer Klasse","text":"<p>Jede Komponente, f\u00fcr die auf das <code>ActionEvent</code> reagiert werden soll, muss an den <code>ActionListener</code> mithilfe der <code>addActionListener()</code>-Methode angemeldet werden. Dieser Methode wird ein Objekt \u00fcbergeben, in dem der <code>ActionListener</code> implementiert ist. Wir implementieren jetzt direkt dort, wo wir das Objekt \u00fcbergeben, genau diese Klasse, geben ihr aber keinen Namen. Stattdessen geben wir <code>ActionListener</code> wie einen Konstruktor an, obwohl es sich bei <code>ActionListener</code> um ein Interface handelt, welches erstens keinen Konstruktor besitzt und zweitens von dem gar kein Objekt erzeugt werden kann. Wir schauen uns das am Beispiel des <code>-</code>-Buttons an:</p> <pre><code>    minus.addActionListener(new ActionListener() {      // Objekt einer anonymen Klasse\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nEreignisbehandlung.this.anzKlicks--;\nEreignisbehandlung.this.unten.setText(Ereignisbehandlung.this.anzKlicks.toString());\n}\n});\n</code></pre> <p>Wir \u00fcbergeben der <code>addActionListener()</code>-Methode ein Objekt einer anonymen Klasse. Diese anonyme Klasse implementiert das <code>ActionListener</code>-Interface. Zun\u00e4chst gehen wir nochmal einen Schritt zur\u00fcck und schauen uns die Varianten an, die wir davor hatten:</p> <pre><code>minus.addActionListener(this);      // ActionListener war in der Fenster-Klasse implementiert\nminus.addActionListener(new ActionHandler());       // ActionListener war in der inneren Klasse ActionHandler implementiert\n</code></pre> <p>Nun implementieren wir das <code>ActionListener</code>-Interface direkt \"vor Ort\" - dort, wo es auch \u00fcbergeben wird. Der Aufruf der <code>addActionListener()</code>-Methode ist \u00fcbrigens noch exakt der gleiche</p> <pre><code>    minus.addActionListener(\n\n\n\n\n\n\n\n);\n</code></pre> <p>, nur das \u00fcbergebene Objekt sieht etwas \"komisch\" aus:</p> <pre><code>                        new ActionListener() {      // Objekt einer anonymen Klasse\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nEreignisbehandlung.this.anzKlicks--;\nEreignisbehandlung.this.unten.setText(Ereignisbehandlung.this.anzKlicks.toString());\n}\n}\n</code></pre> <p>Wir erkennen aber den Klassenrumpf, der ganz normal mit einer geschweiften Klammer <code>{</code> in Zeile <code>1</code>) beginnt und mit einer schlie\u00dfenden geschweiften Klammer <code>}</code> in Zeile <code>9</code> endet. Darin ist, auch ganz normal, die <code>actionPerformed()</code>-Methode implementiert, die ja implementiert werden muss, wenn das <code>ActionListener</code>-Interface implementiert wird. Innerhalb der Methode greifen wir auch, wie bei inneren Klassen \u00fcblich, auf die Objekteigenschaften der \u00e4u\u00dferen Klasse zu. </p> <p>Eigentlich ist nur dieser Ausdruck neu: <code>new ActionListener() { }</code>. Hier m\u00fcssen wir uns einfach merken, dass es sich dabei um drei Sachen hadelt, die zugleich passieren:</p> <ol> <li>Es wird das <code>ActionListener</code>-Interface implementiert. Dies geschieht \"ganz normal\" in einem Klassenrumpf, der mit <code>{</code> beginnt und mit <code>}</code> endet.</li> <li>Die Klasse, in der das Interface implemntiert wird, hat aber keinen Namen, deshalb schreiben wir auch nicht <code>Klassenmane implements ActionListener</code>, sondern nur <code>ActionListener</code>.</li> <li>Es wird ein Objekt erzeugt. Dazu wird, ganz normal, das Schl\u00fcsselwort <code>new</code> verwendet und ein Konstruktor - allerdings hier der Konstruktor einer Klasse, die keinen Namen hat. Da diese Klasse aber das <code>ActionListener</code>-Interface implementiert, kann dieser Name f\u00fcr den Konstruktor verwendet werden.</li> </ol> <p>Der gro\u00dfe Vorteil dieser Art der Implementierung des <code>ActionListener</code>-Interfaces liegt darin, dass jede Komponente ihre eigene Implementierung bekommt und dass es deshalb nicht notwendig ist, eine Fallunterscheidung zu treffen, welche Komponente das Ereignis ausgel\u00f6st hat. Hier kann es nur der <code>minus</code>-Button gewesen sein!</p> <p>Die beiden Implementierungen des <code>ActionListener</code>s mithilfe einer anonymen Klasse sehen so aus:</p> <pre><code>    minus.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nEreignisbehandlung.this.anzKlicks--;\nEreignisbehandlung.this.unten.setText(Ereignisbehandlung.this.anzKlicks.toString());\n}\n});\n\nplus.addActionListener(new ActionListener() {\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nEreignisbehandlung.this.anzKlicks++;\nEreignisbehandlung.this.unten.setText(Ereignisbehandlung.this.anzKlicks.toString());\n}\n});\n</code></pre> <p>Den <code>ActionListener</code> mithilfe anonymer Klassen zu implementieren, ist ein Best Practice. In sehr vielen F\u00e4llen gewinnt man an \u00dcbersichtlichkeit. Wir werden im Rest des Semesters immer mal diskutieren, wann die Verwendung anonymer Klassen sinnvoll ist und wann nicht. Manchmal ist es aber auch nur Geschmackssache. </p> <p>F\u00fcr diejenigen, die sich f\u00fcr nested classes interessieren, sei dieser Link empfohlen.</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Motivation</p> <p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p> <p>Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf <code>null</code>, erhalten wir eine <code>NullPointerException</code>. Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen. </p> <p>Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern:</p> <ul> <li>syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und</li> <li>logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. </li> </ul> <p>Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte, z.B. </p> <ul> <li>fehlerhafte Benutzereingabe </li> <li>Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar </li> <li>gesuchte Datei/Ordner nicht vorhanden usw. </li> </ul> <p>Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt. Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. </p>"},{"location":"exceptions/#try-catch","title":"try-catch","text":"<p>Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem <code>index</code> auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher <code>index</code> aus dem Array ist. Allerdings binden wir diesen Versuch in einen <code>try{}</code>-Block ein. </p> <p>Sollte in einem solchen <code>try{}</code>-Block nun eine Exception geworfen werden, dann fangen wir diese in einem <code>catch(){}</code>-Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus:</p> allgemeine Syntax try-catch <pre><code>try {\n// Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n}   catch(Exception e)  {\n// Behandlung der Exception \n}\n</code></pre> <p>Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile <code>3</code> aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem <code>catch</code>-Block, also nach Zeile <code>8</code> weiter. Wenn aber die Anweisung(en) in Zeile <code>3</code> einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile <code>5</code> \"aufgefangen\" und in dem Anweisungsblock in den Zeilen <code>6-8</code> behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. </p>"},{"location":"exceptions/#beispiel-ohne-try-catch","title":"Beispiel ohne try-catch","text":"<p>Wir verdeutlichen dieses Prinzip an einem ersten Beispiel:</p> Beispiel zun\u00e4chst ohne Behandlung der Exceptions <pre><code>class Ausnahmen {\n\nstatic char charAt(String s, int index)\n{\nchar c = s.charAt(index);           // kritisch!\nreturn c;\n}\nstatic double divide(int divident, int divisor)\n{\ndouble result = divident/divisor;   // kritisch!\nreturn result;\n}\n\npublic static void main(String[] args) {\nSystem.out.println(divide(5,0));            // ArithmeticException\nSystem.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n}\n}\n</code></pre> <p>Das Beispiel enth\u00e4lt zwei Methoden <code>charAt()</code> und <code>divide</code>. Der <code>charAt</code>-Methode wird ein <code>String</code> \u00fcbergeben und ein <code>index</code>. Die Methode gibt das Zeichen (<code>char</code>) zur\u00fcck, dass im <code>String</code> unter dem <code>index</code> gespeichert ist (z.B. <code>charAt(\"Hallo\", 1)</code> gibt das <code>'a'</code> zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob <code>index</code> tats\u00e4chlich ein korrekter Index des Strings <code>s</code> ist, d.h. evtl. ist <code>index</code> kleiner als <code>0</code> oder gr\u00f6\u00dfer als die L\u00e4nge von <code>s</code> minus <code>1</code>. Die Anweisung  <code>s.charAt(index);</code> ist somit eine kritische Anweisung, denn sie kann (bei \"falschem\" <code>index</code>) eine <code>StringIndexOutOfBoundsException</code> werfen. </p> <p>Genau so ist die Anweisung <code>divident/divisor;</code> in der Methode <code>divide</code> eine kritische Anweisung, da es sein kann, dass der <code>divisior</code> gleich <code>0</code> ist. Bei der <code>int</code>-Division durch <code>0</code> wird eine <code>ArithmeticException</code> geworfen. </p> <p>Wenn die <code>main</code>-Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile <code>16</code> ab und Zeile <code>17</code> wird gar nicht mehr erreicht: </p> <pre><code>Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n    at packageName.Ausnahmen.divide(Ausnahmen.java:10)\nat packageName.Ausnahmen.main(Ausnahmen.java:16)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:10</code> und um welche Exception es sich handelt, n\u00e4mlich <code>ArithmeticException: / by zero</code>.</p> <p>Wenn wir in der <code>main</code>-Methode Zeile <code>16</code> auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile <code>17</code> eine Exception wirft, n\u00e4mlich: </p> <pre><code>Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5\nat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:47)\nat java.base/java.lang.String.charAt(String.java:702)\nat packageName.Ausnahmen.charAt(Ausnahmen.java:5)\nat packageName.Ausnahmen.main(Ausnahmen.java:17)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:5</code> und um welche Exception es sich handelt, n\u00e4mlich <code>StringIndexOutOfBoundsException: String index out of range: 5</code>. Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile <code>47</code> in der Klasse <code>StringLatin1</code> in der dortigen Methode <code>charAt</code> die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. </p>"},{"location":"exceptions/#beispiel-mit-try-catch","title":"Beispiel mit try-catch","text":"<p>Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir <code>try-catch</code>-Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen:</p> Beispiel mit Behandlung der Exceptions <pre><code>class Ausnahmen {\n\nstatic char charAt(String s, int index)\n{\nchar c = ' ';\ntry\n{\nc = s.charAt(index); // kritisch!\n}\ncatch(StringIndexOutOfBoundsException e)\n{\nSystem.err.println(\"Der Index war ausserhalb des Strings\");\n}\nreturn c;\n}\n\nstatic double divide(int divident, int divisor)\n{\ndouble result = 0.0;\ntry\n{\nresult = divident/divisor; // kritisch!\n}\ncatch(ArithmeticException ae)\n{\nSystem.err.println(\"Division durch 0 nicht definiert!\");\n}\nreturn result;\n}\n\npublic static void main(String[] args) {\nSystem.out.println(divide(5,0));            // ArithmeticException\nSystem.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n}\n}\n</code></pre> <p>Die kritischen Anweisungen wurden nun jeweils in einen <code>try</code>-Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t <code>out</code> in den <code>println</code>-Anweisungen verwendet, sondern <code>err</code> - Zeilen <code>12</code> und <code>26</code>). </p> <p>Wenn wir das Programm nun ausf\u00fchren (in <code>main</code> muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe:</p> <pre><code>Division durch 0 nicht definiert!\n0.0\nDer Index war ausserhalb des Strings\n</code></pre> <p>Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der <code>divide</code>-Methode wird eine Exception geworfen, dann erfolgt durch Zeile <code>26</code> die Fehlerausgabe auf die Konsole. Danach wird in Zeile <code>28</code> aber <code>result</code> zur\u00fcckgegeben (hat den Wert <code>0.0</code>, den wir bei der Initailisierung in Zeile <code>19</code> angegeben haben) und dieser Wert wird durch Zeile <code>33</code> auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die <code>charAt</code>-Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile <code>34</code> das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. </p> <p>Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:</p>"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","title":"Ablauf einer Ausnahmesituation","text":"<p>Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt:</p> <ol> <li>Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp <code>Exception</code>), wenn eine Exception \"geworfen\" wird</li> <li>Die Abarbeitung des Programmcodes wird sofort unterbrochen.</li> <li>Das Laufzeitsystem sucht nach der n\u00e4chsten <code>catch</code>-Klausel und f\u00fchrt diese aus.</li> <li>Passt die gefundene <code>catch</code>-Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste <code>catch</code>-Klausel gesucht usw.\u00a0</li> </ol> <p>Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen <code>catch</code>-Klausel (Zeile <code>10</code>) ein Objekt vom Typ <code>StringIndexOutOfBoundsException</code> erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von <code>Exception</code> ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von <code>StringIndexOutOfBoundsException</code> allegmein eine <code>Exception</code> erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere <code>catch</code>-Klausel (Zeile <code>24</code>), wo wir eine <code>ArithmeticException</code> erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere <code>catch</code>-Bl\u00f6cke hintereinander setzen kann und der erste <code>catch</code>-Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. </p> <p>Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" <code>catch</code>-Klausel gesprungen wird. </p>"},{"location":"exceptions/#ein-weiteres-beispiel","title":"Ein weiteres Beispiel","text":"<p>Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>inputInt()</code>:</p> eine weitere methode inputInt() <pre><code>/*\n * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten\n * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, \n * dann muessen Sie dort noch\n * module ProjektName\n * {\n *  requires java.desktop;\n * }\n * eintragen, damit Sie das Paket javax.swing importieren koennen. \n */\nimport javax.swing.JOptionPane;\n\npublic class Ausnahmen\n{\nstatic char charAt(String s, int index)\n{\nchar c = ' ';\ntry\n{\nc = s.charAt(index); // kritisch!\n}\ncatch(StringIndexOutOfBoundsException e)\n{\nSystem.err.println(\"Der Index war ausserhalb des Strings\");\n}\nreturn c;\n}\n\nstatic double divide(int divident, int divisor)\n{\ndouble result = 0.0;\ntry\n{\nresult = divident/divisor; // kritisch!\n}\ncatch(ArithmeticException ae)\n{\nSystem.err.println(\"Division durch 0 nicht definiert!\");\n}\nreturn result;\n}\n\nstatic int inputInt()\n{\nint inputInt = 0;\nboolean inputOk = false;\nString input =\"\";\nwhile(!inputOk)\n{\ninput = JOptionPane.showInputDialog(\"Zahl :\");\ninputOk = true;\ntry {\ninputInt = Integer.parseInt(input);\n}\ncatch(NumberFormatException e)\n{\ninputOk = false;\n}\n}\nreturn inputInt;\n}\npublic static void main(String[] args) {\nSystem.out.println(divide(5,0));            // ArithmeticException\nSystem.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\nSystem.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\n}\n}\n</code></pre> <p>Schauen wir uns die Implementierung von <code>inputInt()</code> genauer an: </p> <ul> <li>in Zeile <code>50</code> wird ein kleines Eingabefenster erzeugt (<code>JOptionPane</code> ist eine Klasse aus dem <code>javax.swing</code>-Paket, welches wiederum im Modul <code>java.desktop</code> verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als <code>String</code> zur\u00fcckgegeben und in der Variablen <code>input</code> gespeichert. </li> <li>in Zeile <code>53</code> wird versucht, den Eingabestring <code>input</code> in ein <code>int</code> umzuwandeln. Dazu wird die Methode <code>parseInt()</code> verwendet, die zur Klasse <code>Integer</code> geh\u00f6rt (<code>Integer</code> ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). </li> <li>wenn <code>input</code> eine Zahl enth\u00e4lt, also z.B. so aussieht: <code>\"1234\"</code>, dann erzeugt <code>parseInt()</code> daraus die <code>int</code>-Zahl <code>1234</code> und alles ist ok. Wenn <code>input</code> jedoch keine Zahl enth\u00e4lt, also z.B. <code>\"hallo\"</code>, dann wirft <code>parseInt()</code> eine <code>NumberFormatException</code>, weil die Umwandlung des <code>String</code>s in ein <code>int</code> nicht m\u00f6glich ist. </li> <li>in Zeile <code>55</code> wird eine solche <code>NumberFormatException</code> aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter <code>inputOk</code> auf <code>false</code> gesetzt wird. </li> <li>der gesamte Anweisungsblock Fenster-&gt;Eingabe-&gt;try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von <code>inputOk</code> nicht <code>false</code> ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit <code>parseInt()</code> keine Exception wirft)</li> </ul> <p>\u00dcbrigens k\u00f6nnte die Anweisung <code>inputOk = true;</code> auch nach <code>parseInt()</code> in den <code>try</code>-Block geschrieben werden:</p> <pre><code>static int inputInt()\n{\nint inputInt = 0;\nboolean inputOk = false;\nString input =\"\";\nwhile(!inputOk)\n{\ninput = JOptionPane.showInputDialog(\"Zahl :\");\ntry {\ninputInt = Integer.parseInt(input);\ninputOk = true;\n}\ncatch(NumberFormatException e)\n{\ninputOk = false;\n}\n}\nreturn inputInt;\n}\n</code></pre> <p>Zeile <code>12</code> wird nur genau dann erreicht, wenn <code>parseInt()</code> keine Exception wirft. Dann wird auch der <code>catch</code>-Block nicht betreten und die Schleife wird beendet. </p>"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","title":"Beispiel mit mehreren Exceptions","text":"<p>Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende <code>catch</code>-Klausel gesucht wird. Wir erweitern dazu unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>mehrereExceptions()</code>:</p> <pre><code>public static void mehrereExceptions()\n{\nString[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\nint base = 0;\ndouble result= 0;\nboolean ok = true;\n\nfor(int index = 0; index&lt;=4; index++) {\ntry {\nbase = Integer.parseInt(basen[index]);\nok = true;\n}\ncatch(NumberFormatException nfe) {\nSystem.out.println(\"Keine Zahl!\");\nok = false;\n}\ncatch(IndexOutOfBoundsException ioobe) {\nSystem.out.println(\"Ausserhalb des Arrays\");\nok = false;\n}\nfor(int exp = 0; exp&lt;6 &amp;&amp; ok; exp++) {\nresult = Math.pow(base, exp);\nSystem.out.printf(\"%d ^ %d = %.0f %n\", base, exp, result);\n}\n}\n}\n</code></pre> <ul> <li>In Zeile <code>3</code> definieren wir uns ein <code>String[]</code> mit 4 Eintr\u00e4gen. </li> <li>Durch dieses <code>String[]</code> laufen wir mit einer <code>for</code>-Schleife (Zeile <code>8</code>) durch.</li> <li>In Zeile <code>11</code> wandeln wir jeden Eintrag aus dem <code>String[]</code> in eine <code>int</code>-Zahl um. </li> <li>An zwei Stellen k\u00f6nnen Exceptions geworfen werden:<ul> <li>Bei dem Index-basierten Zugriff auf das Array <code>basen[index]</code> in Zeile <code>11</code> kann eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen werden, falls <code>index</code> kein korrekter Index des <code>String[]</code> ist (gilt f\u00fcr <code>index==4</code>).</li> <li>Bei der Umwandlung von <code>String</code> nach <code>int</code> durch <code>parseInt()</code> in Zeile <code>11</code> kann eine <code>NumberFormatException</code> geworfen werden, falls der entsprechende Eintrag im <code>String[]</code> keine Zahl ist (gilt f\u00fcr <code>basen[3]=='Hi'</code>).</li> </ul> </li> </ul> <p>Die Methode erzeugt die folgende Ausgabe:</p> <pre><code>2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 \nKeine Zahl!\nAusserhalb des Arrays\n</code></pre> <p>Das hei\u00dft, dass wenn f\u00fcr <code>parseInt(\"Hi\")</code> eine <code>NumberFormatException</code> geworfen wird, dann wird der <code>catch</code>-Block ausgef\u00fchrt, der eine <code>NumberFormatException</code> erwartet (Zeilen <code>14-17</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt. </p> <p>Wenn f\u00fcr <code>basen[4]</code> eine <code>ArrayIndexOutOfBoundsException</code> geworfen wird, dann wird der  <code>catch</code>-Block ausgef\u00fchrt, der eine <code>IndexOutOfBoundsException</code> erwartet (Zeilen <code>18-21</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt.</p> <p>Wir sehen, dass es offensichtlich auch eine <code>IndexOutOfBoundsException</code>-Klasse gibt. Das ist eine Elternklasse von <code>ArrayIndexOutOfBoundsException</code> und auch von <code>StringIndexOutOfBoundsException</code>. Wir schauen uns diese Vererbungshierarchie von <code>Exception</code> nun mal an:</p>"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","title":"Die Vererbungshierarchie der Klasse Exception","text":"<p>Wenn Sie sich die Klasse <code>Exception</code> in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen:</p> <p></p> <p>Alle Exception-Klassen erben von der Klasse <code>Exception</code>, die im <code>java.lang</code>-Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden:</p> <ul> <li>checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen <code>try-catch</code>-Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem <code>try</code>-Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). </li> <li>unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse <code>RunTimeException</code> ab. Wir werden uns genau mit diesen uncheck Exceptions, also von <code>RunTimeException</code> abgeleiteten Klassen besch\u00e4ftigen. </li> </ul> <p>Es gibt von <code>RunTimeException</code> noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die <code>IllegalArgumentException</code>-Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene <code>Exception</code>-Klassen erstellen. </p>"},{"location":"exceptions/#try-catch-finally","title":"try-catch-finally","text":"<p>Prinzipiell besteht das Konstrukt <code>try</code> und <code>catch</code> nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem <code>finally</code>-Block. Der <code>finally</code>-Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt:</p> <pre><code>    try {\n// Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n}   catch(Exception e)  {\n// Behandlung der Exception \n}\nfinally\n{\n// Aufraeumen, z.B. Schliessen von Dateien, Beenden von \n// Verbindungen zu Servern, Datenbanken etc.\n}\n</code></pre> <p>Typischerweise wird der <code>finally</code>-Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden <code>finally</code> jedoch nicht sehr oft implementieren. </p>"},{"location":"exceptions/#throws-eine-exception-weiterreichen","title":"throws - eine Exception weiterreichen","text":"<p>Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem <code>try-catch</code>-Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort <code>throws</code> verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um <code>throws</code> und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus:</p> <pre><code>[modifizierer] [rueckgabetyp] methodenname throws ExceptionType\n{\n// Anweisungsblock\n// wirft (evtl.) Exception\n}   </code></pre> <p>Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse <code>Ausnahmen</code> um die Methode <code>getValueAtIndex</code>: </p> <pre><code>static int getValueAtIndex(int[] field, int index) throws ArrayIndexOutOfBoundsException\n{\nreturn field[index];\n}\n\n\npublic static void main(String[] args) {\nSystem.out.println(divide(5,0));            // ArithmeticException\nSystem.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\nSystem.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\nmehrereExceptions();\n\nint value = 0;\nboolean ok = true;\nint[] field = {8, 3,-4, 2, -9};\ntry\n{\nvalue = getValueAtIndex(field,-3);\n}\ncatch(ArrayIndexOutOfBoundsException e)\n{\nSystem.out.println(\"Index ausserhalb des Arrays!\");\nok = false;\n}\nif(ok) {\nSystem.out.println(\"value : \" + value);\n}\n}\n</code></pre> <p>Obwohl die Methode eine kritische Anweisung enth\u00e4lt (<code>field[index]</code>), ist diese Anweisung nicht in einen <code>try-catch</code>-Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine <code>ArrayIndexOutOfBoundsException</code>) geworfen wird. Wir geben das im Methodenkopf mithilfe von <code>throws ArrayIndexOutOfBoundsException</code> bekannt. Die aufrufende Methode (<code>main</code>) kann nun selbst den Aufruf der Methode <code>getValueAtIndex()</code> in einen <code>try-catch</code>-Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode <code>getValueAtIndex()</code> zur\u00fcckgegebene Wert ausgegeben. </p> <p>Wenn wir an unsere einleitenden Beispiele denken (Methoden <code>charAt()</code> und <code>divide()</code>), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von <code>getValueAtIndex()</code> vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei <code>charAt()</code>. Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. </p>"},{"location":"exceptions/#schoner-code","title":"Sch\u00f6ner Code","text":"<p>Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. </p> <p>Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: </p> <ol> <li>eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP)</li> <li>\u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich)</li> <li>\u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter (<code>throws</code>) </li> <li>\u2192 fangen Sie den Fehler in einer anderen Methode ab (<code>try</code>)</li> <li>\u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers (<code>catch</code>) in eine dritte Methode auslagern (single responsibility)</li> </ol> <p>H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt (<code>try</code>) im <code>catch</code>-Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. </p>"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","title":"throw - eigene Exceptions erzeugen","text":"<p>Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich <code>throw</code>. Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort <code>throws</code> sehr \u00e4hnlich. Mit <code>throw</code> erzeugen (werfen) wir eine eigene Exception, mit <code>throws</code> wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. </p> <p>Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe <code>Triangle</code>im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird?</p> <p>Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes <code>throw</code> wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. </p> <p>F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten:</p> <ul> <li>entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse <code>Exception</code> oder von der Klasse <code>RunTimeException</code> ab (<code>extends Exception</code> bzw. <code>extends RunTimeException</code>) oder</li> <li>wir verwenden eine bereits existierende Exception-Klasse (typischerweise <code>IllegalArgumentException</code>).</li> </ul>"},{"location":"exceptions/#throw-new-illegalargumentexception","title":"throw new IllegalArgumentException","text":"<p>Wir implementieren unsere Klasse <code>Triangle</code> so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine <code>IllegalArgumentException</code> werfen. Dieser Exception kann ein <code>String</code> als Parameter \u00fcbergeben werden, der im <code>catch</code>-Block mittels <code>getMessage()</code> wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist.</p> Triangle mit eigenen IllegalArgumentExceptions <pre><code>public class Triangle\n{\nprivate int a,b,c;\n\npublic Triangle(int a, int b, int c) throws IllegalArgumentException\n{\nif(a&lt;=0 || b&lt;=0 || c&lt;=0) {\nthrow new IllegalArgumentException(\"Seiten muessen groesser als 0 sein!\");\n}\nelse if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) {\nthrow new IllegalArgumentException(\"Kein Dreieck!\");\n}\nelse {\nthis.a = a;\nthis.b = b;\nthis.c = c;\n}\n}\npublic static void main(String[] args) {\nTriangle d;\n\ntry {\nd = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n}\ncatch(IllegalArgumentException e) {\nSystem.out.println(e.getMessage());\n}\n}\n}\n</code></pre> <p>Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile <code>5</code> - <code>throws IllegalArgumentException</code>). Im Konstruktor werden die Parameterwerte gepr\u00fcft und</p> <ul> <li>entweder eine <code>IllegalArgumentException</code> geworfen, falls eine Seite kleiner gleich 0 ist (Zeile <code>9</code> - <code>throw new</code>) </li> <li>oder eine <code>IllegalArgumentException</code> geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile <code>13</code> - <code>throw new</code>) </li> <li>oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen <code>17-19</code>).</li> </ul> <p>Die Erzeugung eines <code>Triangle</code>-Objektes (also der Aufruf des Konstruktors) ist nun in einen <code>try-catch</code>-Block eingebettet (Zeilen <code>26-32</code>). Beachten Sie, dass es sein kann, dass <code>d</code> nach Aufruf des Konstruktors immernoch <code>null</code> ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.</p>"},{"location":"exceptions/#eigene-exception-klasse-definieren","title":"Eigene Exception-Klasse definieren","text":"<p>Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von <code>Triangle</code>. Diese eigenen Exception-Klassen erben von der Klasse <code>Exception</code>. Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem <code>try-catch</code>-Block abgefangen und behandelt werden. </p> Eigene Klasse IllegalTriangleException <pre><code>public class IllegalTriangleException extends Exception\n{\npublic IllegalTriangleException(String s) {\nsuper(s);\n}\n\npublic IllegalTriangleException() {\nsuper(\"Each side has to be smaller than the sum of the other sides!\");\n}\n}\n</code></pre> <p>Die Klasse <code>IllegalTriangleException</code> verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. </p> Eigene Klasse IllegalSideLengthException <pre><code>public class IllegalSideLengthException extends Exception\n{\n\npublic IllegalSideLengthException(String s) {\nsuper(s);\n}\n\npublic IllegalSideLengthException() {\nsuper(\"Sides must be greater than zero!\");\n}\n}\n</code></pre> <p>Die Klasse <code>IllegalSideLengthException</code> verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von <code>Exception</code> erzeugt und dem eine Fehlermeldung als <code>String</code> im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als <code>String</code> \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. </p> <p>Die Anwendung dieser beiden Exception-Klassen in der Klasse <code>Triangle</code> k\u00f6nnte nun so aussehen (wir haben hier auch gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen):</p> Triangle mit den selbst definierten Exception-Klassen <pre><code>public class Triangle\n{\nprivate int a,b,c;\n\npublic Triangle(int a, int b, int c) throws Exception\n{\nif(a&lt;=0 || b&lt;=0 || c&lt;=0) {\nthrow new IllegalTriangleException();\n}\nelse if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) {\nthrow new IllegalSideLengthException();\n}\nelse {\nthis.a = a;\nthis.b = b;\nthis.c = c;\n}\n}\n\npublic static void main(String[] args) {\nTriangle d;\n\ntry {\nd = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n}\ncatch(Exception e) {\nSystem.out.println(e.getMessage());\n}\n\n}\n}\n</code></pre> <p>Beide eigenen Klassen sind ja auch vom Laufzeittyp <code>Exception</code>, da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der <code>catch</code>-Klausel mit <code>Exception</code> (Zeile <code>30</code>) passend. Wenn Sie anstelle der Zeilen <code>27-33</code> nur <code>d = new Triangle(3,4,5);</code> schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem <code>try-catch</code>-Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an <code>Surround with try/catch</code>. Das sollten Sie einmal ausprobieren. </p> <p>Wenn Sie anstelle von <code>Exception</code> von der Klasse <code>RunTimeException</code> erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden.</p> <p>Success</p> <p>Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von <code>Exception</code>, insb. von <code>RunTimeException</code>). Mithilfe von <code>try-catch-[finally]</code> k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von <code>throws</code> zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort <code>throw</code> weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem <code>try-catch</code>-Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...</p>"},{"location":"gui/","title":"Graphical User Interfaces","text":"<p>Bis jetzt haben wir unsere Ein- und Ausgaben \u00fcber die Konsole erledigt oder wir haben Testklassen geschrieben, um Funktionalit\u00e4ten unserer Programme zu testen. Nun wollen wir grafische Nutzeroberfl\u00e4chen (Graphical User Interfaces (GUI)) erstellen, also Fenster, die Steuerelemente enthalten. Steuerelemente sind Ein- und Ausgabeelemente, Labels (also Text), Buttons, Checkboxes, Radiobuttons usw. </p> <p>Das Java Developement Kit (JDK) beinhaltet verschiedene Bibliotheken zum Erstellen grafischer Nutzeroberfl\u00e4chen:</p> <ul> <li>AWT (abstract window toolkit) <code>java.awt</code>; alt, aber noch viele Sachen, die man heute noch nutzt: Farben, Listener f\u00fcr Maus und Tastur, Grafiken, ...</li> <li>Swing <code>javax.swing</code>; das verwenden wir zum Erstellen von Fenstern, auch nicht mehr ganz neu</li> <li>JavaFX <code>javafx</code>; sollte eigentlich Swing abl\u00f6sen, hat sich aber nicht durchgesetzt, seit Java 11 nicht mehr Bestandteil des Standard-JDK</li> </ul> <p>Swing ist, wie bereits gesagt, auch nicht mehr neu und wird h\u00e4ufig als veraltet bezeichnet. Allerdings gibt es auch keine Alternativen. JavaFX sollte Swing abl\u00f6sen, hat sich jedoch noch nicht durchgesetzt. Wir verwenden Swing aus zwei Gr\u00fcnden:</p> <ul> <li>erstens ist es immer noch das am meisten verwendete Framework f\u00fcr die Erstellung von GUIs in nativen Desktopanwendungen (also alles, was nicht \"Web\" und was nicht \"mobile\" ist), bspw. wurde IntelliJ mit Swing aufgebaut und</li> <li>zweitens geht es uns um die Konzepte, d.h. um den hierarchischen Aufbau der Oberfl\u00e4chen, um Nutzereignisse und die Behandlung dieser. Wir werden uns im 3. Semester in \"Webtechnologien\" mit der Erstellung moderner Weboberfl\u00e4chen besch\u00e4ftigen und dabei auf die Grundlagen aufbauen, die wir hier legen. Die Konzepte sind n\u00e4mlich dieselben. </li> </ul>"},{"location":"gui/#elemente-einer-gui","title":"Elemente einer GUI","text":"<p>Eine GUI besteht aus verschiedenen Elementen, deren Zusammenspiel erst die Benutzbarkeit der Oberfl\u00e4che erm\u00f6glichen. Unter Benutzbarkeit ist dabei die einfache, intuitive und \u00fcbersichtliche Ein- und Ausgabe von Daten gemeint. Im 6. Semester gibt es eine ganze Lehrveranstaltung zum Thema Usability in unserem Studiengang. </p> <p></p> <p>Folgende Elemente sind in einer GUI von Bedeutung:</p> <ul> <li>Das Fenster stellt den \u00e4u\u00dferen Rahmen einer grafischen Anwendung dar. Es enth\u00e4lt typischerweise einen Rahmen und eine Titelleiste, in der der Name des Fensters bzw. der Anwendung (in der oberen Abbildung <code>Window</code>) und drei Buttons zum Schlie\u00dfen des Fensters bzw. der Anwendung (das rote Kreuz in der oberen Abbildung), zum Vollbildmodus (das Quadrat) und zum Verkleinern des Fensters in die Taskleiste (der Unterstrich) enthalten sind. Der Rahmen, genau wie die Titelleiste mit den drei Buttons, sind aber optional. Ein Fenster enth\u00e4lt Komponenten.</li> <li>Komponenten sind alle Oberfl\u00e4chen- bzw. Steuerelemente, d.h. Buttons (siehe oben <code>&lt; Back</code> und <code>Next &gt;</code>), Labels (Texte, z.B. <code>Checkbox</code>), Checkboxes (die Quadrate, die ein H\u00e4kchen haben k\u00f6nnen oder auch nicht), Ein- und Ausgabefelder, Auswahllisten usw. Steuerelemente sind also alle Elemente, die direkt der Ein- und Ausgabe dienen. Dar\u00fcber hinaus gibt es noch die Komponente Container. Ein Container kann selbst wieder Container  enhalten oder Steuerelemente. Container sind nicht direkt sichtbar, sondern sie dienen der Strukturierung einer grafischen Oberfl\u00e4che. </li> <li>Layoutmanager organisieren die Positionierung von Komponenten. Mithilfe von Layoutmanagern kann man Container unter- und/oder nebeneinander positionieren und organisiert somit die Anordnung der Steuerelemente. </li> <li>Men\u00fcs sind einblendbare Befehlsleisten. Es gibt die Men\u00fcs, die meistens oben in der Men\u00fcleiste verankert sind und Kontextmen\u00fcs, die dort erscheinen, wo man, meistens mit der rechten, Maustaste hinklickt. </li> <li>Events (Ereignisse) haben zun\u00e4chst nichts mit der Darstellung selbst zu tun. Sie sind aber f\u00fcr die Benutzbarkeit sehr wichtig, denn jede Nutzeraktion l\u00f6st ein Ereignis aus, welches wir im Programm behandeln k\u00f6nnen, z.B. Mausklicks, Mausbewegungen, Tastatureingaben, Bewegen, Vergr\u00f6\u00dfern, Verkleinern des Fensters usw. Wir werden uns sehr ausf\u00fchrlich mit der Behandlung von Ereignissen besch\u00e4ftigen.</li> <li>Zeichenoperationen dienen der Erstellung von Punkten, Linien, Text usw. in Fenstern. W\u00e4hrend die Steuerelemente ein festes Aussehen besitzen (anpassbar, je nach Betriebssystem und unterschiedlichen Look&amp;Feel-Frameworks), k\u00f6nnen mit Zeichenoperationen beliebige Elemente erstellt und dargestellt werden, z.B. Grafiken, Kurven oder Diagramme.</li> </ul> <p>Wir werden auf alle diese Elemente eingehen und starten jetzt aber mit unserem ersten Fenster. </p>"},{"location":"gui/#ein-erstes-fenster-mit-swing","title":"Ein erstes Fenster mit Swing","text":"<p>Wir erstellen uns eine Klasse <code>MyFirstWindow</code>. Von dieser Klasse erzeugen wir uns ein Objekt. Dazu implementieren wir den parameterlosen Konstruktor dieser Klasse. In diesem Konstruktor wird ein <code>JFrame</code> erzeugt - das ist das Fenster bei Swing. Wir haben in dieser Klasse auch eine <code>main()</code>-Methode. Das ist nicht ganz sauber, da die <code>main()</code>-Methode ja eigentlich keine Eigenschaft unserer Klasse ist, deren Responsibility die Erstellung eines Fensters ist, aber wir vereinfachen hier zu Anfang:</p> <pre><code>import javax.swing.JFrame;\n\npublic class MyFirstWindow {\n\npublic MyFirstWindow()\n{\nJFrame window = new JFrame();\nwindow.setTitle(\"My first window\");\nwindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nwindow.setSize(400, 300);\nwindow.setLocation(300,200);\nwindow.setVisible(true);\n}\n\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n\n}\n</code></pre> <p>Wenn wir diese Klasse ausf\u00fchren, erscheint folgendes Fenster:</p> <p></p> <p>Das Aussehen ist betriebssystemabh\u00e4ngig. Probieren Sie die drei \"Kn\u00f6pfe\" in der Titelleiste aus, sie funktionieren bereits, d.h. das Fenster l\u00e4sst sich in die Taskleiste verkleinern, es l\u00e4sst sich in den Vollbildmodus umschalten und es kann geschlossen werden (und damit das ganze Programm). Sie k\u00f6nnen es auch bereits in der Gr\u00f6\u00dfe ver\u00e4ndern. </p> <p>Wir betrachten das Programm im Detail:</p> <ul> <li>In Zeile <code>8</code> wird ein Objekt der Klasse <code>JFrame</code> erzeugt. Diese Klasse muss aus dem <code>javax.swing</code>-Paket importiert werden (Zeile <code>1</code>). Sollte der Import bei Ihnen nicht funktionieren, m\u00fcssen Sie in Ihre <code>module-info.java</code> noch <code>requires java.desktop;</code> einf\u00fcgen, um dieses Modul zu laden. Die Klasse <code>JFrame</code> repr\u00e4sentiert ein Fenster im Swing-Paket. Das bedeutet, dass wir, wenn wir in Zukunft eine GUI mithilfe von Swing erstellen, immer damit beginnen, ein Objekt der Klasse <code>JFrame</code> zu erzeugen - n\u00e4mlich ein Fenster. </li> <li>Die Klasse JFrame stellt eine Unmenge an Objektmethoden zur Verf\u00fcgung, um das Fenster zu ver\u00e4ndern. Viele dieser Methoden sind auch aus Klassen des <code>java.awt</code>-Pakets geerbt, z.B. von Frame, von Component, von Container oder von Window, aber dazu kommen wir sp\u00e4ter. Wir wenden einige dieser Methoden bereits an:</li> <li>In Zeile <code>9</code> setzen wir mithilfe der Objektmethode <code>setTitle()</code> einen Titel f\u00fcr unser Fenster, hier <code>\"My first window\"</code>. Um den Titel zu setzen, gibt es auch einen parametrisierten Konstruktor von <code>JFrame</code>, dem dieser Titel \u00fcbergeben werden kann. </li> <li>In Zeile <code>10</code> definieren wir, was passieren soll, wenn wir auf den <code>Schlie\u00dfen</code>-Buttons des Fensters klicken (also auf das rote Kreuz oder den roten Kreis in der Titelleiste). Mit der statischen Konstanten <code>EXIT_ON_CLOSE</code> aus der Klasse <code>JFrame</code> legen wir fest, dass sowohl das Fenster geschlossen als auch das Programm beendet werden soll, wenn wir den <code>Schlie\u00dfen</code>-Button anklicken. Diese Option ist auch die einzig empfohlene Option f\u00fcr das Schlie\u00dfen des (Haupt-)Fensters. Leider ist sie nicht Standard, so dass wir das immer mitprogrammieren m\u00fcssen. Sollten Sie diese Anweisung vergessen, so schlie\u00dft sich zwar das Fenster, nicht jedoch das Programm. </li> <li>In Zeile <code>11</code> legen wir die Gr\u00f6\u00dfe des Fensters in Pixeln fest. Hier wird die Breite mit <code>400</code>Pixeln und die H\u00f6he mit <code>300</code> Pixeln festgelegt. Die Gr\u00f6\u00dfe des Fensters ist somit abh\u00e4ngig von der Aufl\u00f6sung Ihres Monitors. Wenn Sie diese Angabe \"vergessen\", erscheint das Fenster genau so gro\u00df, wie es n\u00f6tig ist, um alle Steuerelemente in dem Fenster darzustellen. Sie w\u00fcrden also nur die drei Kn\u00f6pfe in der Titelleiste sehen. Diese \"minimal erforderliche\" Gr\u00f6\u00dfe eines Fensters erreicht man auch mit der Objektmethode <code>pack()</code>, die das Fenster genau so gro\u00df darstellt, dass alle Steuerelemente sichtbar sind. </li> <li>In Zeile <code>12</code> legen wir fest, wo das Fenster auf unserem Monitor erscheint. Die linke obere Ecke des Monitors hat die Koordinaten <code>(0,0)</code>. Der erste Parameterwert in <code>setLocation()</code> legt fest, wie weit nach rechts der linke obere Punkt des Fensters auf unserem Monitor verschoben wird und der zweite Parameterwert legt fest, wie weit nach unten der linke obere Punkt des Fensters verschoben wird. Hier verschieben wir also das Fenster um <code>300</code> Pixel nach rechts und um <code>200</code> Pixel nach unten. Wenn Sie diese Angabe nicht treffen, erscheint das Fenster in der linken oberen Ecke des Monitors. </li> <li>In Zeile <code>13</code> setzen wir das Fenster auf sichtbar. Diese Anweisung sollten wir nicht vegessen, denn ansonsten sieht man das Fenster nicht und Sie wundern sich. </li> </ul>"},{"location":"gui/#setdefaultcloseoperation","title":"setDefaultCloseOperation()","text":"<p>Mit der Objektmethode <code>setDefaultCloseOperation()</code> wird das Verhalten bei Schlie\u00dfen des Fensters definiert. Daf\u00fcr wurden Konstanten in der Klasse <code>JFrame</code> definiert (genauer gesagt in der Klasse <code>javax.swing.WindowConstants</code>). Es wird empfohlen, dass wir f\u00fcr unser Hauptfenster stets <code>JFrame.EXIT_ON_CLOSE</code>) verwenden, da dann beim Schlie\u00dfen des Fensters auch das Programm beendet wird. Das ist aber leider nicht der Standardwert, deshalb m\u00fcssen wir es immer explizit angeben. Hier eine \u00dcbersicht der vordefinierten Konstanten und ihrer Bedeutung:</p> Konstante Bedeutung DO_NOTHING_ON_CLOSE Es wird keine Aktion ausgef\u00fchrt. Die Reaktion auf das Schlie\u00dfen muss vom Benutzer selbst \u00fcber einen WindowListener realisiert werden. (windowClosing) HIDE_ON_CLOSE Versteckt das Fenster vor dem Benutzer. Alle Objekte und Ressourcen bleiben im Speicher erhalten und das Fenster kann jederzeit wieder sichtbar gemacht werden. DISPOSE_ON_CLOSE Das Fenster wird vom Bildschirm entfernt und alle Objekte und Ressourcen freigegeben. Wenn das letzte Fenster mit dieser Eigenschaft geschlossen wird verh\u00e4lt sich die Anwendung wie bei EXIT_ON_CLOSE. EXIT_ON_CLOSE Beendet die Anwendung und alle Fenster werden geschlossen und Ressourcen freigegeben. (System.exit(0))"},{"location":"gui/#kurzer-uberblick-jframe","title":"Kurzer \u00dcberblick JFrame","text":"<p>Ein <code>JFrame</code> ist der \u00e4u\u00dfere Rahmen einer Swing-Anwendung. Die Klasse befindet sich im Paket <code>javax.swing</code>. Ein Fenster (<code>JFrame</code>) hat </p> <ul> <li>eine Titelleiste mit den drei bekannten Schaltfl\u00e4chen (<code>decorated</code>);  <code>setUndecorated(boolean v)</code></li> <li>einen Rahmen (<code>javax.swing.Border</code>) </li> <li>Sichtbarkeit; <code>setVisible(boolean v)</code></li> <li>Transparenz;  <code>setOpacity(float f)</code> (0 durchsichtig; 1.0 undurchsichtig)</li> <li>eine Gr\u00f6\u00dfe;   <code>setSize(int b, int h)</code></li> <li>eine Position; <code>setLocation(int x, int y)</code></li> <li>eine Form; <code>setShape(Shape s)</code></li> </ul> <p>und kann </p> <ul> <li>im Vordergrund sein;  <code>toFront()</code></li> <li>im Hintergrund sein;  <code>toBack()</code></li> </ul>"},{"location":"gui/#unsere-klasse-ist-selbst-ein-fenster","title":"Unsere Klasse ist selbst ein Fenster","text":"<p>Ehe wir weitere Methoden f\u00fcr <code>JFrame</code> ausprobieren, \u00e4ndern wir die Implementierung unserer Klasse leicht. Derzeit haben wir in unserer Klasse ein Fenster erzeugt. Nun soll unsere Klasse selbst (besser gesagt: ein Objekt unserer Klasse) ein Fenster sein. Dazu lassen wir unsere Klasse von <code>JFrame</code> erben:</p> <pre><code>import javax.swing.JFrame;\n\npublic class MyFirstWindow extends JFrame\n{\n\npublic MyFirstWindow()\n{\nsuper();    // Konstruktor von JFrame\nthis.setTitle(\"My first window\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n\n}\n</code></pre> <p>Die wesentlichen \u00c4nderungen sind:</p> <ul> <li>Die Klasse <code>MyFirstWindow</code> erbt von <code>JFrame</code> (Zeile <code>3</code>). Jedes Objekt der Klasse <code>MyFirstWindow</code> ist also (auch) ein Objekt der Klasse <code>JFrame</code> - und damit selbst ein Fenster. </li> <li>Im Konstruktor von <code>MyFirstWindow</code> rufen wir mit <code>super();</code> den Konstruktor von <code>JFrame</code> auf (Zeile <code>8</code>). Damit wird das Fenster erstellt. </li> <li>Die Objektmethoden von <code>JFrame</code> werden jetzt alle von der Referenz <code>this</code> aufgerufen, dem Fenster-Objekt.</li> </ul> <p>Wir werden auf diesem Grundger\u00fcst f\u00fcr die Erstellung eines Fensters aufbauen, d.h. wir verwenden in Zukunft diese zweite Variante und ziehen sie der ersten vor. </p>"},{"location":"gui/#die-content-pane-des-fensters","title":"Die Content Pane des Fensters","text":"<p>Bevor wir dem Fenster nun Komponenten hinzuf\u00fcgen, ist es noch erw\u00e4hnenswert, dass ein Fenster aus verschiedenen \"Schichten\" besteht, sogenannten panes. Die folgende Abbildung zeigt die panes eines JFrames. </p> <p></p> <p>Um dies besser zu erl\u00e4utern, versuchen wir, die Hintergrundfarbe des Fensters neu zu setzen. Dazu steht in der Klasse <code>JFrame</code> die Methode <code>setBackground(Color)</code> zur Verf\u00fcgung. Diese Methode erwartet ein <code>Color</code>, welche im <code>java.awt</code>-Paket zur Verf\u00fcgung steht. Der erste Implementierungsversuch w\u00e4re deshalb wie folgt:</p> <pre><code>import java.awt.Color;\nimport javax.swing.JFrame;\n\npublic class MyFirstWindow extends JFrame\n{\n\npublic MyFirstWindow()\n{\nsuper();\nthis.setTitle(\"My first window\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.setBackground(Color.CYAN);\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n\n}\n</code></pre> <p>Wir wollen unseren Fesnterhintergrund also mit der vorderfinierten Farbe <code>CYAN</code> einf\u00e4rben. Wenn wir dieses Programm ausf\u00fchren, erhalten wir folgendes Fenster:</p> <p></p> <p>Zwar f\u00e4rbt sich die Titelleiste des Fensters, aber der Rest bleibt offensichtlich grau. Das liegt daran, dass die Content Pane des Fensters vor dem Hintergrund liegt. </p> <p>Alle Komponenten f\u00fcgen wir der Content Pane des Fensters hinzu! Das gilt auch f\u00fcr F\u00e4rbungen des Hintergrunds. </p> <p>Die Content Pane ist dazu da, die Komponenten hinzuzuf\u00fcgen und darzustellen. Wenn wir einen anderen Hintergrund f\u00fcr das Fenster (unterhalb der Titelleiste) w\u00fcnschen, dann m\u00fcssen wir den Hintergrund der Content Pane einf\u00e4rben. </p> <p>Den Zugriff auf die Content Pane erhalten wir mithilfe der Objektmethode </p> <pre><code>.getContentPane()\n</code></pre> <p>Unser Beispiel des Einf\u00e4rbens des Hintergrundes sieht also korrekt so aus:</p> <pre><code>import java.awt.Color;\nimport javax.swing.JFrame;\n\npublic class MyFirstWindow extends JFrame\n{\n\npublic MyFirstWindow()\n{\nsuper();\nthis.setTitle(\"My first window\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.getContentPane().setBackground(Color.CYAN);\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n\n}\n</code></pre> <p>Beachten Sie, dass die Content Pane des Fensters zwar nun <code>CYAN</code> ist, daf\u00fcr aber nicht mehr die Titelleiste. Wenn wir diese auch f\u00e4rben sollen, dann gehen wir auch noch wie oben vor. </p> <p></p>"},{"location":"gui/#container-komponenten","title":"Container-Komponenten","text":"<p>Ehe wir Steuerelemente zu unserem Fenster hinzuf\u00fcgen, wollen wir auf die Unterscheidung zwischen Steuerelementen und Containern eingehen. Ein Fenster enth\u00e4lt Komponenten (<code>JComponent</code>). Komponenten k\u00f6nnen sein:</p> <ul> <li>Steuerelemente; das sind die sichtbaren Teile im Fenster, d.h. Buttons, Eingabefelder, Checkboxen usw. und</li> <li>Container; diese sieht man nicht direkt, sie dienen der Strukturierung der GUI. </li> </ul> <p>Container k\u00f6nnen weitere Komponenten (also Container oder Steuerelemente) enthalten. Steuerelemente enthalten aber keine weiteren Komponenten. Durch das Verschachteln von Containern in Containern entsteht eine \"Hierarchie\" (oder besser gesagt: eine \"Baumstruktur\") in unserer GUI:</p> <p></p> <p>Wichtig ist: </p> <ul> <li>die Knoten des Baumes sind Container und</li> <li>die Bl\u00e4tter des Baumes sind Steuerelemente </li> </ul>"},{"location":"gui/#inhalt-der-content-pane","title":"Inhalt der Content Pane","text":"<ul> <li>Die Content Pane ist selbst ein Container. </li> <li>Zur Content Pane k\u00f6nnen neue Komponenten (Container oder Steuerelemente) hinzugef\u00fcgt werden. </li> <li>Zum Hinzuf\u00fcgen neuer Komponenten wird die Objektmethode <code>add()</code> verwendet.</li> <li>Eine typische Klasse f\u00fcr einen Container ist die Klasse <code>JPanel</code>. <code>JPanels</code> k\u00f6nnen also ineinander verschachtelt werden, d.h. ein <code>JPanel</code> kann selbst wieder anderer <code>JPanels</code> entahlten (oder Steuerelemente).</li> <li>Typische Steuerelemente (die in der Baumstruktur die \u201cBl\u00e4tter\u201c bilden), sind <code>JButton</code>, <code>JLabel</code>, <code>JCheckBox</code>, <code>JRadioButton</code>, ...</li> </ul>"},{"location":"gui/#erweitern-des-fensters-um-ein-jpanel","title":"Erweitern des Fensters um ein JPanel","text":"<p>Wir f\u00fcgen unserer Content Pane nun ein <code>JPanel</code> (einen Container) hinzu und werden dieses <code>JPanel</code> danach mit weiteren Komponenten bef\u00fcllen. Unser neues Grundger\u00fcst eines Fensters sieht nun so aus:</p> <pre><code>import java.awt.Color;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\npublic class MyFirstWindow extends JFrame\n{\n\npublic MyFirstWindow()\n{\nsuper();\nthis.setTitle(\"My first window\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nthis.getContentPane().setBackground(Color.CYAN);    JPanel content = this.initContent();\nthis.getContentPane().add(content);\nthis.setSize(400, 300);\nthis.setLocation(300,200);\nthis.setVisible(true);\n}\n\nprivate JPanel initContent()\n{\nJPanel mainPanel = new JPanel();\n// hier weitere Container oder Steuerelemente hinzufuegen\nreturn mainPanel;\n}\npublic static void main(String[] args) {\nnew MyFirstWindow();\n}\n\n}\n</code></pre> <ul> <li>In Zeile <code>15</code> deklarieren wir eine Referenzvariable namens <code>content</code> vom Typ <code>JPanel</code>. Dazu muss die Klasse <code>JPanel</code> aus dem <code>javax.swing</code>-Paket importiert werden (Zeile <code>3</code>). </li> <li>Dieses <code>JPanel</code> wird durch die Methode <code>initContent()</code> erzeugt, welche ein <code>JPanel</code> zur\u00fcckgibt (Zeile <code>27</code>).</li> <li>In der Methode <code>initContent()</code> wird dieses <code>JPanel</code> erzeugt (Zeile <code>25</code>) unter Verwendung des parameterlosen Konstruktors von <code>JPanel</code>. </li> </ul> <p>Das so erzeugte Fenster sieht so aus:</p> <p></p> <p>Beachten Sie, dass der Hintergrund nun nicht mehr <code>CYAN</code> gef\u00e4rbt ist! Deshalb werden wir diese Anweisung auch gleich entfernen. Der Grund daf\u00fcr ist, dass zwar die Content Pane cyan ist, aber davor befindet sich jetzt ein <code>JPanel</code> (<code>content</code>), welches grau (Standardwert) ist. Dieses <code>JPanel</code> bef\u00fcllt die gesamte Content Pane. Diese ist also gar nicht mehr zu sehen. </p>"},{"location":"gui/#erweitern-der-initcontent-methode","title":"Erweitern der initContent()-Methode","text":"<p>Wir werden die <code>initContent()</code>-Methode nun sukzessive erweitern, indem wir Steuerelemente (und sp\u00e4ter auch weitere Container, also <code>JPanel</code>) hinzuf\u00fcgen. Dabei ist das generelle Vorgehen stets gleich:</p> <ol> <li>Steuerelement-Objekt erzeugen</li> <li>Steuerelement-Objekt dem Container (dem <code>JPanel</code>) hinzuf\u00fcgen</li> </ol> <p>Wir betrachten nur die <code>initContent()</code>-Methode (die erforderlichen Klassen m\u00fcssen aus dem <code>javax.swing</code>-Paket importiert werden - oder Sie w\u00e4hlen <code>import javax.swing.*;</code>):</p> <pre><code>    private JPanel initContent()\n{\nJPanel mainPanel = new JPanel();\n\n// Steuerlement-Objekte erstellen\nJLabel label = new JLabel(\"Name: \");\nJTextField input = new JTextField(10);\nJButton button = new JButton(\"Klick mich!\");\n// Steuerlement-Objekte dem Container (JPanel) hinzufuegen\nmainPanel.add(label);\nmainPanel.add(input);\nmainPanel.add(button);\nreturn mainPanel;\n}\n</code></pre> <p>Das Fenster sieht nun so aus:</p> <p></p> <p>Wir haben also ein <code>JLabel</code> (einen Text) hinzugef\u00fcgt (\"Name\"), ein <code>JTextField</code> (ein Eingabefeld, f\u00fcr das die Breite <code>10</code> Zeichen definiert wurde) sowie ein <code>JButton</code> (ein Button, auf dem \"Klick mich!\" steht). Bei allen drei Elementen handelt es sich um Steuerelemente. </p> <p>Beachten Sie, dass die Elemente nebeneinander angeordnet sind. Das ist die Standardeinstellung f\u00fcr ein <code>JPanel</code>. Solche Einstellungen k\u00f6nnen sp\u00e4ter mit einem Layout-Manager ge\u00e4ndert werden. Die Steuerelemente werden solange nebeneinander angeordnet, solange sie nebeneinander passen. Wenn Sie die Fensterbreite schmaler gestalten (mit der Maus zusammenschieben), schieben sich die Steuerelemente untereinander. Um aber Kontrolle \u00fcber die Anordnung der Steuerelemente zu gelangen, betrachten wir nun Layout-Manager. </p>"},{"location":"gui/#layout-manager","title":"Layout-Manager","text":"<p>Layout-Manager dienen der Anordnung von Komponenten. Es gibt viele Layout-Manager (<code>FlowLayout</code>, <code>BorderLAyout</code>, <code>CardLayout</code>, <code>OverlayLayout</code>, <code>GridLayout</code>, <code>GridBagLayout</code>, <code>BoxLayout</code>, <code>GroupLayout</code>, ...). Wir werden aber nicht alle betrachten, da dies erstens auf Dauer langweilig ist und zweitens Layout-Manager ineinander verschachtelt werden k\u00f6nnen. Vielmehr k\u00f6nnen Container ineinander verschachtelt werden und diesen Containern unterschiedliche Layout-Manager zugewiesen werden. </p> <p>Es wird also einem Container ein Layout-Manager zugewiesen und die Komponenten in diesem Container sind dann so angeordnet, wie der Layout-Manager es definiert (nebeneinander oder untereinander oder \u00fcbereinander ...). Das Zuweisen  eines Layout-Managers zu einem Container erfolgt mithilfe von</p> <pre><code>setLayout(new Layoutmanager()) // Layoutmanager durch entsprechenden Namen ersetzen\n</code></pre> <p>Wir betrachten im Folgenden drei Layout-Manager und diese gen\u00fcgen v\u00f6llig f\u00fcr alle GUIs, die wir erstellen wollen:</p> <ul> <li>FlowLayout</li> <li>GridLayout</li> <li>BorderLayout</li> </ul> <p>Alle drei LayoutManager bedinden sich im <code>java.awt</code>-Paket, also <code>java.awt.FlowLayout</code>, <code>java.awt.GridLayout</code> und <code>java.awt.BorderLayout</code>.</p>"},{"location":"gui/#flowlayout","title":"FlowLayout","text":"<p><code>FlowLayout</code> ist der Standard-Layout-Manager f\u00fcr ein <code>JPanel</code>. Das hei\u00dft, wenn wir einem <code>JPanel</code> keinen (anderen) Layout-Manager zuweisen, ist es im <code>FlowLayout</code>. <code>FlowLayout</code> ordnet die Komponenten nebeneinander in einer Zeile an (wenn sie in eine Zeile passen \u2013 ansonsten weitere Zeile).</p> <p>Das Zuweisen eines Containers zum <code>FlowLayout</code> erfolgt mittels <code>setLayout(new FlowLayout());</code>.</p> <p>F\u00fcr <code>FlowLayout</code> steht aber nicht nur der parameterlose Konstruktor zur Verf\u00fcgung, sondern auch </p> <ul> <li> <p><code>FlowLayout(int align)</code>, wobei f\u00fcr <code>align</code> folgende vordefinierte Konstanten verwendet werden k\u00f6nnen:</p> <ul> <li><code>FlowLayout.CENTER</code> ; ordnet alle Komponenten mittig an, ist der Standard-Wert</li> <li><code>FlowLayout.LEFT</code> ; ordnet alle Komponenten linksb\u00fcndig an</li> <li><code>FlowLayout.RIGHT</code> ; ordnet alle Komponenten rechtsb\u00fcndig an</li> </ul> </li> <li> <p><code>FlowLayout(int align, int hgap, int vgap)</code> , wobei <code>align</code> wie oben und </p> <ul> <li><code>hgap</code> den horizontalen Abstand zwischen den Komponenten und</li> <li><code>vgap</code> den vertikalen Abstand zwischen den Komponenten beschreibt</li> </ul> </li> </ul> <p>Beispiele:</p> <p></p> <p>Beim <code>FlowLayout</code> bleiben die Steuerelemente stets in ihrer Standardgr\u00f6\u00dfe!</p> <p>\u00dcbung</p> <p>F\u00fcgen Sie in Ihre <code>initContent()</code>-Methode 6 Buttons ein (wie in der oberen Abbildung). Lassen Sie das <code>mainPanel</code> im <code>FlowLayout</code>. Probieren Sie ruhig mal die verschiedenen <code>align</code>-Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons nicht \u00e4ndert. </p>"},{"location":"gui/#gridlayout","title":"GridLayout","text":"<p><code>GridLayout</code> ordnet Komponenten innerhalb eines rechteckigen Gitters (einem grid) an. Das Zuweisen eines Containers zum <code>GridLayout</code> erfolgt mittels <code>setLayout(new GridLayout(int rows, int columns));</code>. Dabei geben <code>rows</code> die Anzahl der Zeilen des Gitters und <code>columns</code> die Anzahl der Spalten des Gitters an. Dabei wird aber immmer zuerst versucht, ein Rechteck zur erzeugen mit der Zeilenanzahl als ma\u00dfgeblichem Wert! Das verdeutlichen die folgenden Beispiele:</p> <p></p> <p>F\u00fcr <code>GridLayout</code> gibt es noch einen weiteren parametrisierten Konstruktor, n\u00e4mlich <code>GridLayout(int rows, int columns, int hgap, int vgap)</code>, wobei <code>hgap</code> und <code>vgap</code> die gleiche Bedutung haben, wie beim <code>FlowLayout</code>.</p> <p></p> <p>Wichtig ist, dass sich die Gr\u00f6\u00dfe der Komponenten der Gr\u00f6\u00dfe des Containes anpasst, in der die Komponenten enthalten sind. das bedeutet, dass mit der Gr\u00f6\u00dfe des Containers auch die Steuerelemente gr\u00f6\u00dfer werden! Das bedeutet, dass im Gegensatz zum <code>FlowLayout</code> z.B. Buttons in diesem Layout-Manager keine feste Gr\u00f6\u00dfe haben!</p> <p>\u00dcbung</p> <p>Verwenden Sie die <code>initContent()</code>-Methode aus der <code>FlowLayout</code>-\u00dcbung (mit den 6 Buttons). Weisen Sie dem <code>mainPanel</code> das <code>GridLayout</code> zu. Probieren Sie ruhig mal verschiedene <code>rows</code>, <code>columns</code>, <code>hgap</code>, <code>vgap</code>-Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons \u00e4ndert! </p>"},{"location":"gui/#borderlayout","title":"BorderLayout","text":"<p><code>BorderLayout</code> ist der Standard-Layout-Manager f\u00fcr ein <code>JFrame</code>. <code>BorderLayout</code> ordnet Komponenten in f\u00fcnf Felder (<code>North</code>, <code>South</code>, <code>East</code>, <code>West</code>) und die Mitte (<code>Center</code>) an. <code>BorderLayout</code> besitzt</p> <ul> <li>einen parameterlosen Konstruktor <code>BoderLayout()</code> und</li> <li>einen parametrisierten Konstruktor <code>BorderLayout(int hgap, int vgap)</code> mit <code>hgap</code> und <code>vgap</code> wie zuvor.</li> </ul> <p>Um Komponenten zu einem Container im <code>BoderLayout</code> hinzuzuf\u00fcgen, gibt es nun zwei verschiedene <code>add()</code>-Methoden:</p> <ul> <li><code>add(Component comp)</code> f\u00fcgt die Komponente <code>comp</code> dem Center hinzu (entspricht <code>add(comp, BorderLayout.CENTER)</code>),</li> <li> <p><code>add(Component comp, Object constraints)</code>, wobei <code>constraints</code> eine der folgenden vordefinierten Werte annehmen kann:</p> <ul> <li><code>BorderLayout.NORTH</code>; f\u00fcgt <code>comp</code> dem oberen Feld hinzu, </li> <li><code>BorderLayout.SOUTH</code>; f\u00fcgt <code>comp</code> dem unteren Feld hinzu, </li> <li><code>BorderLayout.EAST</code>; f\u00fcgt <code>comp</code> dem linken Feld hinzu, </li> <li><code>BorderLayout.WEST</code>; f\u00fcgt <code>comp</code> dem rechten Feld hinzu, </li> <li><code>BorderLayout.CENTER</code>; f\u00fcgt <code>comp</code> der Mitte hinzu.</li> </ul> </li> </ul> <p>Angenommen, die <code>initContent()</code>-Methode sieht so aus:</p> <pre><code>    private JPanel initContent()\n{\nJPanel mainPanel = new JPanel();\nmainPanel.setLayout(new BorderLayout());\n\nmainPanel.add(new JButton(\"NORTH\"), BorderLayout.NORTH);\nmainPanel.add(new JButton(\"SOUTH\"), BorderLayout.SOUTH);\nmainPanel.add(new JButton(\"EAST\"), BorderLayout.EAST);\nmainPanel.add(new JButton(\"WEST\"), BorderLayout.WEST);\nmainPanel.add(new JButton(\"CENTER\"), BorderLayout.CENTER);\n\nreturn mainPanel;\n}\n</code></pre> <p>, dann wird folgendes Fenster erzeugt:</p> <p></p> <p>Beachten Sie:</p> <ul> <li>die Nord-, S\u00fcd-Buttons behalten ihre H\u00f6he, skalieren auf Fensterbreite</li> <li>die Ost-, West-Buttons behalten ihre Breite, skalieren auf Fensterh\u00f6he (minus H\u00f6he f\u00fcr Norden und S\u00fcden)</li> <li>der Center-Button wird eingepasst (k\u00f6nnte z.B. auch ganz verschwinden)</li> </ul> <p>\u00dcbung</p> <p>Verwenden Sie die <code>initContent()</code>-Methode von oben (mit den 5 Buttons). Lassen Sie einzelne Buttons weg. Erkl\u00e4ren Sie jeweils das Ergebnis!</p>"},{"location":"gui/#verschachteln-von-layout-managern","title":"Verschachteln von Layout-Managern","text":"<p>Eigentlich ist die \u00dcberschrift irref\u00fchrend, denn es werden nicht die Layout-Manger verschachtelt, sondern die Container, denen jeweils andere Layout-Manager zugewiesen werden k\u00f6nnen. Wir wollen das an einem Beispiel demonstrieren. Wir betrachten dazu wieder nur die <code>initContent()</code>-Methode. Alles andere bleibt in unserem \"Grundger\u00fcst\", das wir in der Klasse <code>MyFirstWindow</code> erstellt haben, gleich. </p> <ul> <li>Wir beginnen damit, dass das <code>mainPanel</code> im <code>BorderLayout</code> ist und dass diesem <code>mainPanel</code> drei weitere <code>JPanel</code> hinzugef\u00fcgt werden. </li> <li>Das erste <code>JPanel</code> hei\u00dft <code>oben</code>, ist im <code>FlowLayout</code> und wird dem Norden des <code>mainPanel</code>s hinzugef\u00fcgt. </li> <li>Das zweite <code>JPanel</code> hei\u00dft <code>mitte</code>, ist im <code>GridLayout</code> und wird dem Center des <code>mainPanel</code>s hinzugef\u00fcgt. </li> <li>Das dritte <code>JPanel</code> hei\u00dft <code>unten</code>, ist im <code>FlowLayout</code> und wird dem S\u00fcden des <code>mainPanel</code>s hinzugef\u00fcgt. </li> </ul> <pre><code>    private JPanel initContent()\n{\nJPanel mainPanel = new JPanel();\nmainPanel.setLayout(new BorderLayout());\n\nJPanel oben = new JPanel();\noben.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));\n\nJPanel mitte = new JPanel();\nmitte.setLayout(new GridLayout(3,2, 10, 10));\n\nJPanel unten = new JPanel();\nunten.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));\n\nmainPanel.add(oben, BorderLayout.NORTH);\nmainPanel.add(mitte, BorderLayout.CENTER);\nmainPanel.add(unten, BorderLayout.SOUTH);\n\nreturn mainPanel;\n}\n</code></pre> <p>Die einzelnen <code>JPanel</code> sind nicht unterscheidbar, da sie keinen Rand (<code>Border</code>) besitzen und alle einen grauen Hintergrund haben. Es sind \"nur\" Container, die uns helfen, die GUI zu strukturieren. Sichtbar sind erst die Steuerelemente, die wir nun den einzelnen <code>JPanel</code> hinzuf\u00fcgen:</p> <pre><code>    private JPanel initContent()\n{\nJPanel mainPanel = new JPanel();\nmainPanel.setLayout(new BorderLayout());\n\nJPanel oben = new JPanel();\noben.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));\noben.add(new JLabel(\"Name : \"));\noben.add(new JTextField(10));\noben.setBackground(Color.LIGHT_GRAY);\n\nJPanel mitte = new JPanel();\nmitte.setLayout(new GridLayout(3,2, 10, 10));\nmitte.add(new JButton(\"Button 1\"));\nmitte.add(new JButton(\"Button 2\"));\nmitte.add(new JButton(\"Button 3\"));\nmitte.add(new JButton(\"Button 4\"));\nmitte.add(new JButton(\"Button 5\"));\nmitte.add(new JButton(\"Button 6\"));\nmitte.setBackground(Color.GREEN);\n\nJPanel unten = new JPanel();\nunten.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));\nunten.add(new JButton(\"Abbruch\"));\nunten.add(new JButton(\"OK\"));\nunten.setBackground(Color.LIGHT_GRAY);\n\nmainPanel.add(oben, BorderLayout.NORTH);\nmainPanel.add(mitte, BorderLayout.CENTER);\nmainPanel.add(unten, BorderLayout.SOUTH);\n\nreturn mainPanel;\n}\n</code></pre> <p>Zur besseren Erkennung wurde den einzelnen <code>JPanel</code> auch noch jeweils eine Hintergrundfarbe zugeordnet (Zeilen <code>32</code>, <code>42</code> und <code>48</code>). Somit ergibt sich folgende Ansicht: </p> <p></p> <ul> <li>Das <code>JPanel oben</code> ist im <code>FlowLayout</code>. Diesem Panel werden zwei Steuerelemente hinzugef\u00fcgt: ein <code>JLabel</code> (<code>\"Name\"</code>) und ein <code>JTextField</code> der Breite 10 (Zeichen). Da das Panel im <code>FlowLayout</code> ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind zentriert angeordnet (<code>FlowLayout.CENTER</code>) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von <code>10</code> Pixeln. Dem Panel wurde die Hintergrundfarbe <code>LIGHT-GRAY</code> zugewiesen. </li> <li>Das <code>JPanel mitte</code> ist im <code>GridLayout</code> mit 3 Zeilen und 2 Spalten. Diesem Panel werden 6 <code>JButton</code> zugeordnet. Die Buttons haben einen vertikalen und horizontalen Abstand von jeweils 10 Pixeln (zwischen den Buttons ist der Abstand also 20). Beachten Sie, dass die Gr\u00f6\u00dfe der Buttons an die Fenstergr\u00f6\u00dfe angepasst sind. Mit wachsender Fenstergr\u00f6\u00dfe wachsen auch die Button-Gr\u00f6\u00dfen. Dem Panel wurde die Hintergrundfarbe <code>GREEN</code> zugewiesen. </li> <li>Das <code>JPanel unten</code> ist im <code>FlowLayout</code>. Diesem Panel werden zwei <code>JButton</code> hinzugef\u00fcgt. Das das Panel im <code>FlowLayout</code> ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind rechtsb\u00fcndig angeordnet (<code>FlowLayout.RIGHT</code>) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von jeweils <code>5</code> Pixeln. Beachten Sie, dass die Buttons in ihrer Standardgr\u00f6\u00dfe sind (und stets bleiben). Dem Panel wurde die Hintergrundfarbe <code>LIGHT-GRAY</code> zugewiesen.</li> </ul> <p>Noch ein Wort zu den Gr\u00f6\u00dfen:</p> <ul> <li>Die Gr\u00f6\u00dfe des Fensters ist mit <code>300</code>x<code>200</code> vorgegeben. </li> <li>Der \"Norden\" geht \u00fcber die gesamte Breite. Die H\u00f6he des \"Nordens\" ergibt sich aus den Standardh\u00f6hen von <code>JLabel</code> und <code>JTextField</code> plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils <code>10</code> Pixeln.  </li> <li>Der \"S\u00fcden\" geht ebenfalls \u00fcber die gesamte Breite. Die H\u00f6he des \"S\u00fcdens\" ergibt sich aus der Standardh\u00f6he von <code>JButton</code> plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils <code>5</code> Pixeln. </li> <li>Das <code>Center</code>-Feld geht ebenfalls \u00fcber die gesamte Breite, da es kein <code>EAST</code>- und kein <code>WEST</code>-Feld gibt. Die H\u00f6he des <code>Center</code>-Feldes ergibt sich aus der Fensterh\u00f6he minus der H\u00f6he f\u00fcr die Titelleiste, minus der H\u00f6he f\u00fcr den \"Norden\" und minus der H\u00f6he f\u00fcr den \"S\u00fcden\". Das <code>Center</code>-Feld f\u00fcllt also den verbleibenden Rest des Platzes im Fenster aus. </li> </ul> <p>Sie k\u00f6nnen beliebig viele Container in beliebiger Tiefe ineinanderschachteln und den Containern unterschiedliche Layout_Manager zuweisen. Damit gelingt ihnen jede denkbare Gestaltung grafischer Nutzeroberfl\u00e4chen. Weitere Anregungen zur Verwendung von Layout-Managern finden Sie z.B. hier. </p> <p>\u00dcbung</p> <p>\u00c4ndern Sie ausschlie\u00dflich die H\u00f6he des Fensters und dann einmal ausschlie\u00dflich die Breite des Fensters und begr\u00fcnden Sie das jeweilige Ergebnis!</p> <p>Success</p> <p>Wir haben unser erstes Fenster erstellt! Au\u00dferdem k\u00f6nnen wir dem Fenster Steuerelemente hinzuf\u00fcgen. Diese k\u00f6nnen wir mithilfe von Containern  und Layout-Manager positionieren, so dass wir ordentlich positionierte Grafische Nutzeroberfl\u00e4chen erstellen k\u00f6nnen. Im n\u00e4chsten Schritt schauen wir uns an, wie wir auf Ereignisse reagieren k\u00f6nnen, z.B. auf das Klicken eines Buttons. </p>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen. F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort <code>class</code>, sondern <code>interface</code> verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort <code>extends</code>, sondern das Schl\u00fcsselwort <code>implements</code> verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse beliebig viele Interfaces implementieren. </p> <p>Interfaces sind automatisch <code>abstract</code>, d.h. das Schl\u00fcsselwort <code>abstract</code> muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. </p> \u00a0Abtrakte Klasse \u00a0Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort <code>extends</code>) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort <code>implements</code>), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort <code>abstract</code> deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort <code>interface</code> deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen <code>final</code> Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten (<code>static final</code>) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen <code>private</code>, <code>protected</code>, default und <code>public</code> sein in Interfaces sind alle Eigenschaften <code>public</code> Bsp.: <code>public abstract class Shape{ public abstract void draw(); }</code> Bsp.: <code>public interface Drawable{ void draw(); }</code>"},{"location":"interfaces/#das-interface-comparable","title":"Das Interface <code>Comparable</code>","text":"<p>Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem <code>java.lang</code>-Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode <code>compareTo()</code>. Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> wird verwendet, um zu vergleichen, ob <code>this</code> gr\u00f6\u00dfer, kleiner oder gleich <code>obj</code> ist. Das bedeutet, dass wir <code>compareTo()</code> in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> gibt ein <code>int</code> zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll:</p> <ul> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert positiv (<code>&gt; 0</code>), dann ist <code>this</code> gr\u00f6\u00dfer als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert negativ (<code>&lt; 0</code>), dann ist <code>this</code> kleiner als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert <code>0</code>, dann ist <code>this</code> gleich <code>obj</code>.</li> </ul> <p>Angenommen, wir wollen f\u00fcr die folgende Klasse <code>Rectangle</code> (aus dem Abschnitt Abstrakte Klassen) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch <code>Shape</code> aus Abstrakte Klassen):</p> <pre><code>public class Rectangle extends Shape\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n}\n</code></pre> <p>Die Klasse <code>Rectangle</code> erbt also von der abstrakten Klasse <code>Shape</code> und muss deshalb die Methoden <code>perimeter()</code> und <code>area()</code> implementieren. Nun geben wir an, dass <code>Rectangle</code> auch das Interface <code>Comparable</code> implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um <code>implements Comparable</code>, d.h. die Klassendeklaration sieht jetzt so aus:</p> <pre><code>public class Rectangle extends Shape implements Comparable\n{\n</code></pre> <p>Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: <code>The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object)</code>. Es werden zwei <code>QuickFixes</code> angeboten, </p> <ul> <li>entweder <code>Add unimplemented methods</code> </li> <li>oder <code>Make type Rectangle abstract</code>. </li> </ul> <p>Letzteres wollen wir aber nicht (<code>Rectangle</code> soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir <code>Add unimplemented methods</code>. Eclipse f\u00fcgt uns die <code>compareTo()</code>-Methode in den Code ein:</p> <pre><code>public class Rectangle extends Shape implements Comparable\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n\n@Override\npublic int compareTo(Object o) {\n// TODO Auto-generated method stub\nreturn 0;\n}\n}\n</code></pre> <p>Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung:</p> <pre><code>Comparable is a raw type. References to generic type Comparable&lt;T&gt; should be parameterized\n</code></pre> <p>Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface <code>Comparable</code> typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse <code>Rectangle</code>. Wir typisieren deshalb <code>Comparable</code> mit <code>Rectangle</code>: </p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n\n@Override\npublic int compareTo(Object o) {\n// TODO Auto-generated method stub\nreturn 0;\n}\n}\n</code></pre> <p>Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler:</p> <pre><code>The type Rectangle must implement the inherited abstract method Comparable&lt;Rectangle&gt;.compareTo(Rectangle)\n</code></pre> <p>Dadurch, dass wir <code>Comparable</code> mit <code>Rectangle</code> typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode </p> <pre><code>    @Override\npublic int compareTo(Object o) {\n// TODO Auto-generated method stub\nreturn 0;\n}\n</code></pre> <p>implementieren, sondern die Methode </p> <pre><code>    @Override\npublic int compareTo(Rectangle o) {\n// TODO Auto-generated method stub\nreturn 0;\n}\n</code></pre> <p>Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei <code>equals(Object o)</code>, pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein <code>Rectangle</code> handelt. Wir \u00e4ndern also den Parametertyp in <code>compareTo()</code>:</p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n\n@Override\npublic int compareTo(Rectangle o) {\n// TODO Auto-generated method stub\nreturn 0;\n}\n}\n</code></pre> <p>In Zukunft typisieren wir das <code>Comparable</code>-Interface noch, bevor wir <code>Add unimplemented methods</code> w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. </p> <p>F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein <code>Rectangle</code>-Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da <code>compareTo()</code> ein <code>int</code> zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von <code>height</code> und <code>width</code> verwenden:</p> <pre><code>    @Override\npublic int compareTo(Rectangle o) {\nint diff = (this.height+this.width) - (o.height+o.width);\nreturn diff;\n}\n</code></pre> <p>Wenn die Summe von <code>height</code> und <code>width</code> von <code>this</code> gr\u00f6\u00dfer ist, als von <code>o</code>, dann geben wir eine positive <code>int</code>-Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative <code>int</code>-Zahl und wenn sie gleich sind, dann <code>0</code>. Damit entsprechen wir den Vorgaben von <code>compareTo()</code>. </p>"},{"location":"interfaces/#laufzeittypen-eines-rectangle-objektes","title":"Laufzeittypen eines <code>Rectangle</code>-Objektes","text":"<p>Ein <code>Rectangle</code>-Objekt ist nicht nur vom Laufzeittyp <code>Rectangle</code>, sondern auch</p> <ul> <li>von Laufzeittyp <code>Shape</code>, wegen <code>public class Rectangle extends Shape</code>, </li> <li>vom Laufzeittyp <code>Comparable</code>, wegen <code>public class Rectangle implements Comparable</code> und</li> <li>vom Laufzeittyp <code>Object</code>, weil das immer so ist, weil jede Klasse implizit von <code>Object</code> erbt. </li> </ul> <p>Wir k\u00f6nnten nun also in jeder beliebigen Klasse eine Sortiermethode haben, z.B.: </p> <pre><code>    public static void sortieren(Comparable[] unsorted)\n{   for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n{\nfor(int index=0; index&lt;unsorted.length-bubble; index++)\n{\nif(unsorted[index].compareTo(unsorted[index+1]) &gt; 0) {\nComparable tmp = unsorted[index];\nunsorted[index] = unsorted[index+1];\nunsorted[index+1] = tmp;            }\n}\n}\n}\n</code></pre> <p>Die Methode implementiert Bubble-Sort. In Zeile <code>7</code> verwenden wir die <code>compareTo()</code>-Methode. Das geht genau deshalb, weil klar ist, dass ein Objekt, das (auch) vom Typ <code>Comparable</code> ist, diese Methode auf jeden Fall als Eigenschaft besitzt. Wenn wir nun in der Klasse, in der die Methode <code>sortieren()</code> implementiert ist, folgende <code>main()</code>-Methode haben:</p> <pre><code>public static void main(String[] args) {\nRectangle[] rectArr = new Rectangle[6];\nrectArr[0] = new Rectangle(9, 13);\nrectArr[1] = new Rectangle(4, 17);\nrectArr[2] = new Rectangle(12, 5);\nrectArr[3] = new Rectangle(8, 9);\nrectArr[4] = new Rectangle(10, 11);\nrectArr[5] = new Rectangle(5, 15);\nSystem.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\nfor(Rectangle r : rectArr)\n{\nSystem.out.println(r.toString());\n}\nSystem.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\nsortieren(rectArr);\nfor(Rectangle r : rectArr)\n{\nSystem.out.println(r.toString());\n}\n}\n</code></pre> <p>dann erhalten wir folgende Ausgabe:</p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] [  4 x 17 =  68,00 ] [ 12 x  5 =  60,00 ] [  8 x  9 =  72,00 ] [ 10 x 11 = 110,00 ] [  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] [  8 x  9 =  72,00 ] [  5 x 15 =  75,00 ] [  4 x 17 =  68,00 ] [ 10 x 11 = 110,00 ] [  9 x 13 = 117,00 ] </code></pre> <p>f\u00fcr den Fall, dass wir in unserer Klasse <code>Rectangle</code> auch die <code>toString()</code>-Methode wie folgt implementiert haben:</p> <pre><code>    @Override\npublic String toString()\n{   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); return s;\n}\n</code></pre> <p>Success</p> <p>Wir haben f\u00fcr unsere Klasse <code>Rectangle</code> das Interface <code>Comparable</code> implementiert. Das bedeutet, dass wir in <code>Rectangle</code> die Methode <code>compareTo()</code> so implementiert haben, dass <code>Rectangle</code>-Objekte der Gr\u00f6\u00dfe nach sortiert werden k\u00f6nnen. Wir haben also eine Ordnung \u00fcber <code>Rectangle</code>-Objekte definiert. Nach \"au\u00dfen\" ist sichtbar, dass wir eine solche Ordnung implementiert haben, dass <code>Rectangle</code>-Objekte also sortierbar sind, weil sie (auch) vom Typ <code>Comparable</code> sind. F\u00fcr alle Objekte, die in Java existieren, wissen wir, dass sie sortierbar sind, sobald sie auch vom Typ <code>Comparable</code> sind. <code>Comparable</code> stellt also eine Schnittstelle zur Sortierbarkeit dar. Wenn wir eine eigene Klasse schreiben und wir eine Ordnung \u00fcber die Objekte dieser Klasse definieren k\u00f6nnen, sollten wir das Interface <code>Comparable</code> implementieren, denn dadurch geben wir nach \"au\u00dfen\" an, dass sich die Objekte der Klasse sortieren (ordnen) lassen.</p>"},{"location":"interfaces/#zwischenfazit","title":"Zwischenfazit","text":"<p>Wir haben nun schon mehrere Methoden kennengelernt, die wir f\u00fcr eigene Klassen implementieren sollten.</p> <ul> <li>Die <code>toString()</code>-Methode erben wir von <code>Objects</code>. Wir sollten <code>toString()</code> f\u00fcr \"unsere\" Klassen \u00fcberschreiben, damit wir eine textuelle Repr\u00e4sentation unserer Objekte haben. <code>toString()</code>wird implizit angewendet, sobald eine <code>String</code>-Repr\u00e4sentation erforderlich ist, z.B. ist <code>System.out.println(refVariable);</code>das Gleiche wie <code>System.out.println(refVariable.toString());</code>. </li> <li>Die <code>equals()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>equals()</code> f\u00fcr \"unsere\" Klassen implementieren, um zu definieren, wann Objekte \"unserer\" Klasse gleich sind. Hierbei ist wichtig, zu beachten, dass <code>refVar1 == refVar2</code> ein reiner Referenzvergleich ist, der nichts dar\u00fcber aussagt, ob die Objekte gleich  sind, sondern nur ein <code>true</code> ergibt, wenn beide Variablen auf dasselbe Objekt zeigen. Die Gleichheit von Objekten wird mittels <code>equals()</code>-Methode definiert. </li> <li>Die <code>hashCode()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>hashCode()</code>genau dann implementieren, wenn wir <code>equals()</code> implementieren. Wichtig ist, dass zwei Objekte den gleichen Hash-Code haben (<code>hashCode()</code> liefert den gleichen <code>int</code>-Wert zur\u00fcck), wenn die beiden Objekte laut <code>equals()</code> gleich sind. Gut ist dar\u00fcber hinaus (aber nicht Bedingung), dass zwei Objekte einen unterschiedlichen Hash-Code haben, wenn sie laut <code>equals()</code>-Methode nicht gleich sind (<code>equals()</code>liefert <code>false</code> zur\u00fcck). Der Hash-Code wird bei Hash-basierten Datentypen, wie z.B. Collections verwendet, um diese einzusortieren. </li> <li>Die Methode <code>compareTo()</code> muss implementiert werden, wenn wir das Interface <code>Comparable</code> implementieren. Mithilfe von <code>compareTo()</code> legen wir eine Ordnung \u00fcber die Objekte der Klasse fest, d.h. wir geben an, wann ein Objekt gr\u00f6\u00dfer/kleiner/gleich einem anderen Objekt der gleichen Klasse ist. Dadurch, dass wir das <code>Comparable</code>-Interface implementieren, zeigen wir nach \"au\u00dfen\", dass die Objekte unserer Klasse sortierbar  sind. </li> </ul>"},{"location":"interfaces/#eine-bessere-implementierung","title":"Eine bessere Implementierung","text":"<p>Wir haben bereits bei der Implementierung der Klasse <code>Rectangle</code> gesehen, dass wir das Interface <code>Comparable</code> bei der Implementierung von <code>Rectangle</code> typisieren sollten. Das w\u00e4re f\u00fcr eine wirklich korrekte Implementierung der Methode <code>sortieren()</code> ebenfalls angebracht. Dann w\u00fcrden wir in dieser Methode <code>Comparable</code> mit <code>Rectangle</code> typisieren:</p> <pre><code>    public static void sortieren(Comparable&lt;Rectangle&gt;[] unsorted)\n{   for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n{\nfor(int index=0; index&lt;unsorted.length-bubble; index++)\n{\nif(unsorted[index].compareTo((Rectangle) unsorted[index+1]) &gt; 0) {\nComparable&lt;Rectangle&gt; tmp = unsorted[index];\nunsorted[index] = unsorted[index+1];\nunsorted[index+1] = tmp;            }\n}\n}\n}\n</code></pre> <p>Wenn wir also den Typ <code>Comparable</code> verwenden, dann erg\u00e4nzen wir ihn um die Typisierung <code>&lt;Rectangle&gt;</code> (Zeilen <code>1</code> und <code>9</code>). Das f\u00fchrt allerdings dazu, dass wir dann auch in Zeile <code>7</code> den Typ von <code>unsorted[index+1]</code> nach <code>Rectangle</code> konvertieren m\u00fcssen (<code>(Rectangle) unsorted[index+1]</code>). Damit verlieren wir aber unsere allgemeine Anwendbarkeit der Methode <code>sortieren()</code> f\u00fcr alle Klassen, die <code>Comparable</code> implementiert haben. Insbesondere w\u00fcrde die Methode dann nicht mehr f\u00fcr z.B. die Klasse <code>Circle</code> anwendbar sein: </p> <pre><code>public class Circle extends Shape implements Comparable&lt;Circle&gt;\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2.0 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n@Override\npublic int compareTo(Circle o) {\nif(this.radius &gt; o.radius) return 1;\nelse if(this.radius &lt; o.radius) return -1;\nelse return 0; // this.radius == o.radius\n}\n\n\n@Override\npublic String toString()\n{   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); return s;\n}\n\n}\n</code></pre> <p>Wenn wir nun versuchen w\u00fcrden, die <code>sortieren()</code>-Methode auf ein <code>Circle[]</code> anzuwenden, lie\u00dfe sich das Programm gar nicht compilieren:</p> <pre><code>    public static void main(String[] args) {\nCircle[] circArr = new Circle[6];\ncircArr[0] = new Circle(5.0);\ncircArr[1] = new Circle(5.5);\ncircArr[2] = new Circle(4.0);\ncircArr[3] = new Circle(2.5);\ncircArr[4] = new Circle(7.0);\ncircArr[5] = new Circle(1.0);\nSystem.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\nfor(Circle c : circArr)\n{\nSystem.out.println(c.toString());\n}\nSystem.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n// sortieren(circArr);      // Fehler\nfor(Circle c : circArr)\n{\nSystem.out.println(c.toString());\n}\n}\n</code></pre> <p>Deshalb w\u00e4re es eine bessere Implementierung, wenn wir das Interface <code>Comparable</code> nicht in den konkreten Klassen <code>Rectangle</code> und <code>Circle</code> (und in jeder weiteren Klasse, die wir auf der Basis von <code>Shape</code> erstellen) implementieren, sondern gleich in der Abstrakten Klasse <code>Shape</code>:</p> <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\npublic abstract double perimeter();\npublic abstract double area();\n\n}\n</code></pre> <p>Da <code>Shape</code> eine abstrakte Klasse ist, muss die Methode <code>compareTo()</code> nicht in <code>Shape</code> implementiert werden. Diese Methode w\u00fcrde nun <code>abstract</code> an alle Klassen vererbt, die von <code>Shape</code> erben:</p> Rectangle.javaCircle.java <pre><code>public class Rectangle extends Shape\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n\n@Override\npublic int compareTo(Shape o) {\nRectangle r = (Rectangle)o;\nint diff = (this.height+this.width) - (r.height+r.width);\nreturn diff;\n}\n\n@Override\npublic String toString()\n{   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); return s;\n}\n\n}\n</code></pre> <pre><code>public class Circle extends Shape\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2.0 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n@Override\npublic int compareTo(Shape o) {\nCircle c = (Circle)o;\nif(this.radius &gt; c.radius) return 1;\nelse if(this.radius &lt; c.radius) return -1;\nelse return 0;  // this.radius == c.radius\n}\n\n@Override\npublic String toString()\n{   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); return s;\n}\n\n}\n</code></pre> <p>Beachten Sie, dass die Klassen <code>Rectangle</code> und <code>Circle</code> jetzt nur noch von <code>Shape</code> erben, aber nicht mehr das Interface <code>Comparable</code> implementieren (jeweils Zeile <code>1</code>). Es darf nicht mehrmals von einer Klasse implementiert werden und <code>Shape</code> implementiert es ja bereits. </p> <p>Da <code>Shape</code> diese Interface aber implementiert, wird die Methode <code>compareTo()</code> als abstrakte Methode an die Klassen <code>Rectangle</code> und <code>Circle</code> vererbt. Die Methode muss also von diesen Klassen implementiert werden. Nun wird sie aber mit dem Parametertyp <code>Shape</code> vererbt (Zeile <code>24</code> in <code>Rectangle.java</code> bzw. <code>23</code> in <code>Circle.java</code>). Dieser Parameter muss deshalb zun\u00e4chst innerhalb der Methode <code>compareTo()</code> konvertiert werden (Zeile <code>25</code> in <code>Circle.java</code> bzw. <code>26</code> in <code>Rectangle.java</code>). </p> <p>Die allgemeine Anwendung der Methode <code>sortieren()</code> in der Testklasse gelingt nun aber:</p> TestklasseShape.java <pre><code>public class TestklasseShape {\n\npublic static void sortieren(Comparable&lt;Shape&gt;[] unsorted)\n{   for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n{\nfor(int index=0; index&lt;unsorted.length-bubble; index++)\n{\nif(unsorted[index].compareTo((Shape) unsorted[index+1]) &gt; 0) {\nComparable&lt;Shape&gt; tmp = unsorted[index];\nunsorted[index] = unsorted[index+1];\nunsorted[index+1] = tmp;            }\n}\n}\n}\n\npublic static void main(String[] args) {\nRectangle[] rectArr = new Rectangle[6];\nrectArr[0] = new Rectangle(9, 13);\nrectArr[1] = new Rectangle(4, 17);\nrectArr[2] = new Rectangle(12, 5);\nrectArr[3] = new Rectangle(8, 9);\nrectArr[4] = new Rectangle(10, 11);\nrectArr[5] = new Rectangle(5, 15);\nSystem.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\nfor(Rectangle r : rectArr)\n{\nSystem.out.println(r.toString());\n}\nSystem.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\nsortieren(rectArr);\nfor(Rectangle r : rectArr)\n{\nSystem.out.println(r.toString());\n}\n\nCircle[] circArr = new Circle[6];\ncircArr[0] = new Circle(5.0);\ncircArr[1] = new Circle(5.5);\ncircArr[2] = new Circle(4.0);\ncircArr[3] = new Circle(2.5);\ncircArr[4] = new Circle(7.0);\ncircArr[5] = new Circle(1.0);\nSystem.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\nfor(Circle c : circArr)\n{\nSystem.out.println(c.toString());\n}\nSystem.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\nsortieren(circArr);\nfor(Circle c : circArr)\n{\nSystem.out.println(c.toString());\n}\n}\n}\n</code></pre> <p>Wir k\u00f6nnen nun alle Objekte sortieren lassen, die auf der Klasse <code>Shape</code> basieren. </p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] [  4 x 17 =  68,00 ] [ 12 x  5 =  60,00 ] [  8 x  9 =  72,00 ] [ 10 x 11 = 110,00 ] [  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] [  8 x  9 =  72,00 ] [  5 x 15 =  75,00 ] [  4 x 17 =  68,00 ] [ 10 x 11 = 110,00 ] [  9 x 13 = 117,00 ] \n\n\n------------------------ unsortiert --------------------------\n\n(radius: 5,00 -&gt; area:  78,54 ] (radius: 5,50 -&gt; area:  95,03 ] (radius: 4,00 -&gt; area:  50,27 ] (radius: 2,50 -&gt; area:  19,63 ] (radius: 7,00 -&gt; area: 153,94 ] (radius: 1,00 -&gt; area:   3,14 ] \n\n\n------------------------- sortiert ---------------------------\n\n(radius: 1,00 -&gt; area:   3,14 ] (radius: 2,50 -&gt; area:  19,63 ] (radius: 4,00 -&gt; area:  50,27 ] (radius: 5,00 -&gt; area:  78,54 ] (radius: 5,50 -&gt; area:  95,03 ] (radius: 7,00 -&gt; area: 153,94 ] </code></pre>"},{"location":"interfaces/#eine-noch-bessere-implementierung","title":"Eine noch bessere Implementierung","text":"<p>Obwohl wir nun in <code>Shape</code> das Interface <code>Comparable</code> implementieren, geben wir die Verantwortung der Implementierung der Methode <code>compareTo()</code> an die konkreten Klassen <code>Rectangle</code> und <code>Circle</code> weiter. Es stellt sich die Frage, ob sich die <code>compareTo()</code>-Methode nicht bereits in <code>Shape</code> implementieren lie\u00dfe. Die Antwort auf diese Frage sollte ja lauten, denn ansonsten sollten wir das Interface gar nicht bereits durch die abstrakte Klasse <code>Shape</code> implementieren lassen. Wir haben in <code>Shape</code> gen\u00fcgend Informationen, um die <code>compareTo()</code>-Methode zu implementieren. Wir k\u00f6nnen daf\u00fcr entweder <code>perimeter()</code> oder <code>area()</code> verwenden. Wir entscheiden uns f\u00fcr die Verwendung von <code>area()</code>:</p> Shape.java <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\npublic abstract double perimeter();\npublic abstract double area();\n\n@Override\npublic int compareTo(Shape o) {   return (this.area() - o.area());\n}\n}\n</code></pre> <p>In abstrakten Klassen m\u00fcssen nicht, im Gegensatz zu Interfaces, alle Methoden abstrakt sein. Es k\u00f6nnen auch Methoden bereits implementiert werden. Diese Methoden m\u00fcssen dann nicht mehr in den Klassen implementiert werden, die von der abstrakten Klasse erben. Die Klassen <code>Rectangle</code> und <code>Circle</code> ben\u00f6tigen also keine eigene Implementierung der <code>compareTo()</code>-Methode mehr:</p> Rectangle.javaCircle.java <pre><code>public class Rectangle extends Shape\n{\nprivate int width, height;\n\npublic Rectangle(int width, int height)\n{\nthis.width = width;\nthis.height = height;\n}\n\n@Override\npublic double perimeter() {   return (2.0 * (this.width + this.height));\n}\n\n@Override\npublic double area() {\nreturn (this.width * this.height);\n}\n\n@Override\npublic String toString()\n{   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); return s;\n}\n\n}\n</code></pre> <pre><code>public class Circle extends Shape\n{\nprivate double radius;\n\npublic Circle(double radius)\n{\nthis.radius = radius;\n}\n\n@Override\npublic double perimeter() {\nreturn Math.PI * 2.0 * this.radius;\n}\n\n@Override\npublic double area() {\nreturn Math.PI * this.radius * this.radius;\n}\n\n@Override\npublic String toString()\n{   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); return s;\n}\n\n}\n</code></pre> <p>Wir haben ausgenutzt, dass in der Klasse <code>Shape</code> bereits gen\u00fcgend Informationen vorliegen, um die Methode <code>compareTo()</code> korrekt f\u00fcr alle Klassen zu implementieren, die von <code>Shape</code> erben. Diese Methode muss dann von diesen konkreten Klassen nicht mehr implementiert werden. Wir vermeiden so doppelten Code. Die <code>testklasseShape</code> bleibt unver\u00e4ndert f\u00fcr alle abgeleiteten Klassen aus <code>Shape</code> anwendbar. </p>"},{"location":"maps/","title":"Maps","text":"<p>Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel (keys) enth\u00e4lt und die rechte Spalte die Werte (values). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine <code>Set</code>. </p> <p>Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map. F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial.</p>"},{"location":"maps/#statt-add-und-addall-hier-put-und-putall","title":"Statt <code>add()</code> und <code>addAll()</code> hier <code>put()</code> und <code>putAll()</code>","text":"<p>Da nicht das <code>Collections</code>-Interface f\u00fcr <code>Maps</code> implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer <code>Map</code> leider auch nicht \u00fcber <code>add()</code> bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber <code>addAll()</code>, sondern \u00fcber </p> <ul> <li><code>put(K key, V value)</code> und</li> <li><code>putAll(Map m)</code>.</li> </ul> <p><code>K</code> ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und <code>V</code> ein Platzhalter f\u00fcr den Typ der Werte. </p>"},{"location":"maps/#typ-einer-map-und-typ-eines-schlussel-werte-paares","title":"Typ einer <code>Map</code> und Typ eines Schl\u00fcssel-Werte-Paares","text":"<p>Eine <code>Map</code> wird also mit zwei Typen typisiert:</p> <ul> <li><code>Map&lt;K, V&gt;</code></li> </ul> <p>wobei <code>K</code> den Typ der Schl\u00fcssel und <code>V</code> den Typ der Werte definiert. </p> <p>Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist</p> <ul> <li><code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. <code>Entry</code> ist eine innere Klasse in der Klasse <code>Map</code> (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer <code>Map</code> ist <code>Map&lt;K,V&gt;</code> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser <code>Map</code> ist <code>Map.Entry&lt;K,V&gt;</code>. </p>"},{"location":"maps/#statt-iterator-hier-entryset","title":"Statt <code>iterator()</code> hier <code>entrySet()</code>","text":"<p>Die Objektmethode <code>iterator()</code> gibt es f\u00fcr <code>Map</code> leider auch nicht. Stattdessen wird hier die Methode <code>entrySet()</code> verwendet. Da es sich bei einer <code>Map</code> um eine <code>Set</code> von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ <code>Map.Entry&lt;K,V&gt;</code>) handelt, liefert <code>entrySet()</code> eine </p> <ul> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul> <p>zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine <code>Set</code>. Diese ist typisiert und zwar mit dem Typ <code>Map.Entry</code>, welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. <code>Map.Entry</code> ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel <code>K</code> und dem Typ der Werte <code>V</code>. F\u00fcr <code>K</code> und <code>V</code> werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter. </p>"},{"location":"maps/#klassenbaum-fur-map","title":"Klassenbaum f\u00fcr <code>Map</code>","text":"<p>Der Klassenbaum f\u00fcr <code>Map</code> hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr <code>Collection</code>. Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder.</p> <p></p> <p>Auch hier ist es wieder so, dass wir <code>Map</code> als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen <code>EnumMap</code>, <code>HashMap</code> und <code>TreeMap</code> verwenden. Die am h\u00e4ufigsten verwendete Klasse ist <code>HashMap</code>, da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird <code>TreeMap</code> verwendet. </p>"},{"location":"maps/#erstes-beispiel","title":"Erstes Beispiel","text":"<p>Wir betrachten ein erstes Beispiel. Wir erstellen eine <code>HashMap</code> und f\u00fcgen vier Eintr\u00e4ge hinzu:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class Maps {\n\npublic static void main(String[] args) {\nMap&lt;String,Double&gt; m = new HashMap&lt;&gt;();\nm.put(\"s0512345\", 1.7);     // neues Schluessel-Werte-Paar hinzugefuegt\nm.put(\"s0587654\", 2.3);     // neues Schluessel-Werte-Paar hinzugefuegt\nm.put(\"s0512345\", 2.7);     // Schluessel existiert bereits --&gt; Wert geaendert\nm.put(\"s0555555\", 3.0);     // neues Schluessel-Werte-Paar hinzugefuegt\n}\n}\n</code></pre> <ul> <li>In Zeile <code>8</code> wird unsere <code>Map</code> erzeugt. Die Referenzvariable auf die <code>Map</code> hei\u00dft <code>m</code>. Die Schl\u00fcssel sind vom Typ <code>String</code> und die Werte sind vom Typ <code>Double</code>. Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse <code>HashMap</code> erzeugt. </li> <li>In Zeile <code>9</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0512345\"</code>, der Wert (value) ist <code>1.7</code>. Beachten Sie, dass hier ein Auto-Boxing des <code>double</code>-Wertes <code>1.7</code> in ein <code>Double</code> stattfindet. </li> <li>In Zeile <code>10</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0587654\"</code>, der Wert (value) ist <code>2.3</code> (erneut Auto-Boxing). </li> <li>In Zeile <code>11</code> wird erneut die <code>put()</code>-Methode aufgerufen. Der Schl\u00fcssel <code>\"s0512345\"</code> existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert <code>1.7</code> wird nun <code>2.7</code>. Die <code>Map</code> enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. </li> <li>In Zeile <code>12</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0555555\"</code>, der Wert (value) ist <code>3.0</code> (erneut Auto-Boxing). </li> </ul> <p>Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung):</p> <p></p> <p>Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten:</p> <p></p> <p>Die Anwendung dieser Methoden auf unsere Map <code>m</code> zeigen die folgenden Anweisungen:</p> <pre><code>Set&lt;String&gt; keys = m.keySet();                  // Menge aller Schluessel\nCollection&lt;Double&gt; values = m.values();         // Collection aller Werte\nSet&lt;Map.Entry&lt;String, Double&gt;&gt; entries = m.entrySet();  // Menge aller Schluessel-Werte-Paare\n</code></pre> <ul> <li>die Objektmethode <code>keySet()</code> liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;K&gt;</code>,</li> <li>die Objektmethode <code>values()</code> liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist <code>Collection&lt;V&gt;</code>,</li> <li>die Objektmethode <code>entrySet()</code> liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul>"},{"location":"maps/#durch-eine-map-laufen","title":"Durch eine <code>Map</code> laufen","text":"<p>Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode <code>entrySet()</code> verwenden. F\u00fcr den R\u00fcckgabetyp <code>Map.Entry&lt;K,V&gt;</code> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung:</p> <ul> <li><code>getKey()</code> liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>K</code>,</li> <li><code>getValue()</code> liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>V</code>.</li> </ul> <p>Wir betrachten f\u00fcr unsere Map <code>m</code> ein Beispiel: </p> <p><pre><code>for(Map.Entry&lt;String, Double&gt; eintrag : m.entrySet())\n{\nSystem.out.println( eintrag.getKey() + \"\u00a0 :\u00a0 \" + eintrag.getValue());\n}\n</code></pre> - In Zeile <code>1</code> wird die Methode <code>m.entrySet()</code> aufgerufen, diese gibt eine <code>Set&lt;Map.Entry&lt;String, Double&gt;&gt;</code> zur\u00fcck. Jeder einzelne Eintrag in dieser <code>Set</code> ist also vom Typ <code>Map.Entry&lt;String,Double&gt;</code>. Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable <code>eintrag</code>. Wir nutzen hier also erneut die for-each-Schleife, um durch eine <code>Set</code> zu laufen.  - In Zeile <code>3</code> verwenden wir die Objektmethoden <code>getKey()</code> und <code>getValue()</code>, die uns von <code>Map.Entry</code> zur Verf\u00fcgung gestellt werden. <code>getKey()</code> gibt uns hier einen <code>String</code> zur\u00fcck (den Schl\u00fcssel) und <code>getValue()</code> gibt hier ein <code>Double</code> zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von <code>Double</code> nach <code>String</code> (impliziter Aufruf von <code>toString()</code> f\u00fcr <code>Double</code>). </p> <p>Es erfolgt folgende Ausgabe:</p> <pre><code>s0512345\u00a0 :\u00a0 2.7\ns0555555\u00a0 :\u00a0 3.0\ns0587654\u00a0 :\u00a0 2.3\n</code></pre> <p>Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. </p> <p>Wir probieren auch noch die Objektmethoden <code>keySet()</code> und <code>value()</code> aus, die f\u00fcr eine <code>Map</code> zur Verf\u00fcgung stehen:</p> <pre><code>for(String schluessel : m.keySet())\n{\nSystem.out.println(\"key : \" + schluessel);\n}\n</code></pre> <p>erzeugt: </p> <pre><code>key : s0512345\nkey : s0555555\nkey : s0587654\n</code></pre> <p>und </p> <pre><code>for(Double wert : m.values())\n{\nSystem.out.println(\"value : \" + wert.toString());  // toString() wuerde auch implizit aufgerufen\n}\n</code></pre> <p>erzeugt: </p> <pre><code>value : 2.7\nvalue : 3.0\nvalue : 2.3\n</code></pre> <p>\u00dcbung</p> <p>Was wird ausgegeben? <pre><code>Map&lt;String, String&gt; accounts = new HashMap&lt;&gt;();\n\naccounts.put(\"anton\", \"anton@email.de\");\naccounts.put(\"berta\", \"berta@email.de\");\naccounts.put(\"caesar\", \"caesar@email.de\");\naccounts.put(\"anton\", \"antonius@email.de\");\n\n// Iteration ueber alle Eintraege (Map.Entry) der Map\nfor(Map.Entry&lt;String, String&gt; entry : accounts.entrySet()) {\nSystem.out.println(\"Account : \" + entry.getKey() + \" E-Mail : \" + entry.getValue());\n}\n</code></pre></p>"},{"location":"maps/#zusammenfassung-maps","title":"Zusammenfassung Maps","text":"<ul> <li>Maps speichern Referenztypen als Schl\u00fcssel und Werte</li> <li>Maps werden typisiert mit <code>K</code> (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und <code>V</code> (Platzhalter f\u00fcr den Referenztyp des Wertes) </li> <li>Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt)</li> <li>der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection</li> <li>der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist <code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine <code>Map</code>. Weitere Methoden finden Sie hier.</p> Objektmethode  Beschreibung  <code>V get(K key)</code> Gibt den Wert zum Schl\u00fcssel <code>key</code> zur\u00fcck. Ist der Schl\u00fcssel <code>key</code> nicht in der <code>Map</code> enthalten, wird <code>null</code> zur\u00fcckgegeben. <code>V put(K key, V value)</code> F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel <code>key</code> und dem Wert <code>value</code> in die <code>Map</code> ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel <code>key</code> bereits existiert, wird der <code>value</code> \u00fcberschrieben. <code>void putAll(Map m) F\u00fcgt alle Element der Map <code>m</code> in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben. <code>void clear()</code> Entfernt alle Elemente aus der Map. <code>boolean containsKey(Object k)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel <code>k</code> in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt <code>k</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean containsValue(Object v)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Wert <code>v</code> in der Map gibt. Der Vergleich der Werte mit dem Objekt <code>v</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean isEmpty()</code> Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Map befinden. <code>V remove(Object key)</code> Entfernt den Eintrag mit dem Schl\u00fcssel <code>key</code> aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn <code>key</code> in der Map enthalten ist, sonst <code>null</code>). <code>int size()</code> Gibt die Anzahl der Elemente in der Map zur\u00fcck. <code>Set keySet() Gibt eine <code>Set</code> mit allen Schl\u00fcsseln der Map zur\u00fcck. <code>Collection values() Gibt eine <code>Collection</code> mit allen Werten der Map zur\u00fcck. <code>Set&gt; entrySet() Gibt eine <code>Set</code> mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als <code>Map.Entry der Map zur\u00fcck."},{"location":"mausereignisse/","title":"Mausereignisse","text":"<p>Bei den Mausereignissen unterscheiden wir zwei Arten von Ereignissen:</p> <ul> <li>Ereignisse der Maus, die einmalig von der Maus ausgel\u00f6st werden. Dazu geh\u00f6ren die Ereignisse, wenn die linke Maustaste gedr\u00fcckt wird, wenn die gedr\u00fcckte Taste losgelassen wird, wenn sich die Maus auf eine Komponente bewegt, die sich an den Mauslistener angemeldet hat oder wenn der Mauszeiger diese Komponente wieder verl\u00e4sst. </li> <li>Ereignisse der Maus, die durch Bewegung der Maus permanent ausgel\u00f6st werden. Dazu geh\u00f6rt die Mausbewegung selbst oder auch die Bewegung der Maus bei gedr\u00fcckter Taste.  </li> </ul> <p>Die erste Art von Mausereignissen k\u00f6nnen wir behandeln, indem wir</p> <ul> <li>den <code>MouseListener</code> implementieren und</li> <li>eine Komponente (z.B. ein <code>JPanel</code>) an den <code>MouseListener</code> anmelden. </li> </ul> <p>Die zweite Art von Maus(-Bewegungs-)ereignissen k\u00f6nnen wir behandeln, indem wir</p> <ul> <li>den <code>MouseMotionListener</code> implementieren und</li> <li>eine Komponente (z.B. ein <code>JPanel</code>) an den <code>MouseMotionListener</code> anmelden. </li> </ul> <p>Wir betrachten dieses Semester aber nur den <code>MouseListener</code>. </p>"},{"location":"mausereignisse/#der-mouselistener","title":"Der <code>MouseListener</code>","text":"<p>Wir betrachten ein einfaches Beispiel mit <code>JPanels</code>, die in einem <code>size x size</code>-Gitter angeordnet sind. Diese <code>JPanels</code> haben alle eine zuf\u00e4llig erzeugte Hintergrundfarbe (siehe <code>randomColor()</code>. In dieser Klasse implementieren wir zun\u00e4chst den <code>MouseListener</code>, d.h. wir f\u00fcgen in den Klassenkopf <code>implements MouseListener</code> ein und lassen durch Eclipse die zu implementierenden Methoden einf\u00fcgen:</p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.util.Random;\n\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\n\npublic class Mausereignisse extends JFrame implements MouseListener\n{\nprivate int size;\nprivate JPanel[][] panels;\nprivate JPanel panel;\n\npublic Mausereignisse(int size)\n{\nsuper();\nthis.size = size;\nthis.setTitle(\"Mausereignisse\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\nJPanel mainPanel = initContent(size);\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\n\nthis.setSize(400,400);\nthis.setVisible(true);\n}\n\nprivate Color randomColor() {\nRandom r = new Random();\nint red = r.nextInt(256);\nint blue = r.nextInt(256);\nint green = r.nextInt(256);\n\nColor c = new Color(red, blue, green);\nreturn c;\n}\n\nprivate JPanel initContent(int size)\n{\nthis.panel = new JPanel();\nthis.panel.setLayout(new GridLayout(size, size));\nthis.panel.addMouseListener(this);\n\nthis.panels = new JPanel[size][size];\nfor (int row = 0; row &lt; panels.length; row++) {\nfor (int col = 0; col &lt; panels[row].length; col++) {\nthis.panels[row][col] = new JPanel();\nthis.panels[row][col].setLayout(new BorderLayout());\nJLabel label = new JLabel(row + \" \" + col);\nlabel.setHorizontalAlignment(JLabel.CENTER);\nlabel.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nlabel.setForeground(Color.WHITE);\nthis.panels[row][col].add(label);\nthis.panels[row][col].setBackground(randomColor());\npanel.add(this.panels[row][col]);\n}\n}\nreturn this.panel;\n}\n\npublic static void main(String[] args) {\nnew Mausereignisse(4);\n}\n\n@Override\npublic void mouseClicked(MouseEvent e) {\nSystem.out.println(\"mouse clicked\");    }\n\n@Override\npublic void mousePressed(MouseEvent e) {\nSystem.out.println(\"mouse pressed\");    }\n\n@Override\npublic void mouseReleased(MouseEvent e) {\nSystem.out.println(\"mouse released\");       }\n\n@Override\npublic void mouseEntered(MouseEvent e) {\nSystem.out.println(\"mouse entered\");\n}\n\n@Override\npublic void mouseExited(MouseEvent e) {\nSystem.out.println(\"mouse exited\");\n\n}\n}\n</code></pre> <p>Wie wir sehen, sind es nun nicht mehr nur eine Methode, wie beim <code>ActionListener</code>, sondern gleich f\u00fcnf Methoden, die wir implementieren k\u00f6nnen. Unsere zun\u00e4chst einfachste Implementierung (aber zumindest am Anfang stets empfohlen!) ist die einfache Ausgabe auf die Konsole. Wir d\u00fcrfen auf keinen Fall vergessen, uns an den <code>MouseListener</code> anzumelden! In diesem Beispiel melden wir das <code>panel</code>, das eine Objektvariable ist, an den <code>MouseListener</code> an (siehe Zeile <code>49</code>). </p> <p>Wir k\u00f6nnten auch das gesamte Fenster an den <code>MouseListener</code> anmelden. Dazu w\u00fcrden wir in den Konstruktor von <code>Mausereignisse</code> ein <code>this.addMouseListener(this);</code> einf\u00fcgen. Damit w\u00fcrde <code>this</code> (also das Objekt von <code>Mausereignisse</code>, welches ja selbst ein <code>JFrame</code> ist) an den <code>MouseListener</code> angemeldet. Die Methode <code>addMouseListener()</code> erwartet ein Objekt der Implementierung von <code>MouseListener</code>. Das w\u00e4re ebenfalls <code>this</code>, da der <code>MouseListener</code> in der Klasse <code>Mausereignisse</code> implementiert ist. </p> <p>Weil jedoch sp\u00e4ter der Umgang mit den Mausereignissen etwas leichter ist, melden wir das <code>panel</code>-Objekt an den <code>MouseListener</code> an. Wir h\u00e4tten auch jedes einzelne <code>JPanel</code> anmelden k\u00f6nnen. Das zeigen wir sp\u00e4ter.</p>"},{"location":"mausereignisse/#die-methoden-des-mouselistener","title":"Die Methoden des <code>MouseListener</code>","text":"<p>Nun ist der <code>MouseListener</code> implementiert und das <code>panel</code>-Objekt ist an den <code>MouseListener</code> angemeldet. Wir k\u00f6nnen nun die einzelnen Methoden des <code>MouseListener</code> ausprobieren:</p> <ul> <li><code>mousePressed()</code> wird aufgerufen, wenn die (linke) Maustaste heruntergedr\u00fcckt wird. Dr\u00fccken Sie die Maustaste und halten Sie sie gedr\u00fcckt. In der Konsole erscheint <code>mousePressed</code>.</li> <li><code>mouseReleased()</code> wird aufgerufen, wenn die (linke) Maustaste nach dem Dr\u00fccken wieder losgelassen wird. Lassen Sie die Maustaste, nachdem auf der Konsole <code>mousePressed</code> erschienen ist, wieder los. In der Konsole erscheint <code>mouseReleased</code>.</li> <li><code>mouseClicked()</code> wird aufgerufen, wenn erst <code>mousePressed()</code> und dann <code>mouseReleased()</code> aufgerufen wurde. <code>mouseClicked()</code> beschreibt also die Kombination aus Maustaste gedr\u00fcckt und Maustaste losgelassen - einen Maus-Klick also.</li> <li><code>mouseEntered()</code> wird aufgerufen, wenn Sie den Mauszeiger auf die Komponente bewegen, die an den <code>MouseListener</code> angemeldet ist. Wenn Sie in unserem Fall also die Maus in die Zeichenfl\u00e4che <code>canvas</code> bewegen, dann wird die Methode <code>mouseEntered()</code> einmalig ausgef\u00fchrt. </li> <li><code>mouseExited()</code> wird aufgerufen, wenn Sie den Mauszeiger von der Komponente wieder wegbewegen, die an den <code>MouseListener</code> angemeldet ist. Wenn Sie in unserem Fall also die Maus von der Zeichenfl\u00e4che in die Titelleiste des Fensters oder ganz aus dem Fenster (der <code>ContentPane</code>) bewegen, dann wird die Methode <code>mouseExited()</code> einmalig ausgef\u00fchrt. </li> </ul> \u00dcbung <p>Probieren Sie intensiv aus, wann welche Methoden aufgerufen werden!  1. Schaffen Sie es, dass zwar <code>mouse pressed</code> und danach <code>mouse released</code> auf der Konsole erscheint, nicht aber <code>mouse clicked</code>? Wann ist das der Fall?  2. Erzeugen Sie folgende Ausgabereihenfolge auf der Konsole: <code>mouse pressed</code>, <code>mouse exited</code>, <code>mouse released</code>, <code>mouse entered</code>!</p>"},{"location":"mausereignisse/#objektmethoden-der-klasse-mouseevent","title":"Objektmethoden der Klasse <code>MouseEvent</code>","text":"<p>All diesen Methoden wird ein <code>MouseEvent</code> als Parameter \u00fcbergeben. Dieses Objekt besitzt einige n\u00fctzliche Objektmethoden. Die wichtigsten dabei sind sicherlich die Ausk\u00fcnfte dar\u00fcber, wo das Mausereignis ausgel\u00f6st wurde. Wir betrachten einige Objektmethoden des <code>MouseEvent</code>-Objekts am Beispiel der <code>mouseClicked(MouseEvent e)</code>-Methode. </p> <ul> <li>die Methode <code>getX()</code> gibt den <code>x</code>-Wert der Koordinate zur\u00fcck, bei dem das <code>MouseEvent</code> stattgefunden hat. Die Koordinate bezieht sich auf die Komponente, die an den <code>MouseListener</code> (bzw. <code>MouseMotionListener</code>) angemeldet ist. Das ist auch der Grund, warum wir nicht das gesamte Fenster an den <code>MouseListener</code>  (und <code>MouseMotionListener</code>) angemeldet haben. Der Punkt <code>[x=0, y=0]</code> befindet sich bei dem <code>Canvas</code>-Objekt in der linken oberen Ecke der <code>ContentPane</code>. Der Punkt mit den Koordinaten <code>[x=0, y=0]</code> beim Fenster ist der linke obere Punkt des Fensters, d.h. der linke obere Punkt der Titelleiste. </li> <li>die Methode <code>getY()</code> gibt den <code>y</code>-Wert der Koordinate zur\u00fcck, bei dem das <code>MouseEvent</code> stattgefunden hat (Koordinate der Komponente).</li> <li>die Methode <code>getPoint()</code> gibt ein <code>Point</code>-Objekt (von <code>java.awt</code>) zur\u00fcck. Ein <code>Point</code>-Objekt besitzt die sichtbaren Objektvariablen <code>x</code> und <code>y</code> f\u00fcr die Koordinaten.</li> </ul> <p>Wir probieren beide M\u00f6glichkeiten aus, die Koordinaten zu erfragen:</p> <pre><code>    @Override\npublic void mouseClicked(MouseEvent e) {\nPoint p = e.getPoint();\nint x = e.getX();\nint y = e.getY();\nSystem.out.println(\"mouseClicked bei [x=\" + p.x +\" ,y=\" + p.y + \"]\");   System.out.println(\"mouseClicked bei [x=\" + x +\" ,y=\" + y + \"]\");\n}\n</code></pre> <p>Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. </p> <pre><code>mouseClicked bei [x=388 ,y=215]\nmouseClicked bei [x=388 ,y=215]\n</code></pre> <p>Beachten Sie, dass Sie in allen Methoden, in denen das <code>MouseEvent</code> \u00fcbergeben wird, die Koordinaten des Ereignisses auslesen k\u00f6nnen. </p> <p>Weiterhin kann mithilfe des <code>MouseEvent</code>-Objektes \u00fcberpr\u00fcft werden, ob w\u00e4hrend des ausl\u00f6senden Mausereignisses eine besondere Taste auf der Tastatur gedr\u00fcckt wurde, z.B. die <code>Alt</code>-Taste (linke <code>option</code>-Taste beim Mac), die <code>AltGraph</code>-Taste (rechte <code>option</code>-Taste beim Mac), die <code>Ctrl</code>-Taste, oder die <code>Meta</code>-Taste (<code>Windows</code>-Taste bzw. <code>Apple</code>-Taste):</p> <pre><code>    @Override\npublic void mouseClicked(MouseEvent e) {\nPoint p = e.getPoint();\nint x = e.getX();\nint y = e.getY();\nSystem.out.println(\"mouseClicked bei [x=\" + p.x +\" ,y=\" + p.y + \"]\");   System.out.println(\"mouseClicked bei [x=\" + x +\" ,y=\" + y + \"]\");\n\nif(e.isAltDown()) System.out.println(\"Alt-Taste gedrueckt\");\nif(e.isAltGraphDown()) System.out.println(\"AltGraph-Taste gedrueckt\");\nif(e.isControlDown()) System.out.println(\"Ctrl-Taste gedrueckt\");\nif(e.isMetaDown()) System.out.println(\"Meta-Taste gedrueckt\");\nif(e.isShiftDown()) System.out.println(\"Shift-Taste gedrueckt\");\n}\n</code></pre> <p>Probieren Sie die Maus-Klicks bei unterschiedlich gedr\u00fcckter Taste auf der Tastatur aus!</p> <p>Mithilfe der Objektmethode <code>getClickCount()</code> l\u00e4sst sich die Anzahl die Klicks abfragen:</p> <pre><code>    @Override\npublic void mouseClicked(MouseEvent e) {\nPoint p = e.getPoint();\nint x = e.getX();\nint y = e.getY();\nSystem.out.println(\"mouseClicked bei [x=\" + p.x +\" ,y=\" + p.y + \"]\");   System.out.println(\"mouseClicked bei [x=\" + x +\" ,y=\" + y + \"]\");\n\nif(e.isAltDown()) System.out.println(\"Alt-Taste gedrueckt\");\nif(e.isAltGraphDown()) System.out.println(\"AltGraph-Taste gedrueckt\");\nif(e.isControlDown()) System.out.println(\"Ctrl-Taste gedrueckt\");\nif(e.isMetaDown()) System.out.println(\"Meta-Taste gedrueckt\");\nif(e.isShiftDown()) System.out.println(\"Shift-Taste gedrueckt\");\n\nif(e.getClickCount() == 2) System.out.println(\"Doppelklick\");\n}\n</code></pre> <p>Nochmal, weil es wichtig ist: alle diese Objektmethoden stehen allen Methoden zur Verf\u00fcgung, denen ein <code>MouseEvent</code> \u00fcbergeben wird. Wir k\u00f6nnen sie also in allen Methoden aus <code>MouseListener</code> (und <code>MouseMotionListener</code>) anwenden. </p>"},{"location":"mausereignisse/#farben-andern-mit-mausklick","title":"Farben \u00e4ndern mit Mausklick","text":"<p>Wir implementieren nun die <code>mouseClicked()</code>-Methode, um die Farbe des JPanels zu \u00e4ndern, in das wir geklickt haben. Um das <code>JPanel</code> zu ermitteln, in das wir geklickt haben, ben\u00f6tigen wir folgende Daten:</p> <ul> <li>den <code>x</code>- und den <code>y</code>-Wert der Koordinate, in die wir die Maus innerhalb des <code>panel</code>-Objektes geklickt haben,</li> <li>die Breite und die H\u00f6he jedes einzelnen JPanels,</li> <li>um die Breite und die H\u00f6he jedes einzelnen JPanels zu berechnen, ben\u00f6tigen wir die H\u00f6he und die Breite des <code>panel</code>-Objektes.</li> </ul> <pre><code>    @Override\npublic void mouseClicked(MouseEvent e) {\nint x = e.getX();\nint y = e.getY();\nint width = this.panel.getWidth();\nint height = this.panel.getHeight();\nint panelWidth = width / this.size;\nint panelHeight = height / this.size;\n\nint row = y / panelHeight;\nint col = x / panelWidth;\n\nSystem.out.println(\"mouse clicked [x=\" + x + \", y=\" + y + \"]\");\nSystem.out.println(\"width : \" + width + \", height : \" + height);\nSystem.out.println(\"row : \" + row + \" , col : \" + col);\nthis.panels[row][col].setBackground(randomColor());\n}\n</code></pre> <ul> <li>In den Zeilen <code>77</code> und <code>78</code> fragen wir die Koordinaten des Mausklicks ab.</li> <li>In den Zeilen <code>79</code> und <code>80</code> ermizteln wir die Breite und H\u00f6he des <code>panel</code>-Objektes.</li> <li>In den Zeilen <code>81</code> und <code>82</code> berechnen wir die Breite und H\u00f6he jedes einzelnen <code>JPanels</code>.</li> <li>In den Zeilen <code>84</code> und <code>85</code> berechnen wir mit den obigen Informationen den Zeilen- und Spalten-Index des angeklickten <code>JPanels</code> im <code>panels</code>-Array.</li> <li>Nach Ausgabe aller Informationen auf die Konsole (Zeilen <code>87-89</code>) wird f\u00fcr dieses angeklickte <code>JPanel</code> die Hintergrundfarbe neu gesetzt (Zeile <code>90</code>).</li> </ul>"},{"location":"mausereignisse/#jedes-jpanel-einzeln-anmelden","title":"Jedes JPanel einzeln anmelden","text":"<p>Wir haben den <code>MouseListener</code> an das <code>panel</code>-Objekt angemeldet, das alle <code>JPanels</code> enth\u00e4lt. Wir \u00e4ndern dies nun und melden stattdessen jedes einzelne <code>JPanel</code> aus dem <code>panels</code>-Array an den <code>MouseListener</code> an. Dies erledigen wir mithilfe einer anonymen Klasse, die den <code>MouseListener</code> implementiert. </p> <pre><code>import java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.util.Random;\n\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\n\npublic class Mausereignisse extends JFrame {\nprivate int size;\nprivate JPanel[][] panels;\nprivate JPanel panel;\n\npublic Mausereignisse(int size)\n{\nsuper();\nthis.size = size;\nthis.setTitle(\"Mausereignisse\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\nJPanel mainPanel = initContent(size);\n\nthis.getContentPane().add(mainPanel, BorderLayout.CENTER);\n\nthis.setSize(400,400);\nthis.setVisible(true);\n}\n\nprivate Color randomColor() {\nRandom r = new Random();\nint red = r.nextInt(256);\nint blue = r.nextInt(256);\nint green = r.nextInt(256);\n\nColor c = new Color(red, blue, green);\nreturn c;\n}\n\nprivate JPanel initContent(int size)\n{\nthis.panel = new JPanel();\nthis.panel.setLayout(new GridLayout(size, size));\n\nthis.panels = new JPanel[size][size];\nfor (int row = 0; row &lt; panels.length; row++) {\nfor (int col = 0; col &lt; panels[row].length; col++) {\nthis.panels[row][col] = new JPanel();\nthis.panels[row][col].setLayout(new BorderLayout());\nJLabel label = new JLabel(row + \" \" + col);\nlabel.setHorizontalAlignment(JLabel.CENTER);\nlabel.setFont(new Font(\"Verdana\", Font.BOLD, 24));\nlabel.setForeground(Color.WHITE);\nthis.panels[row][col].add(label);\nthis.panels[row][col].setBackground(randomColor());\nthis.panels[row][col].addMouseListener(new MouseListener() {\n\n@Override\npublic void mouseClicked(MouseEvent e) {\nSystem.out.println(\"einzelnes JPanel clicked\");\nObject src = e.getSource();\nif(src instanceof JPanel) {\nJPanel here = (JPanel)src;\nhere.setBackground(Mausereignisse.this.randomColor()); }\n\n}\n\n@Override\npublic void mousePressed(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseReleased(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseEntered(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n@Override\npublic void mouseExited(MouseEvent e) {\n// TODO Auto-generated method stub\n\n}\n\n});\npanel.add(this.panels[row][col]);\n}\n}\nreturn this.panel;\n}\n\npublic static void main(String[] args) {\nnew Mausereignisse(4);\n\n}\n}\n</code></pre> <p>Beachten Sie, dass nun nicht mehr die <code>Mausereignisse</code>-Klasse den <code>MouseListener</code> implementiert, sondern die Implementierung innerhalb der anonymen Klasse erfolgt (siehe Zeilen <code>63-100</code>). Die Anmeldung an den <code>MouseListener</code> erfolgt nun f\u00fcr jedes einzelne <code>JPanel</code> aus dem <code>panels</code>-Array. Jedes dieser <code>JPanel</code> besitzt nun also sein eigenes <code>MouseListener</code>-Objekt. </p> \u00dcbung <p>Lassen Sie sich erneut die Koordinaten der Mausklicks auf die Konsole ausgeben.  </p>"},{"location":"uebungen/","title":"\u00dcbungen","text":""},{"location":"uebungen/#ubung-1-codereview-und-static","title":"\u00dcbung 1 (Codereview und static)","text":"Was ist an diesem Code alles falsch? <pre><code>package uebungen.uebung1;\n\n/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\nprivate double celsius;\nprivate double fahrenheit;\n\npublic Konvertierung(double celsius) {       this.celsius = celsius;\nthis.fahrenheit = celsius * 1.8 + 32;       }\n\npublic Konvertierung(double fahrenheit) {       this.celsius = fahrenheit - 32 * 5/9;\nthis.fahrenheit = fahrenheit;       }\n\npublic void print()\n{\nSystem.out.println(this.celsius + \"\\u00B0C = \" + this.fahrenheit + \"\\u00B0F\");\n}\n}\n</code></pre> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 <pre><code>package uebungen.uebung1;\n\n/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\nprivate Konvertierung() {\n\n}\n\npublic static double celsiusToFahrenheit(double celsius) {\nfinal double FACTOR_CELSIUS_TO_FAHRENHEIT = 1.8;\nfinal int DIFFERENCE_CELSIUS_TO_FAHRENHEIT = 32;\n\ndouble fahrenheit = celsius * FACTOR_CELSIUS_TO_FAHRENHEIT + DIFFERENCE_CELSIUS_TO_FAHRENHEIT; return fahrenheit;\n}\n\npublic static double fahrenheitToCelsius(double fahrenheit) {\nfinal double FACTOR_FAHRENHEIT_TO_CELSIUS = 5.0/9.0;\nfinal int DIFFERENCE_FAHRENHEIT_TO_CELSIUS = 32;\n\ndouble celsius = (fahrenheit - DIFFERENCE_FAHRENHEIT_TO_CELSIUS) * FACTOR_FAHRENHEIT_TO_CELSIUS;\n\nreturn celsius;\n}\n}\n</code></pre>"},{"location":"uebungen/#ubung-2-string-und-algorithmisches-denken","title":"\u00dcbung 2 (String und algorithmisches Denken)","text":"\u00dcbung 2 <ol> <li> <p>Erstellen Sie im Paket <code>uebungen.uebung2</code> eine Java-Klasse <code>Uebung2</code> mit <code>main()</code>-Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String. \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten.</p> </li> <li> <p>Implementieren Sie eine Methode <code>static boolean isBinaryNumber(String s)</code>. Diese Methode \u00fcberpr\u00fcft, ob der <code>String s</code> einer Bin\u00e4rzahl entspricht, d.h. ob er nur <code>0</code> und <code>1</code> enth\u00e4lt. </p> </li> <li> <p>Testen Sie die Methode <code>isBinaryNumber(String s)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(isBinaryNumber(\"101101\"));   // true\nSystem.out.println(isBinaryNumber(\"0\"));        // true\nSystem.out.println(isBinaryNumber(\"101a01\"));   // false\nSystem.out.println(isBinaryNumber(\"101201\"));   // false\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>static int binaryToDecimal(String s)</code>. Diese Methode wandelt den <code>String s</code> in eine Dezimalzahl um, wenn <code>s</code> einer Bin\u00e4rzahl entspricht. Wenn <code>s</code> keiner Bin\u00e4rzahl entspricht, wird <code>-1</code> zur\u00fcckgegeben. </p> </li> <li> <p>Testen Sie die Methode <code>binaryToDecimal(String s)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(binaryToDecimal(\"101101\"));  // 45\nSystem.out.println(binaryToDecimal(\"0\"));       // 0\nSystem.out.println(binaryToDecimal(\"000001\"));  // 1\nSystem.out.println(binaryToDecimal(\"100000\"));  // 32\nSystem.out.println(binaryToDecimal(\"101a01\"));  // -1\nSystem.out.println(binaryToDecimal(\"101201\"));  // -1\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>static String toLowerCase(String input)</code>. Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an.</p> </li> <li> <p>Testen Sie die Methode <code>toLowerCase(String input)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(toLowerCase(\"abcdEFG\"));     // abcdefg\nSystem.out.println(toLowerCase(\"abcd123EFG\"));  // abcd123efg\nSystem.out.println(toLowerCase(\"ABC XYZ !%\"));  // abc xyz !%\n</code></pre></p> </li> </ol> <p>Zusatz:</p> <ol> <li> <p>Implementieren Sie eine Methode <code>static boolean isPalindrome(String input)</code>. Diese Methode pr\u00fcft, ob es sich bei <code>input</code> um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus <code>String</code> ist dabei wahrscheinlich n\u00fctzlich!</p> </li> <li> <p>Testen Sie die Methode <code>isPalindrome(String input)</code> z.B. mit den folgenden Aufrufen: <pre><code>System.out.println(isPalindrome(\"Otto\"));       // true\nSystem.out.println(isPalindrome(\"abc_CBA\"));    // true\nSystem.out.println(isPalindrome(\"abc_-CBA\"));   // false\nSystem.out.println(isPalindrome(\"-\"));          // true\nSystem.out.println(isPalindrome(\"Dreh mal am Herd\"));   // false \n</code></pre></p> </li> <li> <p>Angenommen, Sie sollen f\u00fcr einen gegebenen <code>String</code> angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: <pre><code>((()))()(())        // korrekt\n((())               // nicht korrekt\n(()))               // nicht korrekt\n())(                // nicht korrekt\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 <pre><code>package uebungen.uebung2.loesung;\n\npublic class Uebung2 {\n\npublic static boolean isBinaryNumber(String s)\n{\nfor(int index=0; index &lt; s.length(); index++)\n{\nchar c = s.charAt(index);\nif(!(c=='0' || c=='1'))\n{\nreturn false;\n}\n}\nreturn true;\n}\n\npublic static int binaryToDecimal(String s)\n{\nif(!isBinaryNumber(s)) return -1;\nint decimalNumber = 0;\nint exp = 0;\nfor(int index = s.length()-1; index &gt;= 0; index--)\n{\nchar c = s.charAt(index);\nint digit = c - '0';\nint value = digit * (int)Math.pow(2, exp);\ndecimalNumber += value;\nexp++;\n}\n\nreturn decimalNumber;\n}\n\npublic static String toLowerCase(String input)\n{\nString output = \"\";\nfinal int UPPER_TO_LOWER = 32;\n\nfor(int index=0; index &lt; input.length(); index++)\n{\nchar c = input.charAt(index);\nif(c &gt;= 'A' &amp;&amp; c&lt;= 'Z')\n{\nc = (char)(c + UPPER_TO_LOWER);\n}\noutput += c;\n}\nreturn output;\n}\n\npublic static boolean isPalindrome(String input)\n{\nString s = toLowerCase(input);\nboolean palindrome = true;\nwhile(palindrome &amp;&amp; s.length() &gt; 1)\n{\nchar c1 = s.charAt(0); char c2 = s.charAt(s.length() - 1);\nif(c1 == c2)\n{\ns = s.substring(1,s.length() - 1);\n}\nelse {\npalindrome = false;\n}\n}\nreturn palindrome;\n}\n\npublic static boolean checkBraces(String input)\n{\nint nrOpening = 0;  // man koennte auch fuer jede oeffnende ++ und\nint nrClosing = 0;  // jede schliessende -- und dann nur eine Variable\n// dann pruefen, ob nie negativ\nboolean correct = true;\nfor(int index=0; correct &amp;&amp; index &lt; input.length(); index++)\n{\nchar c = input.charAt(index);\nif(c== '(') {\nnrOpening++;\n}\nelse if(c== ')') {\nnrClosing++;\n}\n\nif(nrClosing &gt; nrOpening)   // dann waere hier &lt; 0\n{\ncorrect = false;\n}\n}\nif(nrOpening != nrClosing)      // dann waere hier == 0\n{\ncorrect = false;\n}\nreturn correct;\n}\n\npublic static void main(String[] args) {\nSystem.out.println(isBinaryNumber(\"101101\"));   // true\nSystem.out.println(isBinaryNumber(\"0\"));        // true\nSystem.out.println(isBinaryNumber(\"101a01\"));   // false\nSystem.out.println(isBinaryNumber(\"101201\"));   // false\n\nSystem.out.println(binaryToDecimal(\"101101\"));  // 45\nSystem.out.println(binaryToDecimal(\"0\"));       // 0\nSystem.out.println(binaryToDecimal(\"000001\"));  // 1\nSystem.out.println(binaryToDecimal(\"100000\"));  // 32\nSystem.out.println(binaryToDecimal(\"101a01\"));  // -1\nSystem.out.println(binaryToDecimal(\"101201\"));  // -1\n\nSystem.out.println(toLowerCase(\"abcdEFG\"));     // abcdefg\nSystem.out.println(toLowerCase(\"abcd123EFG\"));  // abcd123efg\nSystem.out.println(toLowerCase(\"ABC XYZ !%\"));  // abc xyz !%\n\nSystem.out.println(isPalindrome(\"Otto\"));       // true\nSystem.out.println(isPalindrome(\"abc_CBA\"));    // true\nSystem.out.println(isPalindrome(\"abc_-CBA\"));   // false\nSystem.out.println(isPalindrome(\"-\"));          // true\nSystem.out.println(isPalindrome(\"Dreh mal am Herd\"));   // false\n// das letzte waere okay, wenn man bei der Pruefung\n// die Leerzeichen ignorieren wuerde, waere auch moeglich\n}\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-3-exceptions","title":"\u00dcbung 3 (Exceptions)","text":"\u00dcbung 3 <ol> <li> <p>Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse <code>JOptionPane</code> und deren Division! Fangen Sie folgende Ausnahmen ab:</p> <ul> <li>Falls die Eingabe keiner Zahl entspricht.</li> <li>Falls die zweite Zahl eine 0 ist.</li> </ul> </li> <li> <p>Scenario:</p> <ul> <li>Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich:  </li> <li>falsche Eingabe - keine Zahl:   </li> <li>Fenster \u00f6ffnet sich erneut (andere Nachricht!):   </li> <li>Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich:   </li> <li>die Division Zahl1/Zahl2 schl\u00e4gt fehl (<code>ArithmeticException</code>), deshalb (andere Nachricht!):   </li> <li>Ergebnis   </li> </ul> </li> <li> <p>Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. <code>public int inputInt(int min, int max)</code>, welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich <code>[min, max]</code> liegen muss.</p> </li> <li> <p>Lesen Sie eine Zahl ein und geben Sie die Zahl umgedreht (r\u00fcckw\u00e4rts gelesen) wieder aus (f\u00fchrende Nullen entfallen):     <pre><code>3456789 --&gt; 9876543\n</code></pre></p> <pre><code>1000 --&gt; 1\n</code></pre> </li> <li> <p>Lesen Sie eine Zahl ein und geben Sie die Quersumme der Zahl aus.</p> <pre><code>123456 --&gt; 21\n</code></pre> <pre><code>1000 --&gt; 1      </code></pre> </li> </ol> <p>Viel Spa\u00df!</p> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 <pre><code>package uebungen.uebung3.loesung;\n\nimport javax.swing.JOptionPane;\n\npublic class Uebung3 {\npublic static int inputInt(String message)\n{\nint number = 0;\nboolean notANumber = true;\nwhile(notANumber)\n{\nString input = JOptionPane.showInputDialog(message);\n\ntry {\nnumber = Integer.parseInt(input);\nnotANumber = false;\n} catch (NumberFormatException e) {\nmessage = \"Ihre Eingabe war keine Zahl!\";\n}\n}\nreturn number;\n}\n\npublic static int inputInt(String message, int min, int max)\n{\nint number = 0;\nboolean notANumber = true;\nwhile(notANumber)\n{\nString input = JOptionPane.showInputDialog(message);\n\ntry {\nnumber = Integer.parseInt(input);\nif(number &gt;= min &amp;&amp; number &lt;= max)\n{\nnotANumber = false;\n}\nelse\n{\nmessage = \"Zahl nicht zwischen \" + min + \" und \" + max +\" !\";\n}\n} catch (NumberFormatException e) {\nmessage = \"Ihre Eingabe war keine Zahl!\";\n}\n}\nreturn number;\n}\n\npublic static void printDivide()\n{\nint number1 = inputInt(\"Zahl 1:\");\nint number2 = 0;\ndouble result = 0.0;\n\nboolean isZero = true;\nString message = \"Zahl 2:\";\n\nwhile(isZero)\n{\nnumber2 = inputInt(message);\n\ntry {\nresult = number1 / number2;\nisZero = false;\n} catch (ArithmeticException e) {\nmessage = \"Zahl darf nicht 0 sein\";\n}\n}\nString output = number1 + \" / \" + number2 + \" = \" + result;\n\nJOptionPane.showMessageDialog(null, output);\n}\n\npublic static void printReverse()\n{\nint number = inputInt(\"Zahl : \");\nint copyNumber = number;        // fuer spaetere Ausgabe\nint reverse = 0;\n\nwhile(number != 0)\n{\nint last = number % 10; reverse = reverse * 10 + last;\nnumber = number / 10;   }\n\nString output = copyNumber + \" --&gt; \" + reverse;\nJOptionPane.showMessageDialog(null, output); }\n\n\npublic static void printChecksum()\n{\nint number = inputInt(\"Zahl : \");\nint copyNumber = number;        // fuer spaetere Ausgabe\nint checksum = 0;\n\nwhile(number != 0)\n{\nint last = number % 10; checksum = checksum + last;\nnumber = number / 10;   }\n\nString output = \"Die Quersumme von \" + copyNumber + \" ist \" + checksum;\nJOptionPane.showMessageDialog(null, output); }\n\npublic static void main(String[] args) {\n\nint number1 = inputInt(\"Geben Sie eine Zahl ein :\");\nSystem.out.println(number1);\n\nint choice = JOptionPane.showConfirmDialog(null, \"Wollen Sie weiterspielen?\",\n\"Abfrage\", JOptionPane.YES_NO_OPTION); System.out.println(choice);\n\nif(choice == JOptionPane.YES_OPTION) { System.out.println(\"yes geklickt\"); }\nif(choice == JOptionPane.NO_OPTION) { System.out.println(\"no geklickt\"); }\nif(choice == JOptionPane.CANCEL_OPTION) { System.out.println(\"no geklickt\");\n}\n\nprintDivide();\n\nprintReverse();\n\nprintChecksum();\n\n}\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-4-listen-und-mengen","title":"\u00dcbung 4 (Listen und Mengen)","text":"\u00dcbung 4 <ol> <li>Erstellen Sie eine Klasse <code>Uebung4</code> mit <code>main()</code>-Methode.</li> <li>Definieren Sie in der <code>main()</code>-Methode eine Variable <code>words</code> vom Typ <code>String[]</code> und weisen Sie dieser Variablen folgende Werte zu:     <pre><code>String[] words = {\"Linux\", \"Apple\", \"Facebook\", \"Amazon\", \"IBM\", \"Lenovo\", \"Google\", \"IBM\", \"Microsoft\", \"Apple\", \"Google\", \"Twitter\", \"Skype\", \"Chrome\", \"Linux\", \"Firefox\"};\n</code></pre></li> </ol> <p>A. Listen (<code>List</code>)</p> <ol> <li>Erstellen Sie eine Methode <code>public static List&lt;String&gt; createArrayList(String[] words)</code>. In dieser Methode soll eine <code>ArrayList</code> erstellt werden. Alle Elemente in dieser Liste sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Liste (<code>List</code>) zur\u00fcck. </li> <li>Erstellen Sie eine Methode <code>public static void printList(List&lt;String&gt; list)</code>. Diese Methode gibt alle Elemente der Liste <code>list</code> auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createArrayList(words)</code> eine Liste und speichern Sie diese Liste in einer Variablen vom Typ <code>List&lt;String&gt;</code>. Geben Sie alle Elemente dieser Liste mithilfe der Methode <code>printList()</code> auf der Konsole aus. </li> <li> <p>Studieren Sie alle Methoden f\u00fcr <code>List</code> unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html.</p> <ul> <li> <p>Ermitteln Sie den Index in der Liste, in der <code>\"Apple\"</code> das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe:      <pre><code>Index des ersten Auftretens von Apple  : 1\n</code></pre></p> </li> <li> <p>Ermitteln Sie den Index in der Liste, in der <code>\"Apple\"</code> das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe:      <pre><code>Index des letzten Auftretens von Apple : 9\n</code></pre></p> </li> <li> <p>Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe:      <pre><code>erstes Element der Liste : Linux\n</code></pre></p> </li> <li> <p>Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe:      <pre><code>letztes Element der Liste : Firefox\n</code></pre></p> </li> <li> <p>L\u00f6schen Sie die Werte <code>\"Apple\"</code>, <code>\"Google\"</code> und <code>\"Facebook\"</code>. Geben Sie die Liste erneut mithilfe der <code>printList(list)</code>-Methode aus.</p> </li> </ul> </li> </ol> <p>B. Mengen (<code>Set</code>)</p> <ol> <li>Erstellen Sie eine Methode <code>public static Set&lt;String&gt; createHashSet(String[] words)</code>. In dieser Methode soll eine <code>HashSet</code> erstellt werden. Alle Elemente in dieser Liste sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Menge (<code>Set</code>) zur\u00fcck. </li> <li>Erstellen Sie eine Methode <code>public static void printSet(Set&lt;String&gt; set)</code>. Diese Methode gibt alle Elemente der Menge <code>set</code> auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createHashSet(words)</code> eine Menge und speichern Sie diese Menge in einer Variablen vom Typ <code>Set&lt;String&gt;</code>. Geben Sie alle Elemente dieser Menge mithilfe der Methode <code>printSet()</code> auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so?</li> <li>Erstellen Sie eine Methode <code>public static Set&lt;String&gt; createTreeSet(String[] words)</code>. In dieser Methode soll eine <code>TreeSet</code> erstellt werden. Alle Elemente in dieser Liste sind vom Typ <code>String</code>. Bef\u00fcllen Sie diese Menge (<code>Set</code>) mit allen W\u00f6rtern aus dem <code>words</code>-Array. Die Methode gibt die bef\u00fcllte Menge (<code>Set</code>) zur\u00fcck. </li> <li>Erstellen Sie in der <code>main()</code>-Methode mithilfe der Methode <code>createTreeSet(words)</code> eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode <code>printSet()</code> auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur <code>HashSet</code>?</li> </ol> <p>Zusatz</p> <ol> <li>Erstellen Sie f\u00fcr die Liste eine Methode <code>public static List&lt;String&gt; findDoublets(List&lt;String&gt; list)</code>. Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in <code>list</code> doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der <code>printList()</code>-Methode in der <code>main()</code>-Methode aus.</li> </ol> M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) <pre><code>Liste mit 16 Elementen :\n--------------------------\nLinux\nApple\nFacebook\nAmazon\nIBM\nLenovo\nGoogle\nIBM\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nLinux\nFirefox\nIndex des ersten Auftretens von Apple  : 1\nIndex des letzten Auftretens von Apple : 9\nerstes Element in der Liste  : Linux\nletztes Element in der Liste : Firefox\n\nListe mit 13 Elementen :\n--------------------------\nLinux\nAmazon\nIBM\nLenovo\nIBM\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nLinux\nFirefox\n\nDoublets-\nListe mit 4 Elementen :\n--------------------------\nLinux\nIBM\nIBM\nLinux\n\nohne Doublets-\nListe mit 9 Elementen :\n--------------------------\nAmazon\nLenovo\nMicrosoft\nApple\nGoogle\nTwitter\nSkype\nChrome\nFirefox\n\nMenge mit 12 Elementen :\n--------------------------\nLenovo\nGoogle\nApple\nSkype\nLinux\nIBM\nTwitter\nChrome\nMicrosoft\nAmazon\nFacebook\nFirefox\n\nMenge mit 12 Elementen :\n--------------------------\nAmazon\nApple\nChrome\nFacebook\nFirefox\nGoogle\nIBM\nLenovo\nLinux\nMicrosoft\nSkype\nTwitter\n</code></pre> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 Uebung4.java <pre><code>package uebungen.uebung4.loesung;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Uebung4 {\n\n//A1. Erstellen Sie eine Methode public static List&lt;String&gt; createArrayList(String[] words). \n//In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String. \n//Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. Die Methode gibt die bef\u00fcllte Liste (List) zur\u00fcck.\npublic static List&lt;String&gt; createArrayList(String[] words){\n// neue ArrayList mit String als Type anlegen\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n// jedes Element aus words in die Liste einf\u00fcgen\nfor(int i=0; i&lt;words.length; i++) {\nlist.add(words[i]);\n}\n\nreturn list;        }\n\n\n//A2. Erstellen Sie eine Methode public static void printList(List&lt;String&gt; list). \n//Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. \n//Geben Sie auch die Anzahl der Elemente der Liste aus.\npublic static void printList(List&lt;String&gt; list)\n{\n//Variante 1: Iterator\nSystem.out.println(\"--Iterator--\");                 Iterator&lt;String&gt; it = list.iterator();\nwhile(it.hasNext()) {\nSystem.out.println(it.next());\n}\n\n\n//Variante 2: for-Schleife\nSystem.out.println(\"--Schleife--\");\nfor(String s : list)\n{\nSystem.out.println(s);\n}\n\n//Anzahl der Elemente ausgeben\nSystem.out.println(\"Die Liste hat \"+ list.size() + \" Elemente.\");\n}\n\n//B1. Erstellen Sie eine Methode public static Set&lt;String&gt; createHashSet(String[] words). \n//In dieser Methode soll eine HashSet erstellt werden. \n//Alle Elemente in dieser Liste sind vom Typ String. \n//Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. \n//Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck.\npublic static Set&lt;String&gt; createHashSet(String[] words)\n{\nSet&lt;String&gt; set = new HashSet&lt;&gt;();      for(int i=0; i&lt;words.length; i++) {\nset.add(words[i]);\n}\nreturn set; }\n\n//B2. Erstellen Sie eine Methode public static void printSet(Set&lt;String&gt; set). \n//Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. \n//Geben Sie auch die Anzahl der Elemente der Menge aus. \npublic static void printSet(Set&lt;String&gt; set)\n{\nfor(String s : set)\n{\nSystem.out.println(s);\n}\n\nSystem.out.println(\"Das Set hat \"+ set.size() + \" Elemente.\");\n}\n\n//B4. Erstellen Sie eine Methode public static Set&lt;String&gt; createTreeSet(String[] words). \n//In dieser Methode soll eine TreeSet erstellt werden. \n//Alle Elemente in dieser Liste sind vom Typ String. \n//Bef\u00fcllen Sie diese Menge (Set) mit allen W\u00f6rtern aus dem words-Array. \n//Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. \npublic static Set&lt;String&gt; createTreeSet(String[] words)\n{       Set&lt;String&gt; set = new TreeSet&lt;&gt;();\nfor(int i=0; i&lt;words.length; i++) {\nset.add(words[i]);\n}\nreturn set; }\n\n//Zusatz: Erstellen Sie f\u00fcr die Liste eine Methode public static List&lt;String&gt; findDoublets(List&lt;String&gt; list). \n//Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. \n//Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. \n//Geben Sie diese Liste mithilfe der printList()-Methode in der main()-Methode aus.\npublic static List&lt;String&gt; findDoublets(List&lt;String&gt; list)\n{\n//Grundidee \n//Beispiel-Liste: \"a\" \"b\" \"a\" \"c\" \"a\"\n\n//Index:  0 1 2 3 4\n//Inhalt: a b a c a\n\n//erster Index von \"a\": 0\n//letzter Index von \"a\":4 \n//0 != 4 -&gt; es gibt Duplikate \n//erster Index von \"b\":1\n//letzter Index von \"b\":1\n//1 == 1 -&gt; keine Duplikate, also diesen Eintrag als Einzeleintrag merken\n//...\n\n//leere Liste \"singles\" f\u00fcr Einzeleintr\u00e4ge anlegen\nList&lt;String&gt; singles = new ArrayList&lt;&gt;();\n\n//durch list iterieren und testen ob das Element Duplikate hat, \n//wenn nicht in \"singles\" speichern \nIterator&lt;String&gt; it = list.iterator();\n//it = copy.iterator();\nwhile(it.hasNext()) {\nString s = it.next();\nif(list.indexOf(s) == list.lastIndexOf(s)) singles.add(s);\n}\n\n//Kopie von list anlegen\nList&lt;String&gt; copy = new ArrayList&lt;&gt;();\nit = list.iterator();\nwhile(it.hasNext()) copy.add(it.next());\n\n//alle singles aus der kopierten Liste entfernen\ncopy.removeAll(singles);\nreturn copy;\n//um zu testen, warum die Kopie n\u00f6tig ist:\n//copy.removeAll(singles); und return copy; ersetzen durch\n//list.removeAll(singles); \n//return list;\n//und dann die Ausgabe von l2 in der main anschauen\n\n}\n\npublic static void main(String[] args) {\nString[] words = {\"Linux\", \"Apple\", \"Facebook\", \"Amazon\", \"IBM\", \"Lenovo\", \"Google\", \"IBM\", \"Microsoft\", \"Apple\", \"Google\", \"Twitter\", \"Skype\", \"Chrome\", \"Linux\", \"Firefox\"};\n\nSystem.out.println(\"---------- A ----------\");\n//A3. Erstellen Sie in der main()-Methode mithilfe der Methode createArrayList(words) eine \n//Liste und speichern Sie diese Liste in einer Variablen vom Typ List&lt;String&gt;. \nList&lt;String&gt; l1 = createArrayList(words);       //Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. \nprintList(l1);\n\n//A4. Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. \n//Erzeugen Sie folgende Ausgabe:  Index des ersten Auftretens von Apple  : 1\nSystem.out.println(\"Index des ersten Auftretens von Apple: \" + l1.indexOf(\"Apple\"));\n\n//Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. \n//Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9\nSystem.out.println(\"Index des letzten Auftretens von Apple: \" + l1.lastIndexOf(\"Apple\"));\n\n//Geben Sie den Wert des ersten Elementes der Liste aus. \n//Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux\nSystem.out.println(\"erstes Element der Liste: \" + l1.get(0));\n\n//Geben Sie den Wert des letzten Elementes der Liste aus. \n//Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox\nSystem.out.println(\"letztes Element der Liste: \" + l1.get(l1.size()-1));\n\n//L\u00f6schen Sie die Werte \"Apple\", \"Google\" und \"Facebook\". \n//Geben Sie die Liste erneut mithilfe der printList(list)-Methode aus.\n//1. M\u00f6glichkeit: nur 1. Vorkommen l\u00f6schen\nl1.remove(\"Apple\");\nl1.remove(\"Google\");\nl1.remove(\"Facebook\");\nprintList(l1);\n//2. M\u00f6glichkeit: alle l\u00f6schen\nwhile(l1.remove(\"Apple\"));\nwhile(l1.remove(\"Google\"));\nwhile(l1.remove(\"Facebook\"));\nprintList(l1);\n\nSystem.out.println(\"---------- B ----------\");\nSystem.out.println(\"-------HashSet------\");\n//B3. Erstellen Sie in der main()-Methode mithilfe der Methode createHashSet(words) \n//eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set&lt;String&gt;. \nSet&lt;String&gt; h1 = createHashSet(words);\n//Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. \n//Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente \n//in der Liste? Warum ist das so?\nprintSet(h1);\n\nSystem.out.println(\"-------TreeSet------\");\n//B5. Erstellen Sie in der main()-Methode mithilfe der Methode createTreeSet(words) \n//eine Menge und speichern Sie diese Menge in einer Variablen. \nSet&lt;String&gt; t1 = createTreeSet(words);\n//Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. \n//Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet? \nprintSet(t1);\n\nSystem.out.println(\"-------Duplicates------\");\nList&lt;String&gt; l2 =  createArrayList(words);  List&lt;String&gt; d = findDoublets(l2);\nprintList(d);   printList(l2);\n}\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-5-maps","title":"\u00dcbung 5 (Maps)","text":"\u00dcbung 5 <ol> <li> <p>Erstellen Sie eine Klasse <code>Stadt</code> mit folgenden Objektvariablen:</p> <ul> <li><code>String name;</code></li> <li><code>List&lt;Integer&gt; bevoelkerung;</code></li> <li><code>float flaeche;</code></li> </ul> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Stadt</code> einen parametrisierten Konstruktor <code>public Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)</code>, der die Objektvariablen initialisiert.</p> </li> <li>Erstellen Sie f\u00fcr die Klasse <code>Stadt</code> eine <code>print()</code>-Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.):     <pre><code>Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre></li> <li>Erstellen Sie eine Klasse <code>StadtTest</code> mit <code>main()</code>-Methode. Kopieren Sie in die Klasse die Methode <code>public static Stadt[] staedte()</code> hinein:     <pre><code>public static Stadt[] staedte()\n{\nStadt[] staedte = new Stadt[6];\nList&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nList&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\nhamburgBevoelkerung.add(1715392);   hamburgBevoelkerung.add(1786448);   hamburgBevoelkerung.add(1810438);   staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\nList&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\nmuenchenBevoelkerung.add(1210223);  muenchenBevoelkerung.add(1353186);  muenchenBevoelkerung.add(1464301);\nstaedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\nList&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\nkoelnBevoelkerung.add(962884);  koelnBevoelkerung.add(1007119); koelnBevoelkerung.add(1075935); staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\nList&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\nfrankfurtBevoelkerung.add(648550);  frankfurtBevoelkerung.add(679664);  frankfurtBevoelkerung.add(736414);\nstaedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\nberlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nreturn staedte;\n}       </code></pre></li> </ol> <p>Liste</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>List&lt;Stadt&gt; staedteListe = new ArrayList&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteListe</code> alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array zu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus.</li> </ol> <p>Menge</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>Set&lt;Stadt&gt; staedteMenge = new HashSet&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteMenge</code> alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array zu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Menge unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus.</li> <li>Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum?</li> </ol> <p>Stadt - Teil 2</p> <ol> <li>Implementieren Sie in der Klasse <code>Stadt</code> die <code>equals(Object)</code>- und die <code>hashCode()</code>-Methode.</li> <li>F\u00fchren Sie danach die <code>StadtTest</code>-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert?</li> </ol> <p>Maps</p> <ol> <li>Erstellen Sie in der <code>main()</code>-Methode eine <code>Map&lt;Integer, Stadt&gt; staedteMap = new HashMap&lt;&gt;();</code>. F\u00fcgen Sie der <code>staedteMap</code> einen fortlaufenden, eindeutigen <code>Integer</code>-Wert beginnend mit <code>1</code> als Key sowie alle alle St\u00e4dte aus dem durch Aufruf der <code>staedte()</code>-Methode erzeugtem Array als Value hinzu.</li> <li>Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der <code>print()</code>-Methode aus der Klasse <code>Stadt</code> aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys.</li> </ol> <p>Ausgaben</p> <pre><code>------------ Liste --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\n\n------------ Menge --------------\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n\n------------ Maps --------------\n1  Berlin            891,68 km2    3.382.169   3.460.725   3.574.830\n2  Hamburg           755,22 km2    1.715.392   1.786.448   1.810.438\n3  Muenchen          310,70 km2    1.210.223   1.353.186   1.464.301\n4  Koeln             405,02 km2      962.884   1.007.119   1.075.935\n5  Frankfurt/Main    248,31 km2      648.550     679.664     736.414\n6  Berlin            891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 Stadt.javaStadtTest.java <pre><code>package uebungen.uebung5;\n\nimport java.util.List;\n\npublic class Stadt {\n\nString name;\nList&lt;Integer&gt; bevoelkerung;\nfloat flaeche;\n\npublic Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche) {\nthis.name = name;\nthis.bevoelkerung = bevoelkerung;\nthis.flaeche = flaeche;\n}\n\npublic void print()\n{\nSystem.out.printf(\"%-18s %.2f km%c\", this.name, this.flaeche, '\\u00B2');\nfor(Integer anzahl : this.bevoelkerung)\n{\nSystem.out.printf(\"%,14d\", anzahl);\n}\nSystem.out.println();\n}\n\n@Override\npublic boolean equals(Object o)\n{\nif(o == null) return false;\nif(this == o) return true;\nif(this.getClass() != o.getClass()) return false;\n\nStadt other = (Stadt)o; // Compilertyp Object hat keine Objektvariable name\n// Compilertyp Stadt hat name\n// o und other zeigen auf dasselbe Objekt\nreturn (this.name.equals(other.name));\n}\n\n@Override\npublic int hashCode()\n{\nreturn this.name.hashCode();\n}\n\n}\n</code></pre> <pre><code>package uebungen.uebung5;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class StadtTest {\n\npublic static Stadt[] staedte()\n{\nStadt[] staedte = new Stadt[6];\nList&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nList&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\nhamburgBevoelkerung.add(1715392);   hamburgBevoelkerung.add(1786448);   hamburgBevoelkerung.add(1810438);   staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\nList&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\nmuenchenBevoelkerung.add(1210223);  muenchenBevoelkerung.add(1353186);  muenchenBevoelkerung.add(1464301);\nstaedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\nList&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\nkoelnBevoelkerung.add(962884);  koelnBevoelkerung.add(1007119); koelnBevoelkerung.add(1075935); staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\nList&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\nfrankfurtBevoelkerung.add(648550);  frankfurtBevoelkerung.add(679664);  frankfurtBevoelkerung.add(736414);\nstaedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\nberlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nreturn staedte;\n}       public static void main(String[] args) {\nSystem.out.printf(\"%n%n------------- Array ----------------%n%n\");\nStadt[] staedteArray = staedte();\nfor(Stadt stadt : staedteArray)\n{\nstadt.print();\n}\n\nSystem.out.printf(\"%n%n------------- Liste ----------------%n%n\");\nList&lt;Stadt&gt; staedteListe = new ArrayList&lt;&gt;();\n// Liste befuellen\nfor(Stadt stadt : staedteArray)\n{\nstaedteListe.add(stadt);\n}\n// Liste ausgeben\nfor(Stadt stadt : staedteListe)\n{\nstadt.print();\n}\n\nSystem.out.printf(\"%n%n------------- Menge ----------------%n%n\");\nSet&lt;Stadt&gt; staedteMenge = new HashSet&lt;&gt;();\n// Menge befuellen\nfor(Stadt stadt : staedteArray)\n{\nstaedteMenge.add(stadt);\n}\n// Menge ausgeben\nfor(Stadt stadt : staedteMenge)\n{\nstadt.print();\n}\n\nSystem.out.printf(\"%n%n------------- Maps ----------------%n%n\");\nMap&lt;Integer, Stadt&gt; staedteMap = new HashMap&lt;&gt;();\nInteger i = 1;\n// Map befuellen\nfor(Stadt stadt : staedteArray)\n{\nstaedteMap.put(i, stadt);\ni++;\n}\n\nSystem.out.printf(\"%n%n------------- alle Eintraege ----------------%n%n\");\n// Map ausgeben\nSet&lt;Map.Entry&lt;Integer, Stadt&gt;&gt; alleEintraege = staedteMap.entrySet();\nfor(Map.Entry&lt;Integer, Stadt&gt; eintrag : alleEintraege)\n{\nSystem.out.printf(\"%-3d\", eintrag.getKey());\nStadt stadt = eintrag.getValue();\nstadt.print();\n}\n\nSystem.out.printf(\"%n%n------------- alle Werte ----------------%n%n\");\n// alle Werte ausgeben\nCollection&lt;Stadt&gt; alleWerte = staedteMap.values();\nfor(Stadt stadt : alleWerte)\n{\nstadt.print();\n}\n\nSystem.out.printf(\"%n%n------------- alle Schluessel ----------------%n%n\");\n// alle Schluessel ausgeben\nSet&lt;Integer&gt; alleSchluessel = staedteMap.keySet();\nfor(Integer schluessel : alleSchluessel)\n{\nSystem.out.println(schluessel);\nStadt stadt = staedteMap.get(schluessel);\n}\n}\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-6-interfaces","title":"\u00dcbung 6 (Interfaces)","text":"\u00dcbung 6 <ol> <li> <p>Wir besch\u00e4ftigen uns nochmal mit der \u00dcbung 5, d.h. mit <code>Stadt</code> und <code>StadtTest</code>. Dieses Mal geht es uns aber mehr um die Verwendung des Interfaces <code>Comparable</code>. Zun\u00e4chst sind die beiden Klassen <code>Stadt</code> und <code>StadtTest</code> wie folgt gegeben (das haben wir so in \u00dcbung 5 erarbeitet - es gibt eine \u00c4nderung in <code>StadtTest</code>, dort benutzen wir jetzt ): </p> Stadt.java <pre><code>import java.util.*;\n\npublic class Stadt\n{\nString name;\nList&lt;Integer&gt; bevoelkerung;\nfloat flaeche;\n\npublic Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)\n{\nsuper();\nthis.name = name;\nthis.bevoelkerung = bevoelkerung;\nthis.flaeche = flaeche;\n}\n\nvoid print()\n{\nSystem.out.printf(\"%-18s %.2f km%c\", this.name, this.flaeche, '\\u00B2');\nfor(Integer anzahl : this.bevoelkerung)\n{\nSystem.out.printf(\"%,14d\", anzahl);\n}\nSystem.out.println();\n}\n\n@Override\npublic boolean equals(Object o)\n{\nif(o==null) return false;\nif(o==this) return true;\nif(this.getClass()!=o.getClass()) return false;\n\nStadt other = (Stadt)o;\nreturn (this.name.equals(other.name));\n}\n\n@Override\npublic int hashCode()\n{\nreturn this.name.hashCode();\n}\n\n}\n</code></pre> StadtTest.java <pre><code>import java.util.*;\n\npublic class StadtTest\n{\npublic static Stadt[] staedte()\n{\nStadt[] staedte = new Stadt[6];\nList&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nList&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\nhamburgBevoelkerung.add(1715392);   hamburgBevoelkerung.add(1786448);   hamburgBevoelkerung.add(1810438);   staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\nList&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\nmuenchenBevoelkerung.add(1210223);  muenchenBevoelkerung.add(1353186);  muenchenBevoelkerung.add(1464301);\nstaedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\nList&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\nkoelnBevoelkerung.add(962884);  koelnBevoelkerung.add(1007119); koelnBevoelkerung.add(1075935); staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\nList&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\nfrankfurtBevoelkerung.add(648550);  frankfurtBevoelkerung.add(679664);  frankfurtBevoelkerung.add(736414);\nstaedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\nberlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nreturn staedte;\n}\n\npublic static void main(String[] args)\n{\nSystem.out.printf(\"%n------------ Menge --------------%n\");\nSet&lt;Stadt&gt; staedteMenge = new HashSet&lt;&gt;();\nfor(Stadt s : staedte())\n{\nstaedteMenge.add(s);\n}\nfor(Stadt s : staedteMenge)\n{\ns.print();\n}\n\nSystem.out.printf(\"%n------------ Maps --------------%n\");\nMap&lt;MyInteger, Stadt&gt; staedteMap = new HashMap&lt;&gt;();\nint i = 1;\nfor(Stadt s : staedte())\n{\nstaedteMap.put(new MyInteger(i++), s);\n}\nfor(Map.Entry&lt;MyInteger, Stadt&gt; entry : staedteMap.entrySet())\n{\nMyInteger key = entry.getKey();\nSystem.out.printf(\"%-3d\",key.intValue());\nentry.getValue().print();\n}\n}\n}\n</code></pre> </li> <li> <p>F\u00fcr die Schl\u00fcssel in der <code>Map</code> benutzen wir die selbstgeschriebne Klasse <code>MyInteger</code>:</p> MyInteger.java <pre><code>public class MyInteger {\nprivate int value;\n\npublic MyInteger(int value)\n{\nthis.value = value;\n}\n\npublic int intValue()\n{\nreturn this.value;\n}\n\npublic static MyInteger valueOf(int value)\n{\nreturn new MyInteger(value);\n}\n}\n</code></pre> </li> <li> <p>\u00c4ndern Sie in der <code>StadtTest.java</code> den Konstruktoraufruf der <code>Set</code> von <code>HashSet</code> nach <code>TreeSet</code> und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen (<code>Stadt cannot be cast to class java.lang.Comparable</code>). Implementieren Sie f\u00fcr <code>Stadt</code> das Interface <code>Comparable&lt;Stadt&gt;</code> so, dass nach den Namen der St\u00e4dte sortiert wird. F\u00fchren Sie dann erneut <code>StadtTest.java</code> aus. Es sollte folgende Ausgabe f\u00fcr die <code>Set</code> erzeugt werden:</p> <pre><code>------------ Menge --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>Stadt</code> so, dass die Namen der St\u00e4dte absteigend sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Menge --------------\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>Stadt</code> so, dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Menge --------------\nBerlin             891,68 km2    3.382.169   3.460.725   3.574.830\nHamburg            755,22 km2    1.715.392   1.786.448   1.810.438\nKoeln              405,02 km2      962.884   1.007.119   1.075.935\nMuenchen           310,70 km2    1.210.223   1.353.186   1.464.301\nFrankfurt/Main     248,31 km2      648.550     679.664     736.414\n</code></pre> </li> <li> <p>\u00c4ndern Sie in der <code>StadtTest.java</code> den Konstruktoraufruf der <code>Map</code> von <code>HashMap</code> nach <code>TreeMap</code> und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen (<code>MyInteger cannot be cast to class java.lang.Comparable</code>). Implementieren Sie f\u00fcr <code>MyInteger</code> das Interface <code>Comparable&lt;MyInteger&gt;</code> so, dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. F\u00fchren Sie dann erneut <code>StadtTest.java</code> aus. Es sollte folgende Ausgabe f\u00fcr die <code>Map</code> erzeugt werden:</p> <pre><code>------------ Maps --------------\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n6  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>\u00c4ndern Sie <code>compareTo()</code> in <code>MyInteger</code> so, dass die Werte der Schl\u00fcssel absteigend sortiert werden und f\u00fchren Sie dann <code>StadtTest.java</code> erneut aus. Es sollte folgende Ausgabe erzeugt werden:</p> <pre><code>------------ Maps --------------\n6  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> <li> <p>Zusatz: Schreiben Sie in <code>StadtTest.java</code> eine Methode <code>public static boolean contains(Map&lt;MyInteger, Stadt&gt; staedteMap, Stadt stadt)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Stadt <code>stadt</code> bereits in der <code>staedteMap</code> als ein <code>value</code> existiert. Tipp: Die Methode <code>get(Object key)</code> aus <code>Map</code> gibt den zu <code>key</code> geh\u00f6rigen <code>value</code> zur\u00fcck und mit <code>keySet()</code> bekommt man die Menge aller <code>keys</code> aus der <code>Map</code> ermittelt. Testen Sie die Methode, indem Sie zur Menge nur dann die <code>stadt</code> hinzuf\u00fcgen, wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. Sie sollten folgende Ausgabe erhalten: </p> <pre><code>------------ Maps --------------\n5  Frankfurt/Main     248,31 km2      648.550     679.664     736.414\n4  Koeln              405,02 km2      962.884   1.007.119   1.075.935\n3  Muenchen           310,70 km2    1.210.223   1.353.186   1.464.301\n2  Hamburg            755,22 km2    1.715.392   1.786.448   1.810.438\n1  Berlin             891,68 km2    3.382.169   3.460.725   3.574.830\n</code></pre> </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Stadt.javaMyInteger.javaStadtTest.java <pre><code>package uebungen.uebung6;\n\nimport java.util.*;\n\npublic class Stadt implements Comparable&lt;Stadt&gt;\n{\nString name;\nList&lt;Integer&gt; bevoelkerung;\nfloat flaeche;\n\npublic Stadt(String name, List&lt;Integer&gt; bevoelkerung, float flaeche)\n{\nsuper();\nthis.name = name;\nthis.bevoelkerung = bevoelkerung;\nthis.flaeche = flaeche;\n}\n\nvoid print()\n{\nSystem.out.printf(\"%-18s %.2f km%c\", this.name, this.flaeche, '\\u00B2');\nfor(Integer anzahl : this.bevoelkerung)\n{\nSystem.out.printf(\"%,14d\", anzahl);\n}\nSystem.out.println();\n}\n\n@Override\npublic boolean equals(Object o)\n{\nif(o==null) return false;\nif(o==this) return true;\nif(this.getClass()!=o.getClass()) return false;\n\nStadt other = (Stadt)o;\nreturn (this.name.equals(other.name));\n}\n\n@Override\npublic int hashCode()\n{\nreturn this.name.hashCode();\n}\n\n@Override\npublic int compareTo(Stadt o) {\n//return o.name.compareTo(this.name);\nif(this.flaeche &gt; o.flaeche) return 1;\nelse if(this.flaeche &lt; o.flaeche) return -1;\nelse return 0;\n}\n\n}\n</code></pre> <pre><code>package uebungen.uebung6;\n\npublic class MyInteger implements Comparable&lt;MyInteger&gt;\n{\nprivate int value;\n\npublic MyInteger(int value)\n{\nthis.value = value;\n}\n\npublic int intValue()\n{\nreturn this.value;\n}\n\npublic static MyInteger valueOf(int value)\n{\nreturn new MyInteger(value);\n}\n\n@Override\npublic int compareTo(MyInteger o) {\nreturn (this.value - o.value);\n}\n\n}\n</code></pre> <pre><code>package uebungen.uebung6;\n\nimport java.util.*;\n\npublic class StadtTest\n{\npublic static Stadt[] staedte()\n{\nStadt[] staedte = new Stadt[6];\nList&lt;Integer&gt; berlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[0] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nList&lt;Integer&gt; hamburgBevoelkerung = new ArrayList&lt;&gt;();\nhamburgBevoelkerung.add(1715392);   hamburgBevoelkerung.add(1786448);   hamburgBevoelkerung.add(1810438);   staedte[1] = new Stadt(\"Hamburg\", hamburgBevoelkerung, 755.22f);\n\nList&lt;Integer&gt; muenchenBevoelkerung = new ArrayList&lt;&gt;();\nmuenchenBevoelkerung.add(1210223);  muenchenBevoelkerung.add(1353186);  muenchenBevoelkerung.add(1464301);\nstaedte[2] = new Stadt(\"Muenchen\", muenchenBevoelkerung, 310.70f);\n\nList&lt;Integer&gt; koelnBevoelkerung = new ArrayList&lt;&gt;();\nkoelnBevoelkerung.add(962884);  koelnBevoelkerung.add(1007119); koelnBevoelkerung.add(1075935); staedte[3] = new Stadt(\"Koeln\", koelnBevoelkerung, 405.02f);\n\nList&lt;Integer&gt; frankfurtBevoelkerung = new ArrayList&lt;&gt;();\nfrankfurtBevoelkerung.add(648550);  frankfurtBevoelkerung.add(679664);  frankfurtBevoelkerung.add(736414);\nstaedte[4] = new Stadt(\"Frankfurt/Main\", frankfurtBevoelkerung, 248.31f);\n\nberlinBevoelkerung = new ArrayList&lt;&gt;();\nberlinBevoelkerung.add(3382169);    berlinBevoelkerung.add(3460725);    berlinBevoelkerung.add(3574830);\nstaedte[5] = new Stadt(\"Berlin\", berlinBevoelkerung, 891.68f);\n\nreturn staedte;\n}\n\npublic static boolean contains(Map&lt;MyInteger, Stadt&gt; staedteMap, Stadt stadt)\n{\n/*\n        // ueber alle Values\n        Collection&lt;Stadt&gt; alleStaedte = staedteMap.values();\n        for(Stadt s : alleStaedte)\n        {\n            if(s.equals(stadt)) return true;\n        }\n        return false;\n        */\n\n/*\n        // ueber alle Keys\n        Set&lt;MyInteger&gt; alleSchluessel = staedteMap.keySet();\n        for(MyInteger schluessel : alleSchluessel)\n        {\n            Stadt s = staedteMap.get(schluessel);\n            if(s.equals(stadt)) return true;\n        }\n        return false;\n        */\n\n// uber alle Schluessel-Werte-Paare\nSet&lt;Map.Entry&lt;MyInteger, Stadt&gt;&gt; alleEintraege = staedteMap.entrySet();\nfor(Map.Entry&lt;MyInteger, Stadt&gt; eintrag : alleEintraege)\n{\nStadt s = eintrag.getValue();\nif(s.equals(stadt)) return true;\n}\nreturn false;\n}\n\npublic static void main(String[] args)\n{\nSystem.out.printf(\"%n------------ Menge --------------%n\");\nSet&lt;Stadt&gt; staedteMenge = new TreeSet&lt;&gt;();\nfor(Stadt s : staedte())\n{\nstaedteMenge.add(s);\n}\nfor(Stadt s : staedteMenge)\n{\ns.print();\n}\n\nSystem.out.printf(\"%n------------ Maps --------------%n\");\nMap&lt;MyInteger, Stadt&gt; staedteMap = new TreeMap&lt;&gt;();\nint i = 1;\nfor(Stadt s : staedte())\n{\nif(!contains(staedteMap, s)) {\nstaedteMap.put(new MyInteger(i++), s);\n}\n}\nfor(Map.Entry&lt;MyInteger, Stadt&gt; entry : staedteMap.entrySet())\n{\nMyInteger key = entry.getKey();\nSystem.out.printf(\"%-3d\",key.intValue());\nentry.getValue().print();\n}\n}\n}\n</code></pre>"},{"location":"uebungen/#ubung-7-gui","title":"\u00dcbung 7 (GUI)","text":"\u00dcbung 7 <ol> <li> <p>Erstellen Sie (ungef\u00e4hr) folgende GUI:</p> <p></p> <p>bzw. betriebssystemabh\u00e4ngig ungef\u00e4hr so:</p> <p></p> <p>Tipp: Zur Erstellung von Rahmen (Border) schauen Sie z.B. hier oder hier.</p> </li> </ol> m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Stadt.java <pre><code>package uebungen.uebung7;\n\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.GridLayout;\n\nimport javax.swing.*;\n\npublic class Uebung7 extends JFrame\n{\npublic Uebung7()\n{\nsuper();\nthis.setTitle(\"GUI \u00dcbung\");\nthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\nJPanel content = this.initContent();\nthis.getContentPane().add(content);\nthis.setSize(500, 400);\nthis.setLocation(300, 200);\nthis.setVisible(true);\n}\n\nJPanel initContent()\n{\nJPanel mainPanel = new JPanel();\nmainPanel.setLayout(new BorderLayout());\n\n// Panel fuer den Norden (FlowLayout)\nJPanel norden = new JPanel();\nnorden.setBorder(BorderFactory.createLineBorder(Color.RED, 3));\nnorden.setBackground(Color.BLUE);\nJLabel text = new JLabel(\"Text\");\ntext.setHorizontalAlignment(JLabel.CENTER);\ntext.setForeground(Color.WHITE);\nnorden.add(text);\n\n// Panel fuer den Osten (GridLayout(2,1))\nJPanel osten = new JPanel();\nosten.setLayout(new GridLayout(2,1,0,20));\nJButton button1 = new JButton(\"Button 1\");\nJButton button2 = new JButton(\"Button 2\");\nosten.add(button1);\nosten.add(button2);\n\n// Panel fuer Center (GridLayout(2,1))\n// erste Zelle JLabel\n// zweite Zelle JPanel inputPanel (FlowLayout)\n// inputPanel enthaelt JTextField input \nJPanel center = new JPanel();\ncenter.setLayout(new GridLayout(2,1));\nJLabel text2 = new JLabel(\"Weiterer Text\");\ntext2.setHorizontalAlignment(JLabel.CENTER);\nJPanel inputPanel = new JPanel();\nJTextField input = new JTextField(15);\ninputPanel.add(input);\ncenter.add(text2);\ncenter.add(inputPanel);\n\n// Panel hinzufuegen\nmainPanel.add(norden, BorderLayout.NORTH);\nmainPanel.add(osten, BorderLayout.EAST);\nmainPanel.add(center, BorderLayout.CENTER);\nreturn mainPanel;\n}\n\npublic static void main(String[] args) {\nnew Uebung7();\n}\n\n}\n</code></pre>"},{"location":"uebungen/#ubung-8-ereignisbehandlung-actionlistener","title":"\u00dcbung 8 (Ereignisbehandlung - ActionListener)","text":"\u00dcbung 8 <ol> <li>Erstellen Sie ein Fenster mit einem Textfeld und zwei Buttons <code>add</code> und <code>remove</code>. Sowohl das Textfeld als auch die beiden Buttons sollen Objektvariablen (und somit zugreifbar von allen Methoden der Klasse) sein.</li> <li>Unterteilen Sie das <code>main</code>-<code>JPanel</code> zun\u00e4chst in zwei <code>JPanel</code>s <code>unten</code> und <code>oben</code>. Dem <code>JPanel oben</code> werden das Textfeld und die beiden Buttons hinzugef\u00fcgt. Setzen Sie die Hintergrundfarbe des JPanels <code>oben</code> auf <code>YELLOW</code>.  Setzen Sie die Hintergrundfarbe des JPanels <code>unten</code> auf <code>CYAN</code>. Das JPanel <code>unten</code> soll ebenfalls eine Objektvariable sein.</li> <li> <p>Setzen Sie die Gr\u00f6\u00dfe des Fensters auf Werte, so dass es wie folgt erscheint:     </p> </li> <li> <p>F\u00fcgen Sie folgende Objektvariable hinzu: <code>List&lt;JLabel&gt; labels = new ArrayList&lt;&gt;();</code></p> </li> <li> <p>Implementieren Sie den <code>ActionListener</code> wie folgt:      Wird der <code>add</code>-Button gedr\u00fcckt, </p> <ul> <li> <p>wird der Liste <code>labels</code> ein <code>JLabel</code> hinzugef\u00fcgt, wobei der Text des JLabels dem Text im Textfeld entspricht (der Text des Textfeldes kann \u00fcber die Objektmethode <code>getText()</code> von JTextField ausgelesen werden).</p> </li> <li> <p>Die Liste <code>labels</code> wird vollst\u00e4ndig ausgelesen und jedes <code>JLabel</code> aus <code>labels</code> wird dem <code>JPanel unten</code> mithilfe der <code>add()</code>-Methode von <code>JPanel</code> hinzugef\u00fcgt.</p> </li> <li> <p>Rufen Sie <code>this.unten.revalidate();</code> auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels <code>unten</code> an.</p> </li> </ul> <p>Wird der \u201eremove\u201c-Button gedr\u00fcckt,</p> <ul> <li> <p>wird das <code>JLabel</code> aus der Liste <code>labels</code> gel\u00f6scht, das den gleichen Text hat wie der Text, der im Textfeld eingegeben wurde.</p> </li> <li> <p>Au\u00dferdem wird das <code>JLabel</code> aus den <code>JPanel unten</code> entfernt (Objektmethode <code>remove()</code> von <code>JPanel</code>).</p> </li> <li> <p>Rufen Sie <code>this.unten.revalidate();</code> auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels unten an.</p> </li> </ul> <p></p> </li> <li> <p>Tipp: wenn Sie einem <code>JLabel</code> eine Hintergrundfarbe mit <code>setBackground(Color c)</code> setzen, dann sieht man diese nur, wenn Sie f\u00fcr dieses <code>JLabel</code> die Methode <code>setOpaque(true)</code> aufrufen. Nur dadurch werden f\u00fcr dieses <code>JLabel</code> alle Pixel gezeichnet, die in dessen Grenzen sind, d.h. das komplette Rechteck, das das <code>JLabel</code> ausf\u00fcllt. Ansonsten w\u00fcrde nur der Text \"gezeichnet\" und die Hintergrundfarbe w\u00e4re hinter dem Text versteckt. </p> </li> </ol>"},{"location":"wiederholung/","title":"Wiederholung","text":""},{"location":"wiederholung/#datentypen","title":"Datentypen","text":""},{"location":"wiederholung/#wertetypen","title":"Wertetypen","text":"<ul> <li>es wird der konkrete Wert in der Variablen gespeichert\u000b</li> <li>belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche</li> </ul> Beispiele Wertetypen <pre><code>// boolean f\u00fcr Wahrheitswerte true und false\nboolean x = false;          // mit false initialisiert\nboolean wahr = true;        // Schluesselwort true\nboolean falsch = !wahr;     // Enthaelt den Wert false\n\n// byte, short, int, long f\u00fcr ganze Zahlen\nbyte a = 0;         // mit 0 initialisiert\nshort b = 124;      // Zuweisung einer ganzen Zahl\nint c = a + b;      // Wertebereich immer beachten!\nlong lo = c * 200;  // l nicht als Variablenname verwenden\n\n// char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen!\nchar zeichen = 'c';     // Doppelte \" f\u00fcr Strings!\u00a0\n\n// float und double f\u00fcr Flie\u00dfkommazahlen\nfloat f = 0.0f;         // Wird mit 0.0 initialisiert\ndouble d = 100.25;      // Dezimalpunkt statt Dezimalkomma!!\n</code></pre>"},{"location":"wiederholung/#referenztypen","title":"Referenztypen","text":"<ul> <li>es wird eine Referenz auf ein Objekt gespeichert\u000b</li> <li>Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand)</li> <li>Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator</li> </ul> Beispiele Referenztypen <pre><code>// Schluesselwort class um neue Klasse (Typ) zu definieren\npublic class Power {\nint base; // Objektvariablen, f\u00fcr jedes Objekt\nint exp;  // existieren Kopien im Arbeitsspeicher\n\npublic Power(int base, int exp)\n{\nthis.base = base;\nthis.exp = exp;\n}\n\n// Objektmethode\npublic void print()\n{\nSystem.out.println(this.base + \"^\" + this.exp);\n}\n}\n\n// irgendwo im Hauptprogramm\npublic static void main(String[] args)\u00a0{\nPower p1 = new Power(2,4);\nPower p2 = new Power(2,4);\np1.print();\np2.print();\nboolean equal = (p1 == p2);     // true oder false ?\n}\n</code></pre>"},{"location":"wiederholung/#datenstrukturen","title":"Datenstrukturen","text":""},{"location":"wiederholung/#variablen","title":"Variablen","text":"<ul> <li>einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein)</li> <li>sind von einem Datentyp (Wertetyp oder Referenztyp)</li> <li>haben einen Namen</li> <li>besitzen einen Wert<ul> <li>Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =)</li> <li>Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final)</li> </ul> </li> <li>besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope)<ul> <li>Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde</li> <li>lokale Variable: in einer Methode deklariert \u2192 dort lokal</li> <li>globale Variable: in einer Klasse deklariert \u2192 dort global</li> </ul> </li> </ul> Beispiele Variablen <pre><code>int zahlen = 0;             // konventionelle Variable\nfinal float PI = 3.14516f;  // Konstante\n\n// Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz\nint[] zahlenFeld = new int[100];\n\n// Klassen mit Objekt- und Klassenvariablen\npublic class Power {\nint base; // Objektvariablen, f\u00fcr jedes Objekt\nint exp;  // existieren Kopien im Arbeitsspeicher\n\npublic Power(int base, int exp)\n{\nthis.base = base;\nthis.exp = exp;\n}\n\npublic String toString()\n{\n// lokale Variable --&gt; nur in der Methode gueltig\nString output =\u00a0 this.base + \"^\" + this.exp;\nreturn output;\n}\n\n// Variablen sollten mit einem Kleinbuchstaben beginnen\n// Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden\n}\n</code></pre>"},{"location":"wiederholung/#arrays","title":"Arrays","text":"<ul> <li>Arrays sind Objekte (Referenztypen)</li> <li>speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein)</li> <li>besitzen Methoden (z.B. <code>sort()</code>) und Variablen (z.B. <code>length</code>)</li> <li>k\u00f6nnen auch mehrdimensional sein</li> <li>Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes</li> </ul> Beispiele Arrays <pre><code>// Einfache Deklaration -&gt; nur Datentyp bekannt, keine Laenge\nint[] zahlen;           // Eckige Klammern f\u00fcr Array-Datentyp\n\n// Erzeugen eines neuen Feldes und Zuweisen der Referenz\nzahlen = new int[100];  // new-Operator, hier: Angabe der Laenge\n\n// Explizite Initialisierung bei der Deklaration\n// Bei Initialisiert mit Werten --&gt; keine Laengenangabe noetig\nfloat[] werte = new float[10];      // Platz f\u00fcr 10 Werte \ndouble[] fib = { 1.0, 2.0, 3.0 };   // Werte in {}-Klammern\n\n// Mehrdimensionale Felder\nint[][] hdBild = new int[1920][1080];\n\n// Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden\nPower[] potenzen = new Power[5];    // Noch keine Objekte enthalten\npotenzen[0] = new Power(2, 4);      // Zuweisung Objekt an Index 0\n</code></pre>"},{"location":"wiederholung/#literale","title":"Literale","text":"<ul> <li>sind Werte</li> <li>sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein)</li> <li>keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen</li> <li>meistens <ul> <li>auf der rechten Seite einer Wertzuweisung</li> <li>als Parameterwert bei Aufruf einer Methode</li> <li>als Vergleichswert bei logischen Ausdr\u00fccken</li> </ul> </li> </ul> Beispiele Literale <pre><code>100\ntrue\n'a'\n\"hallo\"\n{1,2,3,4}\n5.5\n</code></pre>"},{"location":"wiederholung/#ausdrucke","title":"Ausdr\u00fccke","text":"<ul> <li>kleinste ausf\u00fchrbare Einheit eines Programms</li> <li> <p>z.B.:</p> <ul> <li>Zuweisung</li> <li>numerische Berechnung</li> <li>logische Bedingung</li> </ul> </li> <li> <p>Operatoren:</p> <ul> <li>arithmetisch:     <code>+, -, *, /, %, ++, --</code></li> <li>relational:       <code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></li> <li>logisch:          <code>!, &amp;&amp;, ||</code></li> <li>Zuweisung:        <code>=, +=, -=, *=, /=, %=</code></li> <li>sonstige:         <code>a?b:c, typecast, new, instanceof, .</code></li> </ul> </li> </ul>"},{"location":"wiederholung/#anweisungen","title":"Anweisungen","text":"<ul> <li>Einzelanweisung       <code>;</code></li> <li>Block                 <code>{}</code></li> <li>Deklaration           <code>Typ Methode</code>, <code>Typ Variable</code></li> <li>Ausdruck</li> <li>Bedingung             <code>if() else  switch() case</code></li> <li>Schleifen             <code>for        while       do while</code></li> <li>Exceptions            <code>try catch()</code></li> <li>Assertions            <code>assert</code></li> </ul> Beispiele Anweisungen <pre><code>// Bloecke immer zwischen geschweiften Klammern\n{\n// Anweisung 1...\n// Anweisung 2...\n}\n\n// Definition und Deklaration\nint a;\nfloat b = 1.0f;\n\n// Einfacher Ausdruck\na = 1010;\u00a0// Bedingungen\nif (a == 1010)\u00a0         // if-Zweig muss immer vorhanden sein\n{\n// Anweisungen...\n}\nelse if (a == 1011)\u00a0    // 0 - beliebig viele else-if-Zweige\n{\n// Anweisungen...\n}\nelse\u00a0           // 0 - 1 else-Zweig\n{\n// Anweisungen...\n}\n\nswitch (a)      // zu pruefende Variable in Klammern\n{\ncase 1010: { b*=2.0; break; }   // beliebig viele case-Zweige\ncase 1011: { b*=3.0; break; }   // break nicht vergessen\ndefault: { b=0.0f; }            // Zweig f\u00fcr alle anderen Werte\n}\n\nint[] meinFeld = {1,2,3,4,5};\n// for-Schleife\n// 1. Initialisierung\n// 2. Schleifen-Bedingung\n// 3. Anweisungen nach Schleifendurchlauf\n// Schleifen-Anweisungen als Block hinter for\nfor (int index = 0; index &lt; meinFeld.length; index++) {\nSystem.out.println(meinFeld[index]);\n}\n\n// while-Schleife\n// Nur Schleifen-Bedingung angeben\n// Auf Endlos-Schleifen achten\nwhile (index &lt; meinFeld.length) {\u00a0System.out.println(meinFeld[index]);\nindex++;\n}\n</code></pre>"},{"location":"wiederholung/#methoden","title":"Methoden","text":"<ul> <li>wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden</li> <li>Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. <code>void</code>)</li> <li>Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden</li> <li>bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum <code>return</code>)</li> <li>werden Methoden mit R\u00fcckgabetyp (also nicht <code>void</code>) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert)</li> </ul> Methodenstack/Call stack <pre><code>public static int multiply(int a, int b) {\nreturn a*b;\n}\n\npublic static int square(int n) {\nreturn multiply(n,n);\n}\n\npublic static void printSquare(int n) {\nint squared = square(n);\nSystem.out.println(n + \" x \" + n + \" = \"\u00a0+ squared);\n}\n\npublic static void main(String[] args) {\nprintSquare(4);\n}\n</code></pre>"},{"location":"wiederholung/#vererbung","title":"Vererbung","text":"<ul> <li>Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse)</li> <li>Schl\u00fcsselwort <code>extends</code></li> <li>jede Klasse (bis auf <code>Object</code>) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch <code>Object</code></li> <li>Vererbung beschreibt \u201eis-a\u201c-Beziehung</li> <li>Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als <code>final</code> definiert wurden) \u2192 @Override verwenden</li> <li>Originalmethode kann mit Schl\u00fcsselwort <code>super</code> aufgerufen werden</li> </ul>"},{"location":"wiederholung/#konstruktoren","title":"Konstruktoren","text":"<ul> <li>besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden</li> <li>gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht <code>void</code>)</li> <li>wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren)</li> <li>Aufruf von <code>this</code> und <code>super</code> m\u00f6glich</li> <li>werden nicht vererbt</li> </ul> Beispiele Konstruktoren <pre><code>public class Power {\nint base;\nint exp;\n\npublic Power()\n{\nthis(1,0);  // Aufruf des Konstruktors in Zeile 15\n}\n\npublic Power(int base)\n{\nthis(base, 0);  // Aufruf des Konstruktors in Zeile 15\n}\n\npublic Power(int base, int exp)\n{\nthis.base=base;     // Parameterwerte f\u00fcr base und int\nthis.exp=exp;       // auf Objektvariablen sichern\n}\n}\n\npublic static void main(String[] args) {\nPower p1 = new Power();         // p1.base = 1, p1.exp = 0\nPower p2 = new Power(10);       // p2.base = 10, p2.exp = 0\nPower p3 = new Power(10,5);     // p3.base = 10, p3.exp = 5\n}\n</code></pre>"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","title":"Access Controller (Zugriffsmodifizierer)","text":"<ul> <li>Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung</li> <li> <p>Klassen</p> <ul> <li><code>public</code>      Zugriff von au\u00dferhalb des Paketes</li> <li>(default)     Zugriff nur innerhalb des Paketes</li> <li><code>final</code>       von der Klasse k\u00f6nnen keine Klassen erben</li> <li><code>abstract</code>    Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind)</li> </ul> </li> <li> <p>Variablen und Methoden (wenn Klasse <code>public</code>)</p> <ul> <li><code>public</code>      Zugriff von \u00fcberall (bei Variablen vermeiden!)</li> <li><code>protected</code>   Zugriff aus Klasse und Kindklasse</li> <li>(default)     Zugriff aus Klasse und Paket</li> <li><code>private</code>         Zugriff nur aus Klasse </li> </ul> </li> </ul>"},{"location":"wiederholung/#kleinigkeiten-die-wir-nicht-betrachtet-haben","title":"\"Kleinigkeiten\", die wir nicht betrachtet haben","text":""},{"location":"wiederholung/#das-schlusselwort-static","title":"Das Schl\u00fcsselwort <code>static</code>","text":"<p>Mit dem Schl\u00fcsselwort <code>static</code> beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort <code>static</code> kann verwendet werden f\u00fcr</p> <ul> <li>Die Deklaration einer (Klassen-)Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). </li> <li>Die Deklaration einer (Klassen-)Methode. Eine statische Methode (Klassenmethode) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der <code>main()</code>-Methode) erstellen, um diese in der <code>main()</code>-Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. </li> <li>Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter.</li> </ul> <p>Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen. </p>"},{"location":"wiederholung/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wir haben ein Array stets so durchlaufen, dass wir in einer <code>for</code>-Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor (int index = 0; index &lt; args.length; index++) {\nSystem.out.print(numbers[index]);\n}\n</code></pre> <p>Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\nSystem.out.print(number);\n}\n</code></pre> <p>Wir bezeichnen diese Schleifensyntax auch als for-each-Schleife. Die allgemeine Syntax ist</p> <pre><code>for(TypElement variablenNameElement : nameDesArrays)\n{\n// hier lesende Verwendung von variablenNameElement\n}\n</code></pre> <p>Beachten Sie, dass Sie mit der for-each-Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\nnumber = 5;\n}\n</code></pre> <p>, dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken (Setter). </p>"},{"location":"wiederholung/#die-klasse-javautilarrays","title":"Die Klasse <code>java.util.Arrays</code>","text":"<p>Die Klasse <code>Arrays</code> aus dem <code>java.util</code>-Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die <code>toString()</code>-Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen <code>toString()</code>-Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse <code>Arrays</code> finden Sie z.B. hier. Beachten Sie, dass Sie zum Verwenden der Klasse das <code>java.util</code>-Paket importieren m\u00fcssen. </p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nSystem.out.println(Arrays.toString(numbers));\n</code></pre> <p>Weitere interessante Methoden dieser Klasse sind <code>copyOf()</code>, <code>binarySearch()</code> und <code>sort()</code>. </p> \u00dcbung <p>Ist die <code>toString()</code>-Methode der <code>Arrays</code>-Klasse statisch oder handelt es sich um eine Objektmethode?</p>"},{"location":"wrapper/","title":"Wrapper-Klassen","text":"<p>Motivation</p> <p>Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen <code>String</code> zu einem <code>int</code> (oder <code>double</code>) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen.</p> <p>In Programmierung I haben wir am Anfang die Datentypen <code>int</code>, <code>boolean</code>, <code>double</code>, <code>char</code>, <code>long</code> usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen, welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen. Diese sind <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code> und <code>Boolean</code> und befinden sich im <code>java.lang</code>-Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. </p> <p>Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" (wrappen) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel <code>int</code> \u2194 <code>Integer</code> verdeutlichen:</p> <p></p> <p>Der <code>int</code>-Wert <code>10</code> wird zu einem Typ <code>Integer</code> und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. </p> <p>Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code> und <code>double</code> so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von <code>char</code> <code>Character</code> und die Wrapper-Klasse von <code>int</code> <code>Integer</code>. </p>  Wertetyp  Referenztyp (Wrapper-Klasse)  <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>boolean</code> <code>Boolean</code> <code>char</code> <code>Character</code>"},{"location":"wrapper/#objekterzeugung","title":"Objekterzeugung","text":"<p>Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen:</p> <ul> <li>Verwendung des Kontruktors, Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>Verwendung der statischen Methode <code>valueOf()</code>,  Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp).</li> </ul> <p>Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von <code>Integer</code> an. Es gilt aber f\u00fcr alle Wrapper-Klassen. </p>"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","title":"Verwendung des Kontruktors - deprecated","text":"<p>F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von <code>Integer</code> als ein <code>int</code>-Wert) oder es wird ein <code>String</code> \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr <code>Integer</code> soll der <code>String</code> eine Zahl enthalten. Am Beispiel von <code>Integer</code> k\u00f6nnte das z.B. so aussehen:</p> <pre><code>// Konstruktor mit Uebergabe Wertetyp\nint i = 100;\nInteger iObject1 = new Integer(i);\nInteger iObject2 = new Integer(100);\n\n// Konstruktor mit Uebergabe String\nString s = \"100\";\nInteger iObject3 = new Integer(s);\nInteger iObject4 = new Integer(\"100\");\n\n// Moeglich f\u00fcr alle numerischen Datentypen und boolean\n</code></pre> <p>F\u00fcr <code>Character</code> gibt es nur einen parametrisierten Konstruktor: <code>Character\u200b(char value)</code>. Die \u00dcbergabe eines <code>Strings</code> ist dort nicht m\u00f6glich. </p> <p>Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated, sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden <code>valueOf()</code> zu verwenden. </p>"},{"location":"wrapper/#die-valueof-methoden","title":"Die <code>valueOf()</code>-Methoden","text":"<p>Die <code>valueOf()</code>-Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften:</p> <ol> <li>sie sind statisch, d.h. der Aufruf erfolgt \u00fcber <code>Klassenname.valueOf()</code>,</li> <li>sie sind sogenannte Erzeugermethoden, denn sie geben ein Objekt der Klasse zur\u00fcck</li> </ol> <p>Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein <code>String</code> \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele</p> <pre><code>// Wrapper-Klassen haben die Klassenmethoden\n// valueOf(Wertetyp b) ...\nInteger iObject1 = Integer.valueOf(100);\nBoolean bObject1 = Boolean.valueOf(true);\nDouble  dObject1 = Double.valueOf(5.5);\n\n// ... oder valueOf(String s)\nInteger iObject2 = Integer.valueOf(\"100\");\nBoolean bObject2 = Boolean.valueOf(\"true\");\nDouble  dObject2 = Double.valueOf(\"5.5\");\n</code></pre> <p>Auch hier gilt wieder, dass f\u00fcr <code>Character</code> nur eine <code>valueOf()</code>-Methode existiert, n\u00e4mlich <code>valueOf(char c)</code>. Die \u00dcbergabe eines <code>Strings</code> ist nicht m\u00f6glich. </p>"},{"location":"wrapper/#auto-boxing","title":"Auto-Boxing","text":"<p>Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing.  Beispiele:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n</code></pre> <p>Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter <code>Eclipse</code> \u2192 <code>Preferences</code> \u2192 <code>Java</code> \u2192 <code>Compiler</code> \u2192 <code>Errors/Warnings</code> folgende Einstellungen:</p> <p></p> <p>\u00dcbung</p> <p>Was wird ausgegeben und warum?  <pre><code>    Integer i1 = 5000;\nInteger i2 = 5000;\n\nSystem.out.println(i1 == i2);\n</code></pre></p>"},{"location":"wrapper/#werte-extrahieren","title":"Werte extrahieren","text":"<p>H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher <code>int</code>-Wert von einem <code>Integer</code>-Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethoden zur Verf\u00fcgung also: <code>intValue()</code>, <code>doubleValue()</code>, <code>charValue()</code>, <code>booleanValue()</code> usw. Betrachten wir nochmal die Beispiele von eben:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n\nint     i1 = io1.intValue();        // 100\nboolean b1 = bo1.booleanValue();    // true\nchar    c1 = co1.charValue();       // 'a'\ndouble  d1 = do1.doubleValue();     // 5.5\nfloat   f1 = fo1.floatValue();      // 2.7\nlong    l1 = lo1.longValue();       // 1234\n</code></pre> <p>Aber auch hier gibt es wieder ein Auto-Unboxing. Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben:</p> <pre><code>int     i2 = io1;   // 100\nboolean b2 = bo1;   // true\nchar    c2 = co1;   // 'a'\ndouble  d2 = do1;   // 5.5\nfloat   f2 = fo1;   // 2.7\nlong    l2 = lo1;   // 1234\n</code></pre> <p>Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. </p> <p>\u00dcbung</p> <p>Geht das und wenn ja, warum? Was wird jeweils ausgegeben? <pre><code>    Integer i1 = 5000;\nInteger i2 = 5000;\nInteger i3 = 5001;\n\nSystem.out.println(i1 &gt;= i2);\nSystem.out.println(i3 &gt; i2);\n</code></pre></p> <p>Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von <code>Double</code>. Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden <code>String</code> erzeugt werden kann, indem die statische <code>&lt;WrapperTyp&gt;.parse&lt;WrapperTyp&gt;</code>-Methode verwendet wird. </p> <p></p>"},{"location":"wrapper/#strings-in-wertetypen","title":"Strings in Wertetypen","text":"<p>Wir wissen jetzt schon, dass wir uns mithilfe der <code>valueOf(String s)</code>-Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von <code>intValue()</code> k\u00f6nnte man z.B. aus einem <code>Intger</code>-Objekt den <code>int</code>-Wert extrahieren. Das ginge auch mit Auto-Unboxing. F\u00fcr die Umwandlung von <code>String</code> nach <code>int</code> verwendet man aber am besten die <code>parseInt()</code>-Methode. </p> <pre><code>String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl ein: \");\nint zahl = Integer.parseInt(eingabe);\n</code></pre> <p>F\u00fcr <code>double</code> steht uns daf\u00fcr <code>Double.parseDouble(String s)</code> zur Verf\u00fcgung usw. </p> <p>Success</p> <p>Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen <code>String</code> in einen <code>int</code> umwandeln! Wir kennen nun Wrapper-Klassen und deren <code>parseXXX(String)</code>-Methoden.</p>"},{"location":"wrapper/#links-zu-den-java-docs","title":"Links zu den Java-Docs","text":"<p>Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. </p> <ul> <li>Boolean</li> <li>Byte</li> <li>Character</li> <li>Double</li> <li>Float</li> <li>Integer</li> <li>Long</li> <li>Short</li> </ul> <p>\u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number. Diese enth\u00e4lt die Objektmethoden <code>byteValue()</code>, <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code>, <code>longValue()</code> und <code>shortValue()</code>. Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. </p> <p>\u00dcbung</p> <p>Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse <code>Integer</code> an. Welche Exception kann die <code>parseInt(String)</code>-Methode werfen? </p>"},{"location":"wrapper/#ausblick","title":"Ausblick","text":"<p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p>"}]}