{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren II \u00b6 Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8 - 9.30 bzw. 14-15.30 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt! Grober Inhalt (kann sich noch \u00e4ndern) \u00b6 Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 10.-14.04.2023 Organisatorisches , Wiederholung , Einstieg - - - 1. 17.-21.04.2023 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2023 2. 24.-28.04.2023 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2023 3. 01.-05.05.2023 Aufgabe 2 besprochen \u00dcbung 3 Aufgabe 3 16.05.2023 4. 08.-12.05.2023 Exceptions II \u00dcbung 4 Aufgabe 4 23.05.2023 5. 15.-19.05.2023 Collections (List und Set) \u00dcbung 5 Aufgabe 5 30.05.2023 6. 22.-26.05.2023 Collections (Map) \u00dcbung 6 Aufgabe 6 - 7. 29.-02.06.2023 Abstrakte Klassen \u00dcbung 7 Aufgabe 7 06.06.2023 8. 05.-09.06.2023 Interfaces \u00dcbung 8 Aufgabe 8 20.06.2023 9. 12.-16.06.2023 GUI Einf\u00fchrung - Aufgabe 9 27.06.2023 10. 19.-23.06.2023 JUnit und Layout-Manager \u00dcbung 10 \u00dcbung 9 Aufgabe 10 04.07.2023 12. 26.-30.06.2023 GUI Ereignisse \u00dcbung 11 - - 13. 03.-07.07.2023 ActionListener \u00dcbung 12 - - 14. 10.-14.07.2023 Mausereignisse \u00dcbung 13 - - 28.07.2023 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 29.09.2023 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - - Inhalte \u00b6 14.04.2023 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Einstieg siehe Aufgabe 1","title":"Home"},{"location":"#programmieren-ii","text":"Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren II"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8 - 9.30 bzw. 14-15.30 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!","title":"Organisatorisches"},{"location":"#grober-inhalt-kann-sich-noch-andern","text":"Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 10.-14.04.2023 Organisatorisches , Wiederholung , Einstieg - - - 1. 17.-21.04.2023 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2023 2. 24.-28.04.2023 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2023 3. 01.-05.05.2023 Aufgabe 2 besprochen \u00dcbung 3 Aufgabe 3 16.05.2023 4. 08.-12.05.2023 Exceptions II \u00dcbung 4 Aufgabe 4 23.05.2023 5. 15.-19.05.2023 Collections (List und Set) \u00dcbung 5 Aufgabe 5 30.05.2023 6. 22.-26.05.2023 Collections (Map) \u00dcbung 6 Aufgabe 6 - 7. 29.-02.06.2023 Abstrakte Klassen \u00dcbung 7 Aufgabe 7 06.06.2023 8. 05.-09.06.2023 Interfaces \u00dcbung 8 Aufgabe 8 20.06.2023 9. 12.-16.06.2023 GUI Einf\u00fchrung - Aufgabe 9 27.06.2023 10. 19.-23.06.2023 JUnit und Layout-Manager \u00dcbung 10 \u00dcbung 9 Aufgabe 10 04.07.2023 12. 26.-30.06.2023 GUI Ereignisse \u00dcbung 11 - - 13. 03.-07.07.2023 ActionListener \u00dcbung 12 - - 14. 10.-14.07.2023 Mausereignisse \u00dcbung 13 - - 28.07.2023 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 29.09.2023 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - -","title":"Grober Inhalt (kann sich noch \u00e4ndern)"},{"location":"#inhalte","text":"14.04.2023 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Einstieg siehe Aufgabe 1","title":"Inhalte"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Aufgabe 1 (W\u00fcrfelspiel) \u00b6 Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! Aufgabe 2 (MyInteger) \u00b6 Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-wurfelspiel","text":"Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 1 (W\u00fcrfelspiel)"},{"location":"aufgaben/#aufgabe-2-myinteger","text":"Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 2 (MyInteger)"},{"location":"einstieg/","text":"Einstieg \u00b6 Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe23 // SoSe23 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION Beispiel showConfirmDialog() \u00b6 Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters. Beispiel mit YES_NO_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } Beispiel mit YES_NO_CANCEL_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster: Beispiel showInputDialog() \u00b6 Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig. Ausblick \u00b6 Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Einstieg"},{"location":"einstieg/#einstieg","text":"Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe23 // SoSe23 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION","title":"Einstieg"},{"location":"einstieg/#beispiel-showconfirmdialog","text":"Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters.","title":"Beispiel showConfirmDialog()"},{"location":"einstieg/#beispiel-mit-yes_no_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt }","title":"Beispiel mit YES_NO_OPTION"},{"location":"einstieg/#beispiel-mit-yes_no_cancel_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster:","title":"Beispiel mit YES_NO_CANCEL_OPTION"},{"location":"einstieg/#beispiel-showinputdialog","text":"Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig.","title":"Beispiel showInputDialog()"},{"location":"einstieg/#ausblick","text":"Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Ausblick"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbung 1 (Wiederholung und Codereview) \u00b6","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubung-1-wiederholung-und-codereview","text":"","title":"\u00dcbung 1 (Wiederholung und Codereview)"},{"location":"wiederholung/","text":"Wiederholung \u00b6 Datentypen \u00b6 Wertetypen \u00b6 es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!! Referenztypen \u00b6 es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? } Datenstrukturen \u00b6 Variablen \u00b6 einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden } Arrays \u00b6 Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0 Literale \u00b6 sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5 Ausdr\u00fccke \u00b6 kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, . Anweisungen \u00b6 Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; } Methoden \u00b6 wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); } Vererbung \u00b6 Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden Konstruktoren \u00b6 besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 } Access Controller (Zugriffsmodifizierer) \u00b6 Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse \"Kleinigkeiten\", die wir nicht betrachtet haben \u00b6 Das Schl\u00fcsselwort static \u00b6 Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen. Die for-each -Schleife \u00b6 Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ). Die Klasse java.util.Arrays \u00b6 Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Wiederholung"},{"location":"wiederholung/#wiederholung","text":"","title":"Wiederholung"},{"location":"wiederholung/#datentypen","text":"","title":"Datentypen"},{"location":"wiederholung/#wertetypen","text":"es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!!","title":"Wertetypen"},{"location":"wiederholung/#referenztypen","text":"es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? }","title":"Referenztypen"},{"location":"wiederholung/#datenstrukturen","text":"","title":"Datenstrukturen"},{"location":"wiederholung/#variablen","text":"einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden }","title":"Variablen"},{"location":"wiederholung/#arrays","text":"Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0","title":"Arrays"},{"location":"wiederholung/#literale","text":"sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5","title":"Literale"},{"location":"wiederholung/#ausdrucke","text":"kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, .","title":"Ausdr\u00fccke"},{"location":"wiederholung/#anweisungen","text":"Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; }","title":"Anweisungen"},{"location":"wiederholung/#methoden","text":"wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); }","title":"Methoden"},{"location":"wiederholung/#vererbung","text":"Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden","title":"Vererbung"},{"location":"wiederholung/#konstruktoren","text":"besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 }","title":"Konstruktoren"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","text":"Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse","title":"Access Controller (Zugriffsmodifizierer)"},{"location":"wiederholung/#kleinigkeiten-die-wir-nicht-betrachtet-haben","text":"","title":"\"Kleinigkeiten\", die wir nicht betrachtet haben"},{"location":"wiederholung/#das-schlusselwort-static","text":"Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen.","title":"Das Schl\u00fcsselwort static"},{"location":"wiederholung/#die-for-each-schleife","text":"Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ).","title":"Die for-each-Schleife"},{"location":"wiederholung/#die-klasse-javautilarrays","text":"Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Die Klasse java.util.Arrays"}]}