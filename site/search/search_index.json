{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren II \u00b6 Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Solange Pr\u00e4senzveranstaltungen m\u00f6glich sind, werden wir die Veranstaltungen auch in Pr\u00e4senz durchf\u00fchren. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden dienstags (14-15.30 Uhr) bzw. donnerstags (14-15.30 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen). Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Zus\u00e4tzlich sollten Sie f\u00fcr mindestens 5 fremde L\u00f6sungen Code-reviews erstellen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt! Grober Inhalt (kann sich noch \u00e4ndern) \u00b6 Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 04.-08.04.2022 Organisatorisches , Wiederholung , Einstieg - - - 1. 11.-15.04.2022 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2022 2. 18.-22.04.2022 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2022 3. 25.-29.04.2022 Aufgabe 2 besprochen \u00dcbung 3 Aufgabe 3 16.05.2022 4. 02.-06.05.2022 Exceptions II \u00dcbung 4 Aufgabe 4 23.05.2022 5. 09.-13.05.2022 Collections (List und Set) \u00dcbung 5 Aufgabe 5 30.05.2022 6. 16.-20.05.2022 Collections (Map) \u00dcbung 6 - - 7. 23.-27.05.2022 Abstrakte Klassen \u00dcbung 7 Aufgabe 6 06.06.2022 8. 30.-03.06.2022 Interfaces \u00dcbung 8 - 20.06.2022 9. 06.-10.06.2022 GUI Einf\u00fchrung - Aufgabe 7 27.06.2022 10. 13.-17.06.2022 JUnit und Layout-Manager \u00dcbung 10 \u00dcbung 9 Aufgabe 8 04.07.2022 12. 20.-24.06.2022 GUI Ereignisse \u00dcbung 11 Aufgabe 9 entf\u00e4llt 13. 27.-01.07.2022 ActionListener \u00dcbung 12 - - 14. 04.-08.07.2022 Mausereignisse \u00dcbung 13 - - 15. 11.-15.07.2022 Klausurvorbereitung keine Veranstaltungen!! 1 2 3 - - 20.07.2022 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 26.09.2022 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - - Inhalte \u00b6 04.-08.04.2022 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Einstieg siehe Aufgabe 1 Quellcode aus der Vorlesung package vorlesungen.vorlesung0406 ; import java.util.Arrays ; import javax.swing.JOptionPane ; public class Vorlesung0406 { public static void print () { System . out . println ( \"Endlich wieder Programmieren!\" ); } public static void input () { int auswahl = JOptionPane . showConfirmDialog ( null , \"Weiter machen?\" , \"Fenstertitel\" , JOptionPane . YES_NO_OPTION ); if ( auswahl == JOptionPane . YES_OPTION ) { // YES geklickt } else if ( auswahl == JOptionPane . NO_OPTION ) { // No geklickt } String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein : \" ); System . out . println ( \"Ihre Eingabe war \" + eingabe ); } public static void testArrays () { int [] a = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; String s = Arrays . toString ( a ); System . out . println ( s ); int [] b = { 11 , 12 , 3 , 14 , 5 , 6 , 17 , 8 , 19 }; for ( int index = 0 ; index < b . length ; index ++ ) { System . out . print ( b [ index ] + \" \" ); // b[index] = 5; } System . out . println (); for ( int element : b ) { System . out . print ( element + \" \" ); element = 5 ; } System . out . println (); Arrays . sort ( b ); System . out . println ( Arrays . toString ( b )); } public static void main ( String [] args ) { Vorlesung0406 . print (); testArrays (); input (); } } 11.-15.04.2022 - Wrapper-Klassen siehe Wrapper-Klassen (boxing und unboxing) siehe \u00dcbung 1 siehe Aufgabe 2 Quellcode aus der Vorlesung package vorlesungen.vorlesung1306 ; import javax.swing.JOptionPane ; public class Vorlesung1304 { static int divide ( int nr1 , int nr2 ) { return nr1 / nr2 ; } public static void main ( String [] args ) { // Wrapper-Klassen String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); // 1. Konstruktoren --> deprecated!!! nicht verwenden Integer i1 = new Integer ( 100 ); // int-Wert Integer i2 = new Integer ( \"100\" ); // Zahl als String Character c1 = new Character ( 'a' ); // Character c2 = new Character(\"a\"); Integer max = Integer . MAX_VALUE ; System . out . println ( max ); // 2. valueOf() Integer i3 = Integer . valueOf ( 100 ); Integer i4 = Integer . valueOf ( \"100\" ); // 3. Auto-Boxing Integer i5 = 100 ; System . out . println ( i5 ); Integer i6 = 1000 ; Integer i7 = 1000 ; Integer i8 = 1001 ; System . out . println ( i6 == i7 ); System . out . println ( i8 >= i7 ); Integer i9 = Integer . valueOf ( \"1000\" ); int i10 = i9 . intValue (); int i11 = Integer . valueOf ( \"1000\" ); int nrInput = Integer . valueOf ( eingabe ); System . out . println ( \"Sie haben \" + nrInput + \" eingegeben\" ); // Exceptions int nr1 = 7 ; int nr2 = 0 ; try { int result = divide ( nr1 , nr2 ); System . out . printf ( \"%4d / %4d = %3d %n\" , nr1 , nr2 , result ); } catch ( ArithmeticException e ) { System . out . println ( \"Division durch 0 ist nicht definiert\" ); // e.printStackTrace(); } System . out . println ( \"Programmende\" ); } } 18.-22.04.2022 - Exceptions I siehe Exceptions siehe \u00dcbung 2 Quellcode aus der Vorlesung - Klasse Vorlesung0420.java package vorlesungen.vorlesung0420 ; import javax.swing.JOptionPane ; public class Vorlesung0420 { public static int divide ( int a , int b ) { return ( a / b ); } public static int getAtIndex ( int [] arr , int index ) { return arr [ index ] ; } public static void main ( String [] args ) { int nr1 = 7 ; int nr2 = 0 ; int [] arr = { 1 , 2 , 3 , 4 , 5 , 6 }; int index = 6 ; try { int result = divide ( nr1 , nr2 ); System . out . printf ( \"%d / %d = %d %n\" , nr1 , nr2 , result ); int wert = getAtIndex ( arr , index ); System . out . println ( \"Wert : \" + wert ); } catch ( ArithmeticException e ) { System . out . println ( \"Divison durch 0 nicht definiert\" ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Ungueltiger Index\" ); } catch ( Exception e ) { } boolean eingabeOk = true ; while ( ! eingabeOk ) { String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein :\" ); try { int zahl = Integer . parseInt ( eingabe ); System . out . println ( \"Ihre Zahl \" + zahl ); eingabeOk = true ; } catch ( NumberFormatException e ) { System . out . println ( \"Eingabe war keine Zahl!\" ); } } try { Triangle t1 = new Triangle ( 3 , 4 , 0 ); t1 . print (); } catch ( Exception e ) { // TODO Auto-generated catch block System . out . println ( e . getMessage ());; } System . out . println ( \"Programmende\" ); } } Quellcode aus der Vorlesung - Klasse Triangle.java package vorlesungen.vorlesung0427 ; public class Triangle { private int a ; private int b ; private int c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"side lengths must be positive integers\" ); } else if ( a > ( b + c ) || b > ( a + c ) || c > ( a + b ) ) { throw new IllegalArgumentException ( \"no triangle \" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public int circumference () { return this . a + this . b + this . c ; } public double area () { double area = 0.0 ; double s = 0.5 * ( this . a + this . b + this . c ); area = Math . sqrt ( s * ( s - this . a ) * ( s - this . b ) * ( s - this . c )); return area ; } public boolean equilateral () { return this . a == this . b && this . b == this . c ; } public boolean isosceles () { return this . a == this . b || this . b == this . c || this . c == this . a ; } public void print () { System . out . println ( \"Seiten : a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c ); System . out . println ( \"Umfang : \" + this . circumference ()); System . out . println ( \"Flaecheninhalt : \" + this . area ()); if ( this . equilateral ()) { System . out . println ( \"Das Dreieck ist gleichseitig.\" ); } else { if ( this . isosceles ()) { System . out . println ( \"Das Dreieck ist gleichschenklig.\" ); } else { System . out . println ( \"Das Dreieck ist unregelmaessig.\" ); } } if ( this . isRightAngled ()) { System . out . println ( \"Das Dreieck ist rechtwinklig.\" ); } else { System . out . println ( \"Das Dreieck ist nicht rechtwinklig.\" ); } System . out . println (); } public boolean sameCircumference ( Triangle t ) { return this . circumference () == t . circumference (); } public boolean sidesAreEqual ( Triangle t ) { return ( this . a == t . a && this . b == t . b && this . c == t . c ) || ( this . a == t . b && this . b == t . c && this . c == t . a ) || ( this . a == t . c && this . b == t . a && this . c == t . b ); } public boolean isRightAngled () { return (( this . a * this . a == ( this . b * this . b + this . c * this . c )) || ( this . b * this . b == ( this . a * this . a + this . c * this . c )) || ( this . c * this . c == ( this . b * this . b + this . a * this . a ))); } public boolean isSmaller ( Triangle t ) { return this . area () < t . area (); } public boolean isBigger ( Triangle t ) { return this . area () > t . area (); } } 25.-29.04.2022 - Exceptions II siehe Exceptions siehe \u00dcbung 3 siehe Aufgabe 3 02.-06.05.2022 - Aufz\u00e4hlungstypen und mehrdimensionale Arrays siehe Aufz\u00e4hlungstypen siehe Mehrdimensionale Arrays siehe \u00dcbung 4 Quellcode aus der Vorlesung - Klasse Vorlesung0504.java package vorlesungen.vorlesung0504 ; public class Vorlesung0504 { public static void test () throws IllegalSideLengthException , IllegalTriangleException { Triangle t1 ; t1 = new Triangle ( 3 , 4 , 8 ); t1 . print (); } public static void main ( String [] args ) { try { test (); } catch ( IllegalSideLengthException | IllegalTriangleException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"Programmende\" ); Tag day = Tag . MONTAG ; if ( day == Tag . DIENSTAG ) { } int [][] zda = new int [ 3 ][ 4 ] ; for ( int row = 0 ; row < zda . length ; row ++ ) { for ( int col = 0 ; col < zda [ row ] . length ; col ++ ) { zda [ row ][ col ] = row * col ; } } System . out . println ( \"Laenge \" + zda . length ); for ( int row = 0 ; row < zda . length ; row ++ ) { for ( int col = 0 ; col < zda [ row ] . length ; col ++ ) { System . out . printf ( \"[%d][%d] \" , row , col ); } System . out . println (); } } } Quellcode aus der Vorlesung - Klasse IllegalTriangleException.java package vorlesungen.vorlesung0504 ; public class IllegalTriangleException extends RuntimeException { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides.\" ); } } Quellcode aus der Vorlesung - Klasse IllegalSideLengthException.java package vorlesungen.vorlesung0504 ; public class IllegalSideLengthException extends RuntimeException { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Each side has to be greater than zero!\" ); } } Quellcode aus der Vorlesung - Klasse Triangle.java package vorlesungen.vorlesung00504 ; public class Triangle { private int a ; private int b ; private int c ; public Triangle ( int a , int b , int c ) throws IllegalSideLengthException , IllegalTriangleException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalSideLengthException (); } else if ( a > ( b + c ) || b > ( a + c ) || c > ( a + b ) ) { throw new IllegalTriangleException (); } else { this . a = a ; this . b = b ; this . c = c ; } } } Quellcode aus der Vorlesung - enum Tag.java package vorlesungen.vorlesung0504 ; public enum Tag { MONTAG , DIENSTAG , MITTWOCH , DONNERSTAG , FREITAG , SAMSTAG , SONNTAG } Quellcode aus der Vorlesung - enum Player.java package vorlesungen.vorlesung0504 ; public enum Player { RED , BLACK } 09.-13.05.2022 - Collections Lists und Sets siehe Collections siehe \u00dcbung 6 siehe Aufgabe 4 Quellcode aus der Vorlesung - Klasse Vorlesung0511.java package vorlesungen.vorlesung0511 ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.LinkedList ; import java.util.List ; import java.util.Random ; import java.util.Set ; import java.util.TreeSet ; public class Vorlesung0511 { public static void main ( String [] args ) { List < Integer > list1 = new ArrayList <> (); List < String > list2 = new LinkedList <> (); Set < String > set1 = new HashSet <> (); Set < Integer > set2 = new TreeSet <> (); String str1 = \"erster\" ; String str2 = \"zweiter\" ; String str3 = \"dritter\" ; String str4 = \"zweiter\" ; System . out . printf ( \"%n%n----------- Elemente zu set1 hinzufuegen --------------%n%n\" ); System . out . println ( \"empty ? \" + set1 . isEmpty ()); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str1 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str2 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str3 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str4 )); System . out . println ( \"empty ? \" + set1 . isEmpty ()); System . out . println ( \"erster in set1 ? \" + set1 . contains ( \"erster\" )); System . out . println ( \"Laenge von set1 : \" + set1 . size ()); // set1.add(new Random()); // Fehler wg. Set<String> System . out . println ( \"Laenge von set1 : \" + set1 . size ()); set2 . add ( 3 ); // hier Auto-Boxing! set1 . add ( Integer . toString ( 1 )); System . out . printf ( \"%n%n----------- alle Elemente aus set1 ausgeben --------------%n%n\" ); for ( String element : set1 ) { System . out . println ( element ); } // set1.remove(\"dritter\"); // wuerde gehen System . out . printf ( \"%n%n----------- Iterator von set1 --------------%n%n\" ); Iterator < String > it = set1 . iterator (); while ( it . hasNext ()) { String next = it . next (); if ( next . equals ( \"dritter\" )) { it . remove (); // loescht aus set1 } System . out . println ( next ); } System . out . printf ( \"%n%n----------- nochmal alle Elemente aus set1 ausgeben --------------%n%n\" ); for ( String element : set1 ) { System . out . println ( element ); } System . out . printf ( \"%n%n----------- list1 --------------%n%n\" ); list1 . add ( 3 ); // Integer 3 hinzufuegen - Auto-Boxing! list1 . add ( 5 ); // Integer 5 hinzufuegen - Auto-Boxing! for ( Integer element : list1 ) { System . out . println ( element ); } System . out . println ( \"Element an Index 1 :\" + list1 . get ( 1 )); // System.out.println(list1.get(2)); list1 . add ( 4 ); // Integer 4 hinzufuegen - Auto-Boxing! for ( Integer element : list1 ) { System . out . println ( element ); } list1 . remove ( 1 ); // Integer-Objekt 5 Index 1 list1 . remove ( 1 ); // Integer-Objekt 4 Index 1 System . out . println ( \"size : \" + list1 . size ()); System . out . printf ( \"%n%n----------- nur noch die 3 in list1 --------------%n%n\" ); for ( Integer element : list1 ) { System . out . println ( element ); } System . out . println ( list1 . get ( 0 )); } } 16.-20.05.2022 - Collections Maps siehe Maps siehe \u00dcbung 7 siehe Aufgabe 5 Quellcode aus der Vorlesung - Klasse Vorlesung0518.java package vorlesungen.vorlesung0518 ; import java.util.ArrayList ; import java.util.Collection ; import java.util.HashMap ; import java.util.HashSet ; import java.util.List ; import java.util.Map ; import java.util.Set ; import java.util.TreeSet ; public class Vorlesung0518 { public static void print ( List < String > list ) { for ( String element : list ) { System . out . print ( element + \" \" ); } System . out . println (); } public static void print ( Set < String > set ) { for ( String element : set ) { System . out . print ( element + \" \" ); } System . out . println (); } public static void main ( String [] args ) { Set < String > set1 = new TreeSet <> (); set1 . add ( \"A\" ); set1 . add ( \"F\" ); set1 . add ( \"I\" ); set1 . add ( \"C\" ); Set < String > set2 = new TreeSet <> (); set2 . add ( \"D\" ); set2 . add ( \"G\" ); set2 . add ( \"Z\" ); set2 . add ( \"K\" ); print ( set1 ); print ( set2 ); set1 . addAll ( set2 ); print ( set1 ); set1 . retainAll ( set2 ); print ( set1 ); System . out . println ( set1 . equals ( set2 )); set1 . add ( \"H\" ); System . out . println ( set1 . equals ( set2 )); print ( set1 ); set1 . removeAll ( set2 ); print ( set1 ); Map < String , Double > myMap = new HashMap <> (); myMap . put ( \"s0512345\" , 1.7 ); myMap . put ( \"s0587654\" , 1.3 ); myMap . put ( \"s0512345\" , 2.3 ); Set < Map . Entry < String , Double >> dataSet = myMap . entrySet (); for ( Map . Entry < String , Double > entry : dataSet ) { System . out . println ( entry . getKey () + \" : \" + entry . getValue ()); } Set < String > keys = myMap . keySet (); for ( String key : keys ) { System . out . println ( key ); } Collection < Double > values = myMap . values (); for ( Double value : values ) { System . out . println ( value ); } } } 23.-27.05.2022 - Abstrakte Klassen siehe Abstrakte Klassen siehe \u00dcbung 7 siehe Aufgabe 5 Quellcode aus der Vorlesung - abstrakte Klasse Shape.java package vorlesungen.vorlesung0525 ; public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Rectangle.java package vorlesungen.vorlesung0525 ; public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return 2 * ( this . width + this . height ); } @Override public double area () { return this . height * this . width ; } } Circle.java package vorlesungen.vorlesung0525 ; public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } } Testklasse.java package vorlesungen.vorlesung0525 ; public class Testklasse { public static void printPerimeter ( Shape s ) { System . out . println ( \"perimeter : \" + s . perimeter () + \"cm\" ); } public static void printArea ( Shape s ) { System . out . println ( \"area : \" + s . area () + \"cm^2\" ); } public static double getSumPerimeters ( Shape [] shapes ) { double sumPerimeters = 0.0 ; for ( Shape s : shapes ) { sumPerimeters += s . perimeter (); } return sumPerimeters ; } public static void main ( String [] args ) { Rectangle r1 = new Rectangle ( 10 , 20 ); Shape r2 = new Rectangle ( 20 , 30 ); printPerimeter ( new Rectangle ( 20 , 30 )); printPerimeter ( r1 ); printPerimeter ( r2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = new Rectangle ( 20 , 30 ); shapes [ 1 ] = new Circle ( 5.0 ); shapes [ 2 ] = new Rectangle ( 11 , 22 ); shapes [ 3 ] = new Circle ( 15.0 ); System . out . println ( getSumPerimeters ( shapes )); } } 30.-03.06.2022 - Interfaces siehe Interfaces siehe \u00dcbung 8 siehe Aufgabe 6 Quellcode aus der Vorlesung - Testklasse.java package vorlesungen.vorlesung0601 ; public class Testklasse { public static void sort ( Comparable [] unsorted ) { for ( int bubble = 0 ; bubble < unsorted . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - 1 - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Rectangle ) unsorted [ index + 1 ] ) > 0 ) { Comparable tmp = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = unsorted [ index ] ; unsorted [ index ] = tmp ; } } } } public static void main ( String [] args ) { String s1 = \"Hallo\" ; String s2 = \"Ballo\" ; System . out . println ( s1 . compareTo ( s2 )); Rectangle [] rects = new Rectangle [ 4 ] ; rects [ 0 ] = new Rectangle ( 33 , 4 ); rects [ 1 ] = new Rectangle ( 4 , 43 ); rects [ 2 ] = new Rectangle ( 3 , 14 ); rects [ 3 ] = new Rectangle ( 23 , 4 ); System . out . printf ( \"%n----- unsortiert ------%n%n\" ); for ( Printable r : rects ) { r . print (); } /* if(rects instanceof Comparable[]) { System.out.println(\"ja\"); } */ sort ( rects ); System . out . printf ( \"%n----- sortiert ? ------%n%n\" ); for ( Printable r : rects ) { r . print (); } System . out . printf ( \"%n----- unsortiert ------%n%n\" ); Circle [] circs = new Circle [ 4 ] ; circs [ 0 ] = new Circle ( 4.0 ); circs [ 1 ] = new Circle ( 3.0 ); circs [ 2 ] = new Circle ( 5.0 ); circs [ 3 ] = new Circle ( 2.0 ); for ( Circle c : circs ) { c . print (); } sort ( circs ); System . out . printf ( \"%n----- sortiert ? ------%n%n\" ); for ( Circle c : circs ) { c . print (); } } } Rectangle.java package vorlesungen.vorlesung0601 ; public class Rectangle extends Shape implements Comparable < Rectangle > , Printable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return 2 * ( this . width + this . height ); } @Override public double area () { return this . height * this . width ; } @Override public int compareTo ( Rectangle o ) { return (( this . height + this . width ) - ( o . height + o . width )); } @Override public void print () { System . out . printf ( \"%2d x %2d = %7.2f %n\" , this . height , this . width , this . area ()); } } Circle.java package vorlesungen.vorlesung0601 ; public class Circle extends Shape implements Comparable < Circle > , Printable { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public void print () { System . out . printf ( \" r=%.2fcm, d=%.2fcm, a=%.2fcm %n\" , this . radius , this . perimeter (), this . area ()); } @Override public int compareTo ( Circle o ) { if ( this . radius > o . radius ) { return 1 ; } else if ( this . radius < o . radius ) { return - 1 ; } else { return 0 ; } } } Printable.java package vorlesungen.vorlesung0601 ; public interface Printable { public void print (); } 06.-10.06.2022 - GUI Einf\u00fchrung siehe GUI Einf\u00fchrung siehe \u00dcbung 9 (machen wir am 21. und 23.6.) siehe Aufgabe 7 (um eine Woche verl\u00e4ngert) Quellcode aus der Vorlesung - MyFirstWindow.java package vorlesungen.vorlesung0608 ; import java.awt.Color ; import java.awt.FlowLayout ; import javax.swing.* ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window!\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = initContent (); this . getContentPane (). add ( content ); this . setLocation ( 300 , 200 ); this . setSize ( 400 , 300 ); this . setVisible ( true ); } public JPanel initContent () { JPanel main = new JPanel (); main . setLayout ( new FlowLayout ( FlowLayout . LEFT , 120 , 130 )); main . setBackground ( Color . LIGHT_GRAY ); JButton btn1 = new JButton ( \"Button1\" ); main . add ( btn1 ); JButton btn2 = new JButton ( \"Button2\" ); main . add ( btn2 ); JButton btn3 = new JButton ( \"Button3\" ); main . add ( btn3 ); JButton btn4 = new JButton ( \"Button4 mit viel Text\" ); main . add ( btn4 ); JButton btn5 = new JButton ( \"1\" ); main . add ( btn5 ); JButton btn6 = new JButton (); main . add ( btn6 ); return main ; } } Testklasse.java package vorlesungen.vorlesung0608 ; public class Testklasse { public static void main ( String [] args ) { new MyFirstWindow (); } } 13.-17.06.2022 - Layout-Manager siehe Layout-Manager siehe \u00dcbung 9 siehe Aufgabe 7 Quellcode aus der Vorlesung - MySecondWindow.java package vorlesungen.vorlesung0615 ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.FlowLayout ; import java.awt.GridLayout ; import javax.swing.* ; public class MySecondWindow extends JFrame { public MySecondWindow () { super (); this . setTitle ( \"My first window!\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setLocation ( 300 , 200 ); this . setSize ( 400 , 300 ); this . setVisible ( true ); } public JPanel initContent () { JPanel main = new JPanel (); main . setLayout ( new BorderLayout ( 30 , 30 )); main . setBackground ( Color . BLUE ); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); main . add ( oben , BorderLayout . NORTH ); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); mitte . setBackground ( Color . GREEN ); main . add ( mitte , BorderLayout . CENTER ); JLabel lab1 = new JLabel ( \"Name : \" ); oben . add ( lab1 ); JTextField tf = new JTextField ( 20 ); oben . add ( tf ); JButton [] btnArr = new JButton [ 18 ] ; for ( int i = 0 ; i < btnArr . length ; i ++ ) { btnArr [ i ] = new JButton (( i + 1 ) + \"\" ); mitte . add ( btnArr [ i ] ); } JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 10 , 10 )); JButton okBtn = new JButton ( \"Ok\" ); unten . add ( okBtn ); JButton cnclBtn = new JButton ( \"Cancel\" ); unten . add ( cnclBtn ); JRadioButton rb = new JRadioButton (); unten . add ( rb ); JCheckBox cb = new JCheckBox (); unten . add ( cb ); JPanel links = new JPanel (); JPanel rechts = new JPanel (); main . add ( links , BorderLayout . WEST ); main . add ( rechts , BorderLayout . EAST ); main . add ( unten , BorderLayout . SOUTH ); /* JButton btn1 = new JButton(\"NORTH\"); main.add(btn1, BorderLayout.NORTH); JButton btn2 = new JButton(\"Button2\"); main.add(btn2, BorderLayout.WEST); JButton btn3 = new JButton(\"Button3\"); main.add(btn3, BorderLayout.EAST); JButton btn4 = new JButton(\"Button4 mit viel Text\"); main.add(btn4, BorderLayout.SOUTH); JButton btn5 = new JButton(\"1\"); main.add(btn5); JButton btn6 = new JButton(); main.add(btn6); JButton btn7 = new JButton(\"Button 7\"); main.add(btn7, BorderLayout.CENTER); */ return main ; } } Testklasse.java package vorlesungen.vorlesung0615 ; public class Testklasse { public static void main ( String [] args ) { new MySecondWindow (); } } 20.-24.06.2022 - GUI Ereignisse siehe GUI Ereignisse siehe \u00dcbung 11 siehe Aufgabe 8 siehe Video zu GUI Ereignisse - Vorlesung aus dem Vorjahr Quellcode aus dem Video Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { Integer anzKlicks = 0 ; JLabel unten ; public Ereignisbehandlung (){ super (); this . setTitle ( \"Ereignisbehandlung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 200 , 150 ); this . setLocation ( 200 , 100 ); this . setVisible ( true ); } public JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); plus . addActionListener ( this ); minus . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); this . unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . unten . setHorizontalAlignment ( JLabel . CENTER ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( unten , BorderLayout . CENTER ); return mainPanel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); // hat ActionEvent ausgeloest if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; System . out . println ( \"Minus-Button geklickt ... \" + this . anzKlicks ); } else if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; System . out . println ( \"Plus-Button geklickt ... \" + this . anzKlicks ); } this . unten . setText ( this . anzKlicks . toString ()); } } } 27.-01.07.2022 - ActionListener siehe GUI Ereignisse siehe \u00dcbung 11 siehe Aufgabe 8 Quellcode aus Vorlesung Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); minus . setActionCommand ( \"minus\" ); JButton plus = new JButton ( \"+\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks ++ ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } class ActionHandler implements ActionListener { Integer anzKlicks ; @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { Ereignisbehandlung . this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { Ereignisbehandlung . this . anzKlicks -- ; } } Ereignisbehandlung . this . unten . setText ( anzKlicks . toString ()); } } public static void main ( String [] args ) { new Ereignisbehandlung (); } } 04.-08.07.2022 - MouseListener siehe Mausereignisse siehe \u00dcbung 12 siehe Aufgabe 8 Quellcode aus Vorlesung Mausereignisse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 package vorlesungen.vorlesung0706 ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panel . addMouseListener ( this ); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); this . panels [ row ][ col ] . addMouseListener ( new MouseListener () { @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"einzelnes clicked\" ); Object src = e . getSource (); if ( src instanceof JPanel ) { JPanel here = ( JPanel ) src ; here . setBackground ( Mausereignisse . this . randomColor ()); } } @Override public void mousePressed ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseReleased ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); int width = this . panel . getWidth (); int height = this . panel . getHeight (); int panelWidth = width / this . size ; int panelHeight = height / this . size ; int row = y / panelHeight ; int col = x / panelWidth ; System . out . println ( \"mouse clicked [x=\" + x + \", y=\" + y + \"]\" ); System . out . println ( \"width : \" + width + \", height : \" + height ); System . out . println ( \"row : \" + row + \" , col : \" + col ); this . panels [ row ][ col ] . setBackground ( randomColor ()); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mouse pressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouse released\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouse entered\" ); for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] . setBackground ( randomColor ()); } } } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouse exited\" ); } }","title":"Home"},{"location":"#programmieren-ii","text":"Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren II"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht. Solange Pr\u00e4senzveranstaltungen m\u00f6glich sind, werden wir die Veranstaltungen auch in Pr\u00e4senz durchf\u00fchren. Es werden keine Videos erstellt. Das Skript wird f\u00fcr die jeweils kommende Woche freitags hochgeladen. Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die kommende Woche als auch die neue Aufgabe hochgeladen. Die \u00dcbung (und die vergangene Aufgabe) werden dienstags (14-15.30 Uhr) bzw. donnerstags (14-15.30 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen). Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben. Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Zus\u00e4tzlich sollten Sie f\u00fcr mindestens 5 fremde L\u00f6sungen Code-reviews erstellen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!","title":"Organisatorisches"},{"location":"#grober-inhalt-kann-sich-noch-andern","text":"Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 04.-08.04.2022 Organisatorisches , Wiederholung , Einstieg - - - 1. 11.-15.04.2022 Wrapper-Klassen (boxing und unboxing) \u00dcbung 1 Aufgabe 1 25.04.2022 2. 18.-22.04.2022 Exceptions I \u00dcbung 2 Aufgabe 2 02.05.2022 3. 25.-29.04.2022 Aufgabe 2 besprochen \u00dcbung 3 Aufgabe 3 16.05.2022 4. 02.-06.05.2022 Exceptions II \u00dcbung 4 Aufgabe 4 23.05.2022 5. 09.-13.05.2022 Collections (List und Set) \u00dcbung 5 Aufgabe 5 30.05.2022 6. 16.-20.05.2022 Collections (Map) \u00dcbung 6 - - 7. 23.-27.05.2022 Abstrakte Klassen \u00dcbung 7 Aufgabe 6 06.06.2022 8. 30.-03.06.2022 Interfaces \u00dcbung 8 - 20.06.2022 9. 06.-10.06.2022 GUI Einf\u00fchrung - Aufgabe 7 27.06.2022 10. 13.-17.06.2022 JUnit und Layout-Manager \u00dcbung 10 \u00dcbung 9 Aufgabe 8 04.07.2022 12. 20.-24.06.2022 GUI Ereignisse \u00dcbung 11 Aufgabe 9 entf\u00e4llt 13. 27.-01.07.2022 ActionListener \u00dcbung 12 - - 14. 04.-08.07.2022 Mausereignisse \u00dcbung 13 - - 15. 11.-15.07.2022 Klausurvorbereitung keine Veranstaltungen!! 1 2 3 - - 20.07.2022 14:00 Uhr Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - 26.09.2022 14:00 Uhr Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - -","title":"Grober Inhalt (kann sich noch \u00e4ndern)"},{"location":"#inhalte","text":"04.-08.04.2022 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Einstieg siehe Aufgabe 1 Quellcode aus der Vorlesung package vorlesungen.vorlesung0406 ; import java.util.Arrays ; import javax.swing.JOptionPane ; public class Vorlesung0406 { public static void print () { System . out . println ( \"Endlich wieder Programmieren!\" ); } public static void input () { int auswahl = JOptionPane . showConfirmDialog ( null , \"Weiter machen?\" , \"Fenstertitel\" , JOptionPane . YES_NO_OPTION ); if ( auswahl == JOptionPane . YES_OPTION ) { // YES geklickt } else if ( auswahl == JOptionPane . NO_OPTION ) { // No geklickt } String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein : \" ); System . out . println ( \"Ihre Eingabe war \" + eingabe ); } public static void testArrays () { int [] a = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; String s = Arrays . toString ( a ); System . out . println ( s ); int [] b = { 11 , 12 , 3 , 14 , 5 , 6 , 17 , 8 , 19 }; for ( int index = 0 ; index < b . length ; index ++ ) { System . out . print ( b [ index ] + \" \" ); // b[index] = 5; } System . out . println (); for ( int element : b ) { System . out . print ( element + \" \" ); element = 5 ; } System . out . println (); Arrays . sort ( b ); System . out . println ( Arrays . toString ( b )); } public static void main ( String [] args ) { Vorlesung0406 . print (); testArrays (); input (); } } 11.-15.04.2022 - Wrapper-Klassen siehe Wrapper-Klassen (boxing und unboxing) siehe \u00dcbung 1 siehe Aufgabe 2 Quellcode aus der Vorlesung package vorlesungen.vorlesung1306 ; import javax.swing.JOptionPane ; public class Vorlesung1304 { static int divide ( int nr1 , int nr2 ) { return nr1 / nr2 ; } public static void main ( String [] args ) { // Wrapper-Klassen String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); // 1. Konstruktoren --> deprecated!!! nicht verwenden Integer i1 = new Integer ( 100 ); // int-Wert Integer i2 = new Integer ( \"100\" ); // Zahl als String Character c1 = new Character ( 'a' ); // Character c2 = new Character(\"a\"); Integer max = Integer . MAX_VALUE ; System . out . println ( max ); // 2. valueOf() Integer i3 = Integer . valueOf ( 100 ); Integer i4 = Integer . valueOf ( \"100\" ); // 3. Auto-Boxing Integer i5 = 100 ; System . out . println ( i5 ); Integer i6 = 1000 ; Integer i7 = 1000 ; Integer i8 = 1001 ; System . out . println ( i6 == i7 ); System . out . println ( i8 >= i7 ); Integer i9 = Integer . valueOf ( \"1000\" ); int i10 = i9 . intValue (); int i11 = Integer . valueOf ( \"1000\" ); int nrInput = Integer . valueOf ( eingabe ); System . out . println ( \"Sie haben \" + nrInput + \" eingegeben\" ); // Exceptions int nr1 = 7 ; int nr2 = 0 ; try { int result = divide ( nr1 , nr2 ); System . out . printf ( \"%4d / %4d = %3d %n\" , nr1 , nr2 , result ); } catch ( ArithmeticException e ) { System . out . println ( \"Division durch 0 ist nicht definiert\" ); // e.printStackTrace(); } System . out . println ( \"Programmende\" ); } } 18.-22.04.2022 - Exceptions I siehe Exceptions siehe \u00dcbung 2 Quellcode aus der Vorlesung - Klasse Vorlesung0420.java package vorlesungen.vorlesung0420 ; import javax.swing.JOptionPane ; public class Vorlesung0420 { public static int divide ( int a , int b ) { return ( a / b ); } public static int getAtIndex ( int [] arr , int index ) { return arr [ index ] ; } public static void main ( String [] args ) { int nr1 = 7 ; int nr2 = 0 ; int [] arr = { 1 , 2 , 3 , 4 , 5 , 6 }; int index = 6 ; try { int result = divide ( nr1 , nr2 ); System . out . printf ( \"%d / %d = %d %n\" , nr1 , nr2 , result ); int wert = getAtIndex ( arr , index ); System . out . println ( \"Wert : \" + wert ); } catch ( ArithmeticException e ) { System . out . println ( \"Divison durch 0 nicht definiert\" ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Ungueltiger Index\" ); } catch ( Exception e ) { } boolean eingabeOk = true ; while ( ! eingabeOk ) { String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein :\" ); try { int zahl = Integer . parseInt ( eingabe ); System . out . println ( \"Ihre Zahl \" + zahl ); eingabeOk = true ; } catch ( NumberFormatException e ) { System . out . println ( \"Eingabe war keine Zahl!\" ); } } try { Triangle t1 = new Triangle ( 3 , 4 , 0 ); t1 . print (); } catch ( Exception e ) { // TODO Auto-generated catch block System . out . println ( e . getMessage ());; } System . out . println ( \"Programmende\" ); } } Quellcode aus der Vorlesung - Klasse Triangle.java package vorlesungen.vorlesung0427 ; public class Triangle { private int a ; private int b ; private int c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"side lengths must be positive integers\" ); } else if ( a > ( b + c ) || b > ( a + c ) || c > ( a + b ) ) { throw new IllegalArgumentException ( \"no triangle \" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public int circumference () { return this . a + this . b + this . c ; } public double area () { double area = 0.0 ; double s = 0.5 * ( this . a + this . b + this . c ); area = Math . sqrt ( s * ( s - this . a ) * ( s - this . b ) * ( s - this . c )); return area ; } public boolean equilateral () { return this . a == this . b && this . b == this . c ; } public boolean isosceles () { return this . a == this . b || this . b == this . c || this . c == this . a ; } public void print () { System . out . println ( \"Seiten : a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c ); System . out . println ( \"Umfang : \" + this . circumference ()); System . out . println ( \"Flaecheninhalt : \" + this . area ()); if ( this . equilateral ()) { System . out . println ( \"Das Dreieck ist gleichseitig.\" ); } else { if ( this . isosceles ()) { System . out . println ( \"Das Dreieck ist gleichschenklig.\" ); } else { System . out . println ( \"Das Dreieck ist unregelmaessig.\" ); } } if ( this . isRightAngled ()) { System . out . println ( \"Das Dreieck ist rechtwinklig.\" ); } else { System . out . println ( \"Das Dreieck ist nicht rechtwinklig.\" ); } System . out . println (); } public boolean sameCircumference ( Triangle t ) { return this . circumference () == t . circumference (); } public boolean sidesAreEqual ( Triangle t ) { return ( this . a == t . a && this . b == t . b && this . c == t . c ) || ( this . a == t . b && this . b == t . c && this . c == t . a ) || ( this . a == t . c && this . b == t . a && this . c == t . b ); } public boolean isRightAngled () { return (( this . a * this . a == ( this . b * this . b + this . c * this . c )) || ( this . b * this . b == ( this . a * this . a + this . c * this . c )) || ( this . c * this . c == ( this . b * this . b + this . a * this . a ))); } public boolean isSmaller ( Triangle t ) { return this . area () < t . area (); } public boolean isBigger ( Triangle t ) { return this . area () > t . area (); } } 25.-29.04.2022 - Exceptions II siehe Exceptions siehe \u00dcbung 3 siehe Aufgabe 3 02.-06.05.2022 - Aufz\u00e4hlungstypen und mehrdimensionale Arrays siehe Aufz\u00e4hlungstypen siehe Mehrdimensionale Arrays siehe \u00dcbung 4 Quellcode aus der Vorlesung - Klasse Vorlesung0504.java package vorlesungen.vorlesung0504 ; public class Vorlesung0504 { public static void test () throws IllegalSideLengthException , IllegalTriangleException { Triangle t1 ; t1 = new Triangle ( 3 , 4 , 8 ); t1 . print (); } public static void main ( String [] args ) { try { test (); } catch ( IllegalSideLengthException | IllegalTriangleException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"Programmende\" ); Tag day = Tag . MONTAG ; if ( day == Tag . DIENSTAG ) { } int [][] zda = new int [ 3 ][ 4 ] ; for ( int row = 0 ; row < zda . length ; row ++ ) { for ( int col = 0 ; col < zda [ row ] . length ; col ++ ) { zda [ row ][ col ] = row * col ; } } System . out . println ( \"Laenge \" + zda . length ); for ( int row = 0 ; row < zda . length ; row ++ ) { for ( int col = 0 ; col < zda [ row ] . length ; col ++ ) { System . out . printf ( \"[%d][%d] \" , row , col ); } System . out . println (); } } } Quellcode aus der Vorlesung - Klasse IllegalTriangleException.java package vorlesungen.vorlesung0504 ; public class IllegalTriangleException extends RuntimeException { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides.\" ); } } Quellcode aus der Vorlesung - Klasse IllegalSideLengthException.java package vorlesungen.vorlesung0504 ; public class IllegalSideLengthException extends RuntimeException { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Each side has to be greater than zero!\" ); } } Quellcode aus der Vorlesung - Klasse Triangle.java package vorlesungen.vorlesung00504 ; public class Triangle { private int a ; private int b ; private int c ; public Triangle ( int a , int b , int c ) throws IllegalSideLengthException , IllegalTriangleException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalSideLengthException (); } else if ( a > ( b + c ) || b > ( a + c ) || c > ( a + b ) ) { throw new IllegalTriangleException (); } else { this . a = a ; this . b = b ; this . c = c ; } } } Quellcode aus der Vorlesung - enum Tag.java package vorlesungen.vorlesung0504 ; public enum Tag { MONTAG , DIENSTAG , MITTWOCH , DONNERSTAG , FREITAG , SAMSTAG , SONNTAG } Quellcode aus der Vorlesung - enum Player.java package vorlesungen.vorlesung0504 ; public enum Player { RED , BLACK } 09.-13.05.2022 - Collections Lists und Sets siehe Collections siehe \u00dcbung 6 siehe Aufgabe 4 Quellcode aus der Vorlesung - Klasse Vorlesung0511.java package vorlesungen.vorlesung0511 ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.LinkedList ; import java.util.List ; import java.util.Random ; import java.util.Set ; import java.util.TreeSet ; public class Vorlesung0511 { public static void main ( String [] args ) { List < Integer > list1 = new ArrayList <> (); List < String > list2 = new LinkedList <> (); Set < String > set1 = new HashSet <> (); Set < Integer > set2 = new TreeSet <> (); String str1 = \"erster\" ; String str2 = \"zweiter\" ; String str3 = \"dritter\" ; String str4 = \"zweiter\" ; System . out . printf ( \"%n%n----------- Elemente zu set1 hinzufuegen --------------%n%n\" ); System . out . println ( \"empty ? \" + set1 . isEmpty ()); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str1 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str2 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str3 )); System . out . println ( \"hinzugefuegt ? \" + set1 . add ( str4 )); System . out . println ( \"empty ? \" + set1 . isEmpty ()); System . out . println ( \"erster in set1 ? \" + set1 . contains ( \"erster\" )); System . out . println ( \"Laenge von set1 : \" + set1 . size ()); // set1.add(new Random()); // Fehler wg. Set<String> System . out . println ( \"Laenge von set1 : \" + set1 . size ()); set2 . add ( 3 ); // hier Auto-Boxing! set1 . add ( Integer . toString ( 1 )); System . out . printf ( \"%n%n----------- alle Elemente aus set1 ausgeben --------------%n%n\" ); for ( String element : set1 ) { System . out . println ( element ); } // set1.remove(\"dritter\"); // wuerde gehen System . out . printf ( \"%n%n----------- Iterator von set1 --------------%n%n\" ); Iterator < String > it = set1 . iterator (); while ( it . hasNext ()) { String next = it . next (); if ( next . equals ( \"dritter\" )) { it . remove (); // loescht aus set1 } System . out . println ( next ); } System . out . printf ( \"%n%n----------- nochmal alle Elemente aus set1 ausgeben --------------%n%n\" ); for ( String element : set1 ) { System . out . println ( element ); } System . out . printf ( \"%n%n----------- list1 --------------%n%n\" ); list1 . add ( 3 ); // Integer 3 hinzufuegen - Auto-Boxing! list1 . add ( 5 ); // Integer 5 hinzufuegen - Auto-Boxing! for ( Integer element : list1 ) { System . out . println ( element ); } System . out . println ( \"Element an Index 1 :\" + list1 . get ( 1 )); // System.out.println(list1.get(2)); list1 . add ( 4 ); // Integer 4 hinzufuegen - Auto-Boxing! for ( Integer element : list1 ) { System . out . println ( element ); } list1 . remove ( 1 ); // Integer-Objekt 5 Index 1 list1 . remove ( 1 ); // Integer-Objekt 4 Index 1 System . out . println ( \"size : \" + list1 . size ()); System . out . printf ( \"%n%n----------- nur noch die 3 in list1 --------------%n%n\" ); for ( Integer element : list1 ) { System . out . println ( element ); } System . out . println ( list1 . get ( 0 )); } } 16.-20.05.2022 - Collections Maps siehe Maps siehe \u00dcbung 7 siehe Aufgabe 5 Quellcode aus der Vorlesung - Klasse Vorlesung0518.java package vorlesungen.vorlesung0518 ; import java.util.ArrayList ; import java.util.Collection ; import java.util.HashMap ; import java.util.HashSet ; import java.util.List ; import java.util.Map ; import java.util.Set ; import java.util.TreeSet ; public class Vorlesung0518 { public static void print ( List < String > list ) { for ( String element : list ) { System . out . print ( element + \" \" ); } System . out . println (); } public static void print ( Set < String > set ) { for ( String element : set ) { System . out . print ( element + \" \" ); } System . out . println (); } public static void main ( String [] args ) { Set < String > set1 = new TreeSet <> (); set1 . add ( \"A\" ); set1 . add ( \"F\" ); set1 . add ( \"I\" ); set1 . add ( \"C\" ); Set < String > set2 = new TreeSet <> (); set2 . add ( \"D\" ); set2 . add ( \"G\" ); set2 . add ( \"Z\" ); set2 . add ( \"K\" ); print ( set1 ); print ( set2 ); set1 . addAll ( set2 ); print ( set1 ); set1 . retainAll ( set2 ); print ( set1 ); System . out . println ( set1 . equals ( set2 )); set1 . add ( \"H\" ); System . out . println ( set1 . equals ( set2 )); print ( set1 ); set1 . removeAll ( set2 ); print ( set1 ); Map < String , Double > myMap = new HashMap <> (); myMap . put ( \"s0512345\" , 1.7 ); myMap . put ( \"s0587654\" , 1.3 ); myMap . put ( \"s0512345\" , 2.3 ); Set < Map . Entry < String , Double >> dataSet = myMap . entrySet (); for ( Map . Entry < String , Double > entry : dataSet ) { System . out . println ( entry . getKey () + \" : \" + entry . getValue ()); } Set < String > keys = myMap . keySet (); for ( String key : keys ) { System . out . println ( key ); } Collection < Double > values = myMap . values (); for ( Double value : values ) { System . out . println ( value ); } } } 23.-27.05.2022 - Abstrakte Klassen siehe Abstrakte Klassen siehe \u00dcbung 7 siehe Aufgabe 5 Quellcode aus der Vorlesung - abstrakte Klasse Shape.java package vorlesungen.vorlesung0525 ; public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Rectangle.java package vorlesungen.vorlesung0525 ; public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return 2 * ( this . width + this . height ); } @Override public double area () { return this . height * this . width ; } } Circle.java package vorlesungen.vorlesung0525 ; public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } } Testklasse.java package vorlesungen.vorlesung0525 ; public class Testklasse { public static void printPerimeter ( Shape s ) { System . out . println ( \"perimeter : \" + s . perimeter () + \"cm\" ); } public static void printArea ( Shape s ) { System . out . println ( \"area : \" + s . area () + \"cm^2\" ); } public static double getSumPerimeters ( Shape [] shapes ) { double sumPerimeters = 0.0 ; for ( Shape s : shapes ) { sumPerimeters += s . perimeter (); } return sumPerimeters ; } public static void main ( String [] args ) { Rectangle r1 = new Rectangle ( 10 , 20 ); Shape r2 = new Rectangle ( 20 , 30 ); printPerimeter ( new Rectangle ( 20 , 30 )); printPerimeter ( r1 ); printPerimeter ( r2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = new Rectangle ( 20 , 30 ); shapes [ 1 ] = new Circle ( 5.0 ); shapes [ 2 ] = new Rectangle ( 11 , 22 ); shapes [ 3 ] = new Circle ( 15.0 ); System . out . println ( getSumPerimeters ( shapes )); } } 30.-03.06.2022 - Interfaces siehe Interfaces siehe \u00dcbung 8 siehe Aufgabe 6 Quellcode aus der Vorlesung - Testklasse.java package vorlesungen.vorlesung0601 ; public class Testklasse { public static void sort ( Comparable [] unsorted ) { for ( int bubble = 0 ; bubble < unsorted . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - 1 - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Rectangle ) unsorted [ index + 1 ] ) > 0 ) { Comparable tmp = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = unsorted [ index ] ; unsorted [ index ] = tmp ; } } } } public static void main ( String [] args ) { String s1 = \"Hallo\" ; String s2 = \"Ballo\" ; System . out . println ( s1 . compareTo ( s2 )); Rectangle [] rects = new Rectangle [ 4 ] ; rects [ 0 ] = new Rectangle ( 33 , 4 ); rects [ 1 ] = new Rectangle ( 4 , 43 ); rects [ 2 ] = new Rectangle ( 3 , 14 ); rects [ 3 ] = new Rectangle ( 23 , 4 ); System . out . printf ( \"%n----- unsortiert ------%n%n\" ); for ( Printable r : rects ) { r . print (); } /* if(rects instanceof Comparable[]) { System.out.println(\"ja\"); } */ sort ( rects ); System . out . printf ( \"%n----- sortiert ? ------%n%n\" ); for ( Printable r : rects ) { r . print (); } System . out . printf ( \"%n----- unsortiert ------%n%n\" ); Circle [] circs = new Circle [ 4 ] ; circs [ 0 ] = new Circle ( 4.0 ); circs [ 1 ] = new Circle ( 3.0 ); circs [ 2 ] = new Circle ( 5.0 ); circs [ 3 ] = new Circle ( 2.0 ); for ( Circle c : circs ) { c . print (); } sort ( circs ); System . out . printf ( \"%n----- sortiert ? ------%n%n\" ); for ( Circle c : circs ) { c . print (); } } } Rectangle.java package vorlesungen.vorlesung0601 ; public class Rectangle extends Shape implements Comparable < Rectangle > , Printable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return 2 * ( this . width + this . height ); } @Override public double area () { return this . height * this . width ; } @Override public int compareTo ( Rectangle o ) { return (( this . height + this . width ) - ( o . height + o . width )); } @Override public void print () { System . out . printf ( \"%2d x %2d = %7.2f %n\" , this . height , this . width , this . area ()); } } Circle.java package vorlesungen.vorlesung0601 ; public class Circle extends Shape implements Comparable < Circle > , Printable { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public void print () { System . out . printf ( \" r=%.2fcm, d=%.2fcm, a=%.2fcm %n\" , this . radius , this . perimeter (), this . area ()); } @Override public int compareTo ( Circle o ) { if ( this . radius > o . radius ) { return 1 ; } else if ( this . radius < o . radius ) { return - 1 ; } else { return 0 ; } } } Printable.java package vorlesungen.vorlesung0601 ; public interface Printable { public void print (); } 06.-10.06.2022 - GUI Einf\u00fchrung siehe GUI Einf\u00fchrung siehe \u00dcbung 9 (machen wir am 21. und 23.6.) siehe Aufgabe 7 (um eine Woche verl\u00e4ngert) Quellcode aus der Vorlesung - MyFirstWindow.java package vorlesungen.vorlesung0608 ; import java.awt.Color ; import java.awt.FlowLayout ; import javax.swing.* ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window!\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = initContent (); this . getContentPane (). add ( content ); this . setLocation ( 300 , 200 ); this . setSize ( 400 , 300 ); this . setVisible ( true ); } public JPanel initContent () { JPanel main = new JPanel (); main . setLayout ( new FlowLayout ( FlowLayout . LEFT , 120 , 130 )); main . setBackground ( Color . LIGHT_GRAY ); JButton btn1 = new JButton ( \"Button1\" ); main . add ( btn1 ); JButton btn2 = new JButton ( \"Button2\" ); main . add ( btn2 ); JButton btn3 = new JButton ( \"Button3\" ); main . add ( btn3 ); JButton btn4 = new JButton ( \"Button4 mit viel Text\" ); main . add ( btn4 ); JButton btn5 = new JButton ( \"1\" ); main . add ( btn5 ); JButton btn6 = new JButton (); main . add ( btn6 ); return main ; } } Testklasse.java package vorlesungen.vorlesung0608 ; public class Testklasse { public static void main ( String [] args ) { new MyFirstWindow (); } } 13.-17.06.2022 - Layout-Manager siehe Layout-Manager siehe \u00dcbung 9 siehe Aufgabe 7 Quellcode aus der Vorlesung - MySecondWindow.java package vorlesungen.vorlesung0615 ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.FlowLayout ; import java.awt.GridLayout ; import javax.swing.* ; public class MySecondWindow extends JFrame { public MySecondWindow () { super (); this . setTitle ( \"My first window!\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setLocation ( 300 , 200 ); this . setSize ( 400 , 300 ); this . setVisible ( true ); } public JPanel initContent () { JPanel main = new JPanel (); main . setLayout ( new BorderLayout ( 30 , 30 )); main . setBackground ( Color . BLUE ); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); main . add ( oben , BorderLayout . NORTH ); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); mitte . setBackground ( Color . GREEN ); main . add ( mitte , BorderLayout . CENTER ); JLabel lab1 = new JLabel ( \"Name : \" ); oben . add ( lab1 ); JTextField tf = new JTextField ( 20 ); oben . add ( tf ); JButton [] btnArr = new JButton [ 18 ] ; for ( int i = 0 ; i < btnArr . length ; i ++ ) { btnArr [ i ] = new JButton (( i + 1 ) + \"\" ); mitte . add ( btnArr [ i ] ); } JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 10 , 10 )); JButton okBtn = new JButton ( \"Ok\" ); unten . add ( okBtn ); JButton cnclBtn = new JButton ( \"Cancel\" ); unten . add ( cnclBtn ); JRadioButton rb = new JRadioButton (); unten . add ( rb ); JCheckBox cb = new JCheckBox (); unten . add ( cb ); JPanel links = new JPanel (); JPanel rechts = new JPanel (); main . add ( links , BorderLayout . WEST ); main . add ( rechts , BorderLayout . EAST ); main . add ( unten , BorderLayout . SOUTH ); /* JButton btn1 = new JButton(\"NORTH\"); main.add(btn1, BorderLayout.NORTH); JButton btn2 = new JButton(\"Button2\"); main.add(btn2, BorderLayout.WEST); JButton btn3 = new JButton(\"Button3\"); main.add(btn3, BorderLayout.EAST); JButton btn4 = new JButton(\"Button4 mit viel Text\"); main.add(btn4, BorderLayout.SOUTH); JButton btn5 = new JButton(\"1\"); main.add(btn5); JButton btn6 = new JButton(); main.add(btn6); JButton btn7 = new JButton(\"Button 7\"); main.add(btn7, BorderLayout.CENTER); */ return main ; } } Testklasse.java package vorlesungen.vorlesung0615 ; public class Testklasse { public static void main ( String [] args ) { new MySecondWindow (); } } 20.-24.06.2022 - GUI Ereignisse siehe GUI Ereignisse siehe \u00dcbung 11 siehe Aufgabe 8 siehe Video zu GUI Ereignisse - Vorlesung aus dem Vorjahr Quellcode aus dem Video Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { Integer anzKlicks = 0 ; JLabel unten ; public Ereignisbehandlung (){ super (); this . setTitle ( \"Ereignisbehandlung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 200 , 150 ); this . setLocation ( 200 , 100 ); this . setVisible ( true ); } public JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); plus . addActionListener ( this ); minus . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); this . unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . unten . setHorizontalAlignment ( JLabel . CENTER ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( unten , BorderLayout . CENTER ); return mainPanel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); // hat ActionEvent ausgeloest if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; System . out . println ( \"Minus-Button geklickt ... \" + this . anzKlicks ); } else if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; System . out . println ( \"Plus-Button geklickt ... \" + this . anzKlicks ); } this . unten . setText ( this . anzKlicks . toString ()); } } } 27.-01.07.2022 - ActionListener siehe GUI Ereignisse siehe \u00dcbung 11 siehe Aufgabe 8 Quellcode aus Vorlesung Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); minus . setActionCommand ( \"minus\" ); JButton plus = new JButton ( \"+\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks ++ ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } class ActionHandler implements ActionListener { Integer anzKlicks ; @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { Ereignisbehandlung . this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { Ereignisbehandlung . this . anzKlicks -- ; } } Ereignisbehandlung . this . unten . setText ( anzKlicks . toString ()); } } public static void main ( String [] args ) { new Ereignisbehandlung (); } } 04.-08.07.2022 - MouseListener siehe Mausereignisse siehe \u00dcbung 12 siehe Aufgabe 8 Quellcode aus Vorlesung Mausereignisse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 package vorlesungen.vorlesung0706 ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panel . addMouseListener ( this ); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); this . panels [ row ][ col ] . addMouseListener ( new MouseListener () { @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"einzelnes clicked\" ); Object src = e . getSource (); if ( src instanceof JPanel ) { JPanel here = ( JPanel ) src ; here . setBackground ( Mausereignisse . this . randomColor ()); } } @Override public void mousePressed ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseReleased ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); int width = this . panel . getWidth (); int height = this . panel . getHeight (); int panelWidth = width / this . size ; int panelHeight = height / this . size ; int row = y / panelHeight ; int col = x / panelWidth ; System . out . println ( \"mouse clicked [x=\" + x + \", y=\" + y + \"]\" ); System . out . println ( \"width : \" + width + \", height : \" + height ); System . out . println ( \"row : \" + row + \" , col : \" + col ); this . panels [ row ][ col ] . setBackground ( randomColor ()); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mouse pressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouse released\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouse entered\" ); for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] . setBackground ( randomColor ()); } } } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouse exited\" ); } }","title":"Inhalte"},{"location":"abstrakt/","text":"Abstrakte Klassen \u00b6 Abstrakte Klassen haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von Collection anschauen, dann finden wir darin Interfaces : die Klassen Collection , List , Set , SortedSet und NavigableSet sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und Abtrakte Klassen : die Klassen AbstractCollection , AbstractList und AbstractSet sind solche abstrakten Klassen (die schauen wir uns jetzt an) Klassen - allgemein \u00b6 Wir haben uns bis jetzt Klassen erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt. Angenommen, in der Klasse wurde eine Methode implementiert public void eineImplementierteMethode () { // Anweisungen } , dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren refVariable.eineImplementierteMethode(); . Klassen - abstrakt \u00b6 Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen . Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen alle Eigenschaften erben zu lassen. Der dritte obere Punkt gilt nicht ! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen . Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abstrakte Methoden \u00b6 Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon): public abstract void eineAbstrakteMethode (); Das Schl\u00fcsselwort abstract gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, wie der Name der Methode lautet, welche Parameter die Methode erwartet, wie der R\u00fcckgabetyp der Methode ist und wie der Sichtbarkeitsmodifizierer dieser Methode ist. Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort abstract im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf haben, also keine { } . Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon! Verwendung abstrakter Klassen \u00b6 Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen als Typ und als Basisklasse, d.h. von abstrakten Klassen wird geerbt. Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)! Ein Beispiel - die abstrakte Klasse Shape \u00b6 Wir erstellen uns eine abstrakte Klasse Shape , welche zwei abstrakte Methoden enth\u00e4lt, perimeter() und area() . public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Beachten Sie, dass eine Klasse selbst als abstract deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile 1 ebanfalls das Schl\u00fcsselwort abstract . Sie lie\u00dfe sich auch sonst gar nicht compilieren. Rectangle erbt von Shape \u00b6 Shape kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse Shape erzeugen. Vielmehr ist die Klasse Shape auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse Rectangle , die von Shape erbt. Wenn wir nun schreiben: 1 2 3 4 public class Rectangle extends Shape { } dann ist Rectangle rot unterstrichen und Eclipse bietet uns zwei QuickFixes an: Add unimplemnted methods oder Make type Rectangle abstract Durch das Erben von Shape haben wir auch die beiden abstrakten Methoden perimeter() und area() geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse Rectangle ist selbst eine abstrakte Klasse. Wir w\u00e4hlen QuickFix 1 und lassen die Methoden hinzuf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rectangle extends Shape { @Override public double perimeter () { // TODO Auto-generated method stub return 0 ; } @Override public double area () { // TODO Auto-generated method stub return 0 ; } } Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als public und mit R\u00fcckgabetyp double sowie den in Shape definierten Namen). Nun sind die beiden Methoden aber jeweils implementiert (aber noch nicht richtig - TODO ). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen 6-9 und 13-16 ), sind sie nicht mehr abstrakt und somit ist auch die Klasse Rectangle keine abstrakte Klasse. Eine sinnvolle Implementierung der Klasse Rectangle sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden perimeter() und area() sinnvoll implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch geeignete Implementierungen f\u00fcr mindestens die von Object geerbten Methoden equals() und toString() enthalten. Circle erbt von Shape \u00b6 Wir k\u00f6nnen beliebig oft von der Klasse Shape erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse Shape erben. F\u00fcr jede dieser Klassen gilt nun: ein Objekt dieser Klasse (z.B. ein Objekt der Klasse Rectangle ) \"besitzt\" die Methoden perimeter() und area() , ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ Shape . Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } } Testen der Klassen \u00b6 Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein Shape als Parameter verwendet wird und die f\u00fcr dieses Shape die Methode perimeter() oder area() aufruft. Es ist ja sicher, dass jedes Objekt vom Typ Shape diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende TestklasseShape : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TestklasseShape { public static void printPerimeter ( Shape s ) { System . out . printf ( \"perimeter : %.2f cm%n\" , s . perimeter ()); } public static void printArea ( Shape s ) { System . out . printf ( \"area : %.2f cm%n\" , s . area ()); } public static double sumPerimeters ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . perimeter (); } return sum ; } public static double sumAreas ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . area (); } return sum ; } public static void main ( String [] args ) { Shape s1 = new Rectangle ( 10 , 20 ); Shape s2 = new Circle ( 6.0 ); printPerimeter ( s1 ); printPerimeter ( s2 ); printArea ( s1 ); printArea ( s2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = s1 ; shapes [ 1 ] = s2 ; shapes [ 2 ] = new Rectangle ( 5 , 15 ); shapes [ 3 ] = new Circle ( 10.0 ); System . out . printf ( \"sum of perimeters : %.2f cm%n\" , sumPerimeters ( shapes )); System . out . printf ( \"sum of areas : %.2f cm%n\" , sumAreas ( shapes )); } } In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ Shape oder vom Typ Shape[] erwarten. Von Objekten, die vom (Laufzeit-)Typ Shape sind, wissen wir, dass sie die Methoden perimeter() bzw. area() als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die Shape -Objekte aufrufen. Abstrakte Klassen fungieren also ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. Rectangle oder Circle ), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden perimeter() und area() verf\u00fcgen. Beispiele aus den Java-Paketen \u00b6 In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben. Die abstrakte Klasse Number \u00b6 Die Klasse Number aus dem java.lang -Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: abstract double doubleValue() abstract float floatValue() abstract int intValue() abstract long longValue() Alle numerischen Wrapper-Klassen erben von Number , d.h. die Klassen Byte , Double , Float , Integer , Long und Short sind von Number abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ Number sind und somit die Methoden doubleValue() , floatValue() , intValue() und longValue() als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen. Abstrakte Klassen f\u00fcr Collections \u00b6 Beispiele f\u00fcr abstrakte Klassen finden wir auch im java.util -Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. add() , addAll() , clear() , contains() , isEmpty() , iterator() , remove() usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen AbstractList und AbstractSet ebenfalls abstrakt sind! Von AbstractSet erben z.B. die Klassen HashSet , TreeSet und EnumSet . Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in AbstractCollection definierten Methoden. Success Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.","title":"Abstrakte Klassen"},{"location":"abstrakt/#abstrakte-klassen","text":"Abstrakte Klassen haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von Collection anschauen, dann finden wir darin Interfaces : die Klassen Collection , List , Set , SortedSet und NavigableSet sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und Abtrakte Klassen : die Klassen AbstractCollection , AbstractList und AbstractSet sind solche abstrakten Klassen (die schauen wir uns jetzt an)","title":"Abstrakte Klassen"},{"location":"abstrakt/#klassen-allgemein","text":"Wir haben uns bis jetzt Klassen erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt. Angenommen, in der Klasse wurde eine Methode implementiert public void eineImplementierteMethode () { // Anweisungen } , dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren refVariable.eineImplementierteMethode(); .","title":"Klassen - allgemein"},{"location":"abstrakt/#klassen-abstrakt","text":"Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen . Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen alle Eigenschaften erben zu lassen. Der dritte obere Punkt gilt nicht ! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen . Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse.","title":"Klassen - abstrakt"},{"location":"abstrakt/#abstrakte-methoden","text":"Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon): public abstract void eineAbstrakteMethode (); Das Schl\u00fcsselwort abstract gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, wie der Name der Methode lautet, welche Parameter die Methode erwartet, wie der R\u00fcckgabetyp der Methode ist und wie der Sichtbarkeitsmodifizierer dieser Methode ist. Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort abstract im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf haben, also keine { } . Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon!","title":"Abstrakte Methoden"},{"location":"abstrakt/#verwendung-abstrakter-klassen","text":"Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen als Typ und als Basisklasse, d.h. von abstrakten Klassen wird geerbt. Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)!","title":"Verwendung abstrakter Klassen"},{"location":"abstrakt/#ein-beispiel-die-abstrakte-klasse-shape","text":"Wir erstellen uns eine abstrakte Klasse Shape , welche zwei abstrakte Methoden enth\u00e4lt, perimeter() und area() . public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Beachten Sie, dass eine Klasse selbst als abstract deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile 1 ebanfalls das Schl\u00fcsselwort abstract . Sie lie\u00dfe sich auch sonst gar nicht compilieren.","title":"Ein Beispiel - die abstrakte Klasse Shape"},{"location":"abstrakt/#rectangle-erbt-von-shape","text":"Shape kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse Shape erzeugen. Vielmehr ist die Klasse Shape auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse Rectangle , die von Shape erbt. Wenn wir nun schreiben: 1 2 3 4 public class Rectangle extends Shape { } dann ist Rectangle rot unterstrichen und Eclipse bietet uns zwei QuickFixes an: Add unimplemnted methods oder Make type Rectangle abstract Durch das Erben von Shape haben wir auch die beiden abstrakten Methoden perimeter() und area() geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse Rectangle ist selbst eine abstrakte Klasse. Wir w\u00e4hlen QuickFix 1 und lassen die Methoden hinzuf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rectangle extends Shape { @Override public double perimeter () { // TODO Auto-generated method stub return 0 ; } @Override public double area () { // TODO Auto-generated method stub return 0 ; } } Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als public und mit R\u00fcckgabetyp double sowie den in Shape definierten Namen). Nun sind die beiden Methoden aber jeweils implementiert (aber noch nicht richtig - TODO ). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen 6-9 und 13-16 ), sind sie nicht mehr abstrakt und somit ist auch die Klasse Rectangle keine abstrakte Klasse. Eine sinnvolle Implementierung der Klasse Rectangle sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden perimeter() und area() sinnvoll implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch geeignete Implementierungen f\u00fcr mindestens die von Object geerbten Methoden equals() und toString() enthalten.","title":"Rectangle erbt von Shape"},{"location":"abstrakt/#circle-erbt-von-shape","text":"Wir k\u00f6nnen beliebig oft von der Klasse Shape erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse Shape erben. F\u00fcr jede dieser Klassen gilt nun: ein Objekt dieser Klasse (z.B. ein Objekt der Klasse Rectangle ) \"besitzt\" die Methoden perimeter() und area() , ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ Shape . Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } }","title":"Circle erbt von Shape"},{"location":"abstrakt/#testen-der-klassen","text":"Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein Shape als Parameter verwendet wird und die f\u00fcr dieses Shape die Methode perimeter() oder area() aufruft. Es ist ja sicher, dass jedes Objekt vom Typ Shape diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende TestklasseShape : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TestklasseShape { public static void printPerimeter ( Shape s ) { System . out . printf ( \"perimeter : %.2f cm%n\" , s . perimeter ()); } public static void printArea ( Shape s ) { System . out . printf ( \"area : %.2f cm%n\" , s . area ()); } public static double sumPerimeters ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . perimeter (); } return sum ; } public static double sumAreas ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . area (); } return sum ; } public static void main ( String [] args ) { Shape s1 = new Rectangle ( 10 , 20 ); Shape s2 = new Circle ( 6.0 ); printPerimeter ( s1 ); printPerimeter ( s2 ); printArea ( s1 ); printArea ( s2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = s1 ; shapes [ 1 ] = s2 ; shapes [ 2 ] = new Rectangle ( 5 , 15 ); shapes [ 3 ] = new Circle ( 10.0 ); System . out . printf ( \"sum of perimeters : %.2f cm%n\" , sumPerimeters ( shapes )); System . out . printf ( \"sum of areas : %.2f cm%n\" , sumAreas ( shapes )); } } In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ Shape oder vom Typ Shape[] erwarten. Von Objekten, die vom (Laufzeit-)Typ Shape sind, wissen wir, dass sie die Methoden perimeter() bzw. area() als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die Shape -Objekte aufrufen. Abstrakte Klassen fungieren also ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. Rectangle oder Circle ), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden perimeter() und area() verf\u00fcgen.","title":"Testen der Klassen"},{"location":"abstrakt/#beispiele-aus-den-java-paketen","text":"In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben.","title":"Beispiele aus den Java-Paketen"},{"location":"abstrakt/#die-abstrakte-klasse-number","text":"Die Klasse Number aus dem java.lang -Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: abstract double doubleValue() abstract float floatValue() abstract int intValue() abstract long longValue() Alle numerischen Wrapper-Klassen erben von Number , d.h. die Klassen Byte , Double , Float , Integer , Long und Short sind von Number abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ Number sind und somit die Methoden doubleValue() , floatValue() , intValue() und longValue() als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen.","title":"Die abstrakte Klasse Number"},{"location":"abstrakt/#abstrakte-klassen-fur-collections","text":"Beispiele f\u00fcr abstrakte Klassen finden wir auch im java.util -Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. add() , addAll() , clear() , contains() , isEmpty() , iterator() , remove() usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen AbstractList und AbstractSet ebenfalls abstrakt sind! Von AbstractSet erben z.B. die Klassen HashSet , TreeSet und EnumSet . Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in AbstractCollection definierten Methoden. Success Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.","title":"Abstrakte Klassen f\u00fcr Collections"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Aufgabe 1 (W\u00fcrfelspiel) \u00b6 Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 Spiel.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package aufgaben.aufgabe1 ; import javax.swing.JOptionPane ; public class Spiel { public static int siegPunkte ; private Spieler [] spieler ; Spiel () { int anzSpieler = 0 ; int siegPunkte = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Anzahl Spieler :\" ); inputOk = true ; anzSpieler = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } inputOk = false ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Siegpunkte :\" ); inputOk = true ; siegPunkte = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; namenErmitteln (); } Spiel ( int siegPunkte , int anzSpieler ) { Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; /* Spielernamen sind A, B, C ... char name = 'A'; for(int i=0; i<spieler.length; i++) { spieler[i] = new Spieler(String.valueOf(name)); name ++; } */ /* Spielernamen werden eingegeben * wenn man namenErmitteln() auskommentiert, * kann man die obige for-Schleife nehmen, damit * man nicht immer die Spielernamen eingeben muss * - zum Testen */ namenErmitteln (); } private void namenErmitteln () { String name = \"\" ; for ( int i = 0 ; i < spieler . length ; i ++ ) { name = JOptionPane . showInputDialog ( \"Name des Spielers \" + ( i + 1 ) + \" :\" ); spieler [ i ] = new Spieler ( name ); } } public void spielen () { int index = 0 ; boolean gewonnen = false ; while ( ! gewonnen ) { gewonnen = spieler [ index ] . wuerfeln (); index = ( index < spieler . length - 1 ) ? index + 1 : 0 ; } } public static void main ( String [] args ) { //Spiel spiel = new Spiel(30, 3); Spiel spiel = new Spiel (); spiel . spielen (); } } Spieler.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package aufgaben.aufgabe1 ; import java.util.Random ; import javax.swing.JOptionPane ; public class Spieler { private String name ; private int aktStand ; private Random r ; Spieler ( String name ) { aktStand = 0 ; this . name = name ; r = new Random (); } public int getAktStand () { return this . aktStand ; } public boolean wuerfeln () { System . out . printf ( \"%n%nSpieler %s ist an der Reihe (bisher %d Punkte) %n ----------------------------------------- %n\" , this . name , this . aktStand ); int reihe = 0 ; int wurf = 0 ; boolean ende = false ; while ( ! ende ) { wurf = r . nextInt ( 6 ) + 1 ; System . out . printf ( \"%s hat eine %d gewuerfelt %n\" , this . name , wurf ); if ( wurf == 6 ) { System . out . printf ( \"Versuch zu Ende %n Aktueller Spielstand von %s : %d Punkte %n Der naechste Spieler ist dran%n\" , this . name , this . aktStand ); ende = true ; } else if ( aktStand + reihe + wurf >= Spiel . siegPunkte ) { System . out . printf ( \"%s hat insgesamt %d Punkte und somit gewonnen !!!\" , this . name , ( aktStand + reihe + wurf )); return true ; } else // eine 1..5 gewuerfelt und noch nicht gewonnen { reihe += wurf ; System . out . printf ( \"in diesem Versuch bisher %d Punkte -- insgesamt %d Punkte %n\" , reihe , ( aktStand + reihe )); int dialogResult = JOptionPane . showConfirmDialog ( null , this . name + \", wollen Sie weiter wuerfeln? \" , \"Weiter wuerfeln?\" , JOptionPane . YES_NO_OPTION ); ende = ! ( dialogResult == JOptionPane . YES_OPTION ); if ( ende ) { aktStand += reihe ; } } } return false ; } } Aufgabe 2 (MyInteger) \u00b6 Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 2 MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package aufgaben.aufgabe2 ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 048 bis 9 ist 057 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { boolean negativ = false ; if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leer\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne f\u00fchrende Nullen while ( s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int exponent = 0 ; int zahl = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { zahl = zahl + charToInt ( s . charAt ( i )) * ( int ) Math . pow ( 10 , exponent ); exponent ++ ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerMain.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package aufgaben.aufgabe2 ; public class MyIntegerMain { public static void main ( String [] args ) { MyInteger mi1 = null , mi2 = null , mi3 = null , mi4 = null , mi5 = null , mi6 = null , mi7 = null , mi8 = null , mi9 = null , mi10 = null ; try { mi1 = new MyInteger ( \"-2147483648\" ); System . out . println ( mi1 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi2 = new MyInteger ( \"-00002147483648\" ); System . out . println ( mi2 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi3 = new MyInteger ( \"hallo\" ); System . out . println ( mi3 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi4 = new MyInteger ( - 2147483648 ); try { mi5 = MyInteger . valueOf ( \"-2147483648\" ); System . out . println ( mi5 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi6 = MyInteger . valueOf ( \"-00002147483648\" ); System . out . println ( mi6 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi7 = MyInteger . valueOf ( \"hallo\" ); System . out . println ( mi7 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi8 = MyInteger . valueOf ( - 2147483648 ); try { mi9 = MyInteger . valueOf ( \"\" ); System . out . println ( mi9 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi10 = MyInteger . valueOf ( \"+\" ); System . out . println ( mi10 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"mi1 equals mi2 ? : \" + mi1 . equals ( mi2 )); System . out . println ( \"mi1 equals mi3 ? : \" + mi1 . equals ( mi3 )); System . out . println ( \"mi1 equals mi4 ? : \" + mi1 . equals ( mi4 )); System . out . println ( \"mi1 equals mi5 ? : \" + mi1 . equals ( mi5 )); System . out . println ( \"mi1 equals mi6 ? : \" + mi1 . equals ( mi6 )); System . out . println ( \"mi1 equals mi7 ? : \" + mi1 . equals ( mi7 )); System . out . println ( \"mi1 equals mi8 ? : \" + mi1 . equals ( mi8 )); System . out . println ( \"mi1 equals mi9 ? : \" + mi1 . equals ( mi9 )); System . out . println ( \"mi1 equals mi10 ? : \" + mi1 . equals ( mi10 )); System . out . println ( \"hashCode mi1 : \" + mi1 . hashCode ()); System . out . println ( \"hashCode mi2 : \" + mi2 . hashCode ()); try { System . out . println ( \"hashCode mi3 : \" + mi3 . hashCode ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"hashCode mi4 : \" + mi4 . hashCode ()); System . out . println ( \"intValue mi1 : \" + mi1 . intValue ()); System . out . println ( \"intValue mi2 : \" + mi2 . intValue ()); try { System . out . println ( \"intValue mi3 : \" + mi3 . intValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"intValue mi4 : \" + mi4 . intValue ()); System . out . println ( \"doubleValue mi1 : \" + mi1 . doubleValue ()); System . out . println ( \"doubleValue mi2 : \" + mi2 . doubleValue ()); try { System . out . println ( \"doubleValue mi3 : \" + mi3 . doubleValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"doubleValue mi4 : \" + mi4 . doubleValue ()); } } Aufgabe 3 (Solitaire) \u00b6 Aufgabe 3 Information und Vorbereitung Wir wenden Aufz\u00e4hlungstypen und mehrdimensionale Arrays an. Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. Teil der Aufgabe ist es auch, \"fremden\" Code zu lesen und zu verstehen, denn einige Klassen sind bereits gegeben: Klasse Point.java package aufgaben.aufgabe3 ; /* * ein Point repreasentiert eine Position * im Spielfeld, bestehend aus der Nummer * fuer die Zeile (row) und der Nummer * fuer die Spalte (col) */ public class Point { private int row ; private int col ; /* * Konstruktor zur Erzeugung einer * Position bestehend aus row und col */ public Point ( int row , int col ) { this . row = row ; this . col = col ; } public int getRow () { return this . row ; } public int getCol () { return this . col ; } @Override public String toString () { return \"(\" + this . row + \",\" + this . col + \")\" ; } } Klasse Move.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert einen Zug * Variablen sind Point from * und Point to * es wird nicht geprueft, ob der Zug ueberhaupt * moeglich ist */ public class Move { private Point from ; private Point to ; /* * ein Zug von dem from-Point (fromRow,fromCol) * zum to-Point (toRow,toCol) */ public Move ( int fromRow , int fromCol , int toRow , int toCol ) { this . from = new Point ( fromRow , fromCol ); this . to = new Point ( toRow , toCol ); } /* * in dem Konstruktor werden in this.from und this.to nicht einfach * die Referenzen von from und to gespeichert, sondern davon Kopien * erstellt, damit das Programm robuster gegen das Aendern von * Referenzen ist */ public Move ( Point from , Point to ) { this . from = new Point ( from . getRow (), from . getCol ()); this . to = new Point ( to . getRow (), to . getCol ()); } /* * der Getter fuer den Point from gibt keine Referenz auf * den Point from zurueck, sondern eine Kopie (einen Klon) * von from --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getFrom () { return new Point ( this . from . getRow (), this . from . getCol ()); } /* * der Getter fuer den Point to gibt keine Referenz auf * den Point to zurueck, sondern eine Kopie (einen Klon) * von to --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getTo () { return new Point ( this . to . getRow (), this . to . getCol ()); } } Klasse Moves.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert eine Folge * von Zuegen (Move), die in einem Array * moves gespeichert sind */ public class Moves { private Move [] moves ; /* * der Konstruktor erstellt ein leeres moves-Array * (d.h. noch keine Zuege (Moves) gespeichert) */ public Moves () { this . moves = new Move [ 0 ] ; } /* * der Konstruktor erstellt ein moves-Array mit einem * Move - dem erste Zug (firstMove) */ public Moves ( Move firstMove ) { this . moves = new Move [ 1 ] ; this . moves [ 0 ] = firstMove ; } /* * Anzahl der bisher gespeicherten Zuege */ public int getLength () { return this . moves . length ; } /* * fuegt einen Zug (nextMove) zum moves-Array hinzu * dazu muss das moves-Array um 1 laenger sein als zuvor * es wird eine Kopie aller Zuege erstellt und dann * der nextMove hinzugefuegt */ public void addMove ( Move nextMove ) { Move [] newMoves = new Move [ this . moves . length + 1 ] ; for ( int index = 0 ; index < this . moves . length ; index ++ ) { newMoves [ index ] = this . moves [ index ] ; } newMoves [ newMoves . length - 1 ] = new Move ( nextMove . getFrom (), nextMove . getTo ()); this . moves = newMoves ; } /* * gibt den Move zurueck, der im moves-Array unter dem Index index * gespeichert ist; * kann sein, dass index kein korrekter Index im moves-Array ist, * dann wird eine IllegalArgumentException geworfen */ public Move getMoveAtIndex ( int index ) throws IllegalArgumentException { try { return this . moves [ index ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"kein gueltiger Index!\" ); } } /* * Ausgabe aller im moves-Array gespeicherten Zuege * wird nur zum Debuggen benoetigt */ public void printMoves () { System . out . printf ( \"%n---%n\" ); for ( int index = 0 ; index < this . moves . length ; index ++ ) { Move move = this . moves [ index ] ; Point from = move . getFrom (); Point to = move . getTo (); System . out . println ( from . toString () + \" --> \" + to . toString ()); } System . out . printf ( \"%n---%n%n\" ); } } enum State.java package aufgaben.aufgabe3 ; /* * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf * USED - der Platz ist ein Spielfeld mit Spielstein drauf * NOT - der Platz gehoert nicht zum Spielfeld */ public enum State { FREE , USED , NOT } Aufgabe Bef\u00fcllen Sie die Klasse Solitaire.java , wie in den Kommentaren beschrieben: Klasse Solitaire.java package aufgaben.aufgabe3.loesung ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } /* * Geben Sie das Spielfeld aus! Am Anfang sollte auf der * Konsole so ein Bild erscheinen: * o o o * o o o * o o o o o o o * o o o o o o * o o o o o o o * o o o * o o o * */ public void print () { } /* * diese Methode gibt ein true zurueck, wenn von der * uebergebenen Position (row,col) ein Zug moeglich ist * d.h. * 1. auf der angegebenen Position muss ein Stein sein * 2. zwei Steine weiter (oben, unten, rechts oder links) * darf kein Stein sein * 3. dazwischen muss ein Stein sein */ public boolean possibleFrom ( int row , int col ) { return false ; } /* * diese Methode gibt alle Positionen (Point) zurueck, * AUF die von (fromRow,fromCol) aus gesprungen werden * kann */ public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; /* * naechste Zeile muss entfernt werden! * sttatdessen muessen Sie alle Point-Objekte ermitteln AUF die * gesprungen werden kann. Diese Point-Objekte werden in einem * Point-Array gespeichert, welches zur\u00fcckgegeben wird. */ return null ; } /* * diese Methode erzeugt ein Moves-Objekt * in dieses Moves-Objekt werden mithilfe der * Objektmethode addMove() (aus Moves) alle * moeglichen Zuege hinzugefuegt * (moeglich im aktuellen Zustand von field[][]) */ public Moves possibleMoves () { Moves possibleMoves = new Moves (); // next line for debugging possibleMoves . printMoves (); return possibleMoves ; } /* * gibt ein true zurueck, wenn im aktuellen Zustand * von field[][] ueberhaupt noch ein Zug moeglich ist * sonst false */ public boolean movePossible () { return false ; } /* * ruft die Methode move(Move move) auf, * wenn ein Zug moeglich ist (dann true zurueck) * sonst false */ public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; /* * hier einen moeglichen Zug ausfuehren * den ersten, den Sie finden (siehe * possibleMoves() ) */ return true ; } /* * hier wird der Zug Move move ausgefuehrt * nach dem Zug ist * 1. die from-Position leer * 2. die to-Position mit einem Stein besetzt * 3. dazwischen leer (Stein wird \"entfernt\") * falls Zug nicht moeglich, wird eine * IllegalArgumentException geworfen */ public void move ( Move move ) throws IllegalArgumentException { } } Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. Testen Sie Ihr Spiel in einer Testklasse . F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen: m\u00f6gliche Konsolenausgaben o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,1 ) --> ( 2 ,3 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 2 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,2 ) --> ( 2 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 0 ,2 ) ( 2 ,3 ) --> ( 2 ,1 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,3 ) --> ( 2 ,1 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,0 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,2 ) --> ( 2 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,6 ) --> ( 2 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,4 ) --> ( 2 ,4 ) --- o o o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 3 ,1 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o --- ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 2 ,4 ) ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o o --- ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o --- ( 3 ,3 ) --> ( 3 ,5 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o --- ( 4 ,5 ) --> ( 2 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 2 ,6 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o --- ( 4 ,1 ) --> ( 4 ,3 ) ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o o --- ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 4 ,4 ) --> ( 4 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) ( 6 ,2 ) --> ( 4 ,2 ) --- o o o o o o o o o o --- ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o --- ( 5 ,4 ) --> ( 5 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o --- ( 4 ,2 ) --> ( 6 ,2 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o o o o o o o Dabei steht z.B. --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 3 Solitaire.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package aufgaben.aufgabe3 ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( this . field [ row ][ col ] == State . USED ) System . out . print ( \"o \" ); else System . out . print ( \" \" ); } System . out . println (); } System . out . println (); } public boolean possibleFrom ( int row , int col ) { if ( row >= 0 && row < 7 && col >= 0 && col < 7 && this . field [ row ][ col ] == State . USED ) { // up ? if ( row > 1 && this . field [ row - 1 ][ col ] == State . USED && this . field [ row - 2 ][ col ] == State . FREE ) return true ; // down ? if ( row < 5 && this . field [ row + 1 ][ col ] == State . USED && this . field [ row + 2 ][ col ] == State . FREE ) return true ; // right ? if ( col < 5 && this . field [ row ][ col + 1 ] == State . USED && this . field [ row ][ col + 2 ] == State . FREE ) return true ; // left ? if ( col > 1 && this . field [ row ][ col - 1 ] == State . USED && this . field [ row ][ col - 2 ] == State . FREE ) return true ; } return false ; } public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // there is at least one To-Point int nrOfPossibleTos = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) nrOfPossibleTos ++ ; Point [] tos = new Point [ nrOfPossibleTos ] ; int index = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow - 2 , fromCol ); if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow + 2 , fromCol ); if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol + 2 ); if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol - 2 ); return tos ; } public Moves possibleMoves () { Moves possibleMoves = new Moves (); for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) { Point [] tos = this . possibleTo ( row , col ); Point from = new Point ( row , col ); for ( int index = 0 ; index < tos . length ; index ++ ) { possibleMoves . addMove ( new Move ( from , tos [ index ] )); } } } } // next line for debug possibleMoves . printMoves (); return possibleMoves ; } public boolean movePossible () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) return true ; } } return false ; } public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; else { Moves possibleMoves = this . possibleMoves (); try { Move move = possibleMoves . getMoveAtIndex ( 0 ); this . move ( move ); return true ; } catch ( IllegalArgumentException e ) { System . out . println ( \"Zug nicht moeglich! Index : 0\" ); return false ; } } } public void move ( Move move ) throws IllegalArgumentException { Point from = move . getFrom (); Point to = move . getTo (); int fromRow = from . getRow (); int fromCol = from . getCol (); int toRow = to . getRow (); int toCol = to . getCol (); int middleRow = ( fromRow + toRow ) / 2 ; int middleCol = ( fromCol + toCol ) / 2 ; try { this . field [ fromRow ][ fromCol ] = State . FREE ; this . field [ middleRow ][ middleCol ] = State . FREE ; this . field [ toRow ][ toCol ] = State . USED ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"Zug nicht moeglich! (\" + fromRow + \", \" + fromCol + \") --> \" + \"( \" + toRow + \", \" + toCol + \") \" ); } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package aufgaben.aufgabe3 ; public class Testklasse { public static void main ( String [] args ) { Solitaire s = new Solitaire (); s . print (); while ( s . moveFirstPossible ()) { s . print (); } s . print (); } } Aufgabe 4 (Operationen \u00fcber Mengen) \u00b6 Aufgabe 4 Implementieren Sie eine Klasse SetOperations . Erstellen Sie drei Objektvariablen (z.B. numbers1 , numbers2 und both ) vom Typ Set<Integer> . Erzeugen Sie f\u00fcr diese Objektvariablen TreeSet -Objekte. Erstellen Sie eine Objektmethode fill() . In dieser Methode sollen die beiden Sets numbers1 und numbers2 mit Zufallszahlen aus dem Wertebereich 0..99 bef\u00fcllt werden. Erzeugen Sie jeweils 100 Zufallszahlen (die number s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.) Beachten Sie, dass die nextInt() -Methode ein int zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein Integer -Objekt umgewandelt werden ( Integer.valueOf(int) ) und dieses Integer -Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist). Erstellen Sie eine Objektmethode fillBothUnion() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einer Vereinigung der Mengen numbers1 und numbers2 entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html . Erstellen Sie eine Objektmethode fillBothIntersection() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einem Schnitt der Mengen numbers1 und numbers2 entspricht. Erstellen Sie eine Objektmethode fillBothDifference() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both der Differenz der Menge numbers1 minus der Menge numbers2 entspricht. Schreiben Sie eine Methode print() so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen ( o, *, #, x, ... ) verwenden). Gestalten Sie die Ausgabe so, dass die drei Mengen numbers1 , numbers2 und both nebeneinander auf der Konsole erscheinen. Testen Sie alle drei Methoden fillBothUnion() , fillBothIntersection() und fillBothDifference() . Die Ausgabe k\u00f6nnte wie folgt sein ( A stellt die Menge numbers1 dar, B die Menge numbers2 und rechts ist jeweils die both -Menge dargestellt): Tipps : F\u00fcr die schwarzen Punkte habe ich das Character '\\u25cf' verwendet (ein passendes Leerzeichen dazu ist '\\u2009' ). Das Zeichen f\u00fcr die Vereinigung ist '\\u222a' und f\u00fcr den Schnitt '\\u2229' . Schauen Sie sich auch im Skript Mengenoperationen an. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 4 SetOperations.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 package aufgaben.aufgabe4 ; import java.util.* ; public class SetOperations { Set < Integer > numbers1 ; Set < Integer > numbers2 ; Set < Integer > both ; final static int UPPER_BOUND = 100 ; public SetOperations () { this . numbers1 = new TreeSet <> (); this . numbers2 = new TreeSet <> (); this . both = new TreeSet <> (); } public void fill () { Random r = new Random (); int nextIntNr = 0 ; Integer nextIntegerNr = Integer . valueOf ( nextIntNr ); // fill numbers1 for ( int i = 0 ; i < UPPER_BOUND ; i ++ ) { nextIntNr = r . nextInt ( UPPER_BOUND ); nextIntegerNr = Integer . valueOf ( nextIntNr ); this . numbers1 . add ( nextIntegerNr ); } // fill numbers2 for ( int i = 0 ; i < UPPER_BOUND ; i ++ ) { nextIntNr = r . nextInt ( UPPER_BOUND ); nextIntegerNr = Integer . valueOf ( nextIntNr ); this . numbers2 . add ( nextIntegerNr ); } } public void fillBothUnion () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A \" + '\\u222a' + \" B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . addAll ( numbers1 ); this . both . addAll ( numbers2 ); } public void fillBothIntersection () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A \" + '\\u2229' + \" B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . clear (); this . both . addAll ( numbers1 ); this . both . retainAll ( numbers2 ); } public void fillBothDifference () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A-B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . clear (); this . both . addAll ( numbers1 ); this . both . removeAll ( numbers2 ); } public Integer printOneLine ( Iterator < Integer > it , Integer next , int curRow ) { int curNr = 0 ; // row*10+col for ( int col = 0 ; col < 10 ; col ++ ) { curNr = curRow * 10 + col ; if ( next != null && next . intValue () == curNr ) { System . out . print ( '\\u25cf' + \" \" ); if ( it . hasNext ()) { next = it . next (); } } else { //System.out.print('\\u25cc'+\" \"); System . out . print ( '\\u2009' + \" \" ); } } return next ; } private void printSpaces ( int nrOfSpaces ) { for ( int spaces = 0 ; spaces < nrOfSpaces ; spaces ++ ) System . out . print ( \" \" ); } private void justTestPrint () { System . out . print ( numbers1 . size () + \" : [ \" ); for ( Integer i : numbers1 ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); System . out . print ( numbers2 . size () + \" : [ \" ); for ( Integer i : numbers2 ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); System . out . print ( both . size () + \" : [ \" ); for ( Integer i : both ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); } public void print () { justTestPrint (); System . out . println (); Iterator < Integer > it1 = numbers1 . iterator (); Integer next1 = ( it1 . hasNext ()) ? it1 . next () : null ; Iterator < Integer > it2 = numbers2 . iterator (); Integer next2 = ( it2 . hasNext ()) ? it2 . next () : null ; Iterator < Integer > itb = both . iterator (); Integer nextB = ( itb . hasNext ()) ? itb . next () : null ; for ( int row = 0 ; row < 10 ; row ++ ) { next1 = this . printOneLine ( it1 , next1 , row ); printSpaces ( 8 ); next2 = this . printOneLine ( it2 , next2 , row ); printSpaces ( 8 ); nextB = this . printOneLine ( itb , nextB , row ); System . out . println (); } System . out . println (); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package aufgaben.aufgabe4 ; public class Testklasse { public static void main ( String [] args ) { SetOperations so = new SetOperations (); so . fill (); so . fillBothUnion (); so . print (); so . fillBothIntersection (); so . print (); so . fillBothDifference (); so . print (); } } Aufgabe 5 (Maps) \u00b6 Aufgabe 5 Testen Sie folgenden Code: long a = 1000 ; Integer b = 1000 ; Integer c = 1000 ; System . out . println ( a == b ); System . out . println ( b == c ); Was stellen Sie fest und warum? \u00c4ndern Sie den Vergleich der Variablen b und c so, dass true ausgegeben wird. Die ersten drei Zeilen bleiben dabei unver\u00e4ndert. Sie ben\u00f6tigen also einen anderen Vergleich als b == c . Erstellen Sie eine Klasse PizzaMenu . Erzeugen Sie darin eine HashMap und f\u00fcgen Sie folgende Pizzen mit ihren Preisen ein: Pizza Preis Margherita 7,00 Veggie 7,50 Salami 8,50 Schinken 8,50 Schreiben Sie eine Methode public static boolean existingPizza(Map<String,Double> menu, String pizza) , die testet, ob eine eingegebene Pizza im Men\u00fc existiert. Schreiben Sie eine Methode public static void printPrice(Map<String,Double> menu, String pizza) , die f\u00fcr eine eingegebene Pizza den Preis ausgibt. Verwenden Sie dazu existingPizza() . Beispielausgabe: Salami: 8 .50 Euro Hawaii: Diese Pizza gibt es nicht. Schreiben Sie eine printMenu() -Methode, die ausgibt, wie viele Pizzen es im Men\u00fc gibt. Wenn das Men\u00fc nicht leer ist, sollen zudem alle Pizzen mit ihrem Preis ausgegeben werden. Beispielausgabe: // Beispiel fuer leeres Menue ############## Das Menu enth\u00e4lt 0 Pizzen. ############## // Beispiel fuer Menue ############## Das Menu enth\u00e4lt 4 Pizzen. Pizza Margherita: 7 .00 Euro Pizza Salami: 8 .50 Euro Pizza Schinken: 8 .50 Euro Pizza Veggie: 7 .50 Euro ############## \u00c4ndern Sie den Preis der Schinken -Pizza in der HashMap zu 8,20 . Schreiben Sie eine Methode public static void affordablePizza(Map<String,Double> menu, double maxPrice) , die alle Pizzen ausgibt, die man sich f\u00fcr einen bestimmten Betrag leisten kann. Beispielausgabe: Eingegebener Betrag: 4 .0 Euro Leider gibt es zu diesem Preis keine Pizza. Eingegebener Betrag: 8 .0 Euro M\u00f6gliche Pizzen: [ Margherita, Veggie ] Das Menu wird \u00fcberarbeitet, l\u00f6schen Sie daher alle Eintr\u00e4ge. F\u00fcllen Sie das Men\u00fc anschlie\u00dfend mit diesen neuen Pizzen: Pizza Preis Verde 7,00 Hawaii 8,20 Tradizionale 8,50 Legen Sie ein zweites Men\u00fc an und kopieren Sie alle Eintr\u00e4ge aus dem ersten Men\u00fc hinein. L\u00f6schen Sie im zweiten Men\u00fc die Pizza Hawaii und geben Sie die Namen aller noch verf\u00fcgbaren Pizzen aus. Finden Sie in Ihrem Code ein Beispiel f\u00fcr Auto-Boxing und schreiben Sie einen entsprechenden Kommentar. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 5 PizzaMenue.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package aufgaben.aufgabe5 ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.Map ; import java.util.Set ; import java.util.List ; public class PizzaMenu { //3. public static boolean existingPizza ( Map < String , Double > menu , String pizza ) { if ( menu . containsKey ( pizza )){ return true ; } return false ; } //4. public static void printPrice ( Map < String , Double > menu , String pizza ) { if ( existingPizza ( menu , pizza )){ System . out . println ( pizza + \": \" + menu . get ( pizza )); } else { System . out . println ( pizza + \": \" + \"Diese Pizza gibt es nicht.\" ); } } //5. public static void printMenu ( Map < String , Double > menu ) { System . out . println (); System . out . println ( \"##############\" ); System . out . println ( \"Das Menu enth\u00e4lt \" + menu . size () + \" Pizzen.\" ); if ( ! menu . isEmpty ()) { for ( Map . Entry < String , Double > entry : menu . entrySet ()) { System . out . println ( \"Pizza : \" + entry . getKey () + \" - \" + entry . getValue ()); } } System . out . println ( \"##############\" ); } //7. public static void affordablePizza ( Map < String , Double > menu , double maxPrice ) { List < String > pizzen = new ArrayList <> (); System . out . println ( \"Eingegebener Betrag: \" + maxPrice + \" Euro\" ); for ( Map . Entry < String , Double > eintrag : menu . entrySet ()) { if ( eintrag . getValue () <= maxPrice ) { //Auto-Boxing von double zu Double pizzen . add ( eintrag . getKey ()); } } if ( pizzen . size () == 0 ) { System . out . println ( \"Leider gibt es zu diesem Preis keine Pizza.\" ); } else { System . out . println ( \"M\u00f6gliche Pizzen: \" + pizzen ); } } public static void main ( String [] args ) { //2. Map < String , Double > menu1 = new HashMap <> (); menu1 . put ( \"Margherita\" , 7.0 ); //Auto-Boxing von double zu Double menu1 . put ( \"Veggie\" , 7.5 ); //Auto-Boxing von double zu Double menu1 . put ( \"Salami\" , 8.5 ); //Auto-Boxing von double zu Double menu1 . put ( \"Schinken\" , 8.5 ); //Auto-Boxing von double zu Double //4. printPrice ( menu1 , \"Salami\" ); printPrice ( menu1 , \"Hawaii\" ); //5. printMenu ( menu1 ); //6. menu1 . put ( \"Schinken\" , 8.20 ); //Auto-Boxing von double zu Double //7. affordablePizza ( menu1 , 4.0 ); affordablePizza ( menu1 , 8.0 ); //8. menu1 . clear (); printMenu ( menu1 ); menu1 . put ( \"Verde\" , 7.0 ); //Auto-Boxing von double zu Double menu1 . put ( \"Hawaii\" , 8.2 ); //Auto-Boxing von double zu Double menu1 . put ( \"Tradizionale\" , 8.5 ); //Auto-Boxing von double zu Double printMenu ( menu1 ); //9. Map < String , Double > menu2 = new HashMap <> (); menu2 . putAll ( menu1 ); menu2 . remove ( \"Hawaii\" ); Set < String > pizzaNames = menu2 . keySet (); System . out . println (); System . out . println ( \"Es gibt folgende Pizzen: \" + pizzaNames ); } } Aufgabe 6 (Interfaces) \u00b6 Aufgabe 6 Das Observer -Entwurfsmuster geh\u00f6rt zu den am meisten verwendeten Designmustern/Designpattern/Pattern in der Programmierung. Es wird auch Beobachter -Muster oder Publisher -Pattern genannt. Wir werden dieses Muster in K\u00fcrze sehr h\u00e4ufig anwenden, wenn wir Nutzerereignisse in grafischen Oberfl\u00e4chen behandeln. Man kann sich dieses Pattern so vorstellen, dass der Publisher eine Zeitung oder auch Slack ist und dass Listener diese Zeitung (oder Slack) \"abonnieren\". Immer, wenn eine Nachricht ver\u00f6ffentlicht wird, dann erfahren alle Abonnenten davon. Wir werden eine (einfache) Implementierung dieses Entwurfsmusters durchf\u00fchren. Erstellen Sie ein Interface Publisher mit folgenden (abstrakten) Methoden: public boolean register(Listener listener); public boolean unregister(Listener listener); public void notifyListeners(); public String getUpdate(Listener listener); Erstellen Sie ein weiteres Interface Listener mit folgenden (abstrakten) Methoden: public void update(); public void setPublisher(Publisher publisher); public void removePublisher(Publisher publisher); Erstellen Sie eine Klasse Slack , die das Publisher -Interface implementiert. Objektvariablen der Klasse sind private Set<Listener> listeners; (speichert alle \"Abonnenten\"; kann gerne auch eine Liste sein) private int nrOfMessages; (speichert die aktuelle Nummer einer ver\u00f6ffentlichten Nachricht - die Nachrichten, die ver\u00f6ffentlicht werden, sollen fortlaufend nummeriert werden) Im parameterlosen Konstruktor werden die Menge (oder Liste) erzeugt und die nrOfMessages auf `0 gesetzt. In der Methode register(Listener listener) wird der listener in die Set listeners eingef\u00fcgt. Geben Sie ein true zur\u00fcck, wenn listener tats\u00e4chlich eingef\u00fcgt wurde und false sonst (falls er schon in der Menge (oder Liste) war. In der Methode unregister(Listener listener) wird der listener wieder aus der Set listeners gel\u00f6scht. Geben Sie ein true zur\u00fcck, wenn listener tats\u00e4chlich gel\u00f6scht wurde und false sonst (falls er nicht in der Menge (oder Liste) war. In der Methode notifyListeners() wird f\u00fcr alle listener aus der Menge listeners die update() -Methode aufgerufen (siehe Listener und Student ). Die Methode getUpdate(Listener obj) liefert einfach folgenden String zur\u00fcck: \"Breaking News \" + this.nrOfMessages . Erstellen Sie eine Methode public void publishNews() , in der die nrOfMessages um 1 erh\u00f6ht und die Methode notifyListeners() aufgerufen wird. Erstellen Sie eine Klasse Student , die das Listener -Interface implementiert. Objektvariablen der Klasse sind private String name; (speichert den Namen von Student ) private Publisher publisher; (speichert den Publisher , an den sich Student anmeldet) Im parametrisierten Konstruktor public Student(String name) wird der Name initalisiert. In der Methode setPublisher(Publisher publisher) wird die register() -Methode des publisher aufgerufen und der Wert der Objektvariable publisher gesetzt. Geben Sie bei erfolgreicher Anmeldung an den publisher auf die Konsole this.name + \" registered!\" aus. In der Methode removePublisher(Publisher publisher) meldet sich Student wieder vom publisher ab (Aufruf von unregister() und Ausgabe auf die Konsole this.name + \" deregistered!\" . In der Methode update() wird die getUpdate() -Methode des publisher aufgerufen und die zur\u00fcckgegebene Nachricht msg wie folgt auf die Konsole ausgegben: this.name + \" received \" + msg . Implementieren Sie f\u00fcr Student auch die Methoden equals() und hashCode() . Wenn Sie Ihre Implementierung mit folgender Klasse testen: public class Testklasse { public static void main ( String [] args ) { final int NR_OF_STUDENTS = 5 ; Slack slack = new Slack (); Student [] students = new Student [ NR_OF_STUDENTS ] ; Character c = 'A' ; for ( int index = 0 ; index < students . length ; index ++ ) { students [ index ] = new Student ( c . toString ()); c ++ ; students [ index ] . setPublisher ( slack ); } slack . publishNews (); System . out . println (); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 1 ] . setPublisher ( slack ); students [ 2 ] . removePublisher ( slack ); students [ 4 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 0 ] . removePublisher ( slack ); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . setPublisher ( slack ); System . out . println (); slack . publishNews (); } } dann sollte die Ausgabe ungef\u00e4hr so sein: A registered! B registered! C registered! D registered! E registered! D received Breaking News 1 C received Breaking News 1 B received Breaking News 1 A received Breaking News 1 E received Breaking News 1 B deregistered! D deregistered! C received Breaking News 2 A received Breaking News 2 E received Breaking News 2 B registered! C deregistered! E deregistered! B received Breaking News 3 A received Breaking News 3 A deregistered! B deregistered! D registered! D received Breaking News 4 eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 6 Listener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 package aufgaben.aufgabe6 ; public interface Listener { //method to update the listener, used by publisher public void update (); //attach with publisher to observe public void setPublisher ( Publisher publisher ); //attach with publisher to observe public void removePublisher ( Publisher publisher ); } Publisher.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package aufgaben.aufgabe6 ; public interface Publisher { //methods to register and unregister listeners (observers) public boolean register ( Listener listener ); public boolean unregister ( Listener listener ); //method to notify listeners of change public void notifyListeners (); //method to get updates from publisher (subject) public String getUpdate ( Listener listener ); } Slack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package aufgaben.aufgabe6 ; import java.util.* ; public class Slack implements Publisher { private Set < Listener > listeners ; private int nrOfMessages ; public Slack () { this . listeners = new HashSet <> (); this . nrOfMessages = 0 ; } @Override public boolean register ( Listener listener ) { return listeners . add ( listener ); } @Override public boolean unregister ( Listener listener ) { return listeners . remove ( listener ); } @Override public void notifyListeners () { for ( Listener listener : listeners ) { listener . update (); } } @Override public String getUpdate ( Listener obj ) { return \"Breaking News \" + this . nrOfMessages ; } public void publishNews () { this . nrOfMessages ++ ; this . notifyListeners (); } } Student.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package aufgaben.aufgabe6 ; public class Student implements Listener { private String name ; private Publisher publisher ; public Student ( String name ) { this . name = name ; } @Override public void update () { String msg = this . publisher . getUpdate ( this ); System . out . println ( this . name + \" received \" + msg ); } @Override public void setPublisher ( Publisher publisher ) { this . publisher = publisher ; if ( this . publisher . register ( this )) { System . out . println ( this . name + \" registered!\" ); } } @Override public void removePublisher ( Publisher publisher ) { if ( this . publisher . unregister ( this )) { System . out . println ( this . name + \" deregistered!\" ); this . publisher = null ; } } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Student so = ( Student ) o ; return this . name . equals ( so . name ); } @Override public int hashCode () { return this . name . hashCode (); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package aufgaben.aufgabe6 ; public class Testklasse { public static void main ( String [] args ) { final int NR_OF_STUDENTS = 5 ; Slack slack = new Slack (); Student [] students = new Student [ NR_OF_STUDENTS ] ; Character c = 'A' ; for ( int index = 0 ; index < students . length ; index ++ ) { students [ index ] = new Student ( c . toString ()); c ++ ; students [ index ] . setPublisher ( slack ); } slack . publishNews (); System . out . println (); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 1 ] . setPublisher ( slack ); students [ 2 ] . removePublisher ( slack ); students [ 4 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 0 ] . removePublisher ( slack ); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . setPublisher ( slack ); System . out . println (); slack . publishNews (); } } Aufgabe 7 (GUI) \u00b6 Aufgabe 7 Erstellen Sie die GUI f\u00fcr einen solchen Taschenrechner: Kann auch schicker sein :-) Viel Spa\u00df! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 7 Taschenrechner.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package aufgaben.aufgabe7 ; import java.awt.* ; import javax.swing.* ; public class Taschenrechner extends JFrame { public Taschenrechner () { super (); setTitle ( \"Taschenrechner\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . add ( mainPanel , BorderLayout . CENTER ); setSize ( 250 , 350 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); JTextField tf = new JTextField ( 8 ); tf . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); tf . setHorizontalAlignment ( JTextField . RIGHT ); oben . add ( tf ); JPanel unten = new JPanel (); unten . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); JButton b0 = new JButton ( \"0\" ); JButton b1 = new JButton ( \"1\" ); JButton b2 = new JButton ( \"2\" ); JButton b3 = new JButton ( \"3\" ); JButton b4 = new JButton ( \"4\" ); JButton b5 = new JButton ( \"5\" ); JButton b6 = new JButton ( \"6\" ); JButton b7 = new JButton ( \"7\" ); JButton b8 = new JButton ( \"8\" ); JButton b9 = new JButton ( \"9\" ); JButton bMal = new JButton ( \"*\" ); JButton bDurch = new JButton ( \"/\" ); JButton bPlus = new JButton ( \"+\" ); JButton bMinus = new JButton ( \"-\" ); JButton bKlauf = new JButton ( \"(\" ); JButton bKlzu = new JButton ( \")\" ); JButton bKomma = new JButton ( \".\" ); JButton bC = new JButton ( \"C\" ); JButton bCE = new JButton ( \"CE\" ); JButton bErg = new JButton ( \"=\" ); unten . add ( b1 ); unten . add ( b2 ); unten . add ( b3 ); unten . add ( b4 ); unten . add ( b5 ); unten . add ( b6 ); unten . add ( b7 ); unten . add ( b8 ); unten . add ( b9 ); unten . add ( bKlauf ); unten . add ( b0 ); unten . add ( bKlzu ); unten . add ( bMal ); unten . add ( bDurch ); unten . add ( bPlus ); unten . add ( bMinus ); unten . add ( bKomma ); unten . add ( bErg ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Taschenrechner (); } } Aufgabe 8 (Ereignisbehandlung) \u00b6 Aufgabe 8 Implementieren Sie f\u00fcr den Taschenrechner aus Aufgabe 7 das ActionListener -Interface, so dass der Taschenrechner \u00fcber m\u00f6glichst viel Funktionalit\u00e4t verf\u00fcgt. Minimumanforderung ist, dass durch die Eingabe von Ziffern Zahlen entstehen und dass die Buttons + , - , / , + und = insofern funktionieren, dass dadurch tats\u00e4chlich gerechnet wird, auch wenn die Regel \"Punktrechnung geht vor Strichrechnung\" nicht eingehalten wird. Eine erste Verbesserung (ist schon Zusatz ) w\u00e4re, dass die Regel \"Punktrechnung geht vor Strichrechnung\" eingehalten wird. Ab dann ist alles Zusatz und bedarf in vielen F\u00e4llen der Erweiterung der GUI: Verwendung und Beachten von Klammern (ist aber sehr schwer!), Speichern von Zwischenergebnissen, komplexere Operationen durch zu\u00e4tzliche Tasten (Wurzel, Potenzieren, ...). Alles, was Sie m\u00f6chten - Viel Spa\u00df! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 9 Taschenrechner.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 package aufgaben.aufgabe9 ; import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; //Klammern werden ignoriert public class Taschenrechner extends JFrame implements ActionListener { JPanel hauptPanel ; JButton b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , bMal , bPlus , bMinus , bDurch , bErg , bKlauf , bKlzu , bKomma , bC , bCE ; JTextField tf ; double zahl1 , zahl2 , zahl3 ; boolean zahl1Gesetzt = false ; boolean zahl2Gesetzt = false ; boolean zahl3Gesetzt = false ; boolean letztesZeichenZiffer = false ; String eingabe = \"\" , aktEingabe = \"0\" ; String op1 = \"\" , op2 = \"\" ; int anzKlammern = 0 ; Taschenrechner () { super (); setTitle ( \"Taschenrechner\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); hauptPanel = init (); tf = new JTextField (); tf . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); tf . setHorizontalAlignment ( JTextField . RIGHT ); this . add ( tf , BorderLayout . NORTH ); this . add ( hauptPanel , BorderLayout . CENTER ); setSize ( 250 , 350 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); b0 = new JButton ( \"0\" ); b1 = new JButton ( \"1\" ); b2 = new JButton ( \"2\" ); b3 = new JButton ( \"3\" ); b4 = new JButton ( \"4\" ); b5 = new JButton ( \"5\" ); b6 = new JButton ( \"6\" ); b7 = new JButton ( \"7\" ); b8 = new JButton ( \"8\" ); b9 = new JButton ( \"9\" ); bMal = new JButton ( \"*\" ); bDurch = new JButton ( \"/\" ); bPlus = new JButton ( \"+\" ); bMinus = new JButton ( \"-\" ); bKlauf = new JButton ( \"(\" ); bKlzu = new JButton ( \")\" ); bKomma = new JButton ( \".\" ); bC = new JButton ( \"C\" ); bCE = new JButton ( \"CE\" ); bErg = new JButton ( \"=\" ); b0 . addActionListener ( this ); b1 . addActionListener ( this ); b2 . addActionListener ( this ); b3 . addActionListener ( this ); b4 . addActionListener ( this ); b5 . addActionListener ( this ); b6 . addActionListener ( this ); b7 . addActionListener ( this ); b8 . addActionListener ( this ); b9 . addActionListener ( this ); bMal . addActionListener ( this ); bDurch . addActionListener ( this ); bPlus . addActionListener ( this ); bMinus . addActionListener ( this ); bErg . addActionListener ( this ); bKlauf . addActionListener ( this ); bKlzu . addActionListener ( this ); bC . addActionListener ( this ); bCE . addActionListener ( this ); bKomma . addActionListener ( this ); panel . add ( b1 ); panel . add ( b2 ); panel . add ( b3 ); panel . add ( b4 ); panel . add ( b5 ); panel . add ( b6 ); panel . add ( b7 ); panel . add ( b8 ); panel . add ( b9 ); panel . add ( bKlauf ); panel . add ( b0 ); panel . add ( bKlzu ); panel . add ( bMal ); panel . add ( bDurch ); panel . add ( bPlus ); panel . add ( bMinus ); panel . add ( bKomma ); panel . add ( bErg ); return panel ; } public static void main ( String [] args ) { new Taschenrechner (); } @Override public void actionPerformed ( ActionEvent event ) { Object quelle = event . getSource (); if ( quelle instanceof JButton ) { switch ((( JButton ) quelle ). getActionCommand ()) { case \"0\" : eingabeZiffer ( 0 ); tf . setText ( aktEingabe ); break ; case \"1\" : eingabeZiffer ( 1 ); tf . setText ( aktEingabe ); break ; case \"2\" : eingabeZiffer ( 2 ); tf . setText ( aktEingabe ); break ; case \"3\" : eingabeZiffer ( 3 ); tf . setText ( aktEingabe ); break ; case \"4\" : eingabeZiffer ( 4 ); tf . setText ( aktEingabe ); break ; case \"5\" : eingabeZiffer ( 5 ); tf . setText ( aktEingabe ); break ; case \"6\" : eingabeZiffer ( 6 ); tf . setText ( aktEingabe ); break ; case \"7\" : eingabeZiffer ( 7 ); tf . setText ( aktEingabe ); break ; case \"8\" : eingabeZiffer ( 8 ); tf . setText ( aktEingabe ); break ; case \"9\" : eingabeZiffer ( 9 ); tf . setText ( aktEingabe ); break ; case \"*\" : eingabePunktOperator ( \"*\" ); tf . setText ( eingabe ); break ; case \"/\" : eingabePunktOperator ( \"/\" ); tf . setText ( eingabe ); break ; case \"+\" : eingabeStrichOperator ( \"+\" ); tf . setText ( eingabe ); break ; case \"-\" : eingabeStrichOperator ( \"-\" ); tf . setText ( eingabe ); break ; case \"=\" : eingabeGleich (); tf . setText ( eingabe ); break ; case \".\" : eingabeKomma (); tf . setText ( aktEingabe ); break ; case \"(\" : eingabeOeffnendeKlammer (); tf . setText ( eingabe ); break ; case \")\" : eingabeSchliessendeKlammer (); tf . setText ( aktEingabe ); break ; case \"C\" : tf . setText ( \"\" ); break ; } } } void eingabeOeffnendeKlammer () { if ( ! letztesZeichenZiffer ) { anzKlammern ++ ; } } void eingabeSchliessendeKlammer () { if ( letztesZeichenZiffer ) { anzKlammern -- ; letztesZeichenZiffer = false ; } } void eingabeZiffer ( int ziffer ) { if ( letztesZeichenZiffer ) { aktEingabe += ( new Integer ( ziffer )). toString (); } else { aktEingabe = ( new Integer ( ziffer )). toString (); letztesZeichenZiffer = true ; } } void eingabeKomma () { if ( aktEingabeIstIntZahl ()) aktEingabe += \".\" ; letztesZeichenZiffer = true ; if ( aktEingabeIstDoubleZahl ()) System . out . println ( \"ok\" ); else System . out . println ( \"kein double\" ); } void eingabeGleich () { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = false ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = false ; zahl2 = Double . parseDouble ( aktEingabe ); switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = false ; zahl2Gesetzt = false ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 * zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 * zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 * zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 * zahl3 ; break ; } } else if ( op2 . equals ( \"/\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 / zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 / zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 / zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 / zahl3 ; break ; } } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } } } void eingabeStrichOperator ( String operator ) { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = true ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = aktEingabe + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = true ; zahl2 = Double . parseDouble ( aktEingabe ); switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString () + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = true ; zahl2Gesetzt = false ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 * zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 * zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 * zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 * zahl3 ; break ; } } else if ( op2 . equals ( \"/\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 / zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 / zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 / zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 / zahl3 ; break ; } } eingabe = ( new Double ( zahl1 )). toString () + operator ; aktEingabe = \"0\" ; op1 = operator ; } } } void eingabePunktOperator ( String operator ) { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = true ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = aktEingabe + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = true ; zahl2 = Double . parseDouble ( aktEingabe ); if ( op1 . equals ( \"*\" ) || op1 . equals ( \"/\" )) { switch ( op1 ) { case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = operator ; } else { op2 = operator ; eingabe = eingabe + aktEingabe + operator ; aktEingabe = \"0\" ; zahl2Gesetzt = true ; } } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = true ; zahl2Gesetzt = true ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { zahl2 = zahl2 * zahl3 ; } else if ( op2 . equals ( \"/\" )) { zahl2 = zahl2 / zahl3 ; } eingabe = ( new Double ( zahl1 )). toString () + op1 + ( new Double ( zahl2 )). toString () + op2 ; aktEingabe = \"0\" ; op2 = operator ; } } } boolean aktEingabeIstIntZahl () { try { Integer . parseInt ( aktEingabe ); } catch ( NumberFormatException e ) { return false ; } return true ; } boolean aktEingabeIstDoubleZahl () { try { Double . parseDouble ( aktEingabe ); } catch ( NumberFormatException e ) { return false ; } return true ; } } Aufgabe 9 (Zeichnen - entf\u00e4llt ) \u00b6 Aufgabe 9 Wir berechnen PI mithilfe der Monte-Carlo-Methode . Dazu zeichnen wir ein Quadrat und darin einen Kreisbogen (einen Viertelkreis), dessen Radius der Seitenl\u00e4nge des Quadrats entspricht: Nun zeichnen wir in dieses Quadrat viele kleine ausgef\u00fcllte Kreise (Durchmesser z.B. 2 Pixel). Die Positionen dieser Kreise werden zuf\u00e4llig ermittelt. Wenn die zuf\u00e4llig ermittelte Position f\u00fcr diesen Kreis im Kreisbogen liegt, dann sind die kleinen Kreise rot, wenn die Position au\u00dferhalb liegt, dann sind die Kreise blau. Es entsteht bei ganz vielen (z.B. 50000 ) Punkten so ein Bild: Tipp: Ob ein Punkt mit den Koordinaten (x,y) in einem (Viertel-)Kreis liegt, ermitteln Sie mithilfe der Kreisgleichung . Sei (xm, ym) der Mittelpunkt und r der Radius des Kreises, dann gilt (x-xm)^2 + (y-ym)^2 = r^2 f\u00fcr alle Punkte auf dem Kreis (f\u00fcr Punkte im Kreis gilt <= und f\u00fcr Punkte au\u00dferhalb des Kreises >). Der Quotient aus der Anzahl der roten Punkte und der Gesamtanzahl der Punkte ist eine N\u00e4herung von PI/4. Geben Sie Ihre Ann\u00e4herung von PI auf der Konsole aus. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 9 ComputePI.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package aufgaben.aufgabe9 ; import java.awt.* ; import java.util.Random ; import javax.swing.* ; public class ComputePI extends JFrame { ComputePI (){ super ( \"Berechne PI\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . add ( new Canvas (), BorderLayout . CENTER ); this . setSize ( 500 , 500 ); this . setVisible ( true ); } class Canvas extends JPanel { private Random r = new Random (); private int anzahlPunkte = 50000 ; private int rotePunkte = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); int x0 = 20 ; int y0 = 20 ; int quadLength = 440 ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setStroke ( new BasicStroke ( 3 )); // Quadrat g2 . setColor ( Color . WHITE ); g2 . fillRect ( x0 , y0 , quadLength , quadLength ); g2 . setColor ( Color . BLACK ); g2 . drawRect ( x0 , y0 , quadLength , quadLength ); //Kreisbogen g2 . drawArc ( x0 , y0 , 2 * quadLength , 2 * quadLength , 90 , 90 ); g2 . setStroke ( new BasicStroke ( 1 )); g2 . setColor ( Color . RED ); int x , y ; int xM = x0 + quadLength ; int yM = y0 + quadLength ; //counting variables for keeping track of red/blue dots rotePunkte = 0 ; //draws all the points for ( int i = 0 ; i < anzahlPunkte ; i ++ ){ //random coordinates f the dot x = r . nextInt ( quadLength ) + x0 ; y = r . nextInt ( quadLength ) + y0 ; //set the color of the dot if ((( x - xM ) * ( x - xM ) + ( y - yM ) * ( y - yM )) <= ( quadLength * quadLength )){ g2 . setColor ( Color . RED ); rotePunkte ++ ; } else { g2 . setColor ( Color . BLUE ); } //draw the dot g2 . fillOval ( x , y , 2 , 2 ); double pi = ( double ) rotePunkte / ( double ) anzahlPunkte * 4.0 ; System . out . println ( \"PI ist \" + pi ); } } } public static void main ( String [] args ) { ComputePI pi = new ComputePI (); //pi.canvas.repaint(); } }","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-wurfelspiel","text":"Aufgabe 1 Vorbereitung (siehe Einstieg ) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Erstellen Sie insbesondere folgenden Dialog (in den Buttons kann auch Yes und No stehen) und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 Spiel.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package aufgaben.aufgabe1 ; import javax.swing.JOptionPane ; public class Spiel { public static int siegPunkte ; private Spieler [] spieler ; Spiel () { int anzSpieler = 0 ; int siegPunkte = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Anzahl Spieler :\" ); inputOk = true ; anzSpieler = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } inputOk = false ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Siegpunkte :\" ); inputOk = true ; siegPunkte = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; namenErmitteln (); } Spiel ( int siegPunkte , int anzSpieler ) { Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; /* Spielernamen sind A, B, C ... char name = 'A'; for(int i=0; i<spieler.length; i++) { spieler[i] = new Spieler(String.valueOf(name)); name ++; } */ /* Spielernamen werden eingegeben * wenn man namenErmitteln() auskommentiert, * kann man die obige for-Schleife nehmen, damit * man nicht immer die Spielernamen eingeben muss * - zum Testen */ namenErmitteln (); } private void namenErmitteln () { String name = \"\" ; for ( int i = 0 ; i < spieler . length ; i ++ ) { name = JOptionPane . showInputDialog ( \"Name des Spielers \" + ( i + 1 ) + \" :\" ); spieler [ i ] = new Spieler ( name ); } } public void spielen () { int index = 0 ; boolean gewonnen = false ; while ( ! gewonnen ) { gewonnen = spieler [ index ] . wuerfeln (); index = ( index < spieler . length - 1 ) ? index + 1 : 0 ; } } public static void main ( String [] args ) { //Spiel spiel = new Spiel(30, 3); Spiel spiel = new Spiel (); spiel . spielen (); } } Spieler.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package aufgaben.aufgabe1 ; import java.util.Random ; import javax.swing.JOptionPane ; public class Spieler { private String name ; private int aktStand ; private Random r ; Spieler ( String name ) { aktStand = 0 ; this . name = name ; r = new Random (); } public int getAktStand () { return this . aktStand ; } public boolean wuerfeln () { System . out . printf ( \"%n%nSpieler %s ist an der Reihe (bisher %d Punkte) %n ----------------------------------------- %n\" , this . name , this . aktStand ); int reihe = 0 ; int wurf = 0 ; boolean ende = false ; while ( ! ende ) { wurf = r . nextInt ( 6 ) + 1 ; System . out . printf ( \"%s hat eine %d gewuerfelt %n\" , this . name , wurf ); if ( wurf == 6 ) { System . out . printf ( \"Versuch zu Ende %n Aktueller Spielstand von %s : %d Punkte %n Der naechste Spieler ist dran%n\" , this . name , this . aktStand ); ende = true ; } else if ( aktStand + reihe + wurf >= Spiel . siegPunkte ) { System . out . printf ( \"%s hat insgesamt %d Punkte und somit gewonnen !!!\" , this . name , ( aktStand + reihe + wurf )); return true ; } else // eine 1..5 gewuerfelt und noch nicht gewonnen { reihe += wurf ; System . out . printf ( \"in diesem Versuch bisher %d Punkte -- insgesamt %d Punkte %n\" , reihe , ( aktStand + reihe )); int dialogResult = JOptionPane . showConfirmDialog ( null , this . name + \", wollen Sie weiter wuerfeln? \" , \"Weiter wuerfeln?\" , JOptionPane . YES_NO_OPTION ); ende = ! ( dialogResult == JOptionPane . YES_OPTION ); if ( ende ) { aktStand += reihe ; } } } return false ; } }","title":"Aufgabe 1 (W\u00fcrfelspiel)"},{"location":"aufgaben/#aufgabe-2-myinteger","text":"Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 2 MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package aufgaben.aufgabe2 ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 048 bis 9 ist 057 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { boolean negativ = false ; if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leer\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne f\u00fchrende Nullen while ( s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int exponent = 0 ; int zahl = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { zahl = zahl + charToInt ( s . charAt ( i )) * ( int ) Math . pow ( 10 , exponent ); exponent ++ ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerMain.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package aufgaben.aufgabe2 ; public class MyIntegerMain { public static void main ( String [] args ) { MyInteger mi1 = null , mi2 = null , mi3 = null , mi4 = null , mi5 = null , mi6 = null , mi7 = null , mi8 = null , mi9 = null , mi10 = null ; try { mi1 = new MyInteger ( \"-2147483648\" ); System . out . println ( mi1 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi2 = new MyInteger ( \"-00002147483648\" ); System . out . println ( mi2 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi3 = new MyInteger ( \"hallo\" ); System . out . println ( mi3 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi4 = new MyInteger ( - 2147483648 ); try { mi5 = MyInteger . valueOf ( \"-2147483648\" ); System . out . println ( mi5 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi6 = MyInteger . valueOf ( \"-00002147483648\" ); System . out . println ( mi6 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi7 = MyInteger . valueOf ( \"hallo\" ); System . out . println ( mi7 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi8 = MyInteger . valueOf ( - 2147483648 ); try { mi9 = MyInteger . valueOf ( \"\" ); System . out . println ( mi9 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi10 = MyInteger . valueOf ( \"+\" ); System . out . println ( mi10 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"mi1 equals mi2 ? : \" + mi1 . equals ( mi2 )); System . out . println ( \"mi1 equals mi3 ? : \" + mi1 . equals ( mi3 )); System . out . println ( \"mi1 equals mi4 ? : \" + mi1 . equals ( mi4 )); System . out . println ( \"mi1 equals mi5 ? : \" + mi1 . equals ( mi5 )); System . out . println ( \"mi1 equals mi6 ? : \" + mi1 . equals ( mi6 )); System . out . println ( \"mi1 equals mi7 ? : \" + mi1 . equals ( mi7 )); System . out . println ( \"mi1 equals mi8 ? : \" + mi1 . equals ( mi8 )); System . out . println ( \"mi1 equals mi9 ? : \" + mi1 . equals ( mi9 )); System . out . println ( \"mi1 equals mi10 ? : \" + mi1 . equals ( mi10 )); System . out . println ( \"hashCode mi1 : \" + mi1 . hashCode ()); System . out . println ( \"hashCode mi2 : \" + mi2 . hashCode ()); try { System . out . println ( \"hashCode mi3 : \" + mi3 . hashCode ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"hashCode mi4 : \" + mi4 . hashCode ()); System . out . println ( \"intValue mi1 : \" + mi1 . intValue ()); System . out . println ( \"intValue mi2 : \" + mi2 . intValue ()); try { System . out . println ( \"intValue mi3 : \" + mi3 . intValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"intValue mi4 : \" + mi4 . intValue ()); System . out . println ( \"doubleValue mi1 : \" + mi1 . doubleValue ()); System . out . println ( \"doubleValue mi2 : \" + mi2 . doubleValue ()); try { System . out . println ( \"doubleValue mi3 : \" + mi3 . doubleValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"doubleValue mi4 : \" + mi4 . doubleValue ()); } }","title":"Aufgabe 2 (MyInteger)"},{"location":"aufgaben/#aufgabe-3-solitaire","text":"Aufgabe 3 Information und Vorbereitung Wir wenden Aufz\u00e4hlungstypen und mehrdimensionale Arrays an. Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. Teil der Aufgabe ist es auch, \"fremden\" Code zu lesen und zu verstehen, denn einige Klassen sind bereits gegeben: Klasse Point.java package aufgaben.aufgabe3 ; /* * ein Point repreasentiert eine Position * im Spielfeld, bestehend aus der Nummer * fuer die Zeile (row) und der Nummer * fuer die Spalte (col) */ public class Point { private int row ; private int col ; /* * Konstruktor zur Erzeugung einer * Position bestehend aus row und col */ public Point ( int row , int col ) { this . row = row ; this . col = col ; } public int getRow () { return this . row ; } public int getCol () { return this . col ; } @Override public String toString () { return \"(\" + this . row + \",\" + this . col + \")\" ; } } Klasse Move.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert einen Zug * Variablen sind Point from * und Point to * es wird nicht geprueft, ob der Zug ueberhaupt * moeglich ist */ public class Move { private Point from ; private Point to ; /* * ein Zug von dem from-Point (fromRow,fromCol) * zum to-Point (toRow,toCol) */ public Move ( int fromRow , int fromCol , int toRow , int toCol ) { this . from = new Point ( fromRow , fromCol ); this . to = new Point ( toRow , toCol ); } /* * in dem Konstruktor werden in this.from und this.to nicht einfach * die Referenzen von from und to gespeichert, sondern davon Kopien * erstellt, damit das Programm robuster gegen das Aendern von * Referenzen ist */ public Move ( Point from , Point to ) { this . from = new Point ( from . getRow (), from . getCol ()); this . to = new Point ( to . getRow (), to . getCol ()); } /* * der Getter fuer den Point from gibt keine Referenz auf * den Point from zurueck, sondern eine Kopie (einen Klon) * von from --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getFrom () { return new Point ( this . from . getRow (), this . from . getCol ()); } /* * der Getter fuer den Point to gibt keine Referenz auf * den Point to zurueck, sondern eine Kopie (einen Klon) * von to --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getTo () { return new Point ( this . to . getRow (), this . to . getCol ()); } } Klasse Moves.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert eine Folge * von Zuegen (Move), die in einem Array * moves gespeichert sind */ public class Moves { private Move [] moves ; /* * der Konstruktor erstellt ein leeres moves-Array * (d.h. noch keine Zuege (Moves) gespeichert) */ public Moves () { this . moves = new Move [ 0 ] ; } /* * der Konstruktor erstellt ein moves-Array mit einem * Move - dem erste Zug (firstMove) */ public Moves ( Move firstMove ) { this . moves = new Move [ 1 ] ; this . moves [ 0 ] = firstMove ; } /* * Anzahl der bisher gespeicherten Zuege */ public int getLength () { return this . moves . length ; } /* * fuegt einen Zug (nextMove) zum moves-Array hinzu * dazu muss das moves-Array um 1 laenger sein als zuvor * es wird eine Kopie aller Zuege erstellt und dann * der nextMove hinzugefuegt */ public void addMove ( Move nextMove ) { Move [] newMoves = new Move [ this . moves . length + 1 ] ; for ( int index = 0 ; index < this . moves . length ; index ++ ) { newMoves [ index ] = this . moves [ index ] ; } newMoves [ newMoves . length - 1 ] = new Move ( nextMove . getFrom (), nextMove . getTo ()); this . moves = newMoves ; } /* * gibt den Move zurueck, der im moves-Array unter dem Index index * gespeichert ist; * kann sein, dass index kein korrekter Index im moves-Array ist, * dann wird eine IllegalArgumentException geworfen */ public Move getMoveAtIndex ( int index ) throws IllegalArgumentException { try { return this . moves [ index ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"kein gueltiger Index!\" ); } } /* * Ausgabe aller im moves-Array gespeicherten Zuege * wird nur zum Debuggen benoetigt */ public void printMoves () { System . out . printf ( \"%n---%n\" ); for ( int index = 0 ; index < this . moves . length ; index ++ ) { Move move = this . moves [ index ] ; Point from = move . getFrom (); Point to = move . getTo (); System . out . println ( from . toString () + \" --> \" + to . toString ()); } System . out . printf ( \"%n---%n%n\" ); } } enum State.java package aufgaben.aufgabe3 ; /* * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf * USED - der Platz ist ein Spielfeld mit Spielstein drauf * NOT - der Platz gehoert nicht zum Spielfeld */ public enum State { FREE , USED , NOT } Aufgabe Bef\u00fcllen Sie die Klasse Solitaire.java , wie in den Kommentaren beschrieben: Klasse Solitaire.java package aufgaben.aufgabe3.loesung ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } /* * Geben Sie das Spielfeld aus! Am Anfang sollte auf der * Konsole so ein Bild erscheinen: * o o o * o o o * o o o o o o o * o o o o o o * o o o o o o o * o o o * o o o * */ public void print () { } /* * diese Methode gibt ein true zurueck, wenn von der * uebergebenen Position (row,col) ein Zug moeglich ist * d.h. * 1. auf der angegebenen Position muss ein Stein sein * 2. zwei Steine weiter (oben, unten, rechts oder links) * darf kein Stein sein * 3. dazwischen muss ein Stein sein */ public boolean possibleFrom ( int row , int col ) { return false ; } /* * diese Methode gibt alle Positionen (Point) zurueck, * AUF die von (fromRow,fromCol) aus gesprungen werden * kann */ public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; /* * naechste Zeile muss entfernt werden! * sttatdessen muessen Sie alle Point-Objekte ermitteln AUF die * gesprungen werden kann. Diese Point-Objekte werden in einem * Point-Array gespeichert, welches zur\u00fcckgegeben wird. */ return null ; } /* * diese Methode erzeugt ein Moves-Objekt * in dieses Moves-Objekt werden mithilfe der * Objektmethode addMove() (aus Moves) alle * moeglichen Zuege hinzugefuegt * (moeglich im aktuellen Zustand von field[][]) */ public Moves possibleMoves () { Moves possibleMoves = new Moves (); // next line for debugging possibleMoves . printMoves (); return possibleMoves ; } /* * gibt ein true zurueck, wenn im aktuellen Zustand * von field[][] ueberhaupt noch ein Zug moeglich ist * sonst false */ public boolean movePossible () { return false ; } /* * ruft die Methode move(Move move) auf, * wenn ein Zug moeglich ist (dann true zurueck) * sonst false */ public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; /* * hier einen moeglichen Zug ausfuehren * den ersten, den Sie finden (siehe * possibleMoves() ) */ return true ; } /* * hier wird der Zug Move move ausgefuehrt * nach dem Zug ist * 1. die from-Position leer * 2. die to-Position mit einem Stein besetzt * 3. dazwischen leer (Stein wird \"entfernt\") * falls Zug nicht moeglich, wird eine * IllegalArgumentException geworfen */ public void move ( Move move ) throws IllegalArgumentException { } } Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. Testen Sie Ihr Spiel in einer Testklasse . F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen: m\u00f6gliche Konsolenausgaben o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,1 ) --> ( 2 ,3 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 2 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,2 ) --> ( 2 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 0 ,2 ) ( 2 ,3 ) --> ( 2 ,1 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,3 ) --> ( 2 ,1 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,0 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,2 ) --> ( 2 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,6 ) --> ( 2 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,4 ) --> ( 2 ,4 ) --- o o o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 3 ,1 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o --- ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 2 ,4 ) ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o o --- ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o --- ( 3 ,3 ) --> ( 3 ,5 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o --- ( 4 ,5 ) --> ( 2 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 2 ,6 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o --- ( 4 ,1 ) --> ( 4 ,3 ) ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o o --- ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 4 ,4 ) --> ( 4 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) ( 6 ,2 ) --> ( 4 ,2 ) --- o o o o o o o o o o --- ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o --- ( 5 ,4 ) --> ( 5 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o --- ( 4 ,2 ) --> ( 6 ,2 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o o o o o o o Dabei steht z.B. --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 3 Solitaire.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package aufgaben.aufgabe3 ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( this . field [ row ][ col ] == State . USED ) System . out . print ( \"o \" ); else System . out . print ( \" \" ); } System . out . println (); } System . out . println (); } public boolean possibleFrom ( int row , int col ) { if ( row >= 0 && row < 7 && col >= 0 && col < 7 && this . field [ row ][ col ] == State . USED ) { // up ? if ( row > 1 && this . field [ row - 1 ][ col ] == State . USED && this . field [ row - 2 ][ col ] == State . FREE ) return true ; // down ? if ( row < 5 && this . field [ row + 1 ][ col ] == State . USED && this . field [ row + 2 ][ col ] == State . FREE ) return true ; // right ? if ( col < 5 && this . field [ row ][ col + 1 ] == State . USED && this . field [ row ][ col + 2 ] == State . FREE ) return true ; // left ? if ( col > 1 && this . field [ row ][ col - 1 ] == State . USED && this . field [ row ][ col - 2 ] == State . FREE ) return true ; } return false ; } public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // there is at least one To-Point int nrOfPossibleTos = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) nrOfPossibleTos ++ ; Point [] tos = new Point [ nrOfPossibleTos ] ; int index = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow - 2 , fromCol ); if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow + 2 , fromCol ); if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol + 2 ); if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol - 2 ); return tos ; } public Moves possibleMoves () { Moves possibleMoves = new Moves (); for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) { Point [] tos = this . possibleTo ( row , col ); Point from = new Point ( row , col ); for ( int index = 0 ; index < tos . length ; index ++ ) { possibleMoves . addMove ( new Move ( from , tos [ index ] )); } } } } // next line for debug possibleMoves . printMoves (); return possibleMoves ; } public boolean movePossible () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) return true ; } } return false ; } public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; else { Moves possibleMoves = this . possibleMoves (); try { Move move = possibleMoves . getMoveAtIndex ( 0 ); this . move ( move ); return true ; } catch ( IllegalArgumentException e ) { System . out . println ( \"Zug nicht moeglich! Index : 0\" ); return false ; } } } public void move ( Move move ) throws IllegalArgumentException { Point from = move . getFrom (); Point to = move . getTo (); int fromRow = from . getRow (); int fromCol = from . getCol (); int toRow = to . getRow (); int toCol = to . getCol (); int middleRow = ( fromRow + toRow ) / 2 ; int middleCol = ( fromCol + toCol ) / 2 ; try { this . field [ fromRow ][ fromCol ] = State . FREE ; this . field [ middleRow ][ middleCol ] = State . FREE ; this . field [ toRow ][ toCol ] = State . USED ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"Zug nicht moeglich! (\" + fromRow + \", \" + fromCol + \") --> \" + \"( \" + toRow + \", \" + toCol + \") \" ); } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package aufgaben.aufgabe3 ; public class Testklasse { public static void main ( String [] args ) { Solitaire s = new Solitaire (); s . print (); while ( s . moveFirstPossible ()) { s . print (); } s . print (); } }","title":"Aufgabe 3 (Solitaire)"},{"location":"aufgaben/#aufgabe-4-operationen-uber-mengen","text":"Aufgabe 4 Implementieren Sie eine Klasse SetOperations . Erstellen Sie drei Objektvariablen (z.B. numbers1 , numbers2 und both ) vom Typ Set<Integer> . Erzeugen Sie f\u00fcr diese Objektvariablen TreeSet -Objekte. Erstellen Sie eine Objektmethode fill() . In dieser Methode sollen die beiden Sets numbers1 und numbers2 mit Zufallszahlen aus dem Wertebereich 0..99 bef\u00fcllt werden. Erzeugen Sie jeweils 100 Zufallszahlen (die number s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.) Beachten Sie, dass die nextInt() -Methode ein int zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein Integer -Objekt umgewandelt werden ( Integer.valueOf(int) ) und dieses Integer -Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist). Erstellen Sie eine Objektmethode fillBothUnion() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einer Vereinigung der Mengen numbers1 und numbers2 entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html . Erstellen Sie eine Objektmethode fillBothIntersection() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einem Schnitt der Mengen numbers1 und numbers2 entspricht. Erstellen Sie eine Objektmethode fillBothDifference() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both der Differenz der Menge numbers1 minus der Menge numbers2 entspricht. Schreiben Sie eine Methode print() so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen ( o, *, #, x, ... ) verwenden). Gestalten Sie die Ausgabe so, dass die drei Mengen numbers1 , numbers2 und both nebeneinander auf der Konsole erscheinen. Testen Sie alle drei Methoden fillBothUnion() , fillBothIntersection() und fillBothDifference() . Die Ausgabe k\u00f6nnte wie folgt sein ( A stellt die Menge numbers1 dar, B die Menge numbers2 und rechts ist jeweils die both -Menge dargestellt): Tipps : F\u00fcr die schwarzen Punkte habe ich das Character '\\u25cf' verwendet (ein passendes Leerzeichen dazu ist '\\u2009' ). Das Zeichen f\u00fcr die Vereinigung ist '\\u222a' und f\u00fcr den Schnitt '\\u2229' . Schauen Sie sich auch im Skript Mengenoperationen an. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 4 SetOperations.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 package aufgaben.aufgabe4 ; import java.util.* ; public class SetOperations { Set < Integer > numbers1 ; Set < Integer > numbers2 ; Set < Integer > both ; final static int UPPER_BOUND = 100 ; public SetOperations () { this . numbers1 = new TreeSet <> (); this . numbers2 = new TreeSet <> (); this . both = new TreeSet <> (); } public void fill () { Random r = new Random (); int nextIntNr = 0 ; Integer nextIntegerNr = Integer . valueOf ( nextIntNr ); // fill numbers1 for ( int i = 0 ; i < UPPER_BOUND ; i ++ ) { nextIntNr = r . nextInt ( UPPER_BOUND ); nextIntegerNr = Integer . valueOf ( nextIntNr ); this . numbers1 . add ( nextIntegerNr ); } // fill numbers2 for ( int i = 0 ; i < UPPER_BOUND ; i ++ ) { nextIntNr = r . nextInt ( UPPER_BOUND ); nextIntegerNr = Integer . valueOf ( nextIntNr ); this . numbers2 . add ( nextIntegerNr ); } } public void fillBothUnion () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A \" + '\\u222a' + \" B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . addAll ( numbers1 ); this . both . addAll ( numbers2 ); } public void fillBothIntersection () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A \" + '\\u2229' + \" B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . clear (); this . both . addAll ( numbers1 ); this . both . retainAll ( numbers2 ); } public void fillBothDifference () { System . out . println (); System . out . println ( \"----------------------------------------------------------------------------\" ); System . out . println ( \" A B A-B \" ); System . out . println ( \"----------------------------------------------------------------------------\" ); this . both . clear (); this . both . addAll ( numbers1 ); this . both . removeAll ( numbers2 ); } public Integer printOneLine ( Iterator < Integer > it , Integer next , int curRow ) { int curNr = 0 ; // row*10+col for ( int col = 0 ; col < 10 ; col ++ ) { curNr = curRow * 10 + col ; if ( next != null && next . intValue () == curNr ) { System . out . print ( '\\u25cf' + \" \" ); if ( it . hasNext ()) { next = it . next (); } } else { //System.out.print('\\u25cc'+\" \"); System . out . print ( '\\u2009' + \" \" ); } } return next ; } private void printSpaces ( int nrOfSpaces ) { for ( int spaces = 0 ; spaces < nrOfSpaces ; spaces ++ ) System . out . print ( \" \" ); } private void justTestPrint () { System . out . print ( numbers1 . size () + \" : [ \" ); for ( Integer i : numbers1 ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); System . out . print ( numbers2 . size () + \" : [ \" ); for ( Integer i : numbers2 ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); System . out . print ( both . size () + \" : [ \" ); for ( Integer i : both ) System . out . print ( i . intValue () + \" \" ); System . out . println ( \"]\" ); System . out . println (); } public void print () { justTestPrint (); System . out . println (); Iterator < Integer > it1 = numbers1 . iterator (); Integer next1 = ( it1 . hasNext ()) ? it1 . next () : null ; Iterator < Integer > it2 = numbers2 . iterator (); Integer next2 = ( it2 . hasNext ()) ? it2 . next () : null ; Iterator < Integer > itb = both . iterator (); Integer nextB = ( itb . hasNext ()) ? itb . next () : null ; for ( int row = 0 ; row < 10 ; row ++ ) { next1 = this . printOneLine ( it1 , next1 , row ); printSpaces ( 8 ); next2 = this . printOneLine ( it2 , next2 , row ); printSpaces ( 8 ); nextB = this . printOneLine ( itb , nextB , row ); System . out . println (); } System . out . println (); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package aufgaben.aufgabe4 ; public class Testklasse { public static void main ( String [] args ) { SetOperations so = new SetOperations (); so . fill (); so . fillBothUnion (); so . print (); so . fillBothIntersection (); so . print (); so . fillBothDifference (); so . print (); } }","title":"Aufgabe 4 (Operationen \u00fcber Mengen)"},{"location":"aufgaben/#aufgabe-5-maps","text":"Aufgabe 5 Testen Sie folgenden Code: long a = 1000 ; Integer b = 1000 ; Integer c = 1000 ; System . out . println ( a == b ); System . out . println ( b == c ); Was stellen Sie fest und warum? \u00c4ndern Sie den Vergleich der Variablen b und c so, dass true ausgegeben wird. Die ersten drei Zeilen bleiben dabei unver\u00e4ndert. Sie ben\u00f6tigen also einen anderen Vergleich als b == c . Erstellen Sie eine Klasse PizzaMenu . Erzeugen Sie darin eine HashMap und f\u00fcgen Sie folgende Pizzen mit ihren Preisen ein: Pizza Preis Margherita 7,00 Veggie 7,50 Salami 8,50 Schinken 8,50 Schreiben Sie eine Methode public static boolean existingPizza(Map<String,Double> menu, String pizza) , die testet, ob eine eingegebene Pizza im Men\u00fc existiert. Schreiben Sie eine Methode public static void printPrice(Map<String,Double> menu, String pizza) , die f\u00fcr eine eingegebene Pizza den Preis ausgibt. Verwenden Sie dazu existingPizza() . Beispielausgabe: Salami: 8 .50 Euro Hawaii: Diese Pizza gibt es nicht. Schreiben Sie eine printMenu() -Methode, die ausgibt, wie viele Pizzen es im Men\u00fc gibt. Wenn das Men\u00fc nicht leer ist, sollen zudem alle Pizzen mit ihrem Preis ausgegeben werden. Beispielausgabe: // Beispiel fuer leeres Menue ############## Das Menu enth\u00e4lt 0 Pizzen. ############## // Beispiel fuer Menue ############## Das Menu enth\u00e4lt 4 Pizzen. Pizza Margherita: 7 .00 Euro Pizza Salami: 8 .50 Euro Pizza Schinken: 8 .50 Euro Pizza Veggie: 7 .50 Euro ############## \u00c4ndern Sie den Preis der Schinken -Pizza in der HashMap zu 8,20 . Schreiben Sie eine Methode public static void affordablePizza(Map<String,Double> menu, double maxPrice) , die alle Pizzen ausgibt, die man sich f\u00fcr einen bestimmten Betrag leisten kann. Beispielausgabe: Eingegebener Betrag: 4 .0 Euro Leider gibt es zu diesem Preis keine Pizza. Eingegebener Betrag: 8 .0 Euro M\u00f6gliche Pizzen: [ Margherita, Veggie ] Das Menu wird \u00fcberarbeitet, l\u00f6schen Sie daher alle Eintr\u00e4ge. F\u00fcllen Sie das Men\u00fc anschlie\u00dfend mit diesen neuen Pizzen: Pizza Preis Verde 7,00 Hawaii 8,20 Tradizionale 8,50 Legen Sie ein zweites Men\u00fc an und kopieren Sie alle Eintr\u00e4ge aus dem ersten Men\u00fc hinein. L\u00f6schen Sie im zweiten Men\u00fc die Pizza Hawaii und geben Sie die Namen aller noch verf\u00fcgbaren Pizzen aus. Finden Sie in Ihrem Code ein Beispiel f\u00fcr Auto-Boxing und schreiben Sie einen entsprechenden Kommentar. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 5 PizzaMenue.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package aufgaben.aufgabe5 ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.Map ; import java.util.Set ; import java.util.List ; public class PizzaMenu { //3. public static boolean existingPizza ( Map < String , Double > menu , String pizza ) { if ( menu . containsKey ( pizza )){ return true ; } return false ; } //4. public static void printPrice ( Map < String , Double > menu , String pizza ) { if ( existingPizza ( menu , pizza )){ System . out . println ( pizza + \": \" + menu . get ( pizza )); } else { System . out . println ( pizza + \": \" + \"Diese Pizza gibt es nicht.\" ); } } //5. public static void printMenu ( Map < String , Double > menu ) { System . out . println (); System . out . println ( \"##############\" ); System . out . println ( \"Das Menu enth\u00e4lt \" + menu . size () + \" Pizzen.\" ); if ( ! menu . isEmpty ()) { for ( Map . Entry < String , Double > entry : menu . entrySet ()) { System . out . println ( \"Pizza : \" + entry . getKey () + \" - \" + entry . getValue ()); } } System . out . println ( \"##############\" ); } //7. public static void affordablePizza ( Map < String , Double > menu , double maxPrice ) { List < String > pizzen = new ArrayList <> (); System . out . println ( \"Eingegebener Betrag: \" + maxPrice + \" Euro\" ); for ( Map . Entry < String , Double > eintrag : menu . entrySet ()) { if ( eintrag . getValue () <= maxPrice ) { //Auto-Boxing von double zu Double pizzen . add ( eintrag . getKey ()); } } if ( pizzen . size () == 0 ) { System . out . println ( \"Leider gibt es zu diesem Preis keine Pizza.\" ); } else { System . out . println ( \"M\u00f6gliche Pizzen: \" + pizzen ); } } public static void main ( String [] args ) { //2. Map < String , Double > menu1 = new HashMap <> (); menu1 . put ( \"Margherita\" , 7.0 ); //Auto-Boxing von double zu Double menu1 . put ( \"Veggie\" , 7.5 ); //Auto-Boxing von double zu Double menu1 . put ( \"Salami\" , 8.5 ); //Auto-Boxing von double zu Double menu1 . put ( \"Schinken\" , 8.5 ); //Auto-Boxing von double zu Double //4. printPrice ( menu1 , \"Salami\" ); printPrice ( menu1 , \"Hawaii\" ); //5. printMenu ( menu1 ); //6. menu1 . put ( \"Schinken\" , 8.20 ); //Auto-Boxing von double zu Double //7. affordablePizza ( menu1 , 4.0 ); affordablePizza ( menu1 , 8.0 ); //8. menu1 . clear (); printMenu ( menu1 ); menu1 . put ( \"Verde\" , 7.0 ); //Auto-Boxing von double zu Double menu1 . put ( \"Hawaii\" , 8.2 ); //Auto-Boxing von double zu Double menu1 . put ( \"Tradizionale\" , 8.5 ); //Auto-Boxing von double zu Double printMenu ( menu1 ); //9. Map < String , Double > menu2 = new HashMap <> (); menu2 . putAll ( menu1 ); menu2 . remove ( \"Hawaii\" ); Set < String > pizzaNames = menu2 . keySet (); System . out . println (); System . out . println ( \"Es gibt folgende Pizzen: \" + pizzaNames ); } }","title":"Aufgabe 5 (Maps)"},{"location":"aufgaben/#aufgabe-6-interfaces","text":"Aufgabe 6 Das Observer -Entwurfsmuster geh\u00f6rt zu den am meisten verwendeten Designmustern/Designpattern/Pattern in der Programmierung. Es wird auch Beobachter -Muster oder Publisher -Pattern genannt. Wir werden dieses Muster in K\u00fcrze sehr h\u00e4ufig anwenden, wenn wir Nutzerereignisse in grafischen Oberfl\u00e4chen behandeln. Man kann sich dieses Pattern so vorstellen, dass der Publisher eine Zeitung oder auch Slack ist und dass Listener diese Zeitung (oder Slack) \"abonnieren\". Immer, wenn eine Nachricht ver\u00f6ffentlicht wird, dann erfahren alle Abonnenten davon. Wir werden eine (einfache) Implementierung dieses Entwurfsmusters durchf\u00fchren. Erstellen Sie ein Interface Publisher mit folgenden (abstrakten) Methoden: public boolean register(Listener listener); public boolean unregister(Listener listener); public void notifyListeners(); public String getUpdate(Listener listener); Erstellen Sie ein weiteres Interface Listener mit folgenden (abstrakten) Methoden: public void update(); public void setPublisher(Publisher publisher); public void removePublisher(Publisher publisher); Erstellen Sie eine Klasse Slack , die das Publisher -Interface implementiert. Objektvariablen der Klasse sind private Set<Listener> listeners; (speichert alle \"Abonnenten\"; kann gerne auch eine Liste sein) private int nrOfMessages; (speichert die aktuelle Nummer einer ver\u00f6ffentlichten Nachricht - die Nachrichten, die ver\u00f6ffentlicht werden, sollen fortlaufend nummeriert werden) Im parameterlosen Konstruktor werden die Menge (oder Liste) erzeugt und die nrOfMessages auf `0 gesetzt. In der Methode register(Listener listener) wird der listener in die Set listeners eingef\u00fcgt. Geben Sie ein true zur\u00fcck, wenn listener tats\u00e4chlich eingef\u00fcgt wurde und false sonst (falls er schon in der Menge (oder Liste) war. In der Methode unregister(Listener listener) wird der listener wieder aus der Set listeners gel\u00f6scht. Geben Sie ein true zur\u00fcck, wenn listener tats\u00e4chlich gel\u00f6scht wurde und false sonst (falls er nicht in der Menge (oder Liste) war. In der Methode notifyListeners() wird f\u00fcr alle listener aus der Menge listeners die update() -Methode aufgerufen (siehe Listener und Student ). Die Methode getUpdate(Listener obj) liefert einfach folgenden String zur\u00fcck: \"Breaking News \" + this.nrOfMessages . Erstellen Sie eine Methode public void publishNews() , in der die nrOfMessages um 1 erh\u00f6ht und die Methode notifyListeners() aufgerufen wird. Erstellen Sie eine Klasse Student , die das Listener -Interface implementiert. Objektvariablen der Klasse sind private String name; (speichert den Namen von Student ) private Publisher publisher; (speichert den Publisher , an den sich Student anmeldet) Im parametrisierten Konstruktor public Student(String name) wird der Name initalisiert. In der Methode setPublisher(Publisher publisher) wird die register() -Methode des publisher aufgerufen und der Wert der Objektvariable publisher gesetzt. Geben Sie bei erfolgreicher Anmeldung an den publisher auf die Konsole this.name + \" registered!\" aus. In der Methode removePublisher(Publisher publisher) meldet sich Student wieder vom publisher ab (Aufruf von unregister() und Ausgabe auf die Konsole this.name + \" deregistered!\" . In der Methode update() wird die getUpdate() -Methode des publisher aufgerufen und die zur\u00fcckgegebene Nachricht msg wie folgt auf die Konsole ausgegben: this.name + \" received \" + msg . Implementieren Sie f\u00fcr Student auch die Methoden equals() und hashCode() . Wenn Sie Ihre Implementierung mit folgender Klasse testen: public class Testklasse { public static void main ( String [] args ) { final int NR_OF_STUDENTS = 5 ; Slack slack = new Slack (); Student [] students = new Student [ NR_OF_STUDENTS ] ; Character c = 'A' ; for ( int index = 0 ; index < students . length ; index ++ ) { students [ index ] = new Student ( c . toString ()); c ++ ; students [ index ] . setPublisher ( slack ); } slack . publishNews (); System . out . println (); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 1 ] . setPublisher ( slack ); students [ 2 ] . removePublisher ( slack ); students [ 4 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 0 ] . removePublisher ( slack ); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . setPublisher ( slack ); System . out . println (); slack . publishNews (); } } dann sollte die Ausgabe ungef\u00e4hr so sein: A registered! B registered! C registered! D registered! E registered! D received Breaking News 1 C received Breaking News 1 B received Breaking News 1 A received Breaking News 1 E received Breaking News 1 B deregistered! D deregistered! C received Breaking News 2 A received Breaking News 2 E received Breaking News 2 B registered! C deregistered! E deregistered! B received Breaking News 3 A received Breaking News 3 A deregistered! B deregistered! D registered! D received Breaking News 4 eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 6 Listener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 package aufgaben.aufgabe6 ; public interface Listener { //method to update the listener, used by publisher public void update (); //attach with publisher to observe public void setPublisher ( Publisher publisher ); //attach with publisher to observe public void removePublisher ( Publisher publisher ); } Publisher.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package aufgaben.aufgabe6 ; public interface Publisher { //methods to register and unregister listeners (observers) public boolean register ( Listener listener ); public boolean unregister ( Listener listener ); //method to notify listeners of change public void notifyListeners (); //method to get updates from publisher (subject) public String getUpdate ( Listener listener ); } Slack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package aufgaben.aufgabe6 ; import java.util.* ; public class Slack implements Publisher { private Set < Listener > listeners ; private int nrOfMessages ; public Slack () { this . listeners = new HashSet <> (); this . nrOfMessages = 0 ; } @Override public boolean register ( Listener listener ) { return listeners . add ( listener ); } @Override public boolean unregister ( Listener listener ) { return listeners . remove ( listener ); } @Override public void notifyListeners () { for ( Listener listener : listeners ) { listener . update (); } } @Override public String getUpdate ( Listener obj ) { return \"Breaking News \" + this . nrOfMessages ; } public void publishNews () { this . nrOfMessages ++ ; this . notifyListeners (); } } Student.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package aufgaben.aufgabe6 ; public class Student implements Listener { private String name ; private Publisher publisher ; public Student ( String name ) { this . name = name ; } @Override public void update () { String msg = this . publisher . getUpdate ( this ); System . out . println ( this . name + \" received \" + msg ); } @Override public void setPublisher ( Publisher publisher ) { this . publisher = publisher ; if ( this . publisher . register ( this )) { System . out . println ( this . name + \" registered!\" ); } } @Override public void removePublisher ( Publisher publisher ) { if ( this . publisher . unregister ( this )) { System . out . println ( this . name + \" deregistered!\" ); this . publisher = null ; } } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Student so = ( Student ) o ; return this . name . equals ( so . name ); } @Override public int hashCode () { return this . name . hashCode (); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package aufgaben.aufgabe6 ; public class Testklasse { public static void main ( String [] args ) { final int NR_OF_STUDENTS = 5 ; Slack slack = new Slack (); Student [] students = new Student [ NR_OF_STUDENTS ] ; Character c = 'A' ; for ( int index = 0 ; index < students . length ; index ++ ) { students [ index ] = new Student ( c . toString ()); c ++ ; students [ index ] . setPublisher ( slack ); } slack . publishNews (); System . out . println (); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 1 ] . setPublisher ( slack ); students [ 2 ] . removePublisher ( slack ); students [ 4 ] . removePublisher ( slack ); System . out . println (); slack . publishNews (); System . out . println (); students [ 0 ] . removePublisher ( slack ); students [ 1 ] . removePublisher ( slack ); students [ 3 ] . setPublisher ( slack ); System . out . println (); slack . publishNews (); } }","title":"Aufgabe 6 (Interfaces)"},{"location":"aufgaben/#aufgabe-7-gui","text":"Aufgabe 7 Erstellen Sie die GUI f\u00fcr einen solchen Taschenrechner: Kann auch schicker sein :-) Viel Spa\u00df! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 7 Taschenrechner.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 package aufgaben.aufgabe7 ; import java.awt.* ; import javax.swing.* ; public class Taschenrechner extends JFrame { public Taschenrechner () { super (); setTitle ( \"Taschenrechner\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . add ( mainPanel , BorderLayout . CENTER ); setSize ( 250 , 350 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); JTextField tf = new JTextField ( 8 ); tf . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); tf . setHorizontalAlignment ( JTextField . RIGHT ); oben . add ( tf ); JPanel unten = new JPanel (); unten . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); JButton b0 = new JButton ( \"0\" ); JButton b1 = new JButton ( \"1\" ); JButton b2 = new JButton ( \"2\" ); JButton b3 = new JButton ( \"3\" ); JButton b4 = new JButton ( \"4\" ); JButton b5 = new JButton ( \"5\" ); JButton b6 = new JButton ( \"6\" ); JButton b7 = new JButton ( \"7\" ); JButton b8 = new JButton ( \"8\" ); JButton b9 = new JButton ( \"9\" ); JButton bMal = new JButton ( \"*\" ); JButton bDurch = new JButton ( \"/\" ); JButton bPlus = new JButton ( \"+\" ); JButton bMinus = new JButton ( \"-\" ); JButton bKlauf = new JButton ( \"(\" ); JButton bKlzu = new JButton ( \")\" ); JButton bKomma = new JButton ( \".\" ); JButton bC = new JButton ( \"C\" ); JButton bCE = new JButton ( \"CE\" ); JButton bErg = new JButton ( \"=\" ); unten . add ( b1 ); unten . add ( b2 ); unten . add ( b3 ); unten . add ( b4 ); unten . add ( b5 ); unten . add ( b6 ); unten . add ( b7 ); unten . add ( b8 ); unten . add ( b9 ); unten . add ( bKlauf ); unten . add ( b0 ); unten . add ( bKlzu ); unten . add ( bMal ); unten . add ( bDurch ); unten . add ( bPlus ); unten . add ( bMinus ); unten . add ( bKomma ); unten . add ( bErg ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Taschenrechner (); } }","title":"Aufgabe 7 (GUI)"},{"location":"aufgaben/#aufgabe-8-ereignisbehandlung","text":"Aufgabe 8 Implementieren Sie f\u00fcr den Taschenrechner aus Aufgabe 7 das ActionListener -Interface, so dass der Taschenrechner \u00fcber m\u00f6glichst viel Funktionalit\u00e4t verf\u00fcgt. Minimumanforderung ist, dass durch die Eingabe von Ziffern Zahlen entstehen und dass die Buttons + , - , / , + und = insofern funktionieren, dass dadurch tats\u00e4chlich gerechnet wird, auch wenn die Regel \"Punktrechnung geht vor Strichrechnung\" nicht eingehalten wird. Eine erste Verbesserung (ist schon Zusatz ) w\u00e4re, dass die Regel \"Punktrechnung geht vor Strichrechnung\" eingehalten wird. Ab dann ist alles Zusatz und bedarf in vielen F\u00e4llen der Erweiterung der GUI: Verwendung und Beachten von Klammern (ist aber sehr schwer!), Speichern von Zwischenergebnissen, komplexere Operationen durch zu\u00e4tzliche Tasten (Wurzel, Potenzieren, ...). Alles, was Sie m\u00f6chten - Viel Spa\u00df! eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 9 Taschenrechner.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 package aufgaben.aufgabe9 ; import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; //Klammern werden ignoriert public class Taschenrechner extends JFrame implements ActionListener { JPanel hauptPanel ; JButton b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 , b8 , b9 , bMal , bPlus , bMinus , bDurch , bErg , bKlauf , bKlzu , bKomma , bC , bCE ; JTextField tf ; double zahl1 , zahl2 , zahl3 ; boolean zahl1Gesetzt = false ; boolean zahl2Gesetzt = false ; boolean zahl3Gesetzt = false ; boolean letztesZeichenZiffer = false ; String eingabe = \"\" , aktEingabe = \"0\" ; String op1 = \"\" , op2 = \"\" ; int anzKlammern = 0 ; Taschenrechner () { super (); setTitle ( \"Taschenrechner\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); hauptPanel = init (); tf = new JTextField (); tf . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); tf . setHorizontalAlignment ( JTextField . RIGHT ); this . add ( tf , BorderLayout . NORTH ); this . add ( hauptPanel , BorderLayout . CENTER ); setSize ( 250 , 350 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new GridLayout ( 6 , 3 , 10 , 10 )); b0 = new JButton ( \"0\" ); b1 = new JButton ( \"1\" ); b2 = new JButton ( \"2\" ); b3 = new JButton ( \"3\" ); b4 = new JButton ( \"4\" ); b5 = new JButton ( \"5\" ); b6 = new JButton ( \"6\" ); b7 = new JButton ( \"7\" ); b8 = new JButton ( \"8\" ); b9 = new JButton ( \"9\" ); bMal = new JButton ( \"*\" ); bDurch = new JButton ( \"/\" ); bPlus = new JButton ( \"+\" ); bMinus = new JButton ( \"-\" ); bKlauf = new JButton ( \"(\" ); bKlzu = new JButton ( \")\" ); bKomma = new JButton ( \".\" ); bC = new JButton ( \"C\" ); bCE = new JButton ( \"CE\" ); bErg = new JButton ( \"=\" ); b0 . addActionListener ( this ); b1 . addActionListener ( this ); b2 . addActionListener ( this ); b3 . addActionListener ( this ); b4 . addActionListener ( this ); b5 . addActionListener ( this ); b6 . addActionListener ( this ); b7 . addActionListener ( this ); b8 . addActionListener ( this ); b9 . addActionListener ( this ); bMal . addActionListener ( this ); bDurch . addActionListener ( this ); bPlus . addActionListener ( this ); bMinus . addActionListener ( this ); bErg . addActionListener ( this ); bKlauf . addActionListener ( this ); bKlzu . addActionListener ( this ); bC . addActionListener ( this ); bCE . addActionListener ( this ); bKomma . addActionListener ( this ); panel . add ( b1 ); panel . add ( b2 ); panel . add ( b3 ); panel . add ( b4 ); panel . add ( b5 ); panel . add ( b6 ); panel . add ( b7 ); panel . add ( b8 ); panel . add ( b9 ); panel . add ( bKlauf ); panel . add ( b0 ); panel . add ( bKlzu ); panel . add ( bMal ); panel . add ( bDurch ); panel . add ( bPlus ); panel . add ( bMinus ); panel . add ( bKomma ); panel . add ( bErg ); return panel ; } public static void main ( String [] args ) { new Taschenrechner (); } @Override public void actionPerformed ( ActionEvent event ) { Object quelle = event . getSource (); if ( quelle instanceof JButton ) { switch ((( JButton ) quelle ). getActionCommand ()) { case \"0\" : eingabeZiffer ( 0 ); tf . setText ( aktEingabe ); break ; case \"1\" : eingabeZiffer ( 1 ); tf . setText ( aktEingabe ); break ; case \"2\" : eingabeZiffer ( 2 ); tf . setText ( aktEingabe ); break ; case \"3\" : eingabeZiffer ( 3 ); tf . setText ( aktEingabe ); break ; case \"4\" : eingabeZiffer ( 4 ); tf . setText ( aktEingabe ); break ; case \"5\" : eingabeZiffer ( 5 ); tf . setText ( aktEingabe ); break ; case \"6\" : eingabeZiffer ( 6 ); tf . setText ( aktEingabe ); break ; case \"7\" : eingabeZiffer ( 7 ); tf . setText ( aktEingabe ); break ; case \"8\" : eingabeZiffer ( 8 ); tf . setText ( aktEingabe ); break ; case \"9\" : eingabeZiffer ( 9 ); tf . setText ( aktEingabe ); break ; case \"*\" : eingabePunktOperator ( \"*\" ); tf . setText ( eingabe ); break ; case \"/\" : eingabePunktOperator ( \"/\" ); tf . setText ( eingabe ); break ; case \"+\" : eingabeStrichOperator ( \"+\" ); tf . setText ( eingabe ); break ; case \"-\" : eingabeStrichOperator ( \"-\" ); tf . setText ( eingabe ); break ; case \"=\" : eingabeGleich (); tf . setText ( eingabe ); break ; case \".\" : eingabeKomma (); tf . setText ( aktEingabe ); break ; case \"(\" : eingabeOeffnendeKlammer (); tf . setText ( eingabe ); break ; case \")\" : eingabeSchliessendeKlammer (); tf . setText ( aktEingabe ); break ; case \"C\" : tf . setText ( \"\" ); break ; } } } void eingabeOeffnendeKlammer () { if ( ! letztesZeichenZiffer ) { anzKlammern ++ ; } } void eingabeSchliessendeKlammer () { if ( letztesZeichenZiffer ) { anzKlammern -- ; letztesZeichenZiffer = false ; } } void eingabeZiffer ( int ziffer ) { if ( letztesZeichenZiffer ) { aktEingabe += ( new Integer ( ziffer )). toString (); } else { aktEingabe = ( new Integer ( ziffer )). toString (); letztesZeichenZiffer = true ; } } void eingabeKomma () { if ( aktEingabeIstIntZahl ()) aktEingabe += \".\" ; letztesZeichenZiffer = true ; if ( aktEingabeIstDoubleZahl ()) System . out . println ( \"ok\" ); else System . out . println ( \"kein double\" ); } void eingabeGleich () { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = false ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = false ; zahl2 = Double . parseDouble ( aktEingabe ); switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = false ; zahl2Gesetzt = false ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 * zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 * zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 * zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 * zahl3 ; break ; } } else if ( op2 . equals ( \"/\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 / zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 / zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 / zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 / zahl3 ; break ; } } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = \"\" ; op2 = \"\" ; } } } void eingabeStrichOperator ( String operator ) { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = true ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = aktEingabe + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = true ; zahl2 = Double . parseDouble ( aktEingabe ); switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString () + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = true ; zahl2Gesetzt = false ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 * zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 * zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 * zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 * zahl3 ; break ; } } else if ( op2 . equals ( \"/\" )) { switch ( op1 ) { case \"+\" : zahl1 = zahl1 + zahl2 / zahl3 ; break ; case \"-\" : zahl1 = zahl1 - zahl2 / zahl3 ; break ; case \"*\" : zahl1 = zahl1 * zahl2 / zahl3 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 / zahl3 ; break ; } } eingabe = ( new Double ( zahl1 )). toString () + operator ; aktEingabe = \"0\" ; op1 = operator ; } } } void eingabePunktOperator ( String operator ) { letztesZeichenZiffer = false ; if ( aktEingabeIstDoubleZahl ()) { // in aktEingabe steht Zahl1 // Op1 wurde eingegeben if ( ! zahl1Gesetzt ){ zahl1Gesetzt = true ; zahl1 = Double . parseDouble ( aktEingabe ); eingabe = aktEingabe + operator ; aktEingabe = \"0\" ; op1 = operator ; } // in aktEingabe steht zahl2; zahl1 bereits gespeichert // op2 wurde eingegeben; mit op1 wird gerechnet else if ( ! zahl2Gesetzt ){ zahl1Gesetzt = true ; zahl2 = Double . parseDouble ( aktEingabe ); if ( op1 . equals ( \"*\" ) || op1 . equals ( \"/\" )) { switch ( op1 ) { case \"*\" : zahl1 = zahl1 * zahl2 ; break ; case \"/\" : zahl1 = zahl1 / zahl2 ; break ; } eingabe = ( new Double ( zahl1 )). toString (); aktEingabe = \"0\" ; op1 = operator ; } else { op2 = operator ; eingabe = eingabe + aktEingabe + operator ; aktEingabe = \"0\" ; zahl2Gesetzt = true ; } } // in aktEingabe steht zahl3; zahl1 und zahl2 bereits gespeichert // op3 wurde eingegeben; mit op1 und op2 (* od. /) wird gerechnet else if ( ! zahl3Gesetzt ){ zahl1Gesetzt = true ; zahl2Gesetzt = true ; zahl3 = Double . parseDouble ( aktEingabe ); if ( op2 . equals ( \"*\" )) { zahl2 = zahl2 * zahl3 ; } else if ( op2 . equals ( \"/\" )) { zahl2 = zahl2 / zahl3 ; } eingabe = ( new Double ( zahl1 )). toString () + op1 + ( new Double ( zahl2 )). toString () + op2 ; aktEingabe = \"0\" ; op2 = operator ; } } } boolean aktEingabeIstIntZahl () { try { Integer . parseInt ( aktEingabe ); } catch ( NumberFormatException e ) { return false ; } return true ; } boolean aktEingabeIstDoubleZahl () { try { Double . parseDouble ( aktEingabe ); } catch ( NumberFormatException e ) { return false ; } return true ; } }","title":"Aufgabe 8 (Ereignisbehandlung)"},{"location":"aufgaben/#aufgabe-9-zeichnen-entfallt","text":"Aufgabe 9 Wir berechnen PI mithilfe der Monte-Carlo-Methode . Dazu zeichnen wir ein Quadrat und darin einen Kreisbogen (einen Viertelkreis), dessen Radius der Seitenl\u00e4nge des Quadrats entspricht: Nun zeichnen wir in dieses Quadrat viele kleine ausgef\u00fcllte Kreise (Durchmesser z.B. 2 Pixel). Die Positionen dieser Kreise werden zuf\u00e4llig ermittelt. Wenn die zuf\u00e4llig ermittelte Position f\u00fcr diesen Kreis im Kreisbogen liegt, dann sind die kleinen Kreise rot, wenn die Position au\u00dferhalb liegt, dann sind die Kreise blau. Es entsteht bei ganz vielen (z.B. 50000 ) Punkten so ein Bild: Tipp: Ob ein Punkt mit den Koordinaten (x,y) in einem (Viertel-)Kreis liegt, ermitteln Sie mithilfe der Kreisgleichung . Sei (xm, ym) der Mittelpunkt und r der Radius des Kreises, dann gilt (x-xm)^2 + (y-ym)^2 = r^2 f\u00fcr alle Punkte auf dem Kreis (f\u00fcr Punkte im Kreis gilt <= und f\u00fcr Punkte au\u00dferhalb des Kreises >). Der Quotient aus der Anzahl der roten Punkte und der Gesamtanzahl der Punkte ist eine N\u00e4herung von PI/4. Geben Sie Ihre Ann\u00e4herung von PI auf der Konsole aus. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 9 ComputePI.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package aufgaben.aufgabe9 ; import java.awt.* ; import java.util.Random ; import javax.swing.* ; public class ComputePI extends JFrame { ComputePI (){ super ( \"Berechne PI\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . add ( new Canvas (), BorderLayout . CENTER ); this . setSize ( 500 , 500 ); this . setVisible ( true ); } class Canvas extends JPanel { private Random r = new Random (); private int anzahlPunkte = 50000 ; private int rotePunkte = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); int x0 = 20 ; int y0 = 20 ; int quadLength = 440 ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setStroke ( new BasicStroke ( 3 )); // Quadrat g2 . setColor ( Color . WHITE ); g2 . fillRect ( x0 , y0 , quadLength , quadLength ); g2 . setColor ( Color . BLACK ); g2 . drawRect ( x0 , y0 , quadLength , quadLength ); //Kreisbogen g2 . drawArc ( x0 , y0 , 2 * quadLength , 2 * quadLength , 90 , 90 ); g2 . setStroke ( new BasicStroke ( 1 )); g2 . setColor ( Color . RED ); int x , y ; int xM = x0 + quadLength ; int yM = y0 + quadLength ; //counting variables for keeping track of red/blue dots rotePunkte = 0 ; //draws all the points for ( int i = 0 ; i < anzahlPunkte ; i ++ ){ //random coordinates f the dot x = r . nextInt ( quadLength ) + x0 ; y = r . nextInt ( quadLength ) + y0 ; //set the color of the dot if ((( x - xM ) * ( x - xM ) + ( y - yM ) * ( y - yM )) <= ( quadLength * quadLength )){ g2 . setColor ( Color . RED ); rotePunkte ++ ; } else { g2 . setColor ( Color . BLUE ); } //draw the dot g2 . fillOval ( x , y , 2 , 2 ); double pi = ( double ) rotePunkte / ( double ) anzahlPunkte * 4.0 ; System . out . println ( \"PI ist \" + pi ); } } } public static void main ( String [] args ) { ComputePI pi = new ComputePI (); //pi.canvas.repaint(); } }","title":"Aufgabe 9 (Zeichnen - entf\u00e4llt)"},{"location":"collections/","text":"Collections \u00b6 Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections . Collections haben drei wesentliche Eigenschaften: Eine Collection hat keine festgelegte L\u00e4nge , d.h. es sind beliebig viele Elemente in einer Collection speicherbar. In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen ( int , double , boolean , char , ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper -Klassen kennenlernen. Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren , damit sie nur Elemente eines Typs speichern kann. Arten von Collections \u00b6 Es gibt unterschiedliche Arten von Collections , welche je nach Einsatzzweck verwendet werden: Typ Struktur Zugriff Eigenschaften List Menge wahlfrei (indexbasiert) Iterator kann Elemente mehrfach enthalten Set Menge Iterator keine doppelten Elemente keine Ordnung der Elemente Map Schl\u00fcssel-Werte-Paare schl\u00fcsselbasiert Schl\u00fcssel ist eindeutig Werte k\u00f6nnen mehrfach sein Stack Stapel/Stack oberstes Element last-in-first-out-Prinzip Queue Warteschlange erstes und letztes Element first-in-first-out-Prinzip Wir werden uns in diesem Semester aber nur mit den Collections List , Set und Map besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann ( pop ) und von dem man das oberste Element entfernen kann ( pop ). Mithilfe von top erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head ) der Warteschlange. Eine Liste ( List ) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente e1 und e2 gilt e1.equals(e2) == true (oder e1.hashCode() == e2.hashCode() ). Eine Menge ( Set ) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die add(element) -Methode f\u00fcr eine Menge ein boolean zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde ( true ) oder nicht ( false ). Eine Map kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel key und in der rechten die Werte value . Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer Map sind eine Set ). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung: Der Collection-Klassenbaum \u00b6 Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von Collection einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps. Die \"Mutter-Klasse\" der Collections List und Set ist Collection . In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces . Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ List f\u00fcr die Listen und den Typ Set f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten List -Objekte bzw. keine konkreten Set -Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes ArrayList -Objekt erzeugen werden oder ein konkretes HashSet -Objekt. Hier einige Beispiele: import java.util.ArrayList ; import java.util.HashSet ; import java.util.LinkedList ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Collections { public static void main ( String [] args ) { List l1 = new ArrayList (); List l2 = new LinkedList (); Set s1 = new HashSet (); Set s2 = new TreeSet (); } } Beachten Sie, alle Klassen aus dem java.util -Paket zu importieren! Eine Klasse List gibt es z.B. auch im java.awt -Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben: import java.util.* ; Der * ist eine Wildcard und importiert alle Klassen aus java.util . Zur Diskussion, wann ArrayList besser ist und wann LinkedList , siehe hier . Eine Diskussion \u00fcber die Unterschiede zwischen HashSet und TreeSet finden Sie z.B. hier . Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von ArrayList erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von HashSet . Mengen - Sets \u00b6 Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set menge = new HashSet (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } In Zeile 1 werden zun\u00e4chst alle verwendeten Klassen aus dem java.util -Paket geladen. Das sind f\u00fcr unser Beispiel Set , HashSet und Iterator . Die Iterator -Klasse wird verwendet, um durch unsere Menge menge zu laufen. Wir werden auf den Iterator gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. In Zeile 7 wird die Menge menge erzeugt. Wir deklarieren daf\u00fcr den Typ Set und erzeugen unter Verwendung des parameterlosen Konstruktors von HashSet ein HashSet -Objekt. Die menge hat also den Compilertyp Set und mindestens den Laufzeittyp HashSet (nat\u00fcrlich noch weitere Laufzeittypen, z.B. Object ). In den Zeilen 14-17 werden der menge Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ String . Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode add(element) . Diese Methode gibt ein boolean zur\u00fcck. Wir lassen in den Zeilen 14-17 diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: true true true false Die add() -Methode gibt also 3x ein true zur\u00fcck und beim vierten Aufruf ein false . Das liegt daran, dass beim vierten Aufruf von add() (Zeile 17 ) das \u00fcbergebene Element s4 nicht in die Menge menge eingef\u00fcgt wird, da sich in dieser Menge bereits ein String mit dem Wert \"zweiter\" befindet und eine Menge keine Doppelungen enthalten darf. Da s2.equals(s4) den Wert true zur\u00fcckgibt, erkennt die add() -Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und s4 wird deshalb nicht eingef\u00fcgt. In Zeile 19 lassen wir uns die Anzahl der Elemente in der Menge menge ausgeben. Dies erfolgt mithilfe der size() -Methode (in Collections ist es also nicht length() , auch nicht length und auch nicht getLength() oder getSize() , sondern size() ). Der Wert von size() in unserem Beispiel ist 3 . Der Iterator \u00b6 Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. Die Klasse Iterator besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren): hasNext() : liefert ein true zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann false , next() : liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), remove() : l\u00f6scht das mit next() zur\u00fcckgegebene Element. In Zeile 21 erzeugen wir zun\u00e4chst mit der iterator() -Methode aus Set ein Objekt von Iterator . Die Referenz auf dieses Objekt nennen wir hier it . Die while() -Schleife in den Zeilen 22-25 durchl\u00e4uft nun diese Iteration, indem sie mithilfe von hasNext() pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von next() aus der Iteration entnommen und in Zeile 24 auf die Konsole ausgegeben. Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben: zweiter dritter erster Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge \"erster\" , \"zweiter\" , \"dritter\" in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge \"zweiter\" , \"dritter\" , \"erster\" . Auf die Reihenfolge haben wir in Mengen keinen Einfluss! Methoden f\u00fcr Mengen \u00b6 Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: add() , size() und iterator() . Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von java.util.Collection erben ( erben ist hier eigentlich nicht ganz richtig, da es sich bei java.util.Collection um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection ): Methode Beschreibung boolean add(E element) F\u00fcgt Element element in die Collection ein. Gibt true zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst false . boolean addAll(Collection c) F\u00fcgt alle Elemente der Collection c in die Collection ein. Gibt true zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst false . void clear() Entfernt alle Elemente aus der Collection. boolean contains(E element) Gibt true zur\u00fcck, wenn sich element in der Collection befindet, sonst false . boolean containsAll(Collection c) Gibt true zur\u00fcck, wenn sich alle Elemente der Collection c in der Collection befinden, sonst false . boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst false . Iterator iterator() Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. boolean remove(Object o) Entfernt o aus der Collection und gibt true zur\u00fcck, wenn ein Element entfernt wurde, sonst false . boolean removeAll(Collection c) Entfernt alle Elemente aus c aus der Collection und gibt true zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst false . int size() Gibt die Anzahl der Elemente in der Collection zur\u00fcck. Object[] toArray() Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. Der TyP E in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem Iterator sehen wir eine neue Syntax <E> . Diese lernen wir gleich kennen. E steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren. Typisieren \u00b6 Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun: Set menge = new HashSet (); menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Power einf\u00fcgen menge . add ( new Point ( 2 , 3 )); // Point einf\u00fcgen menge . add ( new Konto ()); // Konto einf\u00fcgen Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. Das Typisieren einer Collection erfolgt mithilfe der Diamond -Syntax: Collection<Typ> name = new KonkreteKlasse<>(); Wir typisieren die Menge menge aus dem eben gezeigten Beispiel: Set < String > menge = new HashSet <> (); // mit String typisiert - menge nimmt nur Strings auf menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Fehler - kein String menge . add ( new Point ( 2 , 3 )); // Fehler - kein String menge . add ( new Konto ()); // Fehler - kein String Wir haben menge typisiert und angegeben, dass menge nur Objekte vonm Typ String aufnehmen kann. Dazu geben wir bei der Typdeklaration Set<String> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt new HashSet<>(); . Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). Der Versuch, Objekte eines anderen Typs als String in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator < String > it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } Beachten Sie, dass auch der Iterator (Zeile 21 ) typisiert wird. Die for-each-Schleife \u00b6 Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each -Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist: for ( TypElement element : collection ) { } F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 for ( String s : menge ) { System . out . println ( s ); } } } \u00dcbrigens: anstelle der Collection (hier: menge ) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each -Schleife verwenden. \u00dcbung Ersetzen Sie im oberen Beispiel HashSet durch TreeSet . Erkennen Sie einen Unterschied? Listen \u00b6 Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von java.util.Collection abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.* ; public class Collections { static void fillList ( List < String > list ) { for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( String . valueOf ( i )); } } static void printList ( List < String > list ) { Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } public static void main ( String [] args ) { List < String > list1 = new ArrayList <> (); fillList ( list1 ); printList ( list1 ); List < String > list2 = new LinkedList <> (); fillList ( list2 ); list2 . remove ( \"3\" ); // Wert! list2 . remove ( 6 ); // Index! list1 . removeAll ( list2 ); printList ( list2 ); // 0 1 2 4 5 6 8 9 printList ( list1 ); // 3 7 } } Wir erstellen uns zwei Listen list1 (Zeile 26 ) und list2 (Zeile 30 ). Beide sind vom Compilertyp List und beide sind typisiert mit String , d.h. sie k\u00f6nnen nur Strings aufnehmen. Die Methode fillList() (Zeilen 5-11 ) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern 0...9 . Da die Liste Strings erwartet, werden die int -Ziffern mithilfe von String.valueOf() in einen String umgewandelt (Zeile 9 ). Die add() -Methode f\u00fcgt die Strings hinzu (Zeile 9 ). Die Methode printList() (Zeilen 13-33 ) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile 18 ). Der Aufruf von printList(list1); in Zeile 28 f\u00fchrt zu folgender Ausgabe: 0 1 2 3 4 5 6 7 8 9 End of list Die Liste list2 wird zun\u00e4chst ebenfalls mit den Ziffern 0...9 (jeweils als String ) bef\u00fcllt. Die Anweisung list2.remove(\"3\"); in Zeile 32 bewirkt, dass der Wert \"3\" aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" In Zeile 33 wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index 6 gespeichert ist. Das ist das Element \"7\" . Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" Die Anweisung list1.removeAll(list2); in Zeile 34 bewirkt nun, dass aus list1 alle Werte gel\u00f6scht werden, die (auch) in list2 enthalten sind, also \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" . Das bewirkt, dass in list1 dann nur noch die Werte \"3\" \"7\" \u00fcbrig bleiben. Die Anweisung printList(list2); in Zeile 35 bewirkt folgende Ausgabe: 0 1 2 4 5 6 8 9 End of list Die Anweisung printList(list1); in Zeile 36 bewirkt folgende Ausgabe: 3 7 End of list Die Methode printList() h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each -Schleife implementiert werden k\u00f6nnen: 13 14 15 16 17 18 19 20 21 static void printList ( List < String > list ) { for ( String s : list ) { System . out . print ( s + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } \u00dcbung Gegeben ist folgender Code: Set < Integer > s1 = new HashSet <> (); Set < Integer > s2 = new HashSet <> (); for ( int i = 10 ; i >= 1 ; i -- ) { s1 . add ( i ); } for ( int i = 9 ; i <= 12 ; i ++ ) { s2 . add ( i ); } s1 . addAll ( s2 ); Was ist der R\u00fcckgabewert von s1.addAll(s2); und warum? Implementieren Sie die Ausgabe aller Werte von s1 und s2 . Mengenoperationen \u00b6 Angenommen, wir haben drei Mengen A , B und C , wobei alle Elemente aus C auch Elemente in A sind. Mithilfe der Methoden addAll() , removeAll() , retainAll() und containsAll() lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt: Stack und Queue \u00b6 Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen: Stack \u00b6 Last-In-First-Out-Prinzip push(E element) zum Hinzuf\u00fcgen pop() entfernt oberstes Element und gibt es zur\u00fcck empty() pr\u00fcft, ob der Stack leer ist Queue \u00b6 First-In-First-Out-Prinzip add()/offer() zum Hinzuf\u00fcgen remove()/poll() entfernt vorderstes Element und gibt es zur\u00fcck element()/peek() pr\u00fcft, ob die Warteschlange leer ist Wertetypen in Collections \u00b6 Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper -Klassen zur Verf\u00fcgung: Integer , Double , Float , Short , Byte , Long , Character , Boolean : 1 2 3 4 5 6 7 8 // Wertetypen k\u00f6nnen nicht als konkrete // Typen in Collections verwendet werden List < int > l = new ArrayList <> (); // Fehler !! // Verwendung der Wrapper-Klassen + Auto-Boxing List < Integer > l = new ArrayList <> (); l . add ( 100 ); // sogenanntes Auto-Boxing Das obere beispiel zeigt in Zeile 3 , wie es nicht geht. Die List l kann nicht mit int typisiert werden. Stattdessen muss die Wrapper -Klasse Integer verwendet werden. Wir betrachten Wrapper -Klassen im n\u00e4chsten Abschnitt.","title":"Collections"},{"location":"collections/#collections","text":"Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections . Collections haben drei wesentliche Eigenschaften: Eine Collection hat keine festgelegte L\u00e4nge , d.h. es sind beliebig viele Elemente in einer Collection speicherbar. In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen ( int , double , boolean , char , ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper -Klassen kennenlernen. Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren , damit sie nur Elemente eines Typs speichern kann.","title":"Collections"},{"location":"collections/#arten-von-collections","text":"Es gibt unterschiedliche Arten von Collections , welche je nach Einsatzzweck verwendet werden: Typ Struktur Zugriff Eigenschaften List Menge wahlfrei (indexbasiert) Iterator kann Elemente mehrfach enthalten Set Menge Iterator keine doppelten Elemente keine Ordnung der Elemente Map Schl\u00fcssel-Werte-Paare schl\u00fcsselbasiert Schl\u00fcssel ist eindeutig Werte k\u00f6nnen mehrfach sein Stack Stapel/Stack oberstes Element last-in-first-out-Prinzip Queue Warteschlange erstes und letztes Element first-in-first-out-Prinzip Wir werden uns in diesem Semester aber nur mit den Collections List , Set und Map besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann ( pop ) und von dem man das oberste Element entfernen kann ( pop ). Mithilfe von top erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head ) der Warteschlange. Eine Liste ( List ) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente e1 und e2 gilt e1.equals(e2) == true (oder e1.hashCode() == e2.hashCode() ). Eine Menge ( Set ) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die add(element) -Methode f\u00fcr eine Menge ein boolean zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde ( true ) oder nicht ( false ). Eine Map kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel key und in der rechten die Werte value . Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer Map sind eine Set ). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung:","title":"Arten von Collections"},{"location":"collections/#der-collection-klassenbaum","text":"Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von Collection einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps. Die \"Mutter-Klasse\" der Collections List und Set ist Collection . In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces . Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ List f\u00fcr die Listen und den Typ Set f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten List -Objekte bzw. keine konkreten Set -Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes ArrayList -Objekt erzeugen werden oder ein konkretes HashSet -Objekt. Hier einige Beispiele: import java.util.ArrayList ; import java.util.HashSet ; import java.util.LinkedList ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Collections { public static void main ( String [] args ) { List l1 = new ArrayList (); List l2 = new LinkedList (); Set s1 = new HashSet (); Set s2 = new TreeSet (); } } Beachten Sie, alle Klassen aus dem java.util -Paket zu importieren! Eine Klasse List gibt es z.B. auch im java.awt -Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben: import java.util.* ; Der * ist eine Wildcard und importiert alle Klassen aus java.util . Zur Diskussion, wann ArrayList besser ist und wann LinkedList , siehe hier . Eine Diskussion \u00fcber die Unterschiede zwischen HashSet und TreeSet finden Sie z.B. hier . Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von ArrayList erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von HashSet .","title":"Der Collection-Klassenbaum"},{"location":"collections/#mengen-sets","text":"Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set menge = new HashSet (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } In Zeile 1 werden zun\u00e4chst alle verwendeten Klassen aus dem java.util -Paket geladen. Das sind f\u00fcr unser Beispiel Set , HashSet und Iterator . Die Iterator -Klasse wird verwendet, um durch unsere Menge menge zu laufen. Wir werden auf den Iterator gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. In Zeile 7 wird die Menge menge erzeugt. Wir deklarieren daf\u00fcr den Typ Set und erzeugen unter Verwendung des parameterlosen Konstruktors von HashSet ein HashSet -Objekt. Die menge hat also den Compilertyp Set und mindestens den Laufzeittyp HashSet (nat\u00fcrlich noch weitere Laufzeittypen, z.B. Object ). In den Zeilen 14-17 werden der menge Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ String . Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode add(element) . Diese Methode gibt ein boolean zur\u00fcck. Wir lassen in den Zeilen 14-17 diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: true true true false Die add() -Methode gibt also 3x ein true zur\u00fcck und beim vierten Aufruf ein false . Das liegt daran, dass beim vierten Aufruf von add() (Zeile 17 ) das \u00fcbergebene Element s4 nicht in die Menge menge eingef\u00fcgt wird, da sich in dieser Menge bereits ein String mit dem Wert \"zweiter\" befindet und eine Menge keine Doppelungen enthalten darf. Da s2.equals(s4) den Wert true zur\u00fcckgibt, erkennt die add() -Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und s4 wird deshalb nicht eingef\u00fcgt. In Zeile 19 lassen wir uns die Anzahl der Elemente in der Menge menge ausgeben. Dies erfolgt mithilfe der size() -Methode (in Collections ist es also nicht length() , auch nicht length und auch nicht getLength() oder getSize() , sondern size() ). Der Wert von size() in unserem Beispiel ist 3 .","title":"Mengen - Sets"},{"location":"collections/#der-iterator","text":"Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. Die Klasse Iterator besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren): hasNext() : liefert ein true zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann false , next() : liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), remove() : l\u00f6scht das mit next() zur\u00fcckgegebene Element. In Zeile 21 erzeugen wir zun\u00e4chst mit der iterator() -Methode aus Set ein Objekt von Iterator . Die Referenz auf dieses Objekt nennen wir hier it . Die while() -Schleife in den Zeilen 22-25 durchl\u00e4uft nun diese Iteration, indem sie mithilfe von hasNext() pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von next() aus der Iteration entnommen und in Zeile 24 auf die Konsole ausgegeben. Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben: zweiter dritter erster Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge \"erster\" , \"zweiter\" , \"dritter\" in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge \"zweiter\" , \"dritter\" , \"erster\" . Auf die Reihenfolge haben wir in Mengen keinen Einfluss!","title":"Der Iterator"},{"location":"collections/#methoden-fur-mengen","text":"Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: add() , size() und iterator() . Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von java.util.Collection erben ( erben ist hier eigentlich nicht ganz richtig, da es sich bei java.util.Collection um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection ): Methode Beschreibung boolean add(E element) F\u00fcgt Element element in die Collection ein. Gibt true zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst false . boolean addAll(Collection c) F\u00fcgt alle Elemente der Collection c in die Collection ein. Gibt true zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst false . void clear() Entfernt alle Elemente aus der Collection. boolean contains(E element) Gibt true zur\u00fcck, wenn sich element in der Collection befindet, sonst false . boolean containsAll(Collection c) Gibt true zur\u00fcck, wenn sich alle Elemente der Collection c in der Collection befinden, sonst false . boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst false . Iterator iterator() Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. boolean remove(Object o) Entfernt o aus der Collection und gibt true zur\u00fcck, wenn ein Element entfernt wurde, sonst false . boolean removeAll(Collection c) Entfernt alle Elemente aus c aus der Collection und gibt true zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst false . int size() Gibt die Anzahl der Elemente in der Collection zur\u00fcck. Object[] toArray() Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. Der TyP E in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem Iterator sehen wir eine neue Syntax <E> . Diese lernen wir gleich kennen. E steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren.","title":"Methoden f\u00fcr Mengen"},{"location":"collections/#typisieren","text":"Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun: Set menge = new HashSet (); menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Power einf\u00fcgen menge . add ( new Point ( 2 , 3 )); // Point einf\u00fcgen menge . add ( new Konto ()); // Konto einf\u00fcgen Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. Das Typisieren einer Collection erfolgt mithilfe der Diamond -Syntax: Collection<Typ> name = new KonkreteKlasse<>(); Wir typisieren die Menge menge aus dem eben gezeigten Beispiel: Set < String > menge = new HashSet <> (); // mit String typisiert - menge nimmt nur Strings auf menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Fehler - kein String menge . add ( new Point ( 2 , 3 )); // Fehler - kein String menge . add ( new Konto ()); // Fehler - kein String Wir haben menge typisiert und angegeben, dass menge nur Objekte vonm Typ String aufnehmen kann. Dazu geben wir bei der Typdeklaration Set<String> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt new HashSet<>(); . Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). Der Versuch, Objekte eines anderen Typs als String in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator < String > it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } Beachten Sie, dass auch der Iterator (Zeile 21 ) typisiert wird.","title":"Typisieren"},{"location":"collections/#die-for-each-schleife","text":"Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each -Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist: for ( TypElement element : collection ) { } F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 for ( String s : menge ) { System . out . println ( s ); } } } \u00dcbrigens: anstelle der Collection (hier: menge ) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each -Schleife verwenden. \u00dcbung Ersetzen Sie im oberen Beispiel HashSet durch TreeSet . Erkennen Sie einen Unterschied?","title":"Die for-each-Schleife"},{"location":"collections/#listen","text":"Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von java.util.Collection abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.* ; public class Collections { static void fillList ( List < String > list ) { for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( String . valueOf ( i )); } } static void printList ( List < String > list ) { Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } public static void main ( String [] args ) { List < String > list1 = new ArrayList <> (); fillList ( list1 ); printList ( list1 ); List < String > list2 = new LinkedList <> (); fillList ( list2 ); list2 . remove ( \"3\" ); // Wert! list2 . remove ( 6 ); // Index! list1 . removeAll ( list2 ); printList ( list2 ); // 0 1 2 4 5 6 8 9 printList ( list1 ); // 3 7 } } Wir erstellen uns zwei Listen list1 (Zeile 26 ) und list2 (Zeile 30 ). Beide sind vom Compilertyp List und beide sind typisiert mit String , d.h. sie k\u00f6nnen nur Strings aufnehmen. Die Methode fillList() (Zeilen 5-11 ) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern 0...9 . Da die Liste Strings erwartet, werden die int -Ziffern mithilfe von String.valueOf() in einen String umgewandelt (Zeile 9 ). Die add() -Methode f\u00fcgt die Strings hinzu (Zeile 9 ). Die Methode printList() (Zeilen 13-33 ) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile 18 ). Der Aufruf von printList(list1); in Zeile 28 f\u00fchrt zu folgender Ausgabe: 0 1 2 3 4 5 6 7 8 9 End of list Die Liste list2 wird zun\u00e4chst ebenfalls mit den Ziffern 0...9 (jeweils als String ) bef\u00fcllt. Die Anweisung list2.remove(\"3\"); in Zeile 32 bewirkt, dass der Wert \"3\" aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" In Zeile 33 wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index 6 gespeichert ist. Das ist das Element \"7\" . Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" Die Anweisung list1.removeAll(list2); in Zeile 34 bewirkt nun, dass aus list1 alle Werte gel\u00f6scht werden, die (auch) in list2 enthalten sind, also \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" . Das bewirkt, dass in list1 dann nur noch die Werte \"3\" \"7\" \u00fcbrig bleiben. Die Anweisung printList(list2); in Zeile 35 bewirkt folgende Ausgabe: 0 1 2 4 5 6 8 9 End of list Die Anweisung printList(list1); in Zeile 36 bewirkt folgende Ausgabe: 3 7 End of list Die Methode printList() h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each -Schleife implementiert werden k\u00f6nnen: 13 14 15 16 17 18 19 20 21 static void printList ( List < String > list ) { for ( String s : list ) { System . out . print ( s + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } \u00dcbung Gegeben ist folgender Code: Set < Integer > s1 = new HashSet <> (); Set < Integer > s2 = new HashSet <> (); for ( int i = 10 ; i >= 1 ; i -- ) { s1 . add ( i ); } for ( int i = 9 ; i <= 12 ; i ++ ) { s2 . add ( i ); } s1 . addAll ( s2 ); Was ist der R\u00fcckgabewert von s1.addAll(s2); und warum? Implementieren Sie die Ausgabe aller Werte von s1 und s2 .","title":"Listen"},{"location":"collections/#mengenoperationen","text":"Angenommen, wir haben drei Mengen A , B und C , wobei alle Elemente aus C auch Elemente in A sind. Mithilfe der Methoden addAll() , removeAll() , retainAll() und containsAll() lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt:","title":"Mengenoperationen"},{"location":"collections/#stack-und-queue","text":"Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen:","title":"Stack und Queue"},{"location":"collections/#stack","text":"Last-In-First-Out-Prinzip push(E element) zum Hinzuf\u00fcgen pop() entfernt oberstes Element und gibt es zur\u00fcck empty() pr\u00fcft, ob der Stack leer ist","title":"Stack"},{"location":"collections/#queue","text":"First-In-First-Out-Prinzip add()/offer() zum Hinzuf\u00fcgen remove()/poll() entfernt vorderstes Element und gibt es zur\u00fcck element()/peek() pr\u00fcft, ob die Warteschlange leer ist","title":"Queue"},{"location":"collections/#wertetypen-in-collections","text":"Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper -Klassen zur Verf\u00fcgung: Integer , Double , Float , Short , Byte , Long , Character , Boolean : 1 2 3 4 5 6 7 8 // Wertetypen k\u00f6nnen nicht als konkrete // Typen in Collections verwendet werden List < int > l = new ArrayList <> (); // Fehler !! // Verwendung der Wrapper-Klassen + Auto-Boxing List < Integer > l = new ArrayList <> (); l . add ( 100 ); // sogenanntes Auto-Boxing Das obere beispiel zeigt in Zeile 3 , wie es nicht geht. Die List l kann nicht mit int typisiert werden. Stattdessen muss die Wrapper -Klasse Integer verwendet werden. Wir betrachten Wrapper -Klassen im n\u00e4chsten Abschnitt.","title":"Wertetypen in Collections"},{"location":"einstieg/","text":"Einstieg \u00b6 Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe22 // SoSe22 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION Beispiel showConfirmDialog() \u00b6 Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters. Beispiel mit YES_NO_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } Beispiel mit YES_NO_CANCEL_OPTION \u00b6 int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster: Beispiel showInputDialog() \u00b6 Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig. Ausblick \u00b6 Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Einstieg"},{"location":"einstieg/#einstieg","text":"Wir haben bis jetzt noch keine Nutzerinnen-Eingaben erm\u00f6glicht und verwaltet. Das wollen wir nun \u00e4ndern. Es gibt die M\u00f6glichkeit, Nutzerinnen-Eingaben \u00fcber die Konsole zu implementieren. Dazu steht z.B. die Klasse Scanner aus dem java.util -Paket zur Verf\u00fcgung. Diese Klasse wollen wir hier aber nicht betrachten, sondern \u00f6ffnen einen Dialog (ein Fenster), um Eingaben vorzunehmen. Dazu verwenden wir die Klasse JOptionPane . Diese Klasse bietet einige n\u00fctzliche statische Methoden, die uns Dialoge erzeugen. Die Klasse JOptionPane befindet sich im Paket javax.swing . Wenn Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie darin requires java.desktop; eintragen, um \u00fcberhaupt Klassen aus dem javax.swing -Paket importieren zu k\u00f6nnen, das sich das Paket javax.swing im Modul java.desktop befindet: module-info.java module SoSe22 // SoSe22 ist der Name des Java-Projektes { requires java . desktop ; } Die interessanten Methoden zur Erzeugung der Dialoge sind showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() Diese Methoden erzeugen jeweils ein Dialogfenster, in dem entweder etwas eingegeben werden kann ( showInputDialog() ) oder in dem etwas durch den Klick auf einen Button ausgew\u00e4hlt werden kann. Der Eingabe-Dialog gibt einen String zur\u00fcck und die anderen Dialoge geben ein int zur\u00fcck, welcher beschreibt, auf welchen Button geklickt wurde. Der zur\u00fcckgegebene int -Wert l\u00e4sst sich mit den folgenden Konstanten vergleichen: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION","title":"Einstieg"},{"location":"einstieg/#beispiel-showconfirmdialog","text":"Die showConfirmDialog() -Methode ist zwei Mal \u00fcberladen. Es gibt static int showConfirmDialog(Component parentComponent, Object message) und static int showConfirmDialog(Component parentComponent, Object message, String title, int optionType) Als optionType gibt es dabei die Auswahl zwischen JOptionPane.DEFAULT_OPTION , JOptionPane.YES_NO_OPTION , JOptionPane.YES_NO_CANCEL_OPTION , JOptionPane.OK_CANCEL_OPTION Die parentComponent ist das Fenster, welches das Dialogfenster aufruft. Wir haben ein solches Fenster (noch) nicht, deshalb werden wir zun\u00e4chst den Wert hier stets auf null setzen. Der String message erscheint im Dialogfenster als Nachricht. Da dies nicht nur ein String sein kann, sondern besipielsweise auch ein Icon , ist der Typ von message als Object deklariert. Der String title erscheint als Titel des Dialogfensters.","title":"Beispiel showConfirmDialog()"},{"location":"einstieg/#beispiel-mit-yes_no_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , // parentComponent \"Wollen Sie wirklich beenden?\" , // message \"Programmende\" , // title JOptionPane . YES_NO_OPTION // optionType ); erzeugt z.B. folgendes Dialogfenster: Wenn Sie nun auf einen der beiden Button No oder Yes klicken, dann schlie\u00dft sich das Fenster wieder und in dem int auswahl ist der Wert gespeichert, der dem von Ihnen gedr\u00fcckten Button entspricht. Diesen Wert k\u00f6nnen Sie wie folgt auswerten: if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt }","title":"Beispiel mit YES_NO_OPTION"},{"location":"einstieg/#beispiel-mit-yes_no_cancel_option","text":"int auswahl = JOptionPane . showConfirmDialog ( null , \"Weitere Seiten scannen?\" , \"Speichern\" , JOptionPane . YES_NO_CANCEL_OPTION ); if ( auswahl == JOptionPane . NO_OPTION ) { // es wurde auf NO geklickt } else if ( auswahl == JOptionPane . YES_OPTION ) { // es wurde auf YES geklickt } else if ( auswahl == JOptionPane . CANCEL_OPTION ) { // es wurde auf CANCEL geklickt } erzeugt folgendes Dialogfenster:","title":"Beispiel mit YES_NO_CANCEL_OPTION"},{"location":"einstieg/#beispiel-showinputdialog","text":"Die Methode showInputDialog() \u00f6ffnet ein Dialogfenster mit einem einzeiligen Textfeld, in das die Nutzerin etwas eingeben kann und diese Eingabe dann mit dem Klick auf einen Button beendet. Die Methode showInputDialog() ist sechs Mal \u00fcberladen, siehe dazu [hier]. Uns interessiert in den meisten F\u00e4llen die einfachste Form showInputDialog(Object message) oder, wenn wir noch einen messageType hinzuf\u00fcgen wollen, showInputDialog(Component parentComponent, Object message, String title, int messageType) . F\u00fcr den messageType gibt es folgende vordefinierte Konstanten: ERROR_MESSAGE , INFORMATION_MESSAGE , WARNING_MESSAGE , QUESTION_MESSAGE , PLAIN_MESSAGE Wichtig ist, dass die showInputDialog() -Methode den String zur\u00fcckgibt, der eingegeben wurde. String eingabe = JOptionPane . showInputDialog ( \"Ihre Eingabe : \" ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Implementierung String eingabe = JOptionPane . showInputDialog ( null , \"Ihre Eingabe : \" , \"Dialogtitel\" , JOptionPane . ERROR_MESSAGE ); System . out . println ( \"Sie haben \" + eingabe + \" eingegeben\" ); erzeugt folgendes Dialogfenster: Die Ansicht der Fenster und auch der messageType -Icons sind betriebssystemabh\u00e4ngig.","title":"Beispiel showInputDialog()"},{"location":"einstieg/#ausblick","text":"Angenommen, wir wollen JOptionPane.showInputDialog() verwenden, um eine Zahl einzugeben. Klar ist, dass showInputDialog() die Eingabe als String zur\u00fcckgibt. Problem : Wie wandeln wir einen String zu einem int (oder double ) um? Antwort : mit der Hilfe von Wrapper-Klassen Problem : Angenommen, wir haben eine L\u00f6sung, String nach int umzuwandeln. Wie stellen wir dann sicher, dass unser Programm nicht abst\u00fcrzt, wenn wir gar keine Zahl eingeben, sondern z.B. hallo ? Das l\u00e4sst sich ja gar nicht in eine Zahl umwandeln. Antwort : mit der Behandlung von Exceptions","title":"Ausblick"},{"location":"enum/","text":"Aufz\u00e4hlungstypen (enum) \u00b6 Motivation \u00b6 Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar Erster Verbesserungsversuch: Konstanten \u00b6 Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; // Feld ist leer static final int RED = 1 ; // auf das Feld hat rot gesetzt static final int BLACK = 2 ; // auf das Feld hat schwarz gesetzt TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; // hier wird auf das Feld rot oder schwarz gesetzt } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich Der Aufz\u00e4hlungstyp enum \u00b6 Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich Details: \u00b6 alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; } Weiteres: \u00b6 auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } noch ein Beispiel f\u00fcr Werte mit Attributen enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } } N\u00fctzliche Links f\u00fcr enums \u00b6 Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"Aufz\u00e4hlungstypen"},{"location":"enum/#aufzahlungstypen-enum","text":"","title":"Aufz\u00e4hlungstypen (enum)"},{"location":"enum/#motivation","text":"Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar","title":"Motivation"},{"location":"enum/#erster-verbesserungsversuch-konstanten","text":"Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; // Feld ist leer static final int RED = 1 ; // auf das Feld hat rot gesetzt static final int BLACK = 2 ; // auf das Feld hat schwarz gesetzt TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; // hier wird auf das Feld rot oder schwarz gesetzt } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich","title":"Erster Verbesserungsversuch: Konstanten"},{"location":"enum/#der-aufzahlungstyp-enum","text":"Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich","title":"Der Aufz\u00e4hlungstyp enum"},{"location":"enum/#details","text":"alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; }","title":"Details:"},{"location":"enum/#weiteres","text":"auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } noch ein Beispiel f\u00fcr Werte mit Attributen enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } }","title":"Weiteres:"},{"location":"enum/#nutzliche-links-fur-enums","text":"Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"N\u00fctzliche Links f\u00fcr enums"},{"location":"ereignisse/","text":"Ereignisse \u00b6 Aufgrund des Informatiktages am 22.6.2022 f\u00e4llt die Vorlesung aus. Damit wir keine Zeit verlieren, ist das Folgende Thema (bis ActionCommand ) als Selbstudium (E-Learning) gedacht. Zumindest fast vollst\u00e4ndig Selbstudium, wir besprechen Fargen in der Vorlesung am 29.6.2022. Dazu gibt es auch das folgende Video aus dem letzten Jahr zusammen mit dem Source-Code, der darin erstellt wird: Selbstudium GUI Ereignisse siehe GUI Ereignisse siehe Video zu GUI Ereignisse - Vorlesung aus dem Vorjahr Quellcode aus dem Video Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { Integer anzKlicks = 0 ; JLabel unten ; public Ereignisbehandlung (){ super (); this . setTitle ( \"Ereignisbehandlung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 200 , 150 ); this . setLocation ( 200 , 100 ); this . setVisible ( true ); } public JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); plus . addActionListener ( this ); minus . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); this . unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . unten . setHorizontalAlignment ( JLabel . CENTER ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( unten , BorderLayout . CENTER ); return mainPanel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); // hat ActionEvent ausgeloest if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; System . out . println ( \"Minus-Button geklickt ... \" + this . anzKlicks ); } else if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; System . out . println ( \"Plus-Button geklickt ... \" + this . anzKlicks ); } this . unten . setText ( this . anzKlicks . toString ()); } } } Im vorangegangenen Kapitel haben wir gelernt, wie wir Grafische Nutzeroberfl\u00e4chen (GUI) erstellen k\u00f6nnen. Nun wollen wir uns anschauen, wie auf Ereignisse reagiert werden kann, die die Nutzerin auf dieser Grafischen Oberfl\u00e4che ausl\u00f6st. Wenn wir beispielsweise in unserem Taschenrechner auf einen Button klicken, dann soll entweder die Ziffer in dem Textfeld oben erscheinen oder es soll die Operation ausgef\u00fchrt werden, auf die wir geklickt haben. In grafischen Nutzeroberfl\u00e4chen gibt es nicht nur Buttons, auf deren Klick-Ereignisse wir reagieren wollen, es gibt auch Eingaben \u00fcber die Tastatur, das Fenster kann mit der Maus bewegt, vergr\u00f6\u00dfert oder verkleinert werden, es k\u00f6nnen Kontextdialoge durch das Dr\u00fccken der rechten Maustaste ge\u00f6ffnet werden usw. Wir lernen hier, welche unterschiedlichen Ereignisse es gibt und wie wir diese behandeln k\u00f6nnen, d.h. wie wir die Reaktion auf diese Ereignisse implementieren. Zun\u00e4chst \u00fcberlegen wir uns, wie es \u00fcberhaupt m\u00f6glich sein kann, dass Ereignisse (also Aktionen der Nutzerin) auf unserer grafischen Oberfl\u00e4che erkannt werden und auf diese Ereignisse entsprechend reagiert werden kann. Man k\u00f6nnte (in einer Schleife) permanent bei der Maus oder der Tastatur anfragen, ob eine Taste gedr\u00fcckt oder ob die Maus bewegt wurde. Das ist aber viel zu imperformant und w\u00fcrde das Programm blockieren. Diese Aufgabe wird n\u00e4mlich von der Laufzeitumgebung automatisch \u00fcbernommen. Im Hintergrund geschieht genau so etwas, aber wir m\u00fcssen uns gar nicht darum k\u00fcmmern. Wenn z.B. eine Maustaste gedr\u00fcckt wird, dann wird im Hintergrund durch die Laufzeitumgebung eine bestimmte Methode aufgerufen ( mouseClicked() ). Woher wissen wir, wie diese Methode hei\u00dft? Die Antwort sind nat\u00fcrlich: Interfaces ! Interfaces f\u00fcr Ereignisse - Listener \u00b6 Die Idee ist die Folgende: Komponenten k\u00f6nnen unterschiedliche Ereignisse empfangen (Button angeklickt, Text eingegeben, Maus bewegt, Fenster geschlossen, ...). Die Anwendung registriert einen sogenannten Listener (ein Listener -Objekt) bei der Komponente f\u00fcr Ereignisse von Interesse. Tritt ein Ereignis, f\u00fcr das man sich beim Listener angemeldet hat, an der Komponente ein, wird eine bestimmte Methode am Listener-Objekt aufgerufen. Alle diese Methoden, die durch die Laufzeitumgebung f\u00fcr bestimmte Ereignisse aufgerufen werden k\u00f6nnen, sind in Interfaces definiert. Es gibt unterschiedliche Interfaces , die man implementieren muss, je nach den Ereignissen, auf die man reagieren m\u00f6chte (Mausereignisse, Tastaturereigniss, Ereignisse am Fenster, ...). Das Vorgehen kann man sich wie in der Abbildung gezeigt vorstellen: Der Listener lauscht permanent auf Ereignisse. Sobald ein Ereignis aufritt, auf das der Listener lauscht, ruft er eine entsprechende Methode auf. Damit wir im Programm auf dieses Ereignis reagieren k\u00f6nnen (die Ereignisbehandlung implementieren), m\u00fcssen wir zwei Dinge tun: uns an dem Listener anmelden, der auf die Ereignisse lauscht, die uns interessieren (die wir behandeln wollen) und die Ereignisbehandlung in der vom Listener aufgerufenen Methode implementieren. Die Methoden, die wir implementieren sind abstrakt in Interfaces festgelegt. Das bedeutet also, dass wir f\u00fcr die Ereignisbehandlung Interfaces implementieren. Erstes Beispiel ActionListener \u00b6 Wir starten mit einem ersten Beispiel. Dazu haben wir uns folgende GUI erstellt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.awt.BorderLayout ; import java.awt.Font ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); JLabel unten = new JLabel ( \"0\" ); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } } Die Ausf\u00fchrung des Programms zeigt folgendes kleines Fenster: Es soll nun implementiert werden, dass sich durch einen Klick auf den Button die dargestellte Zahl um 1 erh\u00f6ht. Die Methode, die ausgel\u00f6st wird, wenn ein Button geklickt wird, hei\u00dft actionPerformed() . Diese ist in dem Interface ActionListener implementiert. Wir m\u00fcssen nun also das Interface ActionListener implementieren und uns beim ActionListener anmelden. Das Interface ActionListener implementieren \u00b6 Interfaces implementieren k\u00f6nnen wir bereits - mithilfe von implements : Wir schreiben also: public class Ereignisbehandlung extends JFrame implements ActionListener . Das Interface ActionListener muss aus dem java.awt.event -Paket importiert werden. Wir klicken auf Add unimplemented methods und in der Klasse erscheint die folgende Methode: @Override public void actionPerformed ( ActionEvent e ) { // TODO Auto-generated method stub } Das Interface ActionListener enth\u00e4lt also nur genau eine Methode, die implmentiert werden muss. Dieser Methode wird ein ActionEvent als Parameter \u00fcbergeben. Diese Klasse muss ebenfalls aus dem java.awt.event -Paket importiert werden. Wenn unser Button gedr\u00fcckt wird, dann wird also \"automatisch\" (durch die Laufzeitumgebung) die Methode actionPerformed() aufgerufen. Alles, was passieren soll, wenn der Button geklickt wird, m\u00fcssen wir in dieser Methode implementieren. Wir beginnen mit einer ganz einfachen Implementierung, mit einer simplen Ausgabe auf die Konsole: @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); } Wenn wir nun auf den Button klicken, passiert aber noch nichts, denn wir m\u00fcssen den Button noch am ActionListener anmelden (siehe oben Punkt 2 in der Liste). Am ActionListener anmelden \u00b6 Damit das Klick-Ereignis auf den Button auch so behandelt wird, wie wir das in der actionPerformed() -Methode definiert haben, m\u00fcssen wir diesen Button an den ActionListener anmelden. Dazu existiert f\u00fcr einen JButton (f\u00fcr alle Komponenten JComponent ) die Methode addActionListener(ActionListener l) . Dieser Methode muss nun ein ActionListener -Objekt \u00fcbergeben werden, also ein Objekt, das das Interface ActionListener implementiert hat. Da wir den ActionListener in unserer Fensterklasse implementiert haben, ist das Fenster ein solches Objekt, das den ActionListener implementiert hat. Wir verwenden also this . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); oben . addActionListener ( this ); JLabel unten = new JLabel ( \"0\" ); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); } } Jedes mal, wenn wir nun auf den Button klicken, wird eine Ausgabe auf der Konsole erzeugt. Nach 5 Klicks also Button gedrueckt! Button gedrueckt! Button gedrueckt! Button gedrueckt! Button gedrueckt! Wir haben das erste Ereignis behandelt, das durch eine Nutzerinnenaktion ausgel\u00f6st wurde - das Klicken eines Buttons! Zugriff auf Komponenten in actionPerformed() \u00b6 Wenn wir nun aber die actionPerformed() -Methode so implementieren wollen, dass sich der Text des JLabel s unten \u00e4ndert, dann stellen wir fest, dass wir in actionPerformed() ja gar keinen Zugriff auf dieses JLabel haben, weil die Referenz darauf nur eine lokale Variable in der init() -Methode ist. Um in allen Methoden der Klasse Ereignisbehandlung Zugriff auf dieses JLabel zu erlangen, m\u00fcssen wir es global deklarieren (als Objektvariable der Klasse Ereignisbehandlung ). Zus\u00e4tzlich erzeugen wir eine weitere Variable, die die Anzahl der bisherigen Klicks mitz\u00e4hlt, um diesen Wert dann im JLabel darzustellen. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); oben . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); this . anzKlicks ++ ; this . unten . setText ( this . anzKlicks . toString ()); } } Nun \u00e4ndert sich mit jedem Button-Klick der angezeigte Wert. Mehrere Buttons - ActionEvent \u00b6 Wir \u00e4ndern unsere GUI, indem wir die init() -Methode \u00e4ndern: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } Die GUI sieht dadurch nun so aus: Das hei\u00dft, wir haben zwei Buttons und wollen f\u00fcr diese Buttons das Klick-Ereignis unterschiedlich behandeln. Bei Klick auf den - -Button soll der Wert der Zahl dekrementiert werden, bei Klick auf den + -Button inkrementiert. Wir m\u00fcssen nun also innerhalb der actionPerformed() -Methode unterscheiden, welcher Button gedr\u00fcckt wurde, d.h. durch welchen Button das ActionEvent ausgel\u00f6st wurde, welches wir behandeln. Dabei hilft uns das ActionEvent -Objekt, das der actionPerformed(ActionEvent e) -Methode \u00fcbergeben wird. Die Klasse ActionEvent hat einige n\u00fctzliche Methoden. Wir verwenden jetzt zun\u00e4chst eine Methode, die die Klasse ActionEvent von der Klasse EventObject geerbt hat, die getSource() -Methode: 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } Die getSource() -Methode von ActionEvent liefert die Komponente (als Object ) zur\u00fcck, die das ActionEvent ausgel\u00f6st hat. Damit wir Objektmethoden (z.B. getText() - Zeilen 55 und 59 ) von JButton verwenden k\u00f6nnen, m\u00fcssen wir dieses Object nach JButton konvertieren (Zeile 54 ). Damit dies gelingt, m\u00fcssen wir zun\u00e4chst pr\u00fcfen, ob es sich bei der ausl\u00f6senden Komponente tats\u00e4chlich um einen JButton handelt. Das erledigen wir hier mit dem instanceof -Operator in Zeile 52 . Mithilfe der getText() -Methoden erfragen wir den Text, der auf den Buttons steht. Wir vergleichen diesen mithilfe der equals() -Methode und k\u00f6nnen somit unterscheiden, ob das ActionEvent durch den + - oder den - -Button ausgel\u00f6st wurde. Wir d\u00fcrfen nicht vergessen , die beiden Buttons an den ActionListener anzumelden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . addActionListener ( this ); plus . addActionListener ( this ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } } Nun haben wir f\u00fcr die beiden Buttons eine unterschiedliche Ereignisbehandlung realisiert. bis hier Selbstudium ActionCommand \u00b6 Die Abfrage des Textes auf den Buttons zur Unterscheidung der Buttons ist nicht clean code . Das hat mehrere Gr\u00fcnde: GUIs werden h\u00e4ufig f\u00fcr mehrere Sprachen zur Verf\u00fcgung gestellt. Je nach Einstellungen in den Konfigurationen kann die \"angezeigte\" Sprache der GUI ver\u00e4ndert werden. Somit w\u00fcrden auch die Buttons ihre Beschriftung \u00e4ndern und man m\u00fcsste in der actionPerformed() -Methode viele Varianten f\u00fcr die Textabfrage hinzuf\u00fcgen. Buttons k\u00f6nnen auch einfach nur Icons enthalten, d.h. gar keinen Text. Der auf Buttons angezeigte Text kann sehr \"kryptisch\" sein, also irgendwelche Sonderzeichen oder Schriftzeichen enthalten. Es kann z.B. auch HTML -Code sein. Das alles macht die Abfrage des Textes und insbesondere den Vergleich kompliziert bis gar unm\u00f6glich. Deshalb sollte man stattdessen besser das ActionCommand abfragen. Das ActionCommand wird mithilfe der setActionCommand(String command) -Methode gesetzt und mithilfe der getActionCommand() -Methode abgefragt. Wenn f\u00fcr einen Button nicht mithilfe der setActionCommand() -Methode ein ActionCommand definiert wurde, dann entspricht das ActionCommand dem Text auf dem Button. Das bedeutet, dass die getActionCommand() -Methode trotzdem verwendet werden k\u00f6nnte. Wir br\u00e4uchten also nur in der actionPerformed() -Methode getText() durch getActionCommand() ersetzen und h\u00e4tten das gleiche Ergebnis: 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } Wenn wir allerdings eigene (andere) ActionCommands f\u00fcr die Buttons setzen, dann m\u00fcssen wir auch den Vergleich anpassen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . setActionCommand ( \"minus\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( this ); plus . addActionListener ( this ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } } Success Wir kennen nun das Konzept, das hinter der Behandlung von Ereignissen steckt. Wir melden die Komponente, f\u00fcr die wir eine Ereignisbehandlung f\u00fcr ein Ereignis implementieren wollen, an den entsprechenden Listener an und wir implementieren das zugeh\u00f6rige Interface. Wir haben Buttons erfolgreich an den ActionListener angemeldet und das ActionListener -Interface implementiert. Dieses Interface enth\u00e4lt nur genau eine Methode, actionPerformed() . Wir k\u00f6nnen in dieser Methode auch bereits ermitteln, welche Komponente das ActionEvent ausgel\u00f6st hat, das gerade behandelt wird. Dadurch k\u00f6nnen wir in derselben actionPerformed() -Methode die (unterschiedliche) Ereignisbehandlung f\u00fcr mehrere Buttons implementieren. Damit k\u00f6nnen wir nun schonmal einen funktionsf\u00e4higen Taschenrechner bauen! Der L\u00f6sung f\u00fcr Aufgabe 9 steht nichts mehr im Wege! Innere Klassen \u00b6 Mit der Implementierung des ActionListener hat alles geklappt und funktional ist auch alles in Ordnung, aber so richtig sch\u00f6n ist es nicht - kein clean code . Daf\u00fcr gibt es mehrere Gr\u00fcnde: Unsere Klasse verst\u00f6\u00dft auf jeden Fall gegen das Single Responsibility Principle ( SRP ). Unsere Klasse ist einerseits ein Fenster und andererseits k\u00fcmmern wir uns in der Klasse auch um Funktionalit\u00e4ten. Bei der Erstellung von Anwendungen mit grafischen Nutzeroberfl\u00e4chen hat sich sogar eine Dreiteilung etabliert, das sogenannte Model-View-Controller-Pattern . Darin ist die Darstellung der GUI die View , das Verwalten und Manipulieren der Daten das Model und die Steuerung mittels Nutzeraktionen der Controller . Langfristig streben wir eine solche Dreiteilung ebenfalls an. Wenn wir sehr viele Buttons (und sp\u00e4ter auch noch Textfelder, Men\u00fcs usw.) haben, dann kann die actionPerformed() -Methode schon allein dadurch sehr lang werden, dass wir viele Fallunterscheidungen ben\u00f6tigen, um zu ermitteln, welche Komponente das ActionEvent \u00fcberhaupt ausgel\u00f6st hat. Wenn dann jeweils noch viel Funktionalit\u00e4t hinzukommt, wird die actionPerformed() -Methode viel zu lang. Wir haben bis jetzt nur ein einziges Interface, das ActionListener -Interface, implementiert und dieses enth\u00e4lt auch nur eine einzige Methode. Wenn wir nun auch noch auf Maus-, Mausbewegungs-, Tastatur- und Fenstereignisse reagieren wollen, dann implementieren wir mindestens vier weitere Interfaces, die jeweils bis zu sechs Methoden enthalten. Unsere Klasse w\u00fcrde sehr lang werden. Wir ben\u00f6tigen Ideen, wie wir diese Konflikte aufl\u00f6sen k\u00f6nnen. Dazu ben\u00f6tigen wir neue Strukturierungsm\u00f6glichkeiten. Ein erster Schritt dahin sind Innere Klassen . Wir betrachten Innere Klassen aber nur als einen Zwischenschritt hin zu anonymen Klassen . Wir werden uns ansonsten nicht weiter mit inneren Klassen auseinandersetzen. Begriffsbestimmung \u00b6 Prinzipiell handelt es sich bei inneren Klassen um Klassen in einer Klasse. Der Oberbegriff f\u00fcr eine Klasse in einer Klasse ist nested class . In nested classes unterscheidet man zwischen statischen und nicht-statischen Klassen. Die nicht-statischen nested Klassen (also Klassen, wie wir sie bisher kennen - wir kennen noch gar keine statischen Klassen) hei\u00dfen innere Klassen . Wir wollen uns gar nicht mit statischen verschachtelten Klassen auseinandersetzen. Es sei an dieser Stelle aber der wesentliche Unterschied zwischen den statischen und den nicht-statischen verschachtelten Klassen genannt: nicht-statische Klassen (also innere Klassen) haben Zugriff auf die Eigenschaften der \u00e4u\u00dferen Klasse, statische verschachtelte Klassen haben diesen Zugriff nicht. Wenn wir schon bei Sachen sind, die uns nicht interessieren ;-) : sogenannte lokale Klassen sind Klassen in einer Methode. Innere Klassen sind aber n\u00fctzlich und sinnvoll. Wir kennen auch schon eine, n\u00e4mlich Map.Entry - die Klasse Entry ist eine innere Klasse von Map (ganz exakt handelt es sich bei beiden nicht um Klassen, sondern um Interfaces, das macht hier aber keinen Unterschied). In der Klasse Integer gibt es \u00fcbrigens auch eine innere Klasse. Die fungiert als ein Cache f\u00fcr h\u00e4ufig verwendete Zahlen. Wenn Sie ein Integer -Objekt mit einem Wert kleiner als 128 erstellen, dann kommt dieses Objekt in den Cache und wenn Sie ein weiteres Objekt mit dem gleichen Wert erzeugen, dann wird daf\u00fcr einfach das Objekt aus dem Cache verwendet. Das f\u00fchrt zu diesem \"komischen\" Verhalten: Integer i1 = Integer . valueOf ( 1001 ); Integer i2 = Integer . valueOf ( 1001 ); Integer i3 = Integer . valueOf ( 101 ); Integer i4 = Integer . valueOf ( 101 ); System . out . println ( i1 == i2 ); // false System . out . println ( i3 == i4 ); // true Der erste Vergleich ist false , weil es sich bei i1 und i2 um Referenzen auf zwei verschiedene Objekte handelt. Der zweite Vergleich ist aber true , weil es sich bei i3 und i4 um Referenzen auf dasselbe Objekt (aus dem Cache) handelt. Aber das nur nebenbei, um zu erl\u00e4utern, dass es sinnvolle Verwendungen f\u00fcr innere Klassen gibt. Ereignisbehandlung mit innerer Klasse \u00b6 Wir verwenden unsere Klasse Ereignisbehandlung von oben. Aber wir lagern die eigentliche Behandlung des ActionEvent s in eine innere Klasse aus. Das hei\u00dft, wir trennen die Erstellung der GUI und die Behandlung der Ereignisse strukturell, in dem diese Dinge in zwei unterschiedlichen Klassen implementiert sind. Da es sich aber um die Ereignisbehandlung f\u00fcr genau die erstellte GUI handelt, ergibt es wenig Sinn, diese in eine \"normale\" top-level-Klasse zu \u00fcberf\u00fchren. Deshalb verwenden wir daf\u00fcr eine innere Klasse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . setActionCommand ( \"minus\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( new ActionHandler ()); plus . addActionListener ( new ActionHandler ()); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } class ActionHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { Ereignisbehandlung . this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { Ereignisbehandlung . this . anzKlicks -- ; } } Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } } } So viel hat sich gar nicht ge\u00e4ndert: Die Klasse Ereignisbehandlung implementiert jetzt nicht mehr selbst das Interface ActionListener (Zeile 8 ). Das hat jetzt die neue (innere) Klasse ActionHandler \u00fcbernommen (Zeile 54 ). Da der ActionListener nun nicht mehr in Ereignisbehandlung implementiert ist, sondern in ActionHandler , muss beim Anmelden an den ActionListener nun nicht mehr das this -Objekt, sondern ein Objekt von ActionHandler \u00fcbergeben werden (Zeilen 34 und 35 ). Da sich die Methode actionPerformed() nun in der Klasse ActionHandler befindet, handelt es sich dort bei der this -referenz um eine Referenz auf ein ActionHandler -Objekt. Wir k\u00f6nnen also nicht mehr einfach this.anzKlicks++; schreiben, da es sich bei anzKlicks ja nicht um eine Eigenschaft der ActionHandler -Klasse, sondern um eine Eigenschaft der Ereignisbehandlung -Klasse handelt. Das Gleiche gilt auch f\u00fcr das JLabel unten (Zeilen 65 , 69 und 72 ). Um auf die Eigenschaften der \u00e4u\u00dferen Klasse zuzugreifen, kann in der inneren Klasse \u00fcber den Klassennamen der \u00e4u\u00dferen Klasse auf die Eigenschaften der \u00e4u\u00dferen Klasse referenziert werden. Das hei\u00dft, wenn die \u00e4u\u00dfere Klasse AeussereKlasse hei\u00dft und eine Eigenschaft eigenschaft_AeK hat, dann kann aus der inneren Klasse heraus wie folgt auf diese Eigenschaft zugegriffen werden: AeussereKlasse.this.eigenschaft_AeK In unserem Fall bedeutet das, dass wir nun \u00fcber Ereignisbehandlung.this.anzKlicks++; und Ereignisbehandlung.this.anzKlicks--; den Wert der Eigenschaft anzKlicks der \u00e4u\u00dferen Klasse Ereignisbehandlung \u00e4ndern k\u00f6nnen (Zeilen 65 und 69 ). Um auf das JPanel unten aus der inneren Eigenschaft zugreifen zu k\u00f6nnen, schreiben wir deshalb Ereignisbehandlung.this.unten (Zeile 72 ). Beachten Sie, dass das this darin notwendig ist. Wenn wir schreiben w\u00fcrden Ereignisbehandlung . anzKlicks ++ ; , dann w\u00fcrde das bedeuten, dass es sich bei anzKlicks um eine statische (Klassen-)Variable handeln w\u00fcrde. Um auf (nicht-statische) Objektvariablen zuzugreifen, verwenden wir in der Klasse ja die Referenz this und um also auf die Objektvariablen der \u00e4u\u00dferen Klasse zuzugreifen, schreiben wir Ereignisbehandlung . this . anzKlicks ++ ; Dasselbe gilt f\u00fcr Methoden. Wir haben nun immerhin die Verantwortlichkeiten zur Erstellung der GUI und zur Behandlung der Ereignisse in zwei verschiedene Klassen aufgeteilt. Das Single Responsibility Principle ist somit erf\u00fcllt. Das ist schonmal gut! Wir haben aber eingangs erw\u00e4hnt, dass wir uns die inneren Klassen nur als ein Zwischenschritt anschauen. Dazu \u00fcberlegen wir uns nochmal Folgendes: Wir haben f\u00fcr die Ereignisbehandlung eine eigene Klasse ActionHandler geschrieben. Um sich an den ActionListener anzumelden, wurde der addActionListener() -Methode daf\u00fcr ein Objekt von ActionHandler \u00fcbergeben (siehe oben die Zeilen 34 und 35 ). Nun machen wir etwas Verr\u00fccktes ;-) : wir \u00fcbergeben der addActionListener() -Methode auch wieder ein Objekt, in dem wir den ActionListener implementiert haben (implementieren), aber diese Implementierung erfolgt nicht in einer separaten Klasse, die einen Namen hat ( ActionHandler ), sondern die Implementierung erfolgt direkt dort, wo das Objekt \u00fcbergeben wird, daf\u00fcr ohne einen Klassennamen - eine anonyme Klasse. Ereignisbehandlung mit anonymer Klasse \u00b6 Jede Komponente, f\u00fcr die auf das ActionEvent reagiert werden soll, muss an den ActionListener mithilfe der addActionListener() -Methode angemeldet werden. Dieser Methode wird ein Objekt \u00fcbergeben, in dem der ActionListener implementiert ist. Wir implementieren jetzt direkt dort, wo wir das Objekt \u00fcbergeben, genau diese Klasse, geben ihr aber keinen Namen. Stattdessen geben wir ActionListener wie einen Konstruktor an, obwohl es sich bei ActionListener um ein Interface handelt, welches erstens keinen Konstruktor besitzt und zweitens von dem gar kein Objekt erzeugt werden kann. Wir schauen uns das am Beispiel des - -Buttons an: 1 2 3 4 5 6 7 8 9 minus . addActionListener ( new ActionListener () { // Objekt einer anonymen Klasse @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); Wir \u00fcbergeben der addActionListener() -Methode ein Objekt einer anonymen Klasse. Diese anonyme Klasse implementiert das ActionListener -Interface. Zun\u00e4chst gehen wir nochmal einen Schritt zur\u00fcck und schauen uns die Varianten an, die wir davor hatten: minus . addActionListener ( this ); // ActionListener war in der Fenster-Klasse implementiert minus . addActionListener ( new ActionHandler ()); // ActionListener war in der inneren Klasse ActionHandler implementiert Nun implementieren wir das ActionListener -Interface direkt \"vor Ort\" - dort, wo es auch \u00fcbergeben wird. Der Aufruf der addActionListener() -Methode ist \u00fcbrigens noch exakt der gleiche 1 2 3 4 5 6 7 8 9 minus . addActionListener ( ); , nur das \u00fcbergebene Objekt sieht etwas \"komisch\" aus: 1 2 3 4 5 6 7 8 9 new ActionListener () { // Objekt einer anonymen Klasse @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } } Wir erkennen aber den Klassenrumpf, der ganz normal mit einer geschweiften Klammer { in Zeile 1 ) beginnt und mit einer schlie\u00dfenden geschweiften Klammer } in Zeile 9 endet. Darin ist, auch ganz normal, die actionPerformed() -Methode implementiert, die ja implementiert werden muss, wenn das ActionListener -Interface implementiert wird. Innerhalb der Methode greifen wir auch, wie bei inneren Klassen \u00fcblich, auf die Objekteigenschaften der \u00e4u\u00dferen Klasse zu. Eigentlich ist nur dieser Ausdruck neu: new ActionListener() { } . Hier m\u00fcssen wir uns einfach merken, dass es sich dabei um drei Sachen hadelt, die zugleich passieren: Es wird das ActionListener -Interface implementiert. Dies geschieht \"ganz normal\" in einem Klassenrumpf, der mit { beginnt und mit } endet. Die Klasse, in der das Interface implemntiert wird, hat aber keinen Namen, deshalb schreiben wir auch nicht Klassenmane implements ActionListener , sondern nur ActionListener . Es wird ein Objekt erzeugt. Dazu wird, ganz normal, das Schl\u00fcsselwort new verwendet und ein Konstruktor - allerdings hier der Konstruktor einer Klasse, die keinen Namen hat. Da diese Klasse aber das ActionListener -Interface implementiert, kann dieser Name f\u00fcr den Konstruktor verwendet werden. Der gro\u00dfe Vorteil dieser Art der Implementierung des ActionListener -Interfaces liegt darin, dass jede Komponente ihre eigene Implementierung bekommt und dass es deshalb nicht notwendig ist, eine Fallunterscheidung zu treffen, welche Komponente das Ereignis ausgel\u00f6st hat. Hier kann es nur der minus -Button gewesen sein! Die beiden Implementierungen des ActionListener s mithilfe einer anonymen Klasse sehen so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks ++ ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); Den ActionListener mithilfe anonymer Klassen zu implementieren, ist ein Best Practice . In sehr vielen F\u00e4llen gewinnt man an \u00dcbersichtlichkeit. Wir werden im Rest des Semesters immer mal diskutieren, wann die Verwendung anonymer Klassen sinnvoll ist und wann nicht. Manchmal ist es aber auch nur Geschmackssache. F\u00fcr diejenigen, die sich f\u00fcr nested classes interessieren, sei dieser Link empfohlen.","title":"GUI Ereignisse"},{"location":"ereignisse/#ereignisse","text":"Aufgrund des Informatiktages am 22.6.2022 f\u00e4llt die Vorlesung aus. Damit wir keine Zeit verlieren, ist das Folgende Thema (bis ActionCommand ) als Selbstudium (E-Learning) gedacht. Zumindest fast vollst\u00e4ndig Selbstudium, wir besprechen Fargen in der Vorlesung am 29.6.2022. Dazu gibt es auch das folgende Video aus dem letzten Jahr zusammen mit dem Source-Code, der darin erstellt wird: Selbstudium GUI Ereignisse siehe GUI Ereignisse siehe Video zu GUI Ereignisse - Vorlesung aus dem Vorjahr Quellcode aus dem Video Ereignisbehandlung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { Integer anzKlicks = 0 ; JLabel unten ; public Ereignisbehandlung (){ super (); this . setTitle ( \"Ereignisbehandlung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 200 , 150 ); this . setLocation ( 200 , 100 ); this . setVisible ( true ); } public JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); plus . addActionListener ( this ); minus . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); this . unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . unten . setHorizontalAlignment ( JLabel . CENTER ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( unten , BorderLayout . CENTER ); return mainPanel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); // hat ActionEvent ausgeloest if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; System . out . println ( \"Minus-Button geklickt ... \" + this . anzKlicks ); } else if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; System . out . println ( \"Plus-Button geklickt ... \" + this . anzKlicks ); } this . unten . setText ( this . anzKlicks . toString ()); } } } Im vorangegangenen Kapitel haben wir gelernt, wie wir Grafische Nutzeroberfl\u00e4chen (GUI) erstellen k\u00f6nnen. Nun wollen wir uns anschauen, wie auf Ereignisse reagiert werden kann, die die Nutzerin auf dieser Grafischen Oberfl\u00e4che ausl\u00f6st. Wenn wir beispielsweise in unserem Taschenrechner auf einen Button klicken, dann soll entweder die Ziffer in dem Textfeld oben erscheinen oder es soll die Operation ausgef\u00fchrt werden, auf die wir geklickt haben. In grafischen Nutzeroberfl\u00e4chen gibt es nicht nur Buttons, auf deren Klick-Ereignisse wir reagieren wollen, es gibt auch Eingaben \u00fcber die Tastatur, das Fenster kann mit der Maus bewegt, vergr\u00f6\u00dfert oder verkleinert werden, es k\u00f6nnen Kontextdialoge durch das Dr\u00fccken der rechten Maustaste ge\u00f6ffnet werden usw. Wir lernen hier, welche unterschiedlichen Ereignisse es gibt und wie wir diese behandeln k\u00f6nnen, d.h. wie wir die Reaktion auf diese Ereignisse implementieren. Zun\u00e4chst \u00fcberlegen wir uns, wie es \u00fcberhaupt m\u00f6glich sein kann, dass Ereignisse (also Aktionen der Nutzerin) auf unserer grafischen Oberfl\u00e4che erkannt werden und auf diese Ereignisse entsprechend reagiert werden kann. Man k\u00f6nnte (in einer Schleife) permanent bei der Maus oder der Tastatur anfragen, ob eine Taste gedr\u00fcckt oder ob die Maus bewegt wurde. Das ist aber viel zu imperformant und w\u00fcrde das Programm blockieren. Diese Aufgabe wird n\u00e4mlich von der Laufzeitumgebung automatisch \u00fcbernommen. Im Hintergrund geschieht genau so etwas, aber wir m\u00fcssen uns gar nicht darum k\u00fcmmern. Wenn z.B. eine Maustaste gedr\u00fcckt wird, dann wird im Hintergrund durch die Laufzeitumgebung eine bestimmte Methode aufgerufen ( mouseClicked() ). Woher wissen wir, wie diese Methode hei\u00dft? Die Antwort sind nat\u00fcrlich: Interfaces !","title":"Ereignisse"},{"location":"ereignisse/#interfaces-fur-ereignisse-listener","text":"Die Idee ist die Folgende: Komponenten k\u00f6nnen unterschiedliche Ereignisse empfangen (Button angeklickt, Text eingegeben, Maus bewegt, Fenster geschlossen, ...). Die Anwendung registriert einen sogenannten Listener (ein Listener -Objekt) bei der Komponente f\u00fcr Ereignisse von Interesse. Tritt ein Ereignis, f\u00fcr das man sich beim Listener angemeldet hat, an der Komponente ein, wird eine bestimmte Methode am Listener-Objekt aufgerufen. Alle diese Methoden, die durch die Laufzeitumgebung f\u00fcr bestimmte Ereignisse aufgerufen werden k\u00f6nnen, sind in Interfaces definiert. Es gibt unterschiedliche Interfaces , die man implementieren muss, je nach den Ereignissen, auf die man reagieren m\u00f6chte (Mausereignisse, Tastaturereigniss, Ereignisse am Fenster, ...). Das Vorgehen kann man sich wie in der Abbildung gezeigt vorstellen: Der Listener lauscht permanent auf Ereignisse. Sobald ein Ereignis aufritt, auf das der Listener lauscht, ruft er eine entsprechende Methode auf. Damit wir im Programm auf dieses Ereignis reagieren k\u00f6nnen (die Ereignisbehandlung implementieren), m\u00fcssen wir zwei Dinge tun: uns an dem Listener anmelden, der auf die Ereignisse lauscht, die uns interessieren (die wir behandeln wollen) und die Ereignisbehandlung in der vom Listener aufgerufenen Methode implementieren. Die Methoden, die wir implementieren sind abstrakt in Interfaces festgelegt. Das bedeutet also, dass wir f\u00fcr die Ereignisbehandlung Interfaces implementieren.","title":"Interfaces f\u00fcr Ereignisse - Listener"},{"location":"ereignisse/#erstes-beispiel-actionlistener","text":"Wir starten mit einem ersten Beispiel. Dazu haben wir uns folgende GUI erstellt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.awt.BorderLayout ; import java.awt.Font ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); JLabel unten = new JLabel ( \"0\" ); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } } Die Ausf\u00fchrung des Programms zeigt folgendes kleines Fenster: Es soll nun implementiert werden, dass sich durch einen Klick auf den Button die dargestellte Zahl um 1 erh\u00f6ht. Die Methode, die ausgel\u00f6st wird, wenn ein Button geklickt wird, hei\u00dft actionPerformed() . Diese ist in dem Interface ActionListener implementiert. Wir m\u00fcssen nun also das Interface ActionListener implementieren und uns beim ActionListener anmelden.","title":"Erstes Beispiel ActionListener"},{"location":"ereignisse/#das-interface-actionlistener-implementieren","text":"Interfaces implementieren k\u00f6nnen wir bereits - mithilfe von implements : Wir schreiben also: public class Ereignisbehandlung extends JFrame implements ActionListener . Das Interface ActionListener muss aus dem java.awt.event -Paket importiert werden. Wir klicken auf Add unimplemented methods und in der Klasse erscheint die folgende Methode: @Override public void actionPerformed ( ActionEvent e ) { // TODO Auto-generated method stub } Das Interface ActionListener enth\u00e4lt also nur genau eine Methode, die implmentiert werden muss. Dieser Methode wird ein ActionEvent als Parameter \u00fcbergeben. Diese Klasse muss ebenfalls aus dem java.awt.event -Paket importiert werden. Wenn unser Button gedr\u00fcckt wird, dann wird also \"automatisch\" (durch die Laufzeitumgebung) die Methode actionPerformed() aufgerufen. Alles, was passieren soll, wenn der Button geklickt wird, m\u00fcssen wir in dieser Methode implementieren. Wir beginnen mit einer ganz einfachen Implementierung, mit einer simplen Ausgabe auf die Konsole: @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); } Wenn wir nun auf den Button klicken, passiert aber noch nichts, denn wir m\u00fcssen den Button noch am ActionListener anmelden (siehe oben Punkt 2 in der Liste).","title":"Das Interface ActionListener implementieren"},{"location":"ereignisse/#am-actionlistener-anmelden","text":"Damit das Klick-Ereignis auf den Button auch so behandelt wird, wie wir das in der actionPerformed() -Methode definiert haben, m\u00fcssen wir diesen Button an den ActionListener anmelden. Dazu existiert f\u00fcr einen JButton (f\u00fcr alle Komponenten JComponent ) die Methode addActionListener(ActionListener l) . Dieser Methode muss nun ein ActionListener -Objekt \u00fcbergeben werden, also ein Objekt, das das Interface ActionListener implementiert hat. Da wir den ActionListener in unserer Fensterklasse implementiert haben, ist das Fenster ein solches Objekt, das den ActionListener implementiert hat. Wir verwenden also this . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); oben . addActionListener ( this ); JLabel unten = new JLabel ( \"0\" ); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); } } Jedes mal, wenn wir nun auf den Button klicken, wird eine Ausgabe auf der Konsole erzeugt. Nach 5 Klicks also Button gedrueckt! Button gedrueckt! Button gedrueckt! Button gedrueckt! Button gedrueckt! Wir haben das erste Ereignis behandelt, das durch eine Nutzerinnenaktion ausgel\u00f6st wurde - das Klicken eines Buttons!","title":"Am ActionListener anmelden"},{"location":"ereignisse/#zugriff-auf-komponenten-in-actionperformed","text":"Wenn wir nun aber die actionPerformed() -Methode so implementieren wollen, dass sich der Text des JLabel s unten \u00e4ndert, dann stellen wir fest, dass wir in actionPerformed() ja gar keinen Zugriff auf dieses JLabel haben, weil die Referenz darauf nur eine lokale Variable in der init() -Methode ist. Um in allen Methoden der Klasse Ereignisbehandlung Zugriff auf dieses JLabel zu erlangen, m\u00fcssen wir es global deklarieren (als Objektvariable der Klasse Ereignisbehandlung ). Zus\u00e4tzlich erzeugen wir eine weitere Variable, die die Anzahl der bisherigen Klicks mitz\u00e4hlt, um diesen Wert dann im JLabel darzustellen. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JButton oben = new JButton ( \"Klick mich\" ); oben . addActionListener ( this ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { System . out . println ( \"Button gedrueckt!\" ); this . anzKlicks ++ ; this . unten . setText ( this . anzKlicks . toString ()); } } Nun \u00e4ndert sich mit jedem Button-Klick der angezeigte Wert.","title":"Zugriff auf Komponenten in actionPerformed()"},{"location":"ereignisse/#mehrere-buttons-actionevent","text":"Wir \u00e4ndern unsere GUI, indem wir die init() -Methode \u00e4ndern: 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } Die GUI sieht dadurch nun so aus: Das hei\u00dft, wir haben zwei Buttons und wollen f\u00fcr diese Buttons das Klick-Ereignis unterschiedlich behandeln. Bei Klick auf den - -Button soll der Wert der Zahl dekrementiert werden, bei Klick auf den + -Button inkrementiert. Wir m\u00fcssen nun also innerhalb der actionPerformed() -Methode unterscheiden, welcher Button gedr\u00fcckt wurde, d.h. durch welchen Button das ActionEvent ausgel\u00f6st wurde, welches wir behandeln. Dabei hilft uns das ActionEvent -Objekt, das der actionPerformed(ActionEvent e) -Methode \u00fcbergeben wird. Die Klasse ActionEvent hat einige n\u00fctzliche Methoden. Wir verwenden jetzt zun\u00e4chst eine Methode, die die Klasse ActionEvent von der Klasse EventObject geerbt hat, die getSource() -Methode: 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } Die getSource() -Methode von ActionEvent liefert die Komponente (als Object ) zur\u00fcck, die das ActionEvent ausgel\u00f6st hat. Damit wir Objektmethoden (z.B. getText() - Zeilen 55 und 59 ) von JButton verwenden k\u00f6nnen, m\u00fcssen wir dieses Object nach JButton konvertieren (Zeile 54 ). Damit dies gelingt, m\u00fcssen wir zun\u00e4chst pr\u00fcfen, ob es sich bei der ausl\u00f6senden Komponente tats\u00e4chlich um einen JButton handelt. Das erledigen wir hier mit dem instanceof -Operator in Zeile 52 . Mithilfe der getText() -Methoden erfragen wir den Text, der auf den Buttons steht. Wir vergleichen diesen mithilfe der equals() -Methode und k\u00f6nnen somit unterscheiden, ob das ActionEvent durch den + - oder den - -Button ausgel\u00f6st wurde. Wir d\u00fcrfen nicht vergessen , die beiden Buttons an den ActionListener anzumelden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . addActionListener ( this ); plus . addActionListener ( this ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getText (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getText (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } } Nun haben wir f\u00fcr die beiden Buttons eine unterschiedliche Ereignisbehandlung realisiert. bis hier Selbstudium","title":"Mehrere Buttons - ActionEvent"},{"location":"ereignisse/#actioncommand","text":"Die Abfrage des Textes auf den Buttons zur Unterscheidung der Buttons ist nicht clean code . Das hat mehrere Gr\u00fcnde: GUIs werden h\u00e4ufig f\u00fcr mehrere Sprachen zur Verf\u00fcgung gestellt. Je nach Einstellungen in den Konfigurationen kann die \"angezeigte\" Sprache der GUI ver\u00e4ndert werden. Somit w\u00fcrden auch die Buttons ihre Beschriftung \u00e4ndern und man m\u00fcsste in der actionPerformed() -Methode viele Varianten f\u00fcr die Textabfrage hinzuf\u00fcgen. Buttons k\u00f6nnen auch einfach nur Icons enthalten, d.h. gar keinen Text. Der auf Buttons angezeigte Text kann sehr \"kryptisch\" sein, also irgendwelche Sonderzeichen oder Schriftzeichen enthalten. Es kann z.B. auch HTML -Code sein. Das alles macht die Abfrage des Textes und insbesondere den Vergleich kompliziert bis gar unm\u00f6glich. Deshalb sollte man stattdessen besser das ActionCommand abfragen. Das ActionCommand wird mithilfe der setActionCommand(String command) -Methode gesetzt und mithilfe der getActionCommand() -Methode abgefragt. Wenn f\u00fcr einen Button nicht mithilfe der setActionCommand() -Methode ein ActionCommand definiert wurde, dann entspricht das ActionCommand dem Text auf dem Button. Das bedeutet, dass die getActionCommand() -Methode trotzdem verwendet werden k\u00f6nnte. Wir br\u00e4uchten also nur in der actionPerformed() -Methode getText() durch getActionCommand() ersetzen und h\u00e4tten das gleiche Ergebnis: 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"+\" )) { this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"-\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } Wenn wir allerdings eigene (andere) ActionCommands f\u00fcr die Buttons setzen, dann m\u00fcssen wir auch den Vergleich anpassen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame implements ActionListener { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . setActionCommand ( \"minus\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( this ); plus . addActionListener ( this ); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { this . anzKlicks -- ; } } this . unten . setText ( this . anzKlicks . toString ()); } } Success Wir kennen nun das Konzept, das hinter der Behandlung von Ereignissen steckt. Wir melden die Komponente, f\u00fcr die wir eine Ereignisbehandlung f\u00fcr ein Ereignis implementieren wollen, an den entsprechenden Listener an und wir implementieren das zugeh\u00f6rige Interface. Wir haben Buttons erfolgreich an den ActionListener angemeldet und das ActionListener -Interface implementiert. Dieses Interface enth\u00e4lt nur genau eine Methode, actionPerformed() . Wir k\u00f6nnen in dieser Methode auch bereits ermitteln, welche Komponente das ActionEvent ausgel\u00f6st hat, das gerade behandelt wird. Dadurch k\u00f6nnen wir in derselben actionPerformed() -Methode die (unterschiedliche) Ereignisbehandlung f\u00fcr mehrere Buttons implementieren. Damit k\u00f6nnen wir nun schonmal einen funktionsf\u00e4higen Taschenrechner bauen! Der L\u00f6sung f\u00fcr Aufgabe 9 steht nichts mehr im Wege!","title":"ActionCommand"},{"location":"ereignisse/#innere-klassen","text":"Mit der Implementierung des ActionListener hat alles geklappt und funktional ist auch alles in Ordnung, aber so richtig sch\u00f6n ist es nicht - kein clean code . Daf\u00fcr gibt es mehrere Gr\u00fcnde: Unsere Klasse verst\u00f6\u00dft auf jeden Fall gegen das Single Responsibility Principle ( SRP ). Unsere Klasse ist einerseits ein Fenster und andererseits k\u00fcmmern wir uns in der Klasse auch um Funktionalit\u00e4ten. Bei der Erstellung von Anwendungen mit grafischen Nutzeroberfl\u00e4chen hat sich sogar eine Dreiteilung etabliert, das sogenannte Model-View-Controller-Pattern . Darin ist die Darstellung der GUI die View , das Verwalten und Manipulieren der Daten das Model und die Steuerung mittels Nutzeraktionen der Controller . Langfristig streben wir eine solche Dreiteilung ebenfalls an. Wenn wir sehr viele Buttons (und sp\u00e4ter auch noch Textfelder, Men\u00fcs usw.) haben, dann kann die actionPerformed() -Methode schon allein dadurch sehr lang werden, dass wir viele Fallunterscheidungen ben\u00f6tigen, um zu ermitteln, welche Komponente das ActionEvent \u00fcberhaupt ausgel\u00f6st hat. Wenn dann jeweils noch viel Funktionalit\u00e4t hinzukommt, wird die actionPerformed() -Methode viel zu lang. Wir haben bis jetzt nur ein einziges Interface, das ActionListener -Interface, implementiert und dieses enth\u00e4lt auch nur eine einzige Methode. Wenn wir nun auch noch auf Maus-, Mausbewegungs-, Tastatur- und Fenstereignisse reagieren wollen, dann implementieren wir mindestens vier weitere Interfaces, die jeweils bis zu sechs Methoden enthalten. Unsere Klasse w\u00fcrde sehr lang werden. Wir ben\u00f6tigen Ideen, wie wir diese Konflikte aufl\u00f6sen k\u00f6nnen. Dazu ben\u00f6tigen wir neue Strukturierungsm\u00f6glichkeiten. Ein erster Schritt dahin sind Innere Klassen . Wir betrachten Innere Klassen aber nur als einen Zwischenschritt hin zu anonymen Klassen . Wir werden uns ansonsten nicht weiter mit inneren Klassen auseinandersetzen.","title":"Innere Klassen"},{"location":"ereignisse/#begriffsbestimmung","text":"Prinzipiell handelt es sich bei inneren Klassen um Klassen in einer Klasse. Der Oberbegriff f\u00fcr eine Klasse in einer Klasse ist nested class . In nested classes unterscheidet man zwischen statischen und nicht-statischen Klassen. Die nicht-statischen nested Klassen (also Klassen, wie wir sie bisher kennen - wir kennen noch gar keine statischen Klassen) hei\u00dfen innere Klassen . Wir wollen uns gar nicht mit statischen verschachtelten Klassen auseinandersetzen. Es sei an dieser Stelle aber der wesentliche Unterschied zwischen den statischen und den nicht-statischen verschachtelten Klassen genannt: nicht-statische Klassen (also innere Klassen) haben Zugriff auf die Eigenschaften der \u00e4u\u00dferen Klasse, statische verschachtelte Klassen haben diesen Zugriff nicht. Wenn wir schon bei Sachen sind, die uns nicht interessieren ;-) : sogenannte lokale Klassen sind Klassen in einer Methode. Innere Klassen sind aber n\u00fctzlich und sinnvoll. Wir kennen auch schon eine, n\u00e4mlich Map.Entry - die Klasse Entry ist eine innere Klasse von Map (ganz exakt handelt es sich bei beiden nicht um Klassen, sondern um Interfaces, das macht hier aber keinen Unterschied). In der Klasse Integer gibt es \u00fcbrigens auch eine innere Klasse. Die fungiert als ein Cache f\u00fcr h\u00e4ufig verwendete Zahlen. Wenn Sie ein Integer -Objekt mit einem Wert kleiner als 128 erstellen, dann kommt dieses Objekt in den Cache und wenn Sie ein weiteres Objekt mit dem gleichen Wert erzeugen, dann wird daf\u00fcr einfach das Objekt aus dem Cache verwendet. Das f\u00fchrt zu diesem \"komischen\" Verhalten: Integer i1 = Integer . valueOf ( 1001 ); Integer i2 = Integer . valueOf ( 1001 ); Integer i3 = Integer . valueOf ( 101 ); Integer i4 = Integer . valueOf ( 101 ); System . out . println ( i1 == i2 ); // false System . out . println ( i3 == i4 ); // true Der erste Vergleich ist false , weil es sich bei i1 und i2 um Referenzen auf zwei verschiedene Objekte handelt. Der zweite Vergleich ist aber true , weil es sich bei i3 und i4 um Referenzen auf dasselbe Objekt (aus dem Cache) handelt. Aber das nur nebenbei, um zu erl\u00e4utern, dass es sinnvolle Verwendungen f\u00fcr innere Klassen gibt.","title":"Begriffsbestimmung"},{"location":"ereignisse/#ereignisbehandlung-mit-innerer-klasse","text":"Wir verwenden unsere Klasse Ereignisbehandlung von oben. Aber wir lagern die eigentliche Behandlung des ActionEvent s in eine innere Klasse aus. Das hei\u00dft, wir trennen die Erstellung der GUI und die Behandlung der Ereignisse strukturell, in dem diese Dinge in zwei unterschiedlichen Klassen implementiert sind. Da es sich aber um die Ereignisbehandlung f\u00fcr genau die erstellte GUI handelt, ergibt es wenig Sinn, diese in eine \"normale\" top-level-Klasse zu \u00fcberf\u00fchren. Deshalb verwenden wir daf\u00fcr eine innere Klasse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.* ; public class Ereignisbehandlung extends JFrame { JLabel unten ; Integer anzKlicks = 0 ; public Ereignisbehandlung () { super (); setTitle ( \"Ereignisbehandlung\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = init (); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); setSize ( 200 , 150 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); JButton minus = new JButton ( \"-\" ); JButton plus = new JButton ( \"+\" ); minus . setActionCommand ( \"minus\" ); plus . setActionCommand ( \"plus\" ); minus . addActionListener ( new ActionHandler ()); plus . addActionListener ( new ActionHandler ()); oben . add ( minus ); oben . add ( plus ); this . unten = new JLabel ( this . anzKlicks . toString ()); unten . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); unten . setHorizontalAlignment ( JLabel . CENTER ); panel . add ( oben , BorderLayout . NORTH ); panel . add ( unten , BorderLayout . CENTER ); return panel ; } public static void main ( String [] args ) { new Ereignisbehandlung (); } class ActionHandler implements ActionListener { @Override public void actionPerformed ( ActionEvent e ) { Object quelle = e . getSource (); if ( quelle instanceof JButton ) { JButton button = ( JButton ) quelle ; if ( button . getActionCommand (). equals ( \"plus\" )) { Ereignisbehandlung . this . anzKlicks ++ ; } else if ( button . getActionCommand (). equals ( \"minus\" )) { Ereignisbehandlung . this . anzKlicks -- ; } } Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } } } So viel hat sich gar nicht ge\u00e4ndert: Die Klasse Ereignisbehandlung implementiert jetzt nicht mehr selbst das Interface ActionListener (Zeile 8 ). Das hat jetzt die neue (innere) Klasse ActionHandler \u00fcbernommen (Zeile 54 ). Da der ActionListener nun nicht mehr in Ereignisbehandlung implementiert ist, sondern in ActionHandler , muss beim Anmelden an den ActionListener nun nicht mehr das this -Objekt, sondern ein Objekt von ActionHandler \u00fcbergeben werden (Zeilen 34 und 35 ). Da sich die Methode actionPerformed() nun in der Klasse ActionHandler befindet, handelt es sich dort bei der this -referenz um eine Referenz auf ein ActionHandler -Objekt. Wir k\u00f6nnen also nicht mehr einfach this.anzKlicks++; schreiben, da es sich bei anzKlicks ja nicht um eine Eigenschaft der ActionHandler -Klasse, sondern um eine Eigenschaft der Ereignisbehandlung -Klasse handelt. Das Gleiche gilt auch f\u00fcr das JLabel unten (Zeilen 65 , 69 und 72 ). Um auf die Eigenschaften der \u00e4u\u00dferen Klasse zuzugreifen, kann in der inneren Klasse \u00fcber den Klassennamen der \u00e4u\u00dferen Klasse auf die Eigenschaften der \u00e4u\u00dferen Klasse referenziert werden. Das hei\u00dft, wenn die \u00e4u\u00dfere Klasse AeussereKlasse hei\u00dft und eine Eigenschaft eigenschaft_AeK hat, dann kann aus der inneren Klasse heraus wie folgt auf diese Eigenschaft zugegriffen werden: AeussereKlasse.this.eigenschaft_AeK In unserem Fall bedeutet das, dass wir nun \u00fcber Ereignisbehandlung.this.anzKlicks++; und Ereignisbehandlung.this.anzKlicks--; den Wert der Eigenschaft anzKlicks der \u00e4u\u00dferen Klasse Ereignisbehandlung \u00e4ndern k\u00f6nnen (Zeilen 65 und 69 ). Um auf das JPanel unten aus der inneren Eigenschaft zugreifen zu k\u00f6nnen, schreiben wir deshalb Ereignisbehandlung.this.unten (Zeile 72 ). Beachten Sie, dass das this darin notwendig ist. Wenn wir schreiben w\u00fcrden Ereignisbehandlung . anzKlicks ++ ; , dann w\u00fcrde das bedeuten, dass es sich bei anzKlicks um eine statische (Klassen-)Variable handeln w\u00fcrde. Um auf (nicht-statische) Objektvariablen zuzugreifen, verwenden wir in der Klasse ja die Referenz this und um also auf die Objektvariablen der \u00e4u\u00dferen Klasse zuzugreifen, schreiben wir Ereignisbehandlung . this . anzKlicks ++ ; Dasselbe gilt f\u00fcr Methoden. Wir haben nun immerhin die Verantwortlichkeiten zur Erstellung der GUI und zur Behandlung der Ereignisse in zwei verschiedene Klassen aufgeteilt. Das Single Responsibility Principle ist somit erf\u00fcllt. Das ist schonmal gut! Wir haben aber eingangs erw\u00e4hnt, dass wir uns die inneren Klassen nur als ein Zwischenschritt anschauen. Dazu \u00fcberlegen wir uns nochmal Folgendes: Wir haben f\u00fcr die Ereignisbehandlung eine eigene Klasse ActionHandler geschrieben. Um sich an den ActionListener anzumelden, wurde der addActionListener() -Methode daf\u00fcr ein Objekt von ActionHandler \u00fcbergeben (siehe oben die Zeilen 34 und 35 ). Nun machen wir etwas Verr\u00fccktes ;-) : wir \u00fcbergeben der addActionListener() -Methode auch wieder ein Objekt, in dem wir den ActionListener implementiert haben (implementieren), aber diese Implementierung erfolgt nicht in einer separaten Klasse, die einen Namen hat ( ActionHandler ), sondern die Implementierung erfolgt direkt dort, wo das Objekt \u00fcbergeben wird, daf\u00fcr ohne einen Klassennamen - eine anonyme Klasse.","title":"Ereignisbehandlung mit innerer Klasse"},{"location":"ereignisse/#ereignisbehandlung-mit-anonymer-klasse","text":"Jede Komponente, f\u00fcr die auf das ActionEvent reagiert werden soll, muss an den ActionListener mithilfe der addActionListener() -Methode angemeldet werden. Dieser Methode wird ein Objekt \u00fcbergeben, in dem der ActionListener implementiert ist. Wir implementieren jetzt direkt dort, wo wir das Objekt \u00fcbergeben, genau diese Klasse, geben ihr aber keinen Namen. Stattdessen geben wir ActionListener wie einen Konstruktor an, obwohl es sich bei ActionListener um ein Interface handelt, welches erstens keinen Konstruktor besitzt und zweitens von dem gar kein Objekt erzeugt werden kann. Wir schauen uns das am Beispiel des - -Buttons an: 1 2 3 4 5 6 7 8 9 minus . addActionListener ( new ActionListener () { // Objekt einer anonymen Klasse @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); Wir \u00fcbergeben der addActionListener() -Methode ein Objekt einer anonymen Klasse. Diese anonyme Klasse implementiert das ActionListener -Interface. Zun\u00e4chst gehen wir nochmal einen Schritt zur\u00fcck und schauen uns die Varianten an, die wir davor hatten: minus . addActionListener ( this ); // ActionListener war in der Fenster-Klasse implementiert minus . addActionListener ( new ActionHandler ()); // ActionListener war in der inneren Klasse ActionHandler implementiert Nun implementieren wir das ActionListener -Interface direkt \"vor Ort\" - dort, wo es auch \u00fcbergeben wird. Der Aufruf der addActionListener() -Methode ist \u00fcbrigens noch exakt der gleiche 1 2 3 4 5 6 7 8 9 minus . addActionListener ( ); , nur das \u00fcbergebene Objekt sieht etwas \"komisch\" aus: 1 2 3 4 5 6 7 8 9 new ActionListener () { // Objekt einer anonymen Klasse @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } } Wir erkennen aber den Klassenrumpf, der ganz normal mit einer geschweiften Klammer { in Zeile 1 ) beginnt und mit einer schlie\u00dfenden geschweiften Klammer } in Zeile 9 endet. Darin ist, auch ganz normal, die actionPerformed() -Methode implementiert, die ja implementiert werden muss, wenn das ActionListener -Interface implementiert wird. Innerhalb der Methode greifen wir auch, wie bei inneren Klassen \u00fcblich, auf die Objekteigenschaften der \u00e4u\u00dferen Klasse zu. Eigentlich ist nur dieser Ausdruck neu: new ActionListener() { } . Hier m\u00fcssen wir uns einfach merken, dass es sich dabei um drei Sachen hadelt, die zugleich passieren: Es wird das ActionListener -Interface implementiert. Dies geschieht \"ganz normal\" in einem Klassenrumpf, der mit { beginnt und mit } endet. Die Klasse, in der das Interface implemntiert wird, hat aber keinen Namen, deshalb schreiben wir auch nicht Klassenmane implements ActionListener , sondern nur ActionListener . Es wird ein Objekt erzeugt. Dazu wird, ganz normal, das Schl\u00fcsselwort new verwendet und ein Konstruktor - allerdings hier der Konstruktor einer Klasse, die keinen Namen hat. Da diese Klasse aber das ActionListener -Interface implementiert, kann dieser Name f\u00fcr den Konstruktor verwendet werden. Der gro\u00dfe Vorteil dieser Art der Implementierung des ActionListener -Interfaces liegt darin, dass jede Komponente ihre eigene Implementierung bekommt und dass es deshalb nicht notwendig ist, eine Fallunterscheidung zu treffen, welche Komponente das Ereignis ausgel\u00f6st hat. Hier kann es nur der minus -Button gewesen sein! Die beiden Implementierungen des ActionListener s mithilfe einer anonymen Klasse sehen so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks -- ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Ereignisbehandlung . this . anzKlicks ++ ; Ereignisbehandlung . this . unten . setText ( Ereignisbehandlung . this . anzKlicks . toString ()); } }); Den ActionListener mithilfe anonymer Klassen zu implementieren, ist ein Best Practice . In sehr vielen F\u00e4llen gewinnt man an \u00dcbersichtlichkeit. Wir werden im Rest des Semesters immer mal diskutieren, wann die Verwendung anonymer Klassen sinnvoll ist und wann nicht. Manchmal ist es aber auch nur Geschmackssache. F\u00fcr diejenigen, die sich f\u00fcr nested classes interessieren, sei dieser Link empfohlen.","title":"Ereignisbehandlung mit anonymer Klasse"},{"location":"exceptions/","text":"Exceptions \u00b6 Motivation Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt? Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. try-catch \u00b6 Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. Beispiel ohne try-catch \u00b6 Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. Beispiel mit try-catch \u00b6 Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an: Ablauf einer Ausnahmesituation \u00b6 Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird. Ein weiteres Beispiel \u00b6 Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigens k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet. Beispiel mit mehreren Exceptions \u00b6 Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wandeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an: Die Vererbungshierarchie der Klasse Exception \u00b6 Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen. try-catch-finally \u00b6 Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren. throws - eine Exception weiterreichen \u00b6 Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. Sch\u00f6ner Code \u00b6 Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. throw - eigene Exceptions erzeugen \u00b6 Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Triangle im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ). throw new IllegalArgumentException \u00b6 Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen. Eigene Exception-Klasse definieren \u00b6 Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"Motivation Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt? Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt.","title":"Exceptions"},{"location":"exceptions/#try-catch","text":"Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren.","title":"try-catch"},{"location":"exceptions/#beispiel-ohne-try-catch","text":"Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten.","title":"Beispiel ohne try-catch"},{"location":"exceptions/#beispiel-mit-try-catch","text":"Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:","title":"Beispiel mit try-catch"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","text":"Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird.","title":"Ablauf einer Ausnahmesituation"},{"location":"exceptions/#ein-weiteres-beispiel","text":"Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigens k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet.","title":"Ein weiteres Beispiel"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","text":"Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wandeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an:","title":"Beispiel mit mehreren Exceptions"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","text":"Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen.","title":"Die Vererbungshierarchie der Klasse Exception"},{"location":"exceptions/#try-catch-finally","text":"Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren.","title":"try-catch-finally"},{"location":"exceptions/#throws-eine-exception-weiterreichen","text":"Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln.","title":"throws - eine Exception weiterreichen"},{"location":"exceptions/#schoner-code","text":"Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an.","title":"Sch\u00f6ner Code"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","text":"Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Triangle im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ).","title":"throw - eigene Exceptions erzeugen"},{"location":"exceptions/#throw-new-illegalargumentexception","text":"Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.","title":"throw new IllegalArgumentException"},{"location":"exceptions/#eigene-exception-klasse-definieren","text":"Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Eigene Exception-Klasse definieren"},{"location":"graphics/","text":"Graphics \u00b6 Wir werden unsere GUI nun um eine Komponente erweitern, in der wir zeichnen k\u00f6nnen. Im Prinzip wird unsere GUI immer gezeichnet . Die Steuerelemente sind nur vorformatiert und bestehen aus lauter Linien, Polygonen und Punkten, die zusammen dann so, wie z.B. ein Button aussehen. Wenn wir eine GUI haben und dieses Fenster z.B. die Gr\u00f6\u00dfe \u00e4ndert, wird es dabei jedes Mal neu gezeichnet. Diese (Neu-)Zeichnen wird dadurch angesto\u00dfen, dass f\u00fcr unser JFrame die Methode paint() aufgerufen wird. Diese Methode wird z.B. auch in der Methode setVisible(true) aufgerufen. Jede Komponente (also jedes Steuerelement und jeder Container) hat ihre eigene Objektmethode paint() , in der beschrieben ist, wie diese Komponente zu zeichnen ist. Genauer gesagt, werden in paint() folgende drei Methoden aufgerufen: paintBorder() - zeichnet den Rahmen der Komponente paintChildren() - ruft paint() f\u00fcr alle Kindkomponenten auf (also z.B. alle Steurelemente in einem JPanel ) paintComponent() - zeichnet die Komponente (und ihre Kinder) Damit \u00fcberhaupt Linien und Punkte dargestellt werden k\u00f6nnen, gibt es eine Klasse Graphics , die, etwas vereinfacht gesagt, die Schnittstelle zwischen Hardware (dem Monitor) und dem zu zeichnenden Fenster darstellt. Alle Komponenten eines Fensters teilen sich genau ein Objekt dieser Klasse Graphics . Bei diesem Objekt wird auch vom Graphics-Context ( Grafikkontext ) gesprochen. Diese Klasse stellt eine Vielzahl von Methoden zur Verf\u00fcgung, um einfache geometrische Objekte zu zeichnen, z.B. drawLine() , um eine Linie zu zeichnen, drawOval() , um eine (leere) Ellipse zu zeichnen, drawRect() , um ein (leeres) Rechteck zu zeichnen, drawPolygon() , um ein (leeres) Polygon (also ein Vieleck) zu zeichnen, drawString() , um ein Text zu zeichnen, fillOval() , um eine (ausgef\u00fcllte) Ellipse zu zeichnen, fillRect() , um ein (ausgef\u00fclltes) Rechteck zu zeichnen, fillPolygon() , um ein (ausgef\u00fclltes) Polygon (also ein Vieleck) zu zeichnen. Damit nun alle paintX() -Methoden (also paint() , paintBorder() , paintComponent und paintChildren() ) Zugriff auf diesen Grafikkontext (das Objekt von Graphics ) bekommen, wird es diesen Methoden \u00fcbergeben. Das hei\u00dft, die Methoden sind so deklariert (alle void ): paint(Graphics g) paintBorder(Graphics g) paintChildren(Graphics g) paintComponent(Graphics g) Die Graphics -Klasse gibt es schon seit Java 1.0. Allerdings hat man bereits sehr fr\u00fch festgestellt, dass die Methoden in dieser Klasse nicht gen\u00fcgen, um \"sch\u00f6ne\" Grafiken zu erstellen. Deshalb hat man bereits in Java 1.1 eine neue Klasse Graphics2D eingef\u00fchrt (hat von Graphics geerbt), in der haupts\u00e4chlich die Darstellung der geometrischen Objekte verbessert wurde, aber in der auch einige Methoden dazukamen, um z.B. andere Linienformen (gestrichelt, gepunktet, ...) zu definieren, andere Fonts f\u00fcr den Text usw. Tats\u00e4chlich handelt es sich seit JDK 1.2 bei dem Grafikkontext, also dem Graphics -Objekt g um ein Objekt der Klasse Graphics2D . Eigene geometrische Objekte zeichnen \u00b6 Bevor wir eigene geometrische Objekte zeichnen k\u00f6nnen, schauen wir zun\u00e4chst nochmal auf unser \"Grundger\u00fcst\" f\u00fcr eine GUI (siehe Kapitel GUI Einf\u00fchrung ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . initContent ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); // hier weitere Container oder Steuerelemente hinzufuegen return mainPanel ; } public static void main ( String [] args ) { new MyFirstWindow (); } } Darin erzeugt die Methode initContent() ein JPanel und gibt es zur\u00fcck. Dieses JPanel wird der ContentPane unseres Fensters hinzugef\u00fcgt (Zeile 13 ). Somit hat das JFrame ein Kind , n\u00e4mlich das der ContentPane hinzugef\u00fcgte JPanel . Wenn das JFrame nun gezeichnet wird, wird f\u00fcr dieses JPanel die Methode paintComponent(Graphics g) aufgerufen. Diese ist f\u00fcr ein JPanel so implementiert, dass ein hellgraues Rechteck ohne Rand ( Border ) gezeichnet wird. W\u00fcrden wir dem mainPanel in der initContent() -Methode nun weitere Komponenten (Container oder Steuerlemente) hinzuf\u00fcgen, so w\u00fcrden diese alle so gezeichnet werden, wie f\u00fcr diese Komponenten die paintComponent(Graphics g) -Methode implementiert ist. Wir wollen nun aber selbst die paintComponent(Graphics g) -Methode f\u00fcr eine Komponente implementieren. Dazu entscheiden wir uns daf\u00fcr, die paintComponent() -Methode von einem JPanel zu implementieren. Aber wie kommen wir an diese Implementierung ran? Indem wir von JPanel erben . Wenn wir eine Klasse erstellen, die von JPanel erbt, dann erben wir auch die Implementierung der paintComponent() -Methode von JPanel und k\u00f6nnen diese \u00fcberschreiben . Wir \u00e4ndern daf\u00fcr unser \"Grundger\u00fcst\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstDrawingWindow extends JFrame { public MyFirstDrawingWindow () { super (); this . setTitle ( \"Wir zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new MyFirstDrawingWindow (); } } An der Darstellung des Fensters \u00e4ndert das zun\u00e4chst gar nichts. Wenn wir das Programm ausf\u00fchren, dann erscheint folgendes Fenster. Das der ContentPane hinzugef\u00fcgte JPanel wird also \"ganz normal\" als hellgraues Rechteck dargestellt. Der gro\u00dfe Unterschied ist, dass es sich nun um ein Objekt unserer inneren Klasse Canvas handelt. Diese hat von JPanel geerbt. Ein Objekt von Canvas ist somit auch ein Objekt vom Typ JPanel . Aber wir k\u00f6nnen in Canvas die Methode paintComponent(Graphics g) \u00fcberschreiben und somit eine eigene Implementierung f\u00fcr das Zeichnen unserer Komponente (einem Canvas -Objekt) erstellen. Innerhalb unserer eigenen Implementierung der paintComponent() -Methode rufen wir zun\u00e4chst die paintComponent() -Methode von JPanel auf. Damit wird ein hellgraues Rechteck gezeichnet. Das sollten wir immer tun, da ansonsten manchmal unsch\u00f6ne Nebeneffekte entstehen. Au\u00dferdem sollten wir auch immer das Graphics -Objekt nach Graphics2D konvertieren, da uns in Graphics2D deutlich mehr Methoden zur Verf\u00fcgung stehen (siehe z.B. hier und hier ). \u00dcbung Die Methode draw3DRect() ist ein Beispiel f\u00fcr eine Methode, die in der Graphics2D -Klasse implementiert ist, aber in der Klasse Graphics nicht vorkommt. 1. Warum funktioniert Graphics2D g2 = (Graphics2D)g; ? 2. Warum funktioniert g.draw3DRect() nicht, aber g2.draw3DRect() doch (wenn jeweils Parameterliste stimmt)? Erste geometrische Objekte \u00b6 Unser Fenster ist nun soweit vorbereitet und wir \u00fcberschreiben die paintComponent() -Methode in unserer Klasse Canvas . Nun k\u00f6nnen wir darin beliebige Grafiken einf\u00fcgen. Dazu rufen wir Methoden von Graphics2D auf. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar g2 . drawRect ( 40 , 30 , 200 , 200 ); g2 . drawOval ( 40 , 30 , 200 , 200 ); } Die Methode drawRect(int x, int y, int width, int height) zeichnet ein Rechteck mit der Breite width und der H\u00f6he height . Bei uns hat beides den Wert 200 und somit wird ein Quadrat gezeichnet. Die Werte x und y stehen f\u00fcr die Koordinaten des linken oberen Punktes des Rechtecks innerhalb des JPanel s, in dem wir zeichnen (also innerhalb der ContentPane ). Der linke obere Punkt des JPanel hat die Koordinaten (0,0) , also gehen wir in dem Beispiel um 40 Pixel nach rechts und um 30 Pixel nach unten, um mit dem Zeichnen des Quadrates zu beginnen. Die Methode drawOval(int x, int y, int width, int height) zeichnet eine Ellipse mit der Breite width und der H\u00f6he height . Bei uns hat beides den Wert 200 und somit wird ein Kreis gezeichnet. Die Werte x und y stehen f\u00fcr die Koordinaten des linken oberen Punktes des gedachten Tangenetenvierecks um die Ellipse. Der linke obere \"Startpunkt\" ist hier sowohl f\u00fcr den Kreis, als auch f\u00fcr das Quadrat der gleiche. Da auch H\u00f6he und Breite jeweils gleich sind, passen die geometrischen Objekte genau ineinander, d.h. das Quadrat beschreibt das Tangenetenviereck um den Kreis. Sie k\u00f6nnen nun gerne beliebig die Methoden aus Graphics2D ausprobieren. Es macht Spa\u00df! Gerne auch beliebige Muster, z.B. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar for ( int i = 0 ; i < 10 ; i ++ ) { g2 . drawOval ( 50 + i * 10 , 50 , 80 , 80 ); g2 . drawOval ( 50 + i * 10 , 150 , 80 , 180 ); } } Anstelle der \"vorgefertigten\" Methoden f\u00fcr das Zeichnen von Rechtecken ( drawRect() ) und Ellipsen ( drawOval() ), k\u00f6nnen Sie auch immer erst entsprechende Objekte erzeugen und diese mithilfe der draw() -Methode zeichnen lassen, z.B. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar Shape rectangle = new Rectangle2D . Double ( 40.0 , 30.0 , 200.0 , 200.0 ); Shape circle = new Ellipse2D . Double ( 40.0 , 30.0 , 200.0 , 200.0 ); g2 . draw ( rectangle ); g2 . draw ( circle ); } Das Interface Shape ist aus dem java.awt -Paket und die geometrischen Objekte sind aus dem java.awt.geom -Paket. Der Vorteil ist, dass f\u00fcr die geometrischen Objekte selbst viele Methoden existieren, um z.B. die Eigenschaften dieser Objekte abzufragen (z.B. H\u00f6he oder Breite). Es gibt viele solcher Klassen - siehe dazu Shape und darin All Known Implementing Classes . Ein Kreisbogen kann z.B. mithilfe der Klassen Arc2D.Double oder Arc2D.Float gezeichnet werden. Ein Kreisbogen ist ein Teil einer Ellipse. Die Konstruktoren erwarten jeweils 7 Parameter (gibt auch jeweils noch andere Konstruktoren): x , x-Wert der linken oberen Ecke des Tangentenvierecks um die (gesamte) Ellipse, y , y-Wert der linken oberen Ecke des Tangentenvierecks um die (gesamte) Ellipse, width , Breite der (gesamten) Ellipse, height , H\u00f6he der (gesamten) Ellipse, start , Startpunkt des Kreisbogens in Grad (0 ist \"3 Uhr\", 90 ist \"12 Uhr\", 180 ist \"9 Uhr\", 270 ist \"6 Uhr\"), extent , L\u00e4nge des Kreisbogens in Grad (90 ist Viertelkreis, 180 ist Halbkreis, positiver Wert \"gegen die Uhr\", negativer Wert \"mit der Uhr\"), type , Auswahl zwischen Arc2D.OPEN , Arc2D.PIE und Arc2D.CHORD , siehe Abbildung. Beispiele paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar Shape arc1 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 180.0 , 90.0 , Arc2D . OPEN ); Shape arc2 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 180.0 , - 90.0 , Arc2D . OPEN ); Shape arc3 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 20.0 , 45.0 , Arc2D . PIE ); Shape arc4 = new Arc2D . Double ( 60.0 , 63.0 , 180.0 , 180.0 , 0.0 , - 180.0 , Arc2D . PIE ); g2 . setStroke ( new BasicStroke ( 4.0f )); // dickere Linie g2 . draw ( arc1 ); g2 . setColor ( Color . RED ); // Zeichenfarbe rot g2 . draw ( arc2 ); g2 . setColor ( Color . BLUE ); g2 . draw ( arc3 ); g2 . setColor ( Color . GREEN ); g2 . draw ( arc4 ); } \u00dcbung Erstellen Sie folgende Zeichnung: Um die geometrischen Objekte gef\u00fcllt darzustellen, verwenden Sie anstelle von draw(Shape s) die fill(Shape s) -Methode. Linien \u00b6 Die Linienart setzen Sie mithilfe der Methode g2.setStroke(Stroke s) . Das Interface Stroke wird von der Klasse BasicStroke implementiert (Beides aus dem java.awt -Paket). Das bedeutet, der Methode setStroke() wird ein BasicStroke -Objekt \u00fcbergeben. Die Klasse BasicStroke besitzt folgende Konstruktoren: BasicStroke() BasicStroke(float width) BasicStroke(float width, int cap, int join) BasicStroke(float width, int cap, int join, float miterlimit) BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float dash_phase) Dabei gibt - width die Linienst\u00e4rke als float an, z.B. new BasicStroke(4.0f) , - cap beschreibt die Enden einer Linie. Es stehen drei vordefinierte Konstanten zur Verf\u00fcgung: CAP_BUTT , CAP_ROUND und CAP_SQUARE Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 50 , 200 , 50 ); g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_ROUND , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 100 , 200 , 100 ); g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_SQUARE , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 150 , 200 , 150 ); } ergibt: Die Eigenschaft join von BasicStroke gibt an, wie sich zwei Linien an den Endpunkten verbinden. Es gibt die drei vordefinierten Konstanten JOIN_BEVEL , JOIN_MITER und JOIN_ROUND . Die Unterscheidung zeigt am besten die folgende Grafik: Mit dem join von Linien hat auch miterlimit zu tun. Es muss gr\u00f6\u00dfer gleich 1.0f sein und ist nur f\u00fcr JOIN_MITER von Bedeutung. Mit dash kann ein float[] f\u00fcr ein Muster des Strichelns der Linie angegeben werden. Mit dash_phase kann angegeben werden, nach welcher Verz\u00f6gerung die Anwendung des dash -Musters erfolgt. Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar float [] dash1 = { 20.0f }; float [] dash2 = { 20.0f , 40.0f }; g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash1 , 0.0f )); g2 . drawLine ( 30 , 50 , 350 , 50 ); g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash2 , 0.0f )); g2 . drawLine ( 30 , 100 , 350 , 100 ); g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash1 , 10.0f )); g2 . drawLine ( 30 , 150 , 350 , 150 ); } ergibt: Farben \u00b6 Das Java-Farbmodell basiert auf dem RGB-Farbmodell , wobei jede Farbe durch 24Bit repr\u00e4sentiert wird ( 24Bit Farbtiefe ). Das bedeutet, dass f\u00fcr jeden Farbanteil von Rot, Gr\u00fcn, Blau jeweils 8Bit zur Verf\u00fcgung stehen und die einzelnen Farbanteile somit einen Wert zwischen 0 und 255 annehmen k\u00f6nnen. Einige Farben und deren Farbanteile von Rot, Gr\u00fcn und Blau sind in der folgenden Tabelle dargestellt: Farbe Rot-Anteil Gr\u00fcn-Anteil Blau-Anteil Wei\u00df 255 255 255 Schwarz 0 0 0 Grau 127 127 127 Rot 255 0 0 Gr\u00fcn 0 255 0 Blau 0 0 255 Gelb 255 255 0 Magenta 255 0 255 Cyan 0 255 255 Die Klasse Color aus dem java.awt -Paket besitzt sieben Konstruktoren. Die wichtigsten sind public Color(int r, int g, int b) , mit den int -Werten jeweils von 0 bis 255 f\u00fcr die Farbanteile, public Color(float r, float g, float b) , mit den float -Werten jeweils von 0.0f bis 1.0f f\u00fcr die Farbanteile, und die Pendants mit einem zus\u00e4tzlichen Alpha-Anteil f\u00fcr die Transparenz: public Color(int r, int g, int b, int alpha) , 0 bis 255 ( 0 vollst\u00e4ndig transparent, 255 deckend), public Color(float r, float g, float b, float alpha) , 0.0f bis 1.0f ( 0 vollst\u00e4ndig transparent, 1.0 deckend). In Color sind dar\u00fcber hinaus folgende Farben als statische Konstanten definiert: WHITE , BLACK , BLUE , CYAN , DARKGRAY , GRAY , GREEN , LIGHTGRAY , MAGENTA , ORANGE , PINK , RED , YELLOW Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int diffX = 200 ; int diffY = 130 ; Color color ; color = new Color ( 205 , 107 , 117 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 , 50 , 150 , 100 ); color = new Color ( 205 , 107 , 117 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . WHITE ); g2 . fillRect ( 50 , 50 + 2 * diffY , 150 , 100 ); color = new Color ( 100 , 255 , 100 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 + diffX , 50 , 150 , 100 ); color = new Color ( 100 , 255 , 100 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 + diffX , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . GREEN ); g2 . fillRect ( 50 + diffX , 50 + 2 * diffY , 150 , 100 ); color = new Color ( 100 , 100 , 255 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 + 2 * diffX , 50 , 150 , 100 ); color = new Color ( 100 , 100 , 255 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 + 2 * diffX , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . BLUE ); g2 . fillRect ( 50 + 2 * diffX , 50 + 2 * diffY , 150 , 100 ); } ergibt: Mit den Klassen LinearGradientPaint und GradientPaint k\u00f6nnen Farbverl\u00e4ufe implementiert werden. Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar GradientPaint gp = new GradientPaint ( 0 , 0 , Color . RED , 300 , 100 , Color . WHITE ); g2 . setPaint ( gp ); g2 . fillRect ( 50 , 50 , 300 , 100 ); } ergibt: H\u00f6he und Breite abh\u00e4ngig von der Canvas-Gr\u00f6\u00dfe \u00b6 Angenommen, Sie wollen eine geometrischen Figur so zeichnen, dass sich ihre Gr\u00f6\u00dfe der Gr\u00f6\u00dfe des Fensters anpasst. Dazu stehen Ihnen die Methoden getHeight() und getWidth() von JPanel (und somit von Ihrem Canvas -Objekt) zur Verf\u00fcgung. Die linke obere Ecke des JPanels hat die Koordinaten [x=0, y=0] und die rechte untere Ecke hat die Koordinaten [x=this.getWidth(), y= this.getHeight()] , d.h f\u00fcr den linken Rand gilt x = 0 , f\u00fcr den rechten Rand gilt x = this.width() , f\u00fcr den oberen Rand gilt y = 0 und f\u00fcr den unteren Rand gilt y = this.height() . Angenommen, wir wollen ein Rechteck einpassen, das jeweils 30 Pixel von allen vier R\u00e4ndern Abstand hat, dann definieren wir: Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int abstand = 30 ; int links = abstand ; int oben = abstand ; int rechts = this . getWidth () - abstand ; int unten = this . getHeight () - abstand ; int breite = rechts - links ; int hoehe = unten - oben ; g2 . drawRect ( links , oben , breite , hoehe ); } ergibt: noch ein Beispiel - wir passen ein Dreieck in das Fenster ein: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int abstand = 30 ; int links = abstand ; int oben = abstand ; int rechts = this . getWidth () - abstand ; int unten = this . getHeight () - abstand ; int breite = rechts - links ; int hoehe = unten - oben ; int mitteVertikal = this . getWidth () / 2 ; g2 . drawLine ( links , unten , mitteVertikal , oben ); g2 . drawLine ( mitteVertikal , oben , rechts , unten ); g2 . drawLine ( rechts , unten , links , unten ); } ergibt: Success Wir k\u00f6nnen eigene Grafiken erstellen. Wir erstellen dazu eine innere Klasse, die von JPanel erbt. Der Grund daf\u00fcr ist, dass wir die Methode paintComponent(Graphics g) \u00fcberschreiben wollen und darin mithilfe der Methoden aus der Klasse Grahpcs2D geometrische Objekte erstellen. Au\u00dferdem haben wir das Farbmodell von Java kennengelernt und k\u00f6nnen die Grafiken an die Fenstergr\u00f6\u00dfe anpassen. In der kommenden Lektion lernen wir, wie wir mithilfe der Maus zeichnen k\u00f6nnen.","title":"Graphics (entf\u00e4llt)"},{"location":"graphics/#graphics","text":"Wir werden unsere GUI nun um eine Komponente erweitern, in der wir zeichnen k\u00f6nnen. Im Prinzip wird unsere GUI immer gezeichnet . Die Steuerelemente sind nur vorformatiert und bestehen aus lauter Linien, Polygonen und Punkten, die zusammen dann so, wie z.B. ein Button aussehen. Wenn wir eine GUI haben und dieses Fenster z.B. die Gr\u00f6\u00dfe \u00e4ndert, wird es dabei jedes Mal neu gezeichnet. Diese (Neu-)Zeichnen wird dadurch angesto\u00dfen, dass f\u00fcr unser JFrame die Methode paint() aufgerufen wird. Diese Methode wird z.B. auch in der Methode setVisible(true) aufgerufen. Jede Komponente (also jedes Steuerelement und jeder Container) hat ihre eigene Objektmethode paint() , in der beschrieben ist, wie diese Komponente zu zeichnen ist. Genauer gesagt, werden in paint() folgende drei Methoden aufgerufen: paintBorder() - zeichnet den Rahmen der Komponente paintChildren() - ruft paint() f\u00fcr alle Kindkomponenten auf (also z.B. alle Steurelemente in einem JPanel ) paintComponent() - zeichnet die Komponente (und ihre Kinder) Damit \u00fcberhaupt Linien und Punkte dargestellt werden k\u00f6nnen, gibt es eine Klasse Graphics , die, etwas vereinfacht gesagt, die Schnittstelle zwischen Hardware (dem Monitor) und dem zu zeichnenden Fenster darstellt. Alle Komponenten eines Fensters teilen sich genau ein Objekt dieser Klasse Graphics . Bei diesem Objekt wird auch vom Graphics-Context ( Grafikkontext ) gesprochen. Diese Klasse stellt eine Vielzahl von Methoden zur Verf\u00fcgung, um einfache geometrische Objekte zu zeichnen, z.B. drawLine() , um eine Linie zu zeichnen, drawOval() , um eine (leere) Ellipse zu zeichnen, drawRect() , um ein (leeres) Rechteck zu zeichnen, drawPolygon() , um ein (leeres) Polygon (also ein Vieleck) zu zeichnen, drawString() , um ein Text zu zeichnen, fillOval() , um eine (ausgef\u00fcllte) Ellipse zu zeichnen, fillRect() , um ein (ausgef\u00fclltes) Rechteck zu zeichnen, fillPolygon() , um ein (ausgef\u00fclltes) Polygon (also ein Vieleck) zu zeichnen. Damit nun alle paintX() -Methoden (also paint() , paintBorder() , paintComponent und paintChildren() ) Zugriff auf diesen Grafikkontext (das Objekt von Graphics ) bekommen, wird es diesen Methoden \u00fcbergeben. Das hei\u00dft, die Methoden sind so deklariert (alle void ): paint(Graphics g) paintBorder(Graphics g) paintChildren(Graphics g) paintComponent(Graphics g) Die Graphics -Klasse gibt es schon seit Java 1.0. Allerdings hat man bereits sehr fr\u00fch festgestellt, dass die Methoden in dieser Klasse nicht gen\u00fcgen, um \"sch\u00f6ne\" Grafiken zu erstellen. Deshalb hat man bereits in Java 1.1 eine neue Klasse Graphics2D eingef\u00fchrt (hat von Graphics geerbt), in der haupts\u00e4chlich die Darstellung der geometrischen Objekte verbessert wurde, aber in der auch einige Methoden dazukamen, um z.B. andere Linienformen (gestrichelt, gepunktet, ...) zu definieren, andere Fonts f\u00fcr den Text usw. Tats\u00e4chlich handelt es sich seit JDK 1.2 bei dem Grafikkontext, also dem Graphics -Objekt g um ein Objekt der Klasse Graphics2D .","title":"Graphics"},{"location":"graphics/#eigene-geometrische-objekte-zeichnen","text":"Bevor wir eigene geometrische Objekte zeichnen k\u00f6nnen, schauen wir zun\u00e4chst nochmal auf unser \"Grundger\u00fcst\" f\u00fcr eine GUI (siehe Kapitel GUI Einf\u00fchrung ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . initContent ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); // hier weitere Container oder Steuerelemente hinzufuegen return mainPanel ; } public static void main ( String [] args ) { new MyFirstWindow (); } } Darin erzeugt die Methode initContent() ein JPanel und gibt es zur\u00fcck. Dieses JPanel wird der ContentPane unseres Fensters hinzugef\u00fcgt (Zeile 13 ). Somit hat das JFrame ein Kind , n\u00e4mlich das der ContentPane hinzugef\u00fcgte JPanel . Wenn das JFrame nun gezeichnet wird, wird f\u00fcr dieses JPanel die Methode paintComponent(Graphics g) aufgerufen. Diese ist f\u00fcr ein JPanel so implementiert, dass ein hellgraues Rechteck ohne Rand ( Border ) gezeichnet wird. W\u00fcrden wir dem mainPanel in der initContent() -Methode nun weitere Komponenten (Container oder Steuerlemente) hinzuf\u00fcgen, so w\u00fcrden diese alle so gezeichnet werden, wie f\u00fcr diese Komponenten die paintComponent(Graphics g) -Methode implementiert ist. Wir wollen nun aber selbst die paintComponent(Graphics g) -Methode f\u00fcr eine Komponente implementieren. Dazu entscheiden wir uns daf\u00fcr, die paintComponent() -Methode von einem JPanel zu implementieren. Aber wie kommen wir an diese Implementierung ran? Indem wir von JPanel erben . Wenn wir eine Klasse erstellen, die von JPanel erbt, dann erben wir auch die Implementierung der paintComponent() -Methode von JPanel und k\u00f6nnen diese \u00fcberschreiben . Wir \u00e4ndern daf\u00fcr unser \"Grundger\u00fcst\": 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstDrawingWindow extends JFrame { public MyFirstDrawingWindow () { super (); this . setTitle ( \"Wir zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new MyFirstDrawingWindow (); } } An der Darstellung des Fensters \u00e4ndert das zun\u00e4chst gar nichts. Wenn wir das Programm ausf\u00fchren, dann erscheint folgendes Fenster. Das der ContentPane hinzugef\u00fcgte JPanel wird also \"ganz normal\" als hellgraues Rechteck dargestellt. Der gro\u00dfe Unterschied ist, dass es sich nun um ein Objekt unserer inneren Klasse Canvas handelt. Diese hat von JPanel geerbt. Ein Objekt von Canvas ist somit auch ein Objekt vom Typ JPanel . Aber wir k\u00f6nnen in Canvas die Methode paintComponent(Graphics g) \u00fcberschreiben und somit eine eigene Implementierung f\u00fcr das Zeichnen unserer Komponente (einem Canvas -Objekt) erstellen. Innerhalb unserer eigenen Implementierung der paintComponent() -Methode rufen wir zun\u00e4chst die paintComponent() -Methode von JPanel auf. Damit wird ein hellgraues Rechteck gezeichnet. Das sollten wir immer tun, da ansonsten manchmal unsch\u00f6ne Nebeneffekte entstehen. Au\u00dferdem sollten wir auch immer das Graphics -Objekt nach Graphics2D konvertieren, da uns in Graphics2D deutlich mehr Methoden zur Verf\u00fcgung stehen (siehe z.B. hier und hier ). \u00dcbung Die Methode draw3DRect() ist ein Beispiel f\u00fcr eine Methode, die in der Graphics2D -Klasse implementiert ist, aber in der Klasse Graphics nicht vorkommt. 1. Warum funktioniert Graphics2D g2 = (Graphics2D)g; ? 2. Warum funktioniert g.draw3DRect() nicht, aber g2.draw3DRect() doch (wenn jeweils Parameterliste stimmt)?","title":"Eigene geometrische Objekte zeichnen"},{"location":"graphics/#erste-geometrische-objekte","text":"Unser Fenster ist nun soweit vorbereitet und wir \u00fcberschreiben die paintComponent() -Methode in unserer Klasse Canvas . Nun k\u00f6nnen wir darin beliebige Grafiken einf\u00fcgen. Dazu rufen wir Methoden von Graphics2D auf. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar g2 . drawRect ( 40 , 30 , 200 , 200 ); g2 . drawOval ( 40 , 30 , 200 , 200 ); } Die Methode drawRect(int x, int y, int width, int height) zeichnet ein Rechteck mit der Breite width und der H\u00f6he height . Bei uns hat beides den Wert 200 und somit wird ein Quadrat gezeichnet. Die Werte x und y stehen f\u00fcr die Koordinaten des linken oberen Punktes des Rechtecks innerhalb des JPanel s, in dem wir zeichnen (also innerhalb der ContentPane ). Der linke obere Punkt des JPanel hat die Koordinaten (0,0) , also gehen wir in dem Beispiel um 40 Pixel nach rechts und um 30 Pixel nach unten, um mit dem Zeichnen des Quadrates zu beginnen. Die Methode drawOval(int x, int y, int width, int height) zeichnet eine Ellipse mit der Breite width und der H\u00f6he height . Bei uns hat beides den Wert 200 und somit wird ein Kreis gezeichnet. Die Werte x und y stehen f\u00fcr die Koordinaten des linken oberen Punktes des gedachten Tangenetenvierecks um die Ellipse. Der linke obere \"Startpunkt\" ist hier sowohl f\u00fcr den Kreis, als auch f\u00fcr das Quadrat der gleiche. Da auch H\u00f6he und Breite jeweils gleich sind, passen die geometrischen Objekte genau ineinander, d.h. das Quadrat beschreibt das Tangenetenviereck um den Kreis. Sie k\u00f6nnen nun gerne beliebig die Methoden aus Graphics2D ausprobieren. Es macht Spa\u00df! Gerne auch beliebige Muster, z.B. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar for ( int i = 0 ; i < 10 ; i ++ ) { g2 . drawOval ( 50 + i * 10 , 50 , 80 , 80 ); g2 . drawOval ( 50 + i * 10 , 150 , 80 , 180 ); } } Anstelle der \"vorgefertigten\" Methoden f\u00fcr das Zeichnen von Rechtecken ( drawRect() ) und Ellipsen ( drawOval() ), k\u00f6nnen Sie auch immer erst entsprechende Objekte erzeugen und diese mithilfe der draw() -Methode zeichnen lassen, z.B. paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar Shape rectangle = new Rectangle2D . Double ( 40.0 , 30.0 , 200.0 , 200.0 ); Shape circle = new Ellipse2D . Double ( 40.0 , 30.0 , 200.0 , 200.0 ); g2 . draw ( rectangle ); g2 . draw ( circle ); } Das Interface Shape ist aus dem java.awt -Paket und die geometrischen Objekte sind aus dem java.awt.geom -Paket. Der Vorteil ist, dass f\u00fcr die geometrischen Objekte selbst viele Methoden existieren, um z.B. die Eigenschaften dieser Objekte abzufragen (z.B. H\u00f6he oder Breite). Es gibt viele solcher Klassen - siehe dazu Shape und darin All Known Implementing Classes . Ein Kreisbogen kann z.B. mithilfe der Klassen Arc2D.Double oder Arc2D.Float gezeichnet werden. Ein Kreisbogen ist ein Teil einer Ellipse. Die Konstruktoren erwarten jeweils 7 Parameter (gibt auch jeweils noch andere Konstruktoren): x , x-Wert der linken oberen Ecke des Tangentenvierecks um die (gesamte) Ellipse, y , y-Wert der linken oberen Ecke des Tangentenvierecks um die (gesamte) Ellipse, width , Breite der (gesamten) Ellipse, height , H\u00f6he der (gesamten) Ellipse, start , Startpunkt des Kreisbogens in Grad (0 ist \"3 Uhr\", 90 ist \"12 Uhr\", 180 ist \"9 Uhr\", 270 ist \"6 Uhr\"), extent , L\u00e4nge des Kreisbogens in Grad (90 ist Viertelkreis, 180 ist Halbkreis, positiver Wert \"gegen die Uhr\", negativer Wert \"mit der Uhr\"), type , Auswahl zwischen Arc2D.OPEN , Arc2D.PIE und Arc2D.CHORD , siehe Abbildung. Beispiele paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar Shape arc1 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 180.0 , 90.0 , Arc2D . OPEN ); Shape arc2 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 180.0 , - 90.0 , Arc2D . OPEN ); Shape arc3 = new Arc2D . Double ( 50.0 , 50.0 , 200.0 , 200.0 , 20.0 , 45.0 , Arc2D . PIE ); Shape arc4 = new Arc2D . Double ( 60.0 , 63.0 , 180.0 , 180.0 , 0.0 , - 180.0 , Arc2D . PIE ); g2 . setStroke ( new BasicStroke ( 4.0f )); // dickere Linie g2 . draw ( arc1 ); g2 . setColor ( Color . RED ); // Zeichenfarbe rot g2 . draw ( arc2 ); g2 . setColor ( Color . BLUE ); g2 . draw ( arc3 ); g2 . setColor ( Color . GREEN ); g2 . draw ( arc4 ); } \u00dcbung Erstellen Sie folgende Zeichnung: Um die geometrischen Objekte gef\u00fcllt darzustellen, verwenden Sie anstelle von draw(Shape s) die fill(Shape s) -Methode.","title":"Erste geometrische Objekte"},{"location":"graphics/#linien","text":"Die Linienart setzen Sie mithilfe der Methode g2.setStroke(Stroke s) . Das Interface Stroke wird von der Klasse BasicStroke implementiert (Beides aus dem java.awt -Paket). Das bedeutet, der Methode setStroke() wird ein BasicStroke -Objekt \u00fcbergeben. Die Klasse BasicStroke besitzt folgende Konstruktoren: BasicStroke() BasicStroke(float width) BasicStroke(float width, int cap, int join) BasicStroke(float width, int cap, int join, float miterlimit) BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float dash_phase) Dabei gibt - width die Linienst\u00e4rke als float an, z.B. new BasicStroke(4.0f) , - cap beschreibt die Enden einer Linie. Es stehen drei vordefinierte Konstanten zur Verf\u00fcgung: CAP_BUTT , CAP_ROUND und CAP_SQUARE Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 50 , 200 , 50 ); g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_ROUND , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 100 , 200 , 100 ); g2 . setStroke ( new BasicStroke ( 20 , BasicStroke . CAP_SQUARE , BasicStroke . JOIN_MITER )); g2 . drawLine ( 30 , 150 , 200 , 150 ); } ergibt: Die Eigenschaft join von BasicStroke gibt an, wie sich zwei Linien an den Endpunkten verbinden. Es gibt die drei vordefinierten Konstanten JOIN_BEVEL , JOIN_MITER und JOIN_ROUND . Die Unterscheidung zeigt am besten die folgende Grafik: Mit dem join von Linien hat auch miterlimit zu tun. Es muss gr\u00f6\u00dfer gleich 1.0f sein und ist nur f\u00fcr JOIN_MITER von Bedeutung. Mit dash kann ein float[] f\u00fcr ein Muster des Strichelns der Linie angegeben werden. Mit dash_phase kann angegeben werden, nach welcher Verz\u00f6gerung die Anwendung des dash -Musters erfolgt. Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar float [] dash1 = { 20.0f }; float [] dash2 = { 20.0f , 40.0f }; g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash1 , 0.0f )); g2 . drawLine ( 30 , 50 , 350 , 50 ); g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash2 , 0.0f )); g2 . drawLine ( 30 , 100 , 350 , 100 ); g2 . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 1.0f , dash1 , 10.0f )); g2 . drawLine ( 30 , 150 , 350 , 150 ); } ergibt:","title":"Linien"},{"location":"graphics/#farben","text":"Das Java-Farbmodell basiert auf dem RGB-Farbmodell , wobei jede Farbe durch 24Bit repr\u00e4sentiert wird ( 24Bit Farbtiefe ). Das bedeutet, dass f\u00fcr jeden Farbanteil von Rot, Gr\u00fcn, Blau jeweils 8Bit zur Verf\u00fcgung stehen und die einzelnen Farbanteile somit einen Wert zwischen 0 und 255 annehmen k\u00f6nnen. Einige Farben und deren Farbanteile von Rot, Gr\u00fcn und Blau sind in der folgenden Tabelle dargestellt: Farbe Rot-Anteil Gr\u00fcn-Anteil Blau-Anteil Wei\u00df 255 255 255 Schwarz 0 0 0 Grau 127 127 127 Rot 255 0 0 Gr\u00fcn 0 255 0 Blau 0 0 255 Gelb 255 255 0 Magenta 255 0 255 Cyan 0 255 255 Die Klasse Color aus dem java.awt -Paket besitzt sieben Konstruktoren. Die wichtigsten sind public Color(int r, int g, int b) , mit den int -Werten jeweils von 0 bis 255 f\u00fcr die Farbanteile, public Color(float r, float g, float b) , mit den float -Werten jeweils von 0.0f bis 1.0f f\u00fcr die Farbanteile, und die Pendants mit einem zus\u00e4tzlichen Alpha-Anteil f\u00fcr die Transparenz: public Color(int r, int g, int b, int alpha) , 0 bis 255 ( 0 vollst\u00e4ndig transparent, 255 deckend), public Color(float r, float g, float b, float alpha) , 0.0f bis 1.0f ( 0 vollst\u00e4ndig transparent, 1.0 deckend). In Color sind dar\u00fcber hinaus folgende Farben als statische Konstanten definiert: WHITE , BLACK , BLUE , CYAN , DARKGRAY , GRAY , GREEN , LIGHTGRAY , MAGENTA , ORANGE , PINK , RED , YELLOW Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int diffX = 200 ; int diffY = 130 ; Color color ; color = new Color ( 205 , 107 , 117 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 , 50 , 150 , 100 ); color = new Color ( 205 , 107 , 117 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . WHITE ); g2 . fillRect ( 50 , 50 + 2 * diffY , 150 , 100 ); color = new Color ( 100 , 255 , 100 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 + diffX , 50 , 150 , 100 ); color = new Color ( 100 , 255 , 100 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 + diffX , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . GREEN ); g2 . fillRect ( 50 + diffX , 50 + 2 * diffY , 150 , 100 ); color = new Color ( 100 , 100 , 255 , 127 ); g2 . setColor ( color ); g2 . fillRect ( 50 + 2 * diffX , 50 , 150 , 100 ); color = new Color ( 100 , 100 , 255 , 255 ); g2 . setColor ( color ); g2 . fillRect ( 50 + 2 * diffX , 50 + diffY , 150 , 100 ); g2 . setColor ( Color . BLUE ); g2 . fillRect ( 50 + 2 * diffX , 50 + 2 * diffY , 150 , 100 ); } ergibt: Mit den Klassen LinearGradientPaint und GradientPaint k\u00f6nnen Farbverl\u00e4ufe implementiert werden. Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar GradientPaint gp = new GradientPaint ( 0 , 0 , Color . RED , 300 , 100 , Color . WHITE ); g2 . setPaint ( gp ); g2 . fillRect ( 50 , 50 , 300 , 100 ); } ergibt:","title":"Farben"},{"location":"graphics/#hohe-und-breite-abhangig-von-der-canvas-groe","text":"Angenommen, Sie wollen eine geometrischen Figur so zeichnen, dass sich ihre Gr\u00f6\u00dfe der Gr\u00f6\u00dfe des Fensters anpasst. Dazu stehen Ihnen die Methoden getHeight() und getWidth() von JPanel (und somit von Ihrem Canvas -Objekt) zur Verf\u00fcgung. Die linke obere Ecke des JPanels hat die Koordinaten [x=0, y=0] und die rechte untere Ecke hat die Koordinaten [x=this.getWidth(), y= this.getHeight()] , d.h f\u00fcr den linken Rand gilt x = 0 , f\u00fcr den rechten Rand gilt x = this.width() , f\u00fcr den oberen Rand gilt y = 0 und f\u00fcr den unteren Rand gilt y = this.height() . Angenommen, wir wollen ein Rechteck einpassen, das jeweils 30 Pixel von allen vier R\u00e4ndern Abstand hat, dann definieren wir: Beispiel: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int abstand = 30 ; int links = abstand ; int oben = abstand ; int rechts = this . getWidth () - abstand ; int unten = this . getHeight () - abstand ; int breite = rechts - links ; int hoehe = unten - oben ; g2 . drawRect ( links , oben , breite , hoehe ); } ergibt: noch ein Beispiel - wir passen ein Dreieck in das Fenster ein: paintComponent()-Methode in Canvas 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int abstand = 30 ; int links = abstand ; int oben = abstand ; int rechts = this . getWidth () - abstand ; int unten = this . getHeight () - abstand ; int breite = rechts - links ; int hoehe = unten - oben ; int mitteVertikal = this . getWidth () / 2 ; g2 . drawLine ( links , unten , mitteVertikal , oben ); g2 . drawLine ( mitteVertikal , oben , rechts , unten ); g2 . drawLine ( rechts , unten , links , unten ); } ergibt: Success Wir k\u00f6nnen eigene Grafiken erstellen. Wir erstellen dazu eine innere Klasse, die von JPanel erbt. Der Grund daf\u00fcr ist, dass wir die Methode paintComponent(Graphics g) \u00fcberschreiben wollen und darin mithilfe der Methoden aus der Klasse Grahpcs2D geometrische Objekte erstellen. Au\u00dferdem haben wir das Farbmodell von Java kennengelernt und k\u00f6nnen die Grafiken an die Fenstergr\u00f6\u00dfe anpassen. In der kommenden Lektion lernen wir, wie wir mithilfe der Maus zeichnen k\u00f6nnen.","title":"H\u00f6he und Breite abh\u00e4ngig von der Canvas-Gr\u00f6\u00dfe"},{"location":"gui/","text":"Graphical User Interfaces \u00b6 Bis jetzt haben wir unsere Ein- und Ausgaben \u00fcber die Konsole erledigt oder wir haben Testklassen geschrieben, um Funktionalit\u00e4ten unserer Programme zu testen. Nun wollen wir grafische Nutzeroberfl\u00e4chen ( Graphical User Interfaces (GUI) ) erstellen, also Fenster, die Steuerelemente enthalten. Steuerelemente sind Ein- und Ausgabeelemente, Labels (also Text), Buttons, Checkboxes, Radiobuttons usw. Das Java Developement Kit (JDK) beinhaltet verschiedene Bibliotheken zum Erstellen grafischer Nutzeroberfl\u00e4chen: AWT (abstract window toolkit) java.awt ; alt, aber noch viele Sachen, die man heute noch nutzt: Farben, Listener f\u00fcr Maus und Tastur, Grafiken, ... Swing javax.swing ; das verwenden wir zum Erstellen von Fenstern, auch nicht mehr ganz neu JavaFX javafx ; sollte eigentlich Swing abl\u00f6sen, hat sich aber nicht durchgesetzt, seit Java 11 nicht mehr Bestandteil des Standard-JDK Swing ist, wie bereits gesagt, auch nicht mehr neu und wird h\u00e4ufig als veraltet bezeichnet. Allerdings gibt es auch keine Alternativen. JavaFX sollte Swing abl\u00f6sen, hat sich jedoch noch nicht durchgesetzt. Wir verwenden Swing aus zwei Gr\u00fcnden: erstens ist es immer noch das am meisten verwendete Framework f\u00fcr die Erstellung von GUIs in nativen Desktopanwendungen (also alles, was nicht \"Web\" und was nicht \"mobile\" ist), bspw. wurde IntelliJ mit Swing aufgebaut und zweitens geht es uns um die Konzepte , d.h. um den hierarchischen Aufbau der Oberfl\u00e4chen, um Nutzereignisse und die Behandlung dieser. Wir werden uns im 3. Semester in \"Webtechnologien\" mit der Erstellung moderner Weboberfl\u00e4chen besch\u00e4ftigen und dabei auf die Grundlagen aufbauen, die wir hier legen. Die Konzepte sind n\u00e4mlich dieselben. Elemente einer GUI \u00b6 Eine GUI besteht aus verschiedenen Elementen, deren Zusammenspiel erst die Benutzbarkeit der Oberfl\u00e4che erm\u00f6glichen. Unter Benutzbarkeit ist dabei die einfache, intuitive und \u00fcbersichtliche Ein- und Ausgabe von Daten gemeint. Im 6. Semester gibt es eine ganze Lehrveranstaltung zum Thema Usability in unserem Studiengang. Folgende Elemente sind in einer GUI von Bedeutung: Das Fenster stellt den \u00e4u\u00dferen Rahmen einer grafischen Anwendung dar. Es enth\u00e4lt typischerweise einen Rahmen und eine Titelleiste, in der der Name des Fensters bzw. der Anwendung (in der oberen Abbildung Window ) und drei Buttons zum Schlie\u00dfen des Fensters bzw. der Anwendung (das rote Kreuz in der oberen Abbildung), zum Vollbildmodus (das Quadrat) und zum Verkleinern des Fensters in die Taskleiste (der Unterstrich) enthalten sind. Der Rahmen, genau wie die Titelleiste mit den drei Buttons, sind aber optional. Ein Fenster enth\u00e4lt Komponenten . Komponenten sind alle Oberfl\u00e4chen- bzw. Steuerelemente, d.h. Buttons (siehe oben < Back und Next > ), Labels (Texte, z.B. Checkbox ), Checkboxes (die Quadrate, die ein H\u00e4kchen haben k\u00f6nnen oder auch nicht), Ein- und Ausgabefelder, Auswahllisten usw. Steuerelemente sind also alle Elemente, die direkt der Ein- und Ausgabe dienen. Dar\u00fcber hinaus gibt es noch die Komponente Container . Ein Container kann selbst wieder Container enhalten oder Steuerelemente . Container sind nicht direkt sichtbar, sondern sie dienen der Strukturierung einer grafischen Oberfl\u00e4che. Layoutmanager organisieren die Positionierung von Komponenten. Mithilfe von Layoutmanagern kann man Container unter- und/oder nebeneinander positionieren und organisiert somit die Anordnung der Steuerelemente. Men\u00fcs sind einblendbare Befehlsleisten. Es gibt die Men\u00fcs, die meistens oben in der Men\u00fcleiste verankert sind und Kontextmen\u00fcs , die dort erscheinen, wo man, meistens mit der rechten, Maustaste hinklickt. Events ( Ereignisse ) haben zun\u00e4chst nichts mit der Darstellung selbst zu tun. Sie sind aber f\u00fcr die Benutzbarkeit sehr wichtig, denn jede Nutzeraktion l\u00f6st ein Ereignis aus, welches wir im Programm behandeln k\u00f6nnen, z.B. Mausklicks, Mausbewegungen, Tastatureingaben, Bewegen, Vergr\u00f6\u00dfern, Verkleinern des Fensters usw. Wir werden uns sehr ausf\u00fchrlich mit der Behandlung von Ereignissen besch\u00e4ftigen. Zeichenoperationen dienen der Erstellung von Punkten, Linien, Text usw. in Fenstern. W\u00e4hrend die Steuerelemente ein festes Aussehen besitzen (anpassbar, je nach Betriebssystem und unterschiedlichen Look&Feel -Frameworks), k\u00f6nnen mit Zeichenoperationen beliebige Elemente erstellt und dargestellt werden, z.B. Grafiken, Kurven oder Diagramme. Wir werden auf alle diese Elemente eingehen und starten jetzt aber mit unserem ersten Fenster. Ein erstes Fenster mit Swing \u00b6 Wir erstellen uns eine Klasse MyFirstWindow . Von dieser Klasse erzeugen wir uns ein Objekt. Dazu implementieren wir den parameterlosen Konstruktor dieser Klasse. In diesem Konstruktor wird ein JFrame erzeugt - das ist das Fenster bei Swing. Wir haben in dieser Klasse auch eine main() -Methode. Das ist nicht ganz sauber, da die main() -Methode ja eigentlich keine Eigenschaft unserer Klasse ist, deren Responsibility die Erstellung eines Fensters ist, aber wir vereinfachen hier zu Anfang: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import javax.swing.JFrame ; public class MyFirstWindow { public MyFirstWindow () { JFrame window = new JFrame (); window . setTitle ( \"My first window\" ); window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); window . setSize ( 400 , 300 ); window . setLocation ( 300 , 200 ); window . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Wenn wir diese Klasse ausf\u00fchren, erscheint folgendes Fenster: Das Aussehen ist betriebssystemabh\u00e4ngig. Probieren Sie die drei \"Kn\u00f6pfe\" in der Titelleiste aus, sie funktionieren bereits, d.h. das Fenster l\u00e4sst sich in die Taskleiste verkleinern, es l\u00e4sst sich in den Vollbildmodus umschalten und es kann geschlossen werden (und damit das ganze Programm). Sie k\u00f6nnen es auch bereits in der Gr\u00f6\u00dfe ver\u00e4ndern. Wir betrachten das Programm im Detail: In Zeile 8 wird ein Objekt der Klasse JFrame erzeugt. Diese Klasse muss aus dem javax.swing -Paket importiert werden (Zeile 1 ). Sollte der Import bei Ihnen nicht funktionieren, m\u00fcssen Sie in Ihre module-info.java noch requires java.desktop; einf\u00fcgen, um dieses Modul zu laden. Die Klasse JFrame repr\u00e4sentiert ein Fenster im Swing-Paket. Das bedeutet, dass wir, wenn wir in Zukunft eine GUI mithilfe von Swing erstellen, immer damit beginnen, ein Objekt der Klasse JFrame zu erzeugen - n\u00e4mlich ein Fenster. Die Klasse JFrame stellt eine Unmenge an Objektmethoden zur Verf\u00fcgung, um das Fenster zu ver\u00e4ndern. Viele dieser Methoden sind auch aus Klassen des java.awt -Pakets geerbt, z.B. von Frame , von Component , von Container oder von Window , aber dazu kommen wir sp\u00e4ter. Wir wenden einige dieser Methoden bereits an: In Zeile 9 setzen wir mithilfe der Objektmethode setTitle() einen Titel f\u00fcr unser Fenster, hier \"My first window\" . Um den Titel zu setzen, gibt es auch einen parametrisierten Konstruktor von JFrame , dem dieser Titel \u00fcbergeben werden kann. In Zeile 10 definieren wir, was passieren soll, wenn wir auf den Schlie\u00dfen -Buttons des Fensters klicken (also auf das rote Kreuz oder den roten Kreis in der Titelleiste). Mit der statischen Konstanten EXIT_ON_CLOSE aus der Klasse JFrame legen wir fest, dass sowohl das Fenster geschlossen als auch das Programm beendet werden soll, wenn wir den Schlie\u00dfen -Button anklicken. Diese Option ist auch die einzig empfohlene Option f\u00fcr das Schlie\u00dfen des (Haupt-)Fensters. Leider ist sie nicht Standard, so dass wir das immer mitprogrammieren m\u00fcssen. Sollten Sie diese Anweisung vergessen, so schlie\u00dft sich zwar das Fenster, nicht jedoch das Programm. In Zeile 11 legen wir die Gr\u00f6\u00dfe des Fensters in Pixeln fest. Hier wird die Breite mit 400 Pixeln und die H\u00f6he mit 300 Pixeln festgelegt. Die Gr\u00f6\u00dfe des Fensters ist somit abh\u00e4ngig von der Aufl\u00f6sung Ihres Monitors. Wenn Sie diese Angabe \"vergessen\", erscheint das Fenster genau so gro\u00df, wie es n\u00f6tig ist, um alle Steuerelemente in dem Fenster darzustellen. Sie w\u00fcrden also nur die drei Kn\u00f6pfe in der Titelleiste sehen. Diese \"minimal erforderliche\" Gr\u00f6\u00dfe eines Fensters erreicht man auch mit der Objektmethode pack() , die das Fenster genau so gro\u00df darstellt, dass alle Steuerelemente sichtbar sind. In Zeile 12 legen wir fest, wo das Fenster auf unserem Monitor erscheint. Die linke obere Ecke des Monitors hat die Koordinaten (0,0) . Der erste Parameterwert in setLocation() legt fest, wie weit nach rechts der linke obere Punkt des Fensters auf unserem Monitor verschoben wird und der zweite Parameterwert legt fest, wie weit nach unten der linke obere Punkt des Fensters verschoben wird. Hier verschieben wir also das Fenster um 300 Pixel nach rechts und um 200 Pixel nach unten. Wenn Sie diese Angabe nicht treffen, erscheint das Fenster in der linken oberen Ecke des Monitors. In Zeile 13 setzen wir das Fenster auf sichtbar . Diese Anweisung sollten wir nicht vegessen, denn ansonsten sieht man das Fenster nicht und Sie wundern sich. setDefaultCloseOperation() \u00b6 Mit der Objektmethode setDefaultCloseOperation() wird das Verhalten bei Schlie\u00dfen des Fensters definiert. Daf\u00fcr wurden Konstanten in der Klasse JFrame definiert (genauer gesagt in der Klasse javax.swing.WindowConstants ). Es wird empfohlen, dass wir f\u00fcr unser Hauptfenster stets JFrame.EXIT_ON_CLOSE ) verwenden, da dann beim Schlie\u00dfen des Fensters auch das Programm beendet wird. Das ist aber leider nicht der Standardwert, deshalb m\u00fcssen wir es immer explizit angeben. Hier eine \u00dcbersicht der vordefinierten Konstanten und ihrer Bedeutung: Konstante Bedeutung DO_NOTHING_ON_CLOSE Es wird keine Aktion ausgef\u00fchrt. Die Reaktion auf das Schlie\u00dfen muss vom Benutzer selbst \u00fcber einen WindowListener realisiert werden. (windowClosing) HIDE_ON_CLOSE Versteckt das Fenster vor dem Benutzer. Alle Objekte und Ressourcen bleiben im Speicher erhalten und das Fenster kann jederzeit wieder sichtbar gemacht werden. DISPOSE_ON_CLOSE Das Fenster wird vom Bildschirm entfernt und alle Objekte und Ressourcen freigegeben. Wenn das letzte Fenster mit dieser Eigenschaft geschlossen wird verh\u00e4lt sich die Anwendung wie bei EXIT_ON_CLOSE. EXIT_ON_CLOSE Beendet die Anwendung und alle Fenster werden geschlossen und Ressourcen freigegeben. (System.exit(0)) Kurzer \u00dcberblick JFrame \u00b6 Ein JFrame ist der \u00e4u\u00dfere Rahmen einer Swing-Anwendung. Die Klasse befindet sich im Paket javax.swing . Ein Fenster ( JFrame ) hat eine Titelleiste mit den drei bekannten Schaltfl\u00e4chen ( decorated ); setUndecorated(boolean v) einen Rahmen ( javax.swing.Border ) Sichtbarkeit; setVisible(boolean v) Transparenz; setOpacity(float f) (0 durchsichtig; 1.0 undurchsichtig) eine Gr\u00f6\u00dfe; setSize(int b, int h) eine Position; setLocation(int x, int y) eine Form; setShape(Shape s) und kann im Vordergrund sein; toFront() im Hintergrund sein; toBack() Unsere Klasse ist selbst ein Fenster \u00b6 Ehe wir weitere Methoden f\u00fcr JFrame ausprobieren, \u00e4ndern wir die Implementierung unserer Klasse leicht. Derzeit haben wir in unserer Klasse ein Fenster erzeugt. Nun soll unsere Klasse selbst (besser gesagt: ein Objekt unserer Klasse) ein Fenster sein. Dazu lassen wir unsere Klasse von JFrame erben: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); // Konstruktor von JFrame this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Die wesentlichen \u00c4nderungen sind: Die Klasse MyFirstWindow erbt von JFrame (Zeile 3 ). Jedes Objekt der Klasse MyFirstWindow ist also (auch) ein Objekt der Klasse JFrame - und damit selbst ein Fenster. Im Konstruktor von MyFirstWindow rufen wir mit super(); den Konstruktor von JFrame auf (Zeile 8 ). Damit wird das Fenster erstellt. Die Objektmethoden von JFrame werden jetzt alle von der Referenz this aufgerufen, dem Fenster-Objekt. Wir werden auf diesem Grundger\u00fcst f\u00fcr die Erstellung eines Fensters aufbauen, d.h. wir verwenden in Zukunft diese zweite Variante und ziehen sie der ersten vor. Die Content Pane des Fensters \u00b6 Bevor wir dem Fenster nun Komponenten hinzuf\u00fcgen, ist es noch erw\u00e4hnenswert, dass ein Fenster aus verschiedenen \"Schichten\" besteht, sogenannten panes . Die folgende Abbildung zeigt die panes eines JFrames. Um dies besser zu erl\u00e4utern, versuchen wir, die Hintergrundfarbe des Fensters neu zu setzen. Dazu steht in der Klasse JFrame die Methode setBackground(Color) zur Verf\u00fcgung. Diese Methode erwartet ein Color , welche im java.awt -Paket zur Verf\u00fcgung steht. Der erste Implementierungsversuch w\u00e4re deshalb wie folgt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.awt.Color ; import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setBackground ( Color . CYAN ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Wir wollen unseren Fesnterhintergrund also mit der vorderfinierten Farbe CYAN einf\u00e4rben. Wenn wir dieses Programm ausf\u00fchren, erhalten wir folgendes Fenster: Zwar f\u00e4rbt sich die Titelleiste des Fensters, aber der Rest bleibt offensichtlich grau. Das liegt daran, dass die Content Pane des Fensters vor dem Hintergrund liegt. Alle Komponenten f\u00fcgen wir der Content Pane des Fensters hinzu! Das gilt auch f\u00fcr F\u00e4rbungen des Hintergrunds. Die Content Pane ist dazu da, die Komponenten hinzuzuf\u00fcgen und darzustellen. Wenn wir einen anderen Hintergrund f\u00fcr das Fenster (unterhalb der Titelleiste) w\u00fcnschen, dann m\u00fcssen wir den Hintergrund der Content Pane einf\u00e4rben. Den Zugriff auf die Content Pane erhalten wir mithilfe der Objektmethode . getContentPane () Unser Beispiel des Einf\u00e4rbens des Hintergrundes sieht also korrekt so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.awt.Color ; import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). setBackground ( Color . CYAN ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Beachten Sie, dass die Content Pane des Fensters zwar nun CYAN ist, daf\u00fcr aber nicht mehr die Titelleiste. Wenn wir diese auch f\u00e4rben sollen, dann gehen wir auch noch wie oben vor. Container-Komponenten \u00b6 Ehe wir Steuerelemente zu unserem Fenster hinzuf\u00fcgen, wollen wir auf die Unterscheidung zwischen Steuerelementen und Containern eingehen. Ein Fenster enth\u00e4lt Komponenten ( JComponent ). Komponenten k\u00f6nnen sein: Steuerelemente ; das sind die sichtbaren Teile im Fenster, d.h. Buttons, Eingabefelder, Checkboxen usw. und Container ; diese sieht man nicht direkt, sie dienen der Strukturierung der GUI. Container k\u00f6nnen weitere Komponenten (also Container oder Steuerelemente ) enthalten. Steuerelemente enthalten aber keine weiteren Komponenten . Durch das Verschachteln von Containern in Containern entsteht eine \"Hierarchie\" (oder besser gesagt: eine \"Baumstruktur\") in unserer GUI: Wichtig ist: die Knoten des Baumes sind Container und die Bl\u00e4tter des Baumes sind Steuerelemente Inhalt der Content Pane \u00b6 Die Content Pane ist selbst ein Container . Zur Content Pane k\u00f6nnen neue Komponenten ( Container oder Steuerelemente ) hinzugef\u00fcgt werden. Zum Hinzuf\u00fcgen neuer Komponenten wird die Objektmethode add() verwendet. Eine typische Klasse f\u00fcr einen Container ist die Klasse JPanel . JPanels k\u00f6nnen also ineinander verschachtelt werden, d.h. ein JPanel kann selbst wieder anderer JPanels entahlten (oder Steuerelemente ). Typische Steuerelemente (die in der Baumstruktur die \u201cBl\u00e4tter\u201c bilden), sind JButton , JLabel , JCheckBox , JRadioButton , ... Erweitern des Fensters um ein JPanel \u00b6 Wir f\u00fcgen unserer Content Pane nun ein JPanel (einen Container ) hinzu und werden dieses JPanel danach mit weiteren Komponenten bef\u00fcllen. Unser neues Grundger\u00fcst eines Fensters sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.awt.Color ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). setBackground ( Color . CYAN ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); // hier weitere Container oder Steuerelemente hinzufuegen return mainPanel ; } public static void main ( String [] args ) { new MyFirstWindow (); } } In Zeile 15 deklarieren wir eine Referenzvariable namens content vom Typ JPanel . Dazu muss die Klasse JPanel aus dem javax.swing -Paket importiert werden (Zeile 3 ). Dieses JPanel wird durch die Methode initContent() erzeugt, welche ein JPanel zur\u00fcckgibt (Zeile 27 ). In der Methode initContent() wird dieses JPanel erzeugt (Zeile 25 ) unter Verwendung des parameterlosen Konstruktors von JPanel . Das so erzeugte Fenster sieht so aus: Beachten Sie , dass der Hintergrund nun nicht mehr CYAN gef\u00e4rbt ist! Deshalb werden wir diese Anweisung auch gleich entfernen. Der Grund daf\u00fcr ist, dass zwar die Content Pane cyan ist, aber davor befindet sich jetzt ein JPanel ( content ), welches grau (Standardwert) ist. Dieses JPanel bef\u00fcllt die gesamte Content Pane . Diese ist also gar nicht mehr zu sehen. Erweitern der initContent()-Methode \u00b6 Wir werden die initContent() -Methode nun sukzessive erweitern, indem wir Steuerelemente (und sp\u00e4ter auch weitere Container , also JPanel ) hinzuf\u00fcgen. Dabei ist das generelle Vorgehen stets gleich: Steuerelement-Objekt erzeugen Steuerelement-Objekt dem Container (dem JPanel ) hinzuf\u00fcgen Wir betrachten nur die initContent() -Methode (die erforderlichen Klassen m\u00fcssen aus dem javax.swing -Paket importiert werden - oder Sie w\u00e4hlen import javax.swing.*; ): 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 private JPanel initContent () { JPanel mainPanel = new JPanel (); // Steuerlement-Objekte erstellen JLabel label = new JLabel ( \"Name: \" ); JTextField input = new JTextField ( 10 ); JButton button = new JButton ( \"Klick mich!\" ); // Steuerlement-Objekte dem Container (JPanel) hinzufuegen mainPanel . add ( label ); mainPanel . add ( input ); mainPanel . add ( button ); return mainPanel ; } Das Fenster sieht nun so aus: Wir haben also ein JLabel (einen Text) hinzugef\u00fcgt (\"Name\"), ein JTextField (ein Eingabefeld, f\u00fcr das die Breite 10 Zeichen definiert wurde) sowie ein JButton (ein Button, auf dem \"Klick mich!\" steht). Bei allen drei Elementen handelt es sich um Steuerelemente . Beachten Sie, dass die Elemente nebeneinander angeordnet sind. Das ist die Standardeinstellung f\u00fcr ein JPanel . Solche Einstellungen k\u00f6nnen sp\u00e4ter mit einem Layout-Manager ge\u00e4ndert werden. Die Steuerelemente werden solange nebeneinander angeordnet, solange sie nebeneinander passen. Wenn Sie die Fensterbreite schmaler gestalten (mit der Maus zusammenschieben), schieben sich die Steuerelemente untereinander. Um aber Kontrolle \u00fcber die Anordnung der Steuerelemente zu gelangen, betrachten wir nun Layout-Manager . Layout-Manager \u00b6 Layout-Manager dienen der Anordnung von Komponenten. Es gibt viele Layout-Manager ( FlowLayout , BorderLAyout , CardLayout , OverlayLayout , GridLayout , GridBagLayout , BoxLayout , GroupLayout , ...). Wir werden aber nicht alle betrachten, da dies erstens auf Dauer langweilig ist und zweitens Layout-Manager ineinander verschachtelt werden k\u00f6nnen. Vielmehr k\u00f6nnen Container ineinander verschachtelt werden und diesen Containern unterschiedliche Layout-Manager zugewiesen werden. Es wird also einem Container ein Layout-Manager zugewiesen und die Komponenten in diesem Container sind dann so angeordnet, wie der Layout-Manager es definiert (nebeneinander oder untereinander oder \u00fcbereinander ...). Das Zuweisen eines Layout-Managers zu einem Container erfolgt mithilfe von setLayout ( new Layoutmanager ()) // Layoutmanager durch entsprechenden Namen ersetzen Wir betrachten im Folgenden drei Layout-Manager und diese gen\u00fcgen v\u00f6llig f\u00fcr alle GUIs, die wir erstellen wollen: FlowLayout GridLayout BorderLayout Alle drei LayoutManager bedinden sich im java.awt -Paket, also java.awt.FlowLayout , java.awt.GridLayout und java.awt.BorderLayout . FlowLayout \u00b6 FlowLayout ist der Standard-Layout-Manager f\u00fcr ein JPanel . Das hei\u00dft, wenn wir einem JPanel keinen (anderen) Layout-Manager zuweisen, ist es im FlowLayout . FlowLayout ordnet die Komponenten nebeneinander in einer Zeile an (wenn sie in eine Zeile passen \u2013 ansonsten weitere Zeile). Das Zuweisen eines Containers zum FlowLayout erfolgt mittels setLayout(new FlowLayout()); . F\u00fcr FlowLayout steht aber nicht nur der parameterlose Konstruktor zur Verf\u00fcgung, sondern auch FlowLayout(int align) , wobei f\u00fcr align folgende vordefinierte Konstanten verwendet werden k\u00f6nnen: FlowLayout.CENTER ; ordnet alle Komponenten mittig an, ist der Standard-Wert FlowLayout.LEFT ; ordnet alle Komponenten linksb\u00fcndig an FlowLayout.RIGHT ; ordnet alle Komponenten rechtsb\u00fcndig an FlowLayout(int align, int hgap, int vgap) , wobei align wie oben und hgap den horizontalen Abstand zwischen den Komponenten und vgap den vertikalen Abstand zwischen den Komponenten beschreibt Beispiele: Beim FlowLayout bleiben die Steuerelemente stets in ihrer Standardgr\u00f6\u00dfe! \u00dcbung F\u00fcgen Sie in Ihre initContent() -Methode 6 Buttons ein (wie in der oberen Abbildung). Lassen Sie das mainPanel im FlowLayout . Probieren Sie ruhig mal die verschiedenen align -Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons nicht \u00e4ndert. GridLayout \u00b6 GridLayout ordnet Komponenten innerhalb eines rechteckigen Gitters (einem grid ) an. Das Zuweisen eines Containers zum GridLayout erfolgt mittels setLayout(new GridLayout(int rows, int columns)); . Dabei geben rows die Anzahl der Zeilen des Gitters und columns die Anzahl der Spalten des Gitters an. Dabei wird aber immmer zuerst versucht, ein Rechteck zur erzeugen mit der Zeilenanzahl als ma\u00dfgeblichem Wert ! Das verdeutlichen die folgenden Beispiele: F\u00fcr GridLayout gibt es noch einen weiteren parametrisierten Konstruktor, n\u00e4mlich GridLayout(int rows, int columns, int hgap, int vgap) , wobei hgap und vgap die gleiche Bedutung haben, wie beim FlowLayout . Wichtig ist, dass sich die Gr\u00f6\u00dfe der Komponenten der Gr\u00f6\u00dfe des Containes anpasst, in der die Komponenten enthalten sind. das bedeutet, dass mit der Gr\u00f6\u00dfe des Containers auch die Steuerelemente gr\u00f6\u00dfer werden! Das bedeutet, dass im Gegensatz zum FlowLayout z.B. Buttons in diesem Layout-Manager keine feste Gr\u00f6\u00dfe haben! \u00dcbung Verwenden Sie die initContent() -Methode aus der FlowLayout -\u00dcbung (mit den 6 Buttons). Weisen Sie dem mainPanel das GridLayout zu. Probieren Sie ruhig mal verschiedene rows , columns , hgap , vgap -Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons \u00e4ndert ! BorderLayout \u00b6 BorderLayout ist der Standard-Layout-Manager f\u00fcr ein JFrame . BorderLayout ordnet Komponenten in f\u00fcnf Felder ( North , South , East , West ) und die Mitte ( Center ) an. BorderLayout besitzt einen parameterlosen Konstruktor BoderLayout() und einen parametrisierten Konstruktor BorderLayout(int hgap, int vgap) mit hgap und vgap wie zuvor. Um Komponenten zu einem Container im BoderLayout hinzuzuf\u00fcgen, gibt es nun zwei verschiedene add() -Methoden: add(Component comp) f\u00fcgt die Komponente comp dem Center hinzu (entspricht add(comp, BorderLayout.CENTER) ), add(Component comp, Object constraints) , wobei constraints eine der folgenden vordefinierten Werte annehmen kann: BorderLayout.NORTH ; f\u00fcgt comp dem oberen Feld hinzu, BorderLayout.SOUTH ; f\u00fcgt comp dem unteren Feld hinzu, BorderLayout.EAST ; f\u00fcgt comp dem linken Feld hinzu, BorderLayout.WEST ; f\u00fcgt comp dem rechten Feld hinzu, BorderLayout.CENTER ; f\u00fcgt comp der Mitte hinzu. Angenommen, die initContent() -Methode sieht so aus: 23 24 25 26 27 28 29 30 31 32 33 34 35 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); mainPanel . add ( new JButton ( \"NORTH\" ), BorderLayout . NORTH ); mainPanel . add ( new JButton ( \"SOUTH\" ), BorderLayout . SOUTH ); mainPanel . add ( new JButton ( \"EAST\" ), BorderLayout . EAST ); mainPanel . add ( new JButton ( \"WEST\" ), BorderLayout . WEST ); mainPanel . add ( new JButton ( \"CENTER\" ), BorderLayout . CENTER ); return mainPanel ; } , dann wird folgendes Fenster erzeugt: Beachten Sie: die Nord-, S\u00fcd-Buttons behalten ihre H\u00f6he, skalieren auf Fensterbreite die Ost-, West-Buttons behalten ihre Breite, skalieren auf Fensterh\u00f6he (minus H\u00f6he f\u00fcr Norden und S\u00fcden) der Center-Button wird eingepasst (k\u00f6nnte z.B. auch ganz verschwinden) \u00dcbung Verwenden Sie die initContent() -Methode von oben (mit den 5 Buttons). Lassen Sie einzelne Buttons weg. Erkl\u00e4ren Sie jeweils das Ergebnis! Verschachteln von Layout-Managern \u00b6 Eigentlich ist die \u00dcberschrift irref\u00fchrend, denn es werden nicht die Layout-Manger verschachtelt, sondern die Container, denen jeweils andere Layout-Manager zugewiesen werden k\u00f6nnen. Wir wollen das an einem Beispiel demonstrieren. Wir betrachten dazu wieder nur die initContent() -Methode. Alles andere bleibt in unserem \"Grundger\u00fcst\", das wir in der Klasse MyFirstWindow erstellt haben, gleich. Wir beginnen damit, dass das mainPanel im BorderLayout ist und dass diesem mainPanel drei weitere JPanel hinzugef\u00fcgt werden. Das erste JPanel hei\u00dft oben , ist im FlowLayout und wird dem Norden des mainPanel s hinzugef\u00fcgt. Das zweite JPanel hei\u00dft mitte , ist im GridLayout und wird dem Center des mainPanel s hinzugef\u00fcgt. Das dritte JPanel hei\u00dft unten , ist im FlowLayout und wird dem S\u00fcden des mainPanel s hinzugef\u00fcgt. 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 3 , 2 , 10 , 10 )); JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 )); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( mitte , BorderLayout . CENTER ); mainPanel . add ( unten , BorderLayout . SOUTH ); return mainPanel ; } Die einzelnen JPanel sind nicht unterscheidbar, da sie keinen Rand ( Border ) besitzen und alle einen grauen Hintergrund haben. Es sind \"nur\" Container , die uns helfen, die GUI zu strukturieren. Sichtbar sind erst die Steuerelemente, die wir nun den einzelnen JPanel hinzuf\u00fcgen: 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); oben . add ( new JLabel ( \"Name : \" )); oben . add ( new JTextField ( 10 )); oben . setBackground ( Color . LIGHT_GRAY ); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 3 , 2 , 10 , 10 )); mitte . add ( new JButton ( \"Button 1\" )); mitte . add ( new JButton ( \"Button 2\" )); mitte . add ( new JButton ( \"Button 3\" )); mitte . add ( new JButton ( \"Button 4\" )); mitte . add ( new JButton ( \"Button 5\" )); mitte . add ( new JButton ( \"Button 6\" )); mitte . setBackground ( Color . GREEN ); JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 )); unten . add ( new JButton ( \"Abbruch\" )); unten . add ( new JButton ( \"OK\" )); unten . setBackground ( Color . LIGHT_GRAY ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( mitte , BorderLayout . CENTER ); mainPanel . add ( unten , BorderLayout . SOUTH ); return mainPanel ; } Zur besseren Erkennung wurde den einzelnen JPanel auch noch jeweils eine Hintergrundfarbe zugeordnet (Zeilen 32 , 42 und 48 ). Somit ergibt sich folgende Ansicht: Das JPanel oben ist im FlowLayout . Diesem Panel werden zwei Steuerelemente hinzugef\u00fcgt: ein JLabel ( \"Name\" ) und ein JTextField der Breite 10 (Zeichen). Da das Panel im FlowLayout ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind zentriert angeordnet ( FlowLayout.CENTER ) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von 10 Pixeln. Dem Panel wurde die Hintergrundfarbe LIGHT-GRAY zugewiesen. Das JPanel mitte ist im GridLayout mit 3 Zeilen und 2 Spalten. Diesem Panel werden 6 JButton zugeordnet. Die Buttons haben einen vertikalen und horizontalen Abstand von jeweils 10 Pixeln (zwischen den Buttons ist der Abstand also 20). Beachten Sie, dass die Gr\u00f6\u00dfe der Buttons an die Fenstergr\u00f6\u00dfe angepasst sind. Mit wachsender Fenstergr\u00f6\u00dfe wachsen auch die Button-Gr\u00f6\u00dfen. Dem Panel wurde die Hintergrundfarbe GREEN zugewiesen. Das JPanel unten ist im FlowLayout . Diesem Panel werden zwei JButton hinzugef\u00fcgt. Das das Panel im FlowLayout ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind rechtsb\u00fcndig angeordnet ( FlowLayout.RIGHT ) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von jeweils 5 Pixeln. Beachten Sie, dass die Buttons in ihrer Standardgr\u00f6\u00dfe sind (und stets bleiben). Dem Panel wurde die Hintergrundfarbe LIGHT-GRAY zugewiesen. Noch ein Wort zu den Gr\u00f6\u00dfen: Die Gr\u00f6\u00dfe des Fensters ist mit 300 x 200 vorgegeben. Der \"Norden\" geht \u00fcber die gesamte Breite. Die H\u00f6he des \"Nordens\" ergibt sich aus den Standardh\u00f6hen von JLabel und JTextField plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils 10 Pixeln. Der \"S\u00fcden\" geht ebenfalls \u00fcber die gesamte Breite. Die H\u00f6he des \"S\u00fcdens\" ergibt sich aus der Standardh\u00f6he von JButton plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils 5 Pixeln. Das Center -Feld geht ebenfalls \u00fcber die gesamte Breite, da es kein EAST - und kein WEST -Feld gibt. Die H\u00f6he des Center -Feldes ergibt sich aus der Fensterh\u00f6he minus der H\u00f6he f\u00fcr die Titelleiste, minus der H\u00f6he f\u00fcr den \"Norden\" und minus der H\u00f6he f\u00fcr den \"S\u00fcden\". Das Center -Feld f\u00fcllt also den verbleibenden Rest des Platzes im Fenster aus. Sie k\u00f6nnen beliebig viele Container in beliebiger Tiefe ineinanderschachteln und den Containern unterschiedliche Layout_Manager zuweisen. Damit gelingt ihnen jede denkbare Gestaltung grafischer Nutzeroberfl\u00e4chen. Weitere Anregungen zur Verwendung von Layout-Managern finden Sie z.B. hier . \u00dcbung \u00c4ndern Sie ausschlie\u00dflich die H\u00f6he des Fensters und dann einmal ausschlie\u00dflich die Breite des Fensters und begr\u00fcnden Sie das jeweilige Ergebnis! Success Wir haben unser erstes Fenster erstellt! Au\u00dferdem k\u00f6nnen wir dem Fenster Steuerelemente hinzuf\u00fcgen. Diese k\u00f6nnen wir mithilfe von Containern und Layout-Manager positionieren, so dass wir ordentlich positionierte Grafische Nutzeroberfl\u00e4chen erstellen k\u00f6nnen. Im n\u00e4chsten Schritt schauen wir uns an, wie wir auf Ereignisse reagieren k\u00f6nnen, z.B. auf das Klicken eines Buttons.","title":"GUI Einf\u00fchrung"},{"location":"gui/#graphical-user-interfaces","text":"Bis jetzt haben wir unsere Ein- und Ausgaben \u00fcber die Konsole erledigt oder wir haben Testklassen geschrieben, um Funktionalit\u00e4ten unserer Programme zu testen. Nun wollen wir grafische Nutzeroberfl\u00e4chen ( Graphical User Interfaces (GUI) ) erstellen, also Fenster, die Steuerelemente enthalten. Steuerelemente sind Ein- und Ausgabeelemente, Labels (also Text), Buttons, Checkboxes, Radiobuttons usw. Das Java Developement Kit (JDK) beinhaltet verschiedene Bibliotheken zum Erstellen grafischer Nutzeroberfl\u00e4chen: AWT (abstract window toolkit) java.awt ; alt, aber noch viele Sachen, die man heute noch nutzt: Farben, Listener f\u00fcr Maus und Tastur, Grafiken, ... Swing javax.swing ; das verwenden wir zum Erstellen von Fenstern, auch nicht mehr ganz neu JavaFX javafx ; sollte eigentlich Swing abl\u00f6sen, hat sich aber nicht durchgesetzt, seit Java 11 nicht mehr Bestandteil des Standard-JDK Swing ist, wie bereits gesagt, auch nicht mehr neu und wird h\u00e4ufig als veraltet bezeichnet. Allerdings gibt es auch keine Alternativen. JavaFX sollte Swing abl\u00f6sen, hat sich jedoch noch nicht durchgesetzt. Wir verwenden Swing aus zwei Gr\u00fcnden: erstens ist es immer noch das am meisten verwendete Framework f\u00fcr die Erstellung von GUIs in nativen Desktopanwendungen (also alles, was nicht \"Web\" und was nicht \"mobile\" ist), bspw. wurde IntelliJ mit Swing aufgebaut und zweitens geht es uns um die Konzepte , d.h. um den hierarchischen Aufbau der Oberfl\u00e4chen, um Nutzereignisse und die Behandlung dieser. Wir werden uns im 3. Semester in \"Webtechnologien\" mit der Erstellung moderner Weboberfl\u00e4chen besch\u00e4ftigen und dabei auf die Grundlagen aufbauen, die wir hier legen. Die Konzepte sind n\u00e4mlich dieselben.","title":"Graphical User Interfaces"},{"location":"gui/#elemente-einer-gui","text":"Eine GUI besteht aus verschiedenen Elementen, deren Zusammenspiel erst die Benutzbarkeit der Oberfl\u00e4che erm\u00f6glichen. Unter Benutzbarkeit ist dabei die einfache, intuitive und \u00fcbersichtliche Ein- und Ausgabe von Daten gemeint. Im 6. Semester gibt es eine ganze Lehrveranstaltung zum Thema Usability in unserem Studiengang. Folgende Elemente sind in einer GUI von Bedeutung: Das Fenster stellt den \u00e4u\u00dferen Rahmen einer grafischen Anwendung dar. Es enth\u00e4lt typischerweise einen Rahmen und eine Titelleiste, in der der Name des Fensters bzw. der Anwendung (in der oberen Abbildung Window ) und drei Buttons zum Schlie\u00dfen des Fensters bzw. der Anwendung (das rote Kreuz in der oberen Abbildung), zum Vollbildmodus (das Quadrat) und zum Verkleinern des Fensters in die Taskleiste (der Unterstrich) enthalten sind. Der Rahmen, genau wie die Titelleiste mit den drei Buttons, sind aber optional. Ein Fenster enth\u00e4lt Komponenten . Komponenten sind alle Oberfl\u00e4chen- bzw. Steuerelemente, d.h. Buttons (siehe oben < Back und Next > ), Labels (Texte, z.B. Checkbox ), Checkboxes (die Quadrate, die ein H\u00e4kchen haben k\u00f6nnen oder auch nicht), Ein- und Ausgabefelder, Auswahllisten usw. Steuerelemente sind also alle Elemente, die direkt der Ein- und Ausgabe dienen. Dar\u00fcber hinaus gibt es noch die Komponente Container . Ein Container kann selbst wieder Container enhalten oder Steuerelemente . Container sind nicht direkt sichtbar, sondern sie dienen der Strukturierung einer grafischen Oberfl\u00e4che. Layoutmanager organisieren die Positionierung von Komponenten. Mithilfe von Layoutmanagern kann man Container unter- und/oder nebeneinander positionieren und organisiert somit die Anordnung der Steuerelemente. Men\u00fcs sind einblendbare Befehlsleisten. Es gibt die Men\u00fcs, die meistens oben in der Men\u00fcleiste verankert sind und Kontextmen\u00fcs , die dort erscheinen, wo man, meistens mit der rechten, Maustaste hinklickt. Events ( Ereignisse ) haben zun\u00e4chst nichts mit der Darstellung selbst zu tun. Sie sind aber f\u00fcr die Benutzbarkeit sehr wichtig, denn jede Nutzeraktion l\u00f6st ein Ereignis aus, welches wir im Programm behandeln k\u00f6nnen, z.B. Mausklicks, Mausbewegungen, Tastatureingaben, Bewegen, Vergr\u00f6\u00dfern, Verkleinern des Fensters usw. Wir werden uns sehr ausf\u00fchrlich mit der Behandlung von Ereignissen besch\u00e4ftigen. Zeichenoperationen dienen der Erstellung von Punkten, Linien, Text usw. in Fenstern. W\u00e4hrend die Steuerelemente ein festes Aussehen besitzen (anpassbar, je nach Betriebssystem und unterschiedlichen Look&Feel -Frameworks), k\u00f6nnen mit Zeichenoperationen beliebige Elemente erstellt und dargestellt werden, z.B. Grafiken, Kurven oder Diagramme. Wir werden auf alle diese Elemente eingehen und starten jetzt aber mit unserem ersten Fenster.","title":"Elemente einer GUI"},{"location":"gui/#ein-erstes-fenster-mit-swing","text":"Wir erstellen uns eine Klasse MyFirstWindow . Von dieser Klasse erzeugen wir uns ein Objekt. Dazu implementieren wir den parameterlosen Konstruktor dieser Klasse. In diesem Konstruktor wird ein JFrame erzeugt - das ist das Fenster bei Swing. Wir haben in dieser Klasse auch eine main() -Methode. Das ist nicht ganz sauber, da die main() -Methode ja eigentlich keine Eigenschaft unserer Klasse ist, deren Responsibility die Erstellung eines Fensters ist, aber wir vereinfachen hier zu Anfang: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import javax.swing.JFrame ; public class MyFirstWindow { public MyFirstWindow () { JFrame window = new JFrame (); window . setTitle ( \"My first window\" ); window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); window . setSize ( 400 , 300 ); window . setLocation ( 300 , 200 ); window . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Wenn wir diese Klasse ausf\u00fchren, erscheint folgendes Fenster: Das Aussehen ist betriebssystemabh\u00e4ngig. Probieren Sie die drei \"Kn\u00f6pfe\" in der Titelleiste aus, sie funktionieren bereits, d.h. das Fenster l\u00e4sst sich in die Taskleiste verkleinern, es l\u00e4sst sich in den Vollbildmodus umschalten und es kann geschlossen werden (und damit das ganze Programm). Sie k\u00f6nnen es auch bereits in der Gr\u00f6\u00dfe ver\u00e4ndern. Wir betrachten das Programm im Detail: In Zeile 8 wird ein Objekt der Klasse JFrame erzeugt. Diese Klasse muss aus dem javax.swing -Paket importiert werden (Zeile 1 ). Sollte der Import bei Ihnen nicht funktionieren, m\u00fcssen Sie in Ihre module-info.java noch requires java.desktop; einf\u00fcgen, um dieses Modul zu laden. Die Klasse JFrame repr\u00e4sentiert ein Fenster im Swing-Paket. Das bedeutet, dass wir, wenn wir in Zukunft eine GUI mithilfe von Swing erstellen, immer damit beginnen, ein Objekt der Klasse JFrame zu erzeugen - n\u00e4mlich ein Fenster. Die Klasse JFrame stellt eine Unmenge an Objektmethoden zur Verf\u00fcgung, um das Fenster zu ver\u00e4ndern. Viele dieser Methoden sind auch aus Klassen des java.awt -Pakets geerbt, z.B. von Frame , von Component , von Container oder von Window , aber dazu kommen wir sp\u00e4ter. Wir wenden einige dieser Methoden bereits an: In Zeile 9 setzen wir mithilfe der Objektmethode setTitle() einen Titel f\u00fcr unser Fenster, hier \"My first window\" . Um den Titel zu setzen, gibt es auch einen parametrisierten Konstruktor von JFrame , dem dieser Titel \u00fcbergeben werden kann. In Zeile 10 definieren wir, was passieren soll, wenn wir auf den Schlie\u00dfen -Buttons des Fensters klicken (also auf das rote Kreuz oder den roten Kreis in der Titelleiste). Mit der statischen Konstanten EXIT_ON_CLOSE aus der Klasse JFrame legen wir fest, dass sowohl das Fenster geschlossen als auch das Programm beendet werden soll, wenn wir den Schlie\u00dfen -Button anklicken. Diese Option ist auch die einzig empfohlene Option f\u00fcr das Schlie\u00dfen des (Haupt-)Fensters. Leider ist sie nicht Standard, so dass wir das immer mitprogrammieren m\u00fcssen. Sollten Sie diese Anweisung vergessen, so schlie\u00dft sich zwar das Fenster, nicht jedoch das Programm. In Zeile 11 legen wir die Gr\u00f6\u00dfe des Fensters in Pixeln fest. Hier wird die Breite mit 400 Pixeln und die H\u00f6he mit 300 Pixeln festgelegt. Die Gr\u00f6\u00dfe des Fensters ist somit abh\u00e4ngig von der Aufl\u00f6sung Ihres Monitors. Wenn Sie diese Angabe \"vergessen\", erscheint das Fenster genau so gro\u00df, wie es n\u00f6tig ist, um alle Steuerelemente in dem Fenster darzustellen. Sie w\u00fcrden also nur die drei Kn\u00f6pfe in der Titelleiste sehen. Diese \"minimal erforderliche\" Gr\u00f6\u00dfe eines Fensters erreicht man auch mit der Objektmethode pack() , die das Fenster genau so gro\u00df darstellt, dass alle Steuerelemente sichtbar sind. In Zeile 12 legen wir fest, wo das Fenster auf unserem Monitor erscheint. Die linke obere Ecke des Monitors hat die Koordinaten (0,0) . Der erste Parameterwert in setLocation() legt fest, wie weit nach rechts der linke obere Punkt des Fensters auf unserem Monitor verschoben wird und der zweite Parameterwert legt fest, wie weit nach unten der linke obere Punkt des Fensters verschoben wird. Hier verschieben wir also das Fenster um 300 Pixel nach rechts und um 200 Pixel nach unten. Wenn Sie diese Angabe nicht treffen, erscheint das Fenster in der linken oberen Ecke des Monitors. In Zeile 13 setzen wir das Fenster auf sichtbar . Diese Anweisung sollten wir nicht vegessen, denn ansonsten sieht man das Fenster nicht und Sie wundern sich.","title":"Ein erstes Fenster mit Swing"},{"location":"gui/#setdefaultcloseoperation","text":"Mit der Objektmethode setDefaultCloseOperation() wird das Verhalten bei Schlie\u00dfen des Fensters definiert. Daf\u00fcr wurden Konstanten in der Klasse JFrame definiert (genauer gesagt in der Klasse javax.swing.WindowConstants ). Es wird empfohlen, dass wir f\u00fcr unser Hauptfenster stets JFrame.EXIT_ON_CLOSE ) verwenden, da dann beim Schlie\u00dfen des Fensters auch das Programm beendet wird. Das ist aber leider nicht der Standardwert, deshalb m\u00fcssen wir es immer explizit angeben. Hier eine \u00dcbersicht der vordefinierten Konstanten und ihrer Bedeutung: Konstante Bedeutung DO_NOTHING_ON_CLOSE Es wird keine Aktion ausgef\u00fchrt. Die Reaktion auf das Schlie\u00dfen muss vom Benutzer selbst \u00fcber einen WindowListener realisiert werden. (windowClosing) HIDE_ON_CLOSE Versteckt das Fenster vor dem Benutzer. Alle Objekte und Ressourcen bleiben im Speicher erhalten und das Fenster kann jederzeit wieder sichtbar gemacht werden. DISPOSE_ON_CLOSE Das Fenster wird vom Bildschirm entfernt und alle Objekte und Ressourcen freigegeben. Wenn das letzte Fenster mit dieser Eigenschaft geschlossen wird verh\u00e4lt sich die Anwendung wie bei EXIT_ON_CLOSE. EXIT_ON_CLOSE Beendet die Anwendung und alle Fenster werden geschlossen und Ressourcen freigegeben. (System.exit(0))","title":"setDefaultCloseOperation()"},{"location":"gui/#kurzer-uberblick-jframe","text":"Ein JFrame ist der \u00e4u\u00dfere Rahmen einer Swing-Anwendung. Die Klasse befindet sich im Paket javax.swing . Ein Fenster ( JFrame ) hat eine Titelleiste mit den drei bekannten Schaltfl\u00e4chen ( decorated ); setUndecorated(boolean v) einen Rahmen ( javax.swing.Border ) Sichtbarkeit; setVisible(boolean v) Transparenz; setOpacity(float f) (0 durchsichtig; 1.0 undurchsichtig) eine Gr\u00f6\u00dfe; setSize(int b, int h) eine Position; setLocation(int x, int y) eine Form; setShape(Shape s) und kann im Vordergrund sein; toFront() im Hintergrund sein; toBack()","title":"Kurzer \u00dcberblick JFrame"},{"location":"gui/#unsere-klasse-ist-selbst-ein-fenster","text":"Ehe wir weitere Methoden f\u00fcr JFrame ausprobieren, \u00e4ndern wir die Implementierung unserer Klasse leicht. Derzeit haben wir in unserer Klasse ein Fenster erzeugt. Nun soll unsere Klasse selbst (besser gesagt: ein Objekt unserer Klasse) ein Fenster sein. Dazu lassen wir unsere Klasse von JFrame erben: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); // Konstruktor von JFrame this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Die wesentlichen \u00c4nderungen sind: Die Klasse MyFirstWindow erbt von JFrame (Zeile 3 ). Jedes Objekt der Klasse MyFirstWindow ist also (auch) ein Objekt der Klasse JFrame - und damit selbst ein Fenster. Im Konstruktor von MyFirstWindow rufen wir mit super(); den Konstruktor von JFrame auf (Zeile 8 ). Damit wird das Fenster erstellt. Die Objektmethoden von JFrame werden jetzt alle von der Referenz this aufgerufen, dem Fenster-Objekt. Wir werden auf diesem Grundger\u00fcst f\u00fcr die Erstellung eines Fensters aufbauen, d.h. wir verwenden in Zukunft diese zweite Variante und ziehen sie der ersten vor.","title":"Unsere Klasse ist selbst ein Fenster"},{"location":"gui/#die-content-pane-des-fensters","text":"Bevor wir dem Fenster nun Komponenten hinzuf\u00fcgen, ist es noch erw\u00e4hnenswert, dass ein Fenster aus verschiedenen \"Schichten\" besteht, sogenannten panes . Die folgende Abbildung zeigt die panes eines JFrames. Um dies besser zu erl\u00e4utern, versuchen wir, die Hintergrundfarbe des Fensters neu zu setzen. Dazu steht in der Klasse JFrame die Methode setBackground(Color) zur Verf\u00fcgung. Diese Methode erwartet ein Color , welche im java.awt -Paket zur Verf\u00fcgung steht. Der erste Implementierungsversuch w\u00e4re deshalb wie folgt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.awt.Color ; import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setBackground ( Color . CYAN ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Wir wollen unseren Fesnterhintergrund also mit der vorderfinierten Farbe CYAN einf\u00e4rben. Wenn wir dieses Programm ausf\u00fchren, erhalten wir folgendes Fenster: Zwar f\u00e4rbt sich die Titelleiste des Fensters, aber der Rest bleibt offensichtlich grau. Das liegt daran, dass die Content Pane des Fensters vor dem Hintergrund liegt. Alle Komponenten f\u00fcgen wir der Content Pane des Fensters hinzu! Das gilt auch f\u00fcr F\u00e4rbungen des Hintergrunds. Die Content Pane ist dazu da, die Komponenten hinzuzuf\u00fcgen und darzustellen. Wenn wir einen anderen Hintergrund f\u00fcr das Fenster (unterhalb der Titelleiste) w\u00fcnschen, dann m\u00fcssen wir den Hintergrund der Content Pane einf\u00e4rben. Den Zugriff auf die Content Pane erhalten wir mithilfe der Objektmethode . getContentPane () Unser Beispiel des Einf\u00e4rbens des Hintergrundes sieht also korrekt so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.awt.Color ; import javax.swing.JFrame ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). setBackground ( Color . CYAN ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } public static void main ( String [] args ) { new MyFirstWindow (); } } Beachten Sie, dass die Content Pane des Fensters zwar nun CYAN ist, daf\u00fcr aber nicht mehr die Titelleiste. Wenn wir diese auch f\u00e4rben sollen, dann gehen wir auch noch wie oben vor.","title":"Die Content Pane des Fensters"},{"location":"gui/#container-komponenten","text":"Ehe wir Steuerelemente zu unserem Fenster hinzuf\u00fcgen, wollen wir auf die Unterscheidung zwischen Steuerelementen und Containern eingehen. Ein Fenster enth\u00e4lt Komponenten ( JComponent ). Komponenten k\u00f6nnen sein: Steuerelemente ; das sind die sichtbaren Teile im Fenster, d.h. Buttons, Eingabefelder, Checkboxen usw. und Container ; diese sieht man nicht direkt, sie dienen der Strukturierung der GUI. Container k\u00f6nnen weitere Komponenten (also Container oder Steuerelemente ) enthalten. Steuerelemente enthalten aber keine weiteren Komponenten . Durch das Verschachteln von Containern in Containern entsteht eine \"Hierarchie\" (oder besser gesagt: eine \"Baumstruktur\") in unserer GUI: Wichtig ist: die Knoten des Baumes sind Container und die Bl\u00e4tter des Baumes sind Steuerelemente","title":"Container-Komponenten"},{"location":"gui/#inhalt-der-content-pane","text":"Die Content Pane ist selbst ein Container . Zur Content Pane k\u00f6nnen neue Komponenten ( Container oder Steuerelemente ) hinzugef\u00fcgt werden. Zum Hinzuf\u00fcgen neuer Komponenten wird die Objektmethode add() verwendet. Eine typische Klasse f\u00fcr einen Container ist die Klasse JPanel . JPanels k\u00f6nnen also ineinander verschachtelt werden, d.h. ein JPanel kann selbst wieder anderer JPanels entahlten (oder Steuerelemente ). Typische Steuerelemente (die in der Baumstruktur die \u201cBl\u00e4tter\u201c bilden), sind JButton , JLabel , JCheckBox , JRadioButton , ...","title":"Inhalt der Content Pane"},{"location":"gui/#erweitern-des-fensters-um-ein-jpanel","text":"Wir f\u00fcgen unserer Content Pane nun ein JPanel (einen Container ) hinzu und werden dieses JPanel danach mit weiteren Komponenten bef\u00fcllen. Unser neues Grundger\u00fcst eines Fensters sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.awt.Color ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class MyFirstWindow extends JFrame { public MyFirstWindow () { super (); this . setTitle ( \"My first window\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). setBackground ( Color . CYAN ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); // hier weitere Container oder Steuerelemente hinzufuegen return mainPanel ; } public static void main ( String [] args ) { new MyFirstWindow (); } } In Zeile 15 deklarieren wir eine Referenzvariable namens content vom Typ JPanel . Dazu muss die Klasse JPanel aus dem javax.swing -Paket importiert werden (Zeile 3 ). Dieses JPanel wird durch die Methode initContent() erzeugt, welche ein JPanel zur\u00fcckgibt (Zeile 27 ). In der Methode initContent() wird dieses JPanel erzeugt (Zeile 25 ) unter Verwendung des parameterlosen Konstruktors von JPanel . Das so erzeugte Fenster sieht so aus: Beachten Sie , dass der Hintergrund nun nicht mehr CYAN gef\u00e4rbt ist! Deshalb werden wir diese Anweisung auch gleich entfernen. Der Grund daf\u00fcr ist, dass zwar die Content Pane cyan ist, aber davor befindet sich jetzt ein JPanel ( content ), welches grau (Standardwert) ist. Dieses JPanel bef\u00fcllt die gesamte Content Pane . Diese ist also gar nicht mehr zu sehen.","title":"Erweitern des Fensters um ein JPanel"},{"location":"gui/#erweitern-der-initcontent-methode","text":"Wir werden die initContent() -Methode nun sukzessive erweitern, indem wir Steuerelemente (und sp\u00e4ter auch weitere Container , also JPanel ) hinzuf\u00fcgen. Dabei ist das generelle Vorgehen stets gleich: Steuerelement-Objekt erzeugen Steuerelement-Objekt dem Container (dem JPanel ) hinzuf\u00fcgen Wir betrachten nur die initContent() -Methode (die erforderlichen Klassen m\u00fcssen aus dem javax.swing -Paket importiert werden - oder Sie w\u00e4hlen import javax.swing.*; ): 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 private JPanel initContent () { JPanel mainPanel = new JPanel (); // Steuerlement-Objekte erstellen JLabel label = new JLabel ( \"Name: \" ); JTextField input = new JTextField ( 10 ); JButton button = new JButton ( \"Klick mich!\" ); // Steuerlement-Objekte dem Container (JPanel) hinzufuegen mainPanel . add ( label ); mainPanel . add ( input ); mainPanel . add ( button ); return mainPanel ; } Das Fenster sieht nun so aus: Wir haben also ein JLabel (einen Text) hinzugef\u00fcgt (\"Name\"), ein JTextField (ein Eingabefeld, f\u00fcr das die Breite 10 Zeichen definiert wurde) sowie ein JButton (ein Button, auf dem \"Klick mich!\" steht). Bei allen drei Elementen handelt es sich um Steuerelemente . Beachten Sie, dass die Elemente nebeneinander angeordnet sind. Das ist die Standardeinstellung f\u00fcr ein JPanel . Solche Einstellungen k\u00f6nnen sp\u00e4ter mit einem Layout-Manager ge\u00e4ndert werden. Die Steuerelemente werden solange nebeneinander angeordnet, solange sie nebeneinander passen. Wenn Sie die Fensterbreite schmaler gestalten (mit der Maus zusammenschieben), schieben sich die Steuerelemente untereinander. Um aber Kontrolle \u00fcber die Anordnung der Steuerelemente zu gelangen, betrachten wir nun Layout-Manager .","title":"Erweitern der initContent()-Methode"},{"location":"gui/#layout-manager","text":"Layout-Manager dienen der Anordnung von Komponenten. Es gibt viele Layout-Manager ( FlowLayout , BorderLAyout , CardLayout , OverlayLayout , GridLayout , GridBagLayout , BoxLayout , GroupLayout , ...). Wir werden aber nicht alle betrachten, da dies erstens auf Dauer langweilig ist und zweitens Layout-Manager ineinander verschachtelt werden k\u00f6nnen. Vielmehr k\u00f6nnen Container ineinander verschachtelt werden und diesen Containern unterschiedliche Layout-Manager zugewiesen werden. Es wird also einem Container ein Layout-Manager zugewiesen und die Komponenten in diesem Container sind dann so angeordnet, wie der Layout-Manager es definiert (nebeneinander oder untereinander oder \u00fcbereinander ...). Das Zuweisen eines Layout-Managers zu einem Container erfolgt mithilfe von setLayout ( new Layoutmanager ()) // Layoutmanager durch entsprechenden Namen ersetzen Wir betrachten im Folgenden drei Layout-Manager und diese gen\u00fcgen v\u00f6llig f\u00fcr alle GUIs, die wir erstellen wollen: FlowLayout GridLayout BorderLayout Alle drei LayoutManager bedinden sich im java.awt -Paket, also java.awt.FlowLayout , java.awt.GridLayout und java.awt.BorderLayout .","title":"Layout-Manager"},{"location":"gui/#flowlayout","text":"FlowLayout ist der Standard-Layout-Manager f\u00fcr ein JPanel . Das hei\u00dft, wenn wir einem JPanel keinen (anderen) Layout-Manager zuweisen, ist es im FlowLayout . FlowLayout ordnet die Komponenten nebeneinander in einer Zeile an (wenn sie in eine Zeile passen \u2013 ansonsten weitere Zeile). Das Zuweisen eines Containers zum FlowLayout erfolgt mittels setLayout(new FlowLayout()); . F\u00fcr FlowLayout steht aber nicht nur der parameterlose Konstruktor zur Verf\u00fcgung, sondern auch FlowLayout(int align) , wobei f\u00fcr align folgende vordefinierte Konstanten verwendet werden k\u00f6nnen: FlowLayout.CENTER ; ordnet alle Komponenten mittig an, ist der Standard-Wert FlowLayout.LEFT ; ordnet alle Komponenten linksb\u00fcndig an FlowLayout.RIGHT ; ordnet alle Komponenten rechtsb\u00fcndig an FlowLayout(int align, int hgap, int vgap) , wobei align wie oben und hgap den horizontalen Abstand zwischen den Komponenten und vgap den vertikalen Abstand zwischen den Komponenten beschreibt Beispiele: Beim FlowLayout bleiben die Steuerelemente stets in ihrer Standardgr\u00f6\u00dfe! \u00dcbung F\u00fcgen Sie in Ihre initContent() -Methode 6 Buttons ein (wie in der oberen Abbildung). Lassen Sie das mainPanel im FlowLayout . Probieren Sie ruhig mal die verschiedenen align -Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons nicht \u00e4ndert.","title":"FlowLayout"},{"location":"gui/#gridlayout","text":"GridLayout ordnet Komponenten innerhalb eines rechteckigen Gitters (einem grid ) an. Das Zuweisen eines Containers zum GridLayout erfolgt mittels setLayout(new GridLayout(int rows, int columns)); . Dabei geben rows die Anzahl der Zeilen des Gitters und columns die Anzahl der Spalten des Gitters an. Dabei wird aber immmer zuerst versucht, ein Rechteck zur erzeugen mit der Zeilenanzahl als ma\u00dfgeblichem Wert ! Das verdeutlichen die folgenden Beispiele: F\u00fcr GridLayout gibt es noch einen weiteren parametrisierten Konstruktor, n\u00e4mlich GridLayout(int rows, int columns, int hgap, int vgap) , wobei hgap und vgap die gleiche Bedutung haben, wie beim FlowLayout . Wichtig ist, dass sich die Gr\u00f6\u00dfe der Komponenten der Gr\u00f6\u00dfe des Containes anpasst, in der die Komponenten enthalten sind. das bedeutet, dass mit der Gr\u00f6\u00dfe des Containers auch die Steuerelemente gr\u00f6\u00dfer werden! Das bedeutet, dass im Gegensatz zum FlowLayout z.B. Buttons in diesem Layout-Manager keine feste Gr\u00f6\u00dfe haben! \u00dcbung Verwenden Sie die initContent() -Methode aus der FlowLayout -\u00dcbung (mit den 6 Buttons). Weisen Sie dem mainPanel das GridLayout zu. Probieren Sie ruhig mal verschiedene rows , columns , hgap , vgap -Werte. Ver\u00e4ndern Sie mit der Maus die Gr\u00f6\u00dfe des Fensters. Beachten Sie, dass sich die Gr\u00f6\u00dfe der Buttons \u00e4ndert !","title":"GridLayout"},{"location":"gui/#borderlayout","text":"BorderLayout ist der Standard-Layout-Manager f\u00fcr ein JFrame . BorderLayout ordnet Komponenten in f\u00fcnf Felder ( North , South , East , West ) und die Mitte ( Center ) an. BorderLayout besitzt einen parameterlosen Konstruktor BoderLayout() und einen parametrisierten Konstruktor BorderLayout(int hgap, int vgap) mit hgap und vgap wie zuvor. Um Komponenten zu einem Container im BoderLayout hinzuzuf\u00fcgen, gibt es nun zwei verschiedene add() -Methoden: add(Component comp) f\u00fcgt die Komponente comp dem Center hinzu (entspricht add(comp, BorderLayout.CENTER) ), add(Component comp, Object constraints) , wobei constraints eine der folgenden vordefinierten Werte annehmen kann: BorderLayout.NORTH ; f\u00fcgt comp dem oberen Feld hinzu, BorderLayout.SOUTH ; f\u00fcgt comp dem unteren Feld hinzu, BorderLayout.EAST ; f\u00fcgt comp dem linken Feld hinzu, BorderLayout.WEST ; f\u00fcgt comp dem rechten Feld hinzu, BorderLayout.CENTER ; f\u00fcgt comp der Mitte hinzu. Angenommen, die initContent() -Methode sieht so aus: 23 24 25 26 27 28 29 30 31 32 33 34 35 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); mainPanel . add ( new JButton ( \"NORTH\" ), BorderLayout . NORTH ); mainPanel . add ( new JButton ( \"SOUTH\" ), BorderLayout . SOUTH ); mainPanel . add ( new JButton ( \"EAST\" ), BorderLayout . EAST ); mainPanel . add ( new JButton ( \"WEST\" ), BorderLayout . WEST ); mainPanel . add ( new JButton ( \"CENTER\" ), BorderLayout . CENTER ); return mainPanel ; } , dann wird folgendes Fenster erzeugt: Beachten Sie: die Nord-, S\u00fcd-Buttons behalten ihre H\u00f6he, skalieren auf Fensterbreite die Ost-, West-Buttons behalten ihre Breite, skalieren auf Fensterh\u00f6he (minus H\u00f6he f\u00fcr Norden und S\u00fcden) der Center-Button wird eingepasst (k\u00f6nnte z.B. auch ganz verschwinden) \u00dcbung Verwenden Sie die initContent() -Methode von oben (mit den 5 Buttons). Lassen Sie einzelne Buttons weg. Erkl\u00e4ren Sie jeweils das Ergebnis!","title":"BorderLayout"},{"location":"gui/#verschachteln-von-layout-managern","text":"Eigentlich ist die \u00dcberschrift irref\u00fchrend, denn es werden nicht die Layout-Manger verschachtelt, sondern die Container, denen jeweils andere Layout-Manager zugewiesen werden k\u00f6nnen. Wir wollen das an einem Beispiel demonstrieren. Wir betrachten dazu wieder nur die initContent() -Methode. Alles andere bleibt in unserem \"Grundger\u00fcst\", das wir in der Klasse MyFirstWindow erstellt haben, gleich. Wir beginnen damit, dass das mainPanel im BorderLayout ist und dass diesem mainPanel drei weitere JPanel hinzugef\u00fcgt werden. Das erste JPanel hei\u00dft oben , ist im FlowLayout und wird dem Norden des mainPanel s hinzugef\u00fcgt. Das zweite JPanel hei\u00dft mitte , ist im GridLayout und wird dem Center des mainPanel s hinzugef\u00fcgt. Das dritte JPanel hei\u00dft unten , ist im FlowLayout und wird dem S\u00fcden des mainPanel s hinzugef\u00fcgt. 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 3 , 2 , 10 , 10 )); JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 )); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( mitte , BorderLayout . CENTER ); mainPanel . add ( unten , BorderLayout . SOUTH ); return mainPanel ; } Die einzelnen JPanel sind nicht unterscheidbar, da sie keinen Rand ( Border ) besitzen und alle einen grauen Hintergrund haben. Es sind \"nur\" Container , die uns helfen, die GUI zu strukturieren. Sichtbar sind erst die Steuerelemente, die wir nun den einzelnen JPanel hinzuf\u00fcgen: 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 )); oben . add ( new JLabel ( \"Name : \" )); oben . add ( new JTextField ( 10 )); oben . setBackground ( Color . LIGHT_GRAY ); JPanel mitte = new JPanel (); mitte . setLayout ( new GridLayout ( 3 , 2 , 10 , 10 )); mitte . add ( new JButton ( \"Button 1\" )); mitte . add ( new JButton ( \"Button 2\" )); mitte . add ( new JButton ( \"Button 3\" )); mitte . add ( new JButton ( \"Button 4\" )); mitte . add ( new JButton ( \"Button 5\" )); mitte . add ( new JButton ( \"Button 6\" )); mitte . setBackground ( Color . GREEN ); JPanel unten = new JPanel (); unten . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 )); unten . add ( new JButton ( \"Abbruch\" )); unten . add ( new JButton ( \"OK\" )); unten . setBackground ( Color . LIGHT_GRAY ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( mitte , BorderLayout . CENTER ); mainPanel . add ( unten , BorderLayout . SOUTH ); return mainPanel ; } Zur besseren Erkennung wurde den einzelnen JPanel auch noch jeweils eine Hintergrundfarbe zugeordnet (Zeilen 32 , 42 und 48 ). Somit ergibt sich folgende Ansicht: Das JPanel oben ist im FlowLayout . Diesem Panel werden zwei Steuerelemente hinzugef\u00fcgt: ein JLabel ( \"Name\" ) und ein JTextField der Breite 10 (Zeichen). Da das Panel im FlowLayout ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind zentriert angeordnet ( FlowLayout.CENTER ) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von 10 Pixeln. Dem Panel wurde die Hintergrundfarbe LIGHT-GRAY zugewiesen. Das JPanel mitte ist im GridLayout mit 3 Zeilen und 2 Spalten. Diesem Panel werden 6 JButton zugeordnet. Die Buttons haben einen vertikalen und horizontalen Abstand von jeweils 10 Pixeln (zwischen den Buttons ist der Abstand also 20). Beachten Sie, dass die Gr\u00f6\u00dfe der Buttons an die Fenstergr\u00f6\u00dfe angepasst sind. Mit wachsender Fenstergr\u00f6\u00dfe wachsen auch die Button-Gr\u00f6\u00dfen. Dem Panel wurde die Hintergrundfarbe GREEN zugewiesen. Das JPanel unten ist im FlowLayout . Diesem Panel werden zwei JButton hinzugef\u00fcgt. Das das Panel im FlowLayout ist, erscheinen beide Steuerelemente nebeneinander (weil sie nebeneinander passen). Die Steuerelemente sind rechtsb\u00fcndig angeordnet ( FlowLayout.RIGHT ) und haben einen horizontalen und vertikalen Abstand zu den Nachbarn von jeweils 5 Pixeln. Beachten Sie, dass die Buttons in ihrer Standardgr\u00f6\u00dfe sind (und stets bleiben). Dem Panel wurde die Hintergrundfarbe LIGHT-GRAY zugewiesen. Noch ein Wort zu den Gr\u00f6\u00dfen: Die Gr\u00f6\u00dfe des Fensters ist mit 300 x 200 vorgegeben. Der \"Norden\" geht \u00fcber die gesamte Breite. Die H\u00f6he des \"Nordens\" ergibt sich aus den Standardh\u00f6hen von JLabel und JTextField plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils 10 Pixeln. Der \"S\u00fcden\" geht ebenfalls \u00fcber die gesamte Breite. Die H\u00f6he des \"S\u00fcdens\" ergibt sich aus der Standardh\u00f6he von JButton plus den vertikalen Abst\u00e4nden nach oben und unten von jeweils 5 Pixeln. Das Center -Feld geht ebenfalls \u00fcber die gesamte Breite, da es kein EAST - und kein WEST -Feld gibt. Die H\u00f6he des Center -Feldes ergibt sich aus der Fensterh\u00f6he minus der H\u00f6he f\u00fcr die Titelleiste, minus der H\u00f6he f\u00fcr den \"Norden\" und minus der H\u00f6he f\u00fcr den \"S\u00fcden\". Das Center -Feld f\u00fcllt also den verbleibenden Rest des Platzes im Fenster aus. Sie k\u00f6nnen beliebig viele Container in beliebiger Tiefe ineinanderschachteln und den Containern unterschiedliche Layout_Manager zuweisen. Damit gelingt ihnen jede denkbare Gestaltung grafischer Nutzeroberfl\u00e4chen. Weitere Anregungen zur Verwendung von Layout-Managern finden Sie z.B. hier . \u00dcbung \u00c4ndern Sie ausschlie\u00dflich die H\u00f6he des Fensters und dann einmal ausschlie\u00dflich die Breite des Fensters und begr\u00fcnden Sie das jeweilige Ergebnis! Success Wir haben unser erstes Fenster erstellt! Au\u00dferdem k\u00f6nnen wir dem Fenster Steuerelemente hinzuf\u00fcgen. Diese k\u00f6nnen wir mithilfe von Containern und Layout-Manager positionieren, so dass wir ordentlich positionierte Grafische Nutzeroberfl\u00e4chen erstellen k\u00f6nnen. Im n\u00e4chsten Schritt schauen wir uns an, wie wir auf Ereignisse reagieren k\u00f6nnen, z.B. auf das Klicken eines Buttons.","title":"Verschachteln von Layout-Managern"},{"location":"interfaces/","text":"Interfaces \u00b6 Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen . F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort class , sondern interface verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort extends , sondern das Schl\u00fcsselwort implements verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse beliebig viele Interfaces implementieren. Interfaces sind automatisch abstract , d.h. das Schl\u00fcsselwort abstract muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. Abtrakte Klasse Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort extends ) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort implements ), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort abstract deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort interface deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen final Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten ( static final ) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen private , protected , default und public sein in Interfaces sind alle Eigenschaften public Bsp.: public abstract class Shape{ public abstract void draw(); } Bsp.: public interface Drawable{ void draw(); } Das Interface Comparable \u00b6 Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem java.lang -Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode compareTo() . Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. Die Methode this.compareTo(Object obj) wird verwendet, um zu vergleichen, ob this gr\u00f6\u00dfer, kleiner oder gleich obj ist. Das bedeutet, dass wir compareTo() in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. Die Methode this.compareTo(Object obj) gibt ein int zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll: ist der zur\u00fcckgegebene int -Wert positiv ( > 0 ), dann ist this gr\u00f6\u00dfer als obj , ist der zur\u00fcckgegebene int -Wert negativ ( < 0 ), dann ist this kleiner als obj , ist der zur\u00fcckgegebene int -Wert 0 , dann ist this gleich obj . Angenommen, wir wollen f\u00fcr die folgende Klasse Rectangle (aus dem Abschnitt Abstrakte Klassen ) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch Shape aus Abstrakte Klassen ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Die Klasse Rectangle erbt also von der abstrakten Klasse Shape und muss deshalb die Methoden perimeter() und area() implementieren. Nun geben wir an, dass Rectangle auch das Interface Comparable implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um implements Comparable , d.h. die Klassendeklaration sieht jetzt so aus: 1 2 public class Rectangle extends Shape implements Comparable { Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object) . Es werden zwei QuickFixes angeboten, entweder Add unimplemented methods oder Make type Rectangle abstract . Letzteres wollen wir aber nicht ( Rectangle soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir Add unimplemented methods . Eclipse f\u00fcgt uns die compareTo() -Methode in den Code ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung: Comparable is a raw type. References to generic type Comparable<T> should be parameterized Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface Comparable typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse Rectangle . Wir typisieren deshalb Comparable mit Rectangle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler: The type Rectangle must implement the inherited abstract method Comparable<Rectangle>.compareTo ( Rectangle ) Dadurch, dass wir Comparable mit Rectangle typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } implementieren, sondern die Methode @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei equals(Object o) , pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein Rectangle handelt. Wir \u00e4ndern also den Parametertyp in compareTo() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } } In Zukunft typisieren wir das Comparable -Interface noch, bevor wir Add unimplemented methods w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein Rectangle -Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da compareTo() ein int zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von height und width verwenden: 23 24 25 26 27 @Override public int compareTo ( Rectangle o ) { int diff = ( this . height + this . width ) - ( o . height + o . width ); return diff ; } Wenn die Summe von height und width von this gr\u00f6\u00dfer ist, als von o , dann geben wir eine positive int -Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative int -Zahl und wenn sie gleich sind, dann 0 . Damit entsprechen wir den Vorgaben von compareTo() . Laufzeittypen eines Rectangle -Objektes \u00b6 Ein Rectangle -Objekt ist nicht nur vom Laufzeittyp Rectangle , sondern auch von Laufzeittyp Shape , wegen public class Rectangle extends Shape , vom Laufzeittyp Comparable , wegen public class Rectangle implements Comparable und vom Laufzeittyp Object , weil das immer so ist, weil jede Klasse implizit von Object erbt. Wir k\u00f6nnten nun also in jeder beliebigen Klasse eine Sortiermethode haben, z.B.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void sortieren ( Comparable [] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo ( unsorted [ index + 1 ] ) > 0 ) { Comparable tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } Die Methode implementiert Bubble-Sort. In Zeile 7 verwenden wir die compareTo() -Methode. Das geht genau deshalb, weil klar ist, dass ein Objekt, das (auch) vom Typ Comparable ist, diese Methode auf jeden Fall als Eigenschaft besitzt. Wenn wir nun in der Klasse, in der die Methode sortieren() implementiert ist, folgende main() -Methode haben: public static void main ( String [] args ) { Rectangle [] rectArr = new Rectangle [ 6 ] ; rectArr [ 0 ] = new Rectangle ( 9 , 13 ); rectArr [ 1 ] = new Rectangle ( 4 , 17 ); rectArr [ 2 ] = new Rectangle ( 12 , 5 ); rectArr [ 3 ] = new Rectangle ( 8 , 9 ); rectArr [ 4 ] = new Rectangle ( 10 , 11 ); rectArr [ 5 ] = new Rectangle ( 5 , 15 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( rectArr ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } } dann erhalten wir folgende Ausgabe: ------------------------ unsortiert -------------------------- [ 9 x 13 = 117 ,00 ] [ 4 x 17 = 68 ,00 ] [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 10 x 11 = 110 ,00 ] [ 5 x 15 = 75 ,00 ] ------------------------- sortiert --------------------------- [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 5 x 15 = 75 ,00 ] [ 4 x 17 = 68 ,00 ] [ 10 x 11 = 110 ,00 ] [ 9 x 13 = 117 ,00 ] f\u00fcr den Fall, dass wir in unserer Klasse Rectangle auch die toString() -Methode wie folgt implementiert haben: @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } Success Wir haben f\u00fcr unsere Klasse Rectangle das Interface Comparable implementiert. Das bedeutet, dass wir in Rectangle die Methode compareTo() so implementiert haben, dass Rectangle -Objekte der Gr\u00f6\u00dfe nach sortiert werden k\u00f6nnen. Wir haben also eine Ordnung \u00fcber Rectangle -Objekte definiert. Nach \"au\u00dfen\" ist sichtbar, dass wir eine solche Ordnung implementiert haben, dass Rectangle -Objekte also sortierbar sind, weil sie (auch) vom Typ Comparable sind. F\u00fcr alle Objekte, die in Java existieren, wissen wir, dass sie sortierbar sind, sobald sie auch vom Typ Comparable sind. Comparable stellt also eine Schnittstelle zur Sortierbarkeit dar. Wenn wir eine eigene Klasse schreiben und wir eine Ordnung \u00fcber die Objekte dieser Klasse definieren k\u00f6nnen, sollten wir das Interface Comparable implementieren, denn dadurch geben wir nach \"au\u00dfen\" an, dass sich die Objekte der Klasse sortieren ( ordnen ) lassen. Zwischenfazit \u00b6 Wir haben nun schon mehrere Methoden kennengelernt, die wir f\u00fcr eigene Klassen implementieren sollten. Die toString() -Methode erben wir von Objects . Wir sollten toString() f\u00fcr \"unsere\" Klassen \u00fcberschreiben, damit wir eine textuelle Repr\u00e4sentation unserer Objekte haben. toString() wird implizit angewendet, sobald eine String -Repr\u00e4sentation erforderlich ist, z.B. ist System.out.println(refVariable); das Gleiche wie System.out.println(refVariable.toString()); . Die equals() -Methode erben wir ebenfalls von Objects . Wir sollten equals() f\u00fcr \"unsere\" Klassen implementieren, um zu definieren, wann Objekte \"unserer\" Klasse gleich sind. Hierbei ist wichtig, zu beachten, dass refVar1 == refVar2 ein reiner Referenzvergleich ist, der nichts dar\u00fcber aussagt, ob die Objekte gleich sind, sondern nur ein true ergibt, wenn beide Variablen auf dasselbe Objekt zeigen. Die Gleichheit von Objekten wird mittels equals() -Methode definiert. Die hashCode() -Methode erben wir ebenfalls von Objects . Wir sollten hashCode() genau dann implementieren, wenn wir equals() implementieren. Wichtig ist, dass zwei Objekte den gleichen Hash-Code haben ( hashCode() liefert den gleichen int -Wert zur\u00fcck), wenn die beiden Objekte laut equals() gleich sind. Gut ist dar\u00fcber hinaus (aber nicht Bedingung), dass zwei Objekte einen unterschiedlichen Hash-Code haben, wenn sie laut equals() -Methode nicht gleich sind ( equals() liefert false zur\u00fcck). Der Hash-Code wird bei Hash-basierten Datentypen, wie z.B. Collections verwendet, um diese einzusortieren. Die Methode compareTo() muss implementiert werden, wenn wir das Interface Comparable implementieren. Mithilfe von compareTo() legen wir eine Ordnung \u00fcber die Objekte der Klasse fest, d.h. wir geben an, wann ein Objekt gr\u00f6\u00dfer/kleiner/gleich einem anderen Objekt der gleichen Klasse ist. Dadurch, dass wir das Comparable -Interface implementieren, zeigen wir nach \"au\u00dfen\", dass die Objekte unserer Klasse sortierbar sind. Eine bessere Implementierung \u00b6 Wir haben bereits bei der Implementierung der Klasse Rectangle gesehen, dass wir das Interface Comparable bei der Implementierung von Rectangle typisieren sollten. Das w\u00e4re f\u00fcr eine wirklich korrekte Implementierung der Methode sortieren() ebenfalls angebracht. Dann w\u00fcrden wir in dieser Methode Comparable mit Rectangle typisieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void sortieren ( Comparable < Rectangle >[] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Rectangle ) unsorted [ index + 1 ] ) > 0 ) { Comparable < Rectangle > tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } Wenn wir also den Typ Comparable verwenden, dann erg\u00e4nzen wir ihn um die Typisierung <Rectangle> (Zeilen 1 und 9 ). Das f\u00fchrt allerdings dazu, dass wir dann auch in Zeile 7 den Typ von unsorted[index+1] nach Rectangle konvertieren m\u00fcssen ( (Rectangle) unsorted[index+1] ). Damit verlieren wir aber unsere allgemeine Anwendbarkeit der Methode sortieren() f\u00fcr alle Klassen, die Comparable implementiert haben. Insbesondere w\u00fcrde die Methode dann nicht mehr f\u00fcr z.B. die Klasse Circle anwendbar sein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Circle extends Shape implements Comparable < Circle > { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public int compareTo ( Circle o ) { if ( this . radius > o . radius ) return 1 ; else if ( this . radius < o . radius ) return - 1 ; else return 0 ; // this.radius == o.radius } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Wenn wir nun versuchen w\u00fcrden, die sortieren() -Methode auf ein Circle[] anzuwenden, lie\u00dfe sich das Programm gar nicht compilieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void main ( String [] args ) { Circle [] circArr = new Circle [ 6 ] ; circArr [ 0 ] = new Circle ( 5.0 ); circArr [ 1 ] = new Circle ( 5.5 ); circArr [ 2 ] = new Circle ( 4.0 ); circArr [ 3 ] = new Circle ( 2.5 ); circArr [ 4 ] = new Circle ( 7.0 ); circArr [ 5 ] = new Circle ( 1.0 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); // sortieren(circArr); // Fehler for ( Circle c : circArr ) { System . out . println ( c . toString ()); } } Deshalb w\u00e4re es eine bessere Implementierung , wenn wir das Interface Comparable nicht in den konkreten Klassen Rectangle und Circle (und in jeder weiteren Klasse, die wir auf der Basis von Shape erstellen) implementieren, sondern gleich in der Abstrakten Klasse Shape : public abstract class Shape implements Comparable < Shape > { public abstract double perimeter (); public abstract double area (); } Da Shape eine abstrakte Klasse ist, muss die Methode compareTo() nicht in Shape implementiert werden. Diese Methode w\u00fcrde nun abstract an alle Klassen vererbt, die von Shape erben: Rectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Shape o ) { Rectangle r = ( Rectangle ) o ; int diff = ( this . height + this . width ) - ( r . height + r . width ); return diff ; } @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public int compareTo ( Shape o ) { Circle c = ( Circle ) o ; if ( this . radius > c . radius ) return 1 ; else if ( this . radius < c . radius ) return - 1 ; else return 0 ; // this.radius == c.radius } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Beachten Sie, dass die Klassen Rectangle und Circle jetzt nur noch von Shape erben, aber nicht mehr das Interface Comparable implementieren (jeweils Zeile 1 ). Es darf nicht mehrmals von einer Klasse implementiert werden und Shape implementiert es ja bereits. Da Shape diese Interface aber implementiert , wird die Methode compareTo() als abstrakte Methode an die Klassen Rectangle und Circle vererbt. Die Methode muss also von diesen Klassen implementiert werden. Nun wird sie aber mit dem Parametertyp Shape vererbt (Zeile 24 in Rectangle.java bzw. 23 in Circle.java ). Dieser Parameter muss deshalb zun\u00e4chst innerhalb der Methode compareTo() konvertiert werden (Zeile 25 in Circle.java bzw. 26 in Rectangle.java ). Die allgemeine Anwendung der Methode sortieren() in der Testklasse gelingt nun aber: TestklasseShape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class TestklasseShape { public static void sortieren ( Comparable < Shape >[] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Shape ) unsorted [ index + 1 ] ) > 0 ) { Comparable < Shape > tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } public static void main ( String [] args ) { Rectangle [] rectArr = new Rectangle [ 6 ] ; rectArr [ 0 ] = new Rectangle ( 9 , 13 ); rectArr [ 1 ] = new Rectangle ( 4 , 17 ); rectArr [ 2 ] = new Rectangle ( 12 , 5 ); rectArr [ 3 ] = new Rectangle ( 8 , 9 ); rectArr [ 4 ] = new Rectangle ( 10 , 11 ); rectArr [ 5 ] = new Rectangle ( 5 , 15 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( rectArr ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } Circle [] circArr = new Circle [ 6 ] ; circArr [ 0 ] = new Circle ( 5.0 ); circArr [ 1 ] = new Circle ( 5.5 ); circArr [ 2 ] = new Circle ( 4.0 ); circArr [ 3 ] = new Circle ( 2.5 ); circArr [ 4 ] = new Circle ( 7.0 ); circArr [ 5 ] = new Circle ( 1.0 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( circArr ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } } } Wir k\u00f6nnen nun alle Objekte sortieren lassen, die auf der Klasse Shape basieren. ------------------------ unsortiert -------------------------- [ 9 x 13 = 117 ,00 ] [ 4 x 17 = 68 ,00 ] [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 10 x 11 = 110 ,00 ] [ 5 x 15 = 75 ,00 ] ------------------------- sortiert --------------------------- [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 5 x 15 = 75 ,00 ] [ 4 x 17 = 68 ,00 ] [ 10 x 11 = 110 ,00 ] [ 9 x 13 = 117 ,00 ] ------------------------ unsortiert -------------------------- ( radius: 5 ,00 -> area: 78 ,54 ] ( radius: 5 ,50 -> area: 95 ,03 ] ( radius: 4 ,00 -> area: 50 ,27 ] ( radius: 2 ,50 -> area: 19 ,63 ] ( radius: 7 ,00 -> area: 153 ,94 ] ( radius: 1 ,00 -> area: 3 ,14 ] ------------------------- sortiert --------------------------- ( radius: 1 ,00 -> area: 3 ,14 ] ( radius: 2 ,50 -> area: 19 ,63 ] ( radius: 4 ,00 -> area: 50 ,27 ] ( radius: 5 ,00 -> area: 78 ,54 ] ( radius: 5 ,50 -> area: 95 ,03 ] ( radius: 7 ,00 -> area: 153 ,94 ] Eine noch bessere Implementierung \u00b6 Obwohl wir nun in Shape das Interface Comparable implementieren, geben wir die Verantwortung der Implementierung der Methode compareTo() an die konkreten Klassen Rectangle und Circle weiter. Es stellt sich die Frage, ob sich die compareTo() -Methode nicht bereits in Shape implementieren lie\u00dfe. Die Antwort auf diese Frage sollte ja lauten, denn ansonsten sollten wir das Interface gar nicht bereits durch die abstrakte Klasse Shape implementieren lassen. Wir haben in Shape gen\u00fcgend Informationen, um die compareTo() -Methode zu implementieren. Wir k\u00f6nnen daf\u00fcr entweder perimeter() oder area() verwenden. Wir entscheiden uns f\u00fcr die Verwendung von area() : Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public abstract class Shape implements Comparable < Shape > { public abstract double perimeter (); public abstract double area (); @Override public int compareTo ( Shape o ) { return ( this . area () - o . area ()); } } In abstrakten Klassen m\u00fcssen nicht, im Gegensatz zu Interfaces, alle Methoden abstrakt sein. Es k\u00f6nnen auch Methoden bereits implementiert werden. Diese Methoden m\u00fcssen dann nicht mehr in den Klassen implementiert werden, die von der abstrakten Klasse erben. Die Klassen Rectangle und Circle ben\u00f6tigen also keine eigene Implementierung der compareTo() -Methode mehr: Rectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Wir haben ausgenutzt, dass in der Klasse Shape bereits gen\u00fcgend Informationen vorliegen, um die Methode compareTo() korrekt f\u00fcr alle Klassen zu implementieren, die von Shape erben. Diese Methode muss dann von diesen konkreten Klassen nicht mehr implementiert werden. Wir vermeiden so doppelten Code. Die testklasseShape bleibt unver\u00e4ndert f\u00fcr alle abgeleiteten Klassen aus Shape anwendbar.","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen . F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort class , sondern interface verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort extends , sondern das Schl\u00fcsselwort implements verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse beliebig viele Interfaces implementieren. Interfaces sind automatisch abstract , d.h. das Schl\u00fcsselwort abstract muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. Abtrakte Klasse Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort extends ) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort implements ), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort abstract deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort interface deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen final Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten ( static final ) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen private , protected , default und public sein in Interfaces sind alle Eigenschaften public Bsp.: public abstract class Shape{ public abstract void draw(); } Bsp.: public interface Drawable{ void draw(); }","title":"Interfaces"},{"location":"interfaces/#das-interface-comparable","text":"Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem java.lang -Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode compareTo() . Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. Die Methode this.compareTo(Object obj) wird verwendet, um zu vergleichen, ob this gr\u00f6\u00dfer, kleiner oder gleich obj ist. Das bedeutet, dass wir compareTo() in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. Die Methode this.compareTo(Object obj) gibt ein int zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll: ist der zur\u00fcckgegebene int -Wert positiv ( > 0 ), dann ist this gr\u00f6\u00dfer als obj , ist der zur\u00fcckgegebene int -Wert negativ ( < 0 ), dann ist this kleiner als obj , ist der zur\u00fcckgegebene int -Wert 0 , dann ist this gleich obj . Angenommen, wir wollen f\u00fcr die folgende Klasse Rectangle (aus dem Abschnitt Abstrakte Klassen ) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch Shape aus Abstrakte Klassen ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Die Klasse Rectangle erbt also von der abstrakten Klasse Shape und muss deshalb die Methoden perimeter() und area() implementieren. Nun geben wir an, dass Rectangle auch das Interface Comparable implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um implements Comparable , d.h. die Klassendeklaration sieht jetzt so aus: 1 2 public class Rectangle extends Shape implements Comparable { Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object) . Es werden zwei QuickFixes angeboten, entweder Add unimplemented methods oder Make type Rectangle abstract . Letzteres wollen wir aber nicht ( Rectangle soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir Add unimplemented methods . Eclipse f\u00fcgt uns die compareTo() -Methode in den Code ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung: Comparable is a raw type. References to generic type Comparable<T> should be parameterized Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface Comparable typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse Rectangle . Wir typisieren deshalb Comparable mit Rectangle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler: The type Rectangle must implement the inherited abstract method Comparable<Rectangle>.compareTo ( Rectangle ) Dadurch, dass wir Comparable mit Rectangle typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } implementieren, sondern die Methode @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei equals(Object o) , pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein Rectangle handelt. Wir \u00e4ndern also den Parametertyp in compareTo() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } } In Zukunft typisieren wir das Comparable -Interface noch, bevor wir Add unimplemented methods w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein Rectangle -Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da compareTo() ein int zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von height und width verwenden: 23 24 25 26 27 @Override public int compareTo ( Rectangle o ) { int diff = ( this . height + this . width ) - ( o . height + o . width ); return diff ; } Wenn die Summe von height und width von this gr\u00f6\u00dfer ist, als von o , dann geben wir eine positive int -Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative int -Zahl und wenn sie gleich sind, dann 0 . Damit entsprechen wir den Vorgaben von compareTo() .","title":"Das Interface Comparable"},{"location":"interfaces/#laufzeittypen-eines-rectangle-objektes","text":"Ein Rectangle -Objekt ist nicht nur vom Laufzeittyp Rectangle , sondern auch von Laufzeittyp Shape , wegen public class Rectangle extends Shape , vom Laufzeittyp Comparable , wegen public class Rectangle implements Comparable und vom Laufzeittyp Object , weil das immer so ist, weil jede Klasse implizit von Object erbt. Wir k\u00f6nnten nun also in jeder beliebigen Klasse eine Sortiermethode haben, z.B.: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void sortieren ( Comparable [] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo ( unsorted [ index + 1 ] ) > 0 ) { Comparable tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } Die Methode implementiert Bubble-Sort. In Zeile 7 verwenden wir die compareTo() -Methode. Das geht genau deshalb, weil klar ist, dass ein Objekt, das (auch) vom Typ Comparable ist, diese Methode auf jeden Fall als Eigenschaft besitzt. Wenn wir nun in der Klasse, in der die Methode sortieren() implementiert ist, folgende main() -Methode haben: public static void main ( String [] args ) { Rectangle [] rectArr = new Rectangle [ 6 ] ; rectArr [ 0 ] = new Rectangle ( 9 , 13 ); rectArr [ 1 ] = new Rectangle ( 4 , 17 ); rectArr [ 2 ] = new Rectangle ( 12 , 5 ); rectArr [ 3 ] = new Rectangle ( 8 , 9 ); rectArr [ 4 ] = new Rectangle ( 10 , 11 ); rectArr [ 5 ] = new Rectangle ( 5 , 15 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( rectArr ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } } dann erhalten wir folgende Ausgabe: ------------------------ unsortiert -------------------------- [ 9 x 13 = 117 ,00 ] [ 4 x 17 = 68 ,00 ] [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 10 x 11 = 110 ,00 ] [ 5 x 15 = 75 ,00 ] ------------------------- sortiert --------------------------- [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 5 x 15 = 75 ,00 ] [ 4 x 17 = 68 ,00 ] [ 10 x 11 = 110 ,00 ] [ 9 x 13 = 117 ,00 ] f\u00fcr den Fall, dass wir in unserer Klasse Rectangle auch die toString() -Methode wie folgt implementiert haben: @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } Success Wir haben f\u00fcr unsere Klasse Rectangle das Interface Comparable implementiert. Das bedeutet, dass wir in Rectangle die Methode compareTo() so implementiert haben, dass Rectangle -Objekte der Gr\u00f6\u00dfe nach sortiert werden k\u00f6nnen. Wir haben also eine Ordnung \u00fcber Rectangle -Objekte definiert. Nach \"au\u00dfen\" ist sichtbar, dass wir eine solche Ordnung implementiert haben, dass Rectangle -Objekte also sortierbar sind, weil sie (auch) vom Typ Comparable sind. F\u00fcr alle Objekte, die in Java existieren, wissen wir, dass sie sortierbar sind, sobald sie auch vom Typ Comparable sind. Comparable stellt also eine Schnittstelle zur Sortierbarkeit dar. Wenn wir eine eigene Klasse schreiben und wir eine Ordnung \u00fcber die Objekte dieser Klasse definieren k\u00f6nnen, sollten wir das Interface Comparable implementieren, denn dadurch geben wir nach \"au\u00dfen\" an, dass sich die Objekte der Klasse sortieren ( ordnen ) lassen.","title":"Laufzeittypen eines Rectangle-Objektes"},{"location":"interfaces/#zwischenfazit","text":"Wir haben nun schon mehrere Methoden kennengelernt, die wir f\u00fcr eigene Klassen implementieren sollten. Die toString() -Methode erben wir von Objects . Wir sollten toString() f\u00fcr \"unsere\" Klassen \u00fcberschreiben, damit wir eine textuelle Repr\u00e4sentation unserer Objekte haben. toString() wird implizit angewendet, sobald eine String -Repr\u00e4sentation erforderlich ist, z.B. ist System.out.println(refVariable); das Gleiche wie System.out.println(refVariable.toString()); . Die equals() -Methode erben wir ebenfalls von Objects . Wir sollten equals() f\u00fcr \"unsere\" Klassen implementieren, um zu definieren, wann Objekte \"unserer\" Klasse gleich sind. Hierbei ist wichtig, zu beachten, dass refVar1 == refVar2 ein reiner Referenzvergleich ist, der nichts dar\u00fcber aussagt, ob die Objekte gleich sind, sondern nur ein true ergibt, wenn beide Variablen auf dasselbe Objekt zeigen. Die Gleichheit von Objekten wird mittels equals() -Methode definiert. Die hashCode() -Methode erben wir ebenfalls von Objects . Wir sollten hashCode() genau dann implementieren, wenn wir equals() implementieren. Wichtig ist, dass zwei Objekte den gleichen Hash-Code haben ( hashCode() liefert den gleichen int -Wert zur\u00fcck), wenn die beiden Objekte laut equals() gleich sind. Gut ist dar\u00fcber hinaus (aber nicht Bedingung), dass zwei Objekte einen unterschiedlichen Hash-Code haben, wenn sie laut equals() -Methode nicht gleich sind ( equals() liefert false zur\u00fcck). Der Hash-Code wird bei Hash-basierten Datentypen, wie z.B. Collections verwendet, um diese einzusortieren. Die Methode compareTo() muss implementiert werden, wenn wir das Interface Comparable implementieren. Mithilfe von compareTo() legen wir eine Ordnung \u00fcber die Objekte der Klasse fest, d.h. wir geben an, wann ein Objekt gr\u00f6\u00dfer/kleiner/gleich einem anderen Objekt der gleichen Klasse ist. Dadurch, dass wir das Comparable -Interface implementieren, zeigen wir nach \"au\u00dfen\", dass die Objekte unserer Klasse sortierbar sind.","title":"Zwischenfazit"},{"location":"interfaces/#eine-bessere-implementierung","text":"Wir haben bereits bei der Implementierung der Klasse Rectangle gesehen, dass wir das Interface Comparable bei der Implementierung von Rectangle typisieren sollten. Das w\u00e4re f\u00fcr eine wirklich korrekte Implementierung der Methode sortieren() ebenfalls angebracht. Dann w\u00fcrden wir in dieser Methode Comparable mit Rectangle typisieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void sortieren ( Comparable < Rectangle >[] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Rectangle ) unsorted [ index + 1 ] ) > 0 ) { Comparable < Rectangle > tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } Wenn wir also den Typ Comparable verwenden, dann erg\u00e4nzen wir ihn um die Typisierung <Rectangle> (Zeilen 1 und 9 ). Das f\u00fchrt allerdings dazu, dass wir dann auch in Zeile 7 den Typ von unsorted[index+1] nach Rectangle konvertieren m\u00fcssen ( (Rectangle) unsorted[index+1] ). Damit verlieren wir aber unsere allgemeine Anwendbarkeit der Methode sortieren() f\u00fcr alle Klassen, die Comparable implementiert haben. Insbesondere w\u00fcrde die Methode dann nicht mehr f\u00fcr z.B. die Klasse Circle anwendbar sein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Circle extends Shape implements Comparable < Circle > { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public int compareTo ( Circle o ) { if ( this . radius > o . radius ) return 1 ; else if ( this . radius < o . radius ) return - 1 ; else return 0 ; // this.radius == o.radius } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Wenn wir nun versuchen w\u00fcrden, die sortieren() -Methode auf ein Circle[] anzuwenden, lie\u00dfe sich das Programm gar nicht compilieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static void main ( String [] args ) { Circle [] circArr = new Circle [ 6 ] ; circArr [ 0 ] = new Circle ( 5.0 ); circArr [ 1 ] = new Circle ( 5.5 ); circArr [ 2 ] = new Circle ( 4.0 ); circArr [ 3 ] = new Circle ( 2.5 ); circArr [ 4 ] = new Circle ( 7.0 ); circArr [ 5 ] = new Circle ( 1.0 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); // sortieren(circArr); // Fehler for ( Circle c : circArr ) { System . out . println ( c . toString ()); } } Deshalb w\u00e4re es eine bessere Implementierung , wenn wir das Interface Comparable nicht in den konkreten Klassen Rectangle und Circle (und in jeder weiteren Klasse, die wir auf der Basis von Shape erstellen) implementieren, sondern gleich in der Abstrakten Klasse Shape : public abstract class Shape implements Comparable < Shape > { public abstract double perimeter (); public abstract double area (); } Da Shape eine abstrakte Klasse ist, muss die Methode compareTo() nicht in Shape implementiert werden. Diese Methode w\u00fcrde nun abstract an alle Klassen vererbt, die von Shape erben: Rectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Shape o ) { Rectangle r = ( Rectangle ) o ; int diff = ( this . height + this . width ) - ( r . height + r . width ); return diff ; } @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public int compareTo ( Shape o ) { Circle c = ( Circle ) o ; if ( this . radius > c . radius ) return 1 ; else if ( this . radius < c . radius ) return - 1 ; else return 0 ; // this.radius == c.radius } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Beachten Sie, dass die Klassen Rectangle und Circle jetzt nur noch von Shape erben, aber nicht mehr das Interface Comparable implementieren (jeweils Zeile 1 ). Es darf nicht mehrmals von einer Klasse implementiert werden und Shape implementiert es ja bereits. Da Shape diese Interface aber implementiert , wird die Methode compareTo() als abstrakte Methode an die Klassen Rectangle und Circle vererbt. Die Methode muss also von diesen Klassen implementiert werden. Nun wird sie aber mit dem Parametertyp Shape vererbt (Zeile 24 in Rectangle.java bzw. 23 in Circle.java ). Dieser Parameter muss deshalb zun\u00e4chst innerhalb der Methode compareTo() konvertiert werden (Zeile 25 in Circle.java bzw. 26 in Rectangle.java ). Die allgemeine Anwendung der Methode sortieren() in der Testklasse gelingt nun aber: TestklasseShape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class TestklasseShape { public static void sortieren ( Comparable < Shape >[] unsorted ) { for ( int bubble = 1 ; bubble < unsorted . length ; bubble ++ ) { for ( int index = 0 ; index < unsorted . length - bubble ; index ++ ) { if ( unsorted [ index ] . compareTo (( Shape ) unsorted [ index + 1 ] ) > 0 ) { Comparable < Shape > tmp = unsorted [ index ] ; unsorted [ index ] = unsorted [ index + 1 ] ; unsorted [ index + 1 ] = tmp ; } } } } public static void main ( String [] args ) { Rectangle [] rectArr = new Rectangle [ 6 ] ; rectArr [ 0 ] = new Rectangle ( 9 , 13 ); rectArr [ 1 ] = new Rectangle ( 4 , 17 ); rectArr [ 2 ] = new Rectangle ( 12 , 5 ); rectArr [ 3 ] = new Rectangle ( 8 , 9 ); rectArr [ 4 ] = new Rectangle ( 10 , 11 ); rectArr [ 5 ] = new Rectangle ( 5 , 15 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( rectArr ); for ( Rectangle r : rectArr ) { System . out . println ( r . toString ()); } Circle [] circArr = new Circle [ 6 ] ; circArr [ 0 ] = new Circle ( 5.0 ); circArr [ 1 ] = new Circle ( 5.5 ); circArr [ 2 ] = new Circle ( 4.0 ); circArr [ 3 ] = new Circle ( 2.5 ); circArr [ 4 ] = new Circle ( 7.0 ); circArr [ 5 ] = new Circle ( 1.0 ); System . out . printf ( \"%n%n------------------------ unsortiert --------------------------%n%n\" ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } System . out . printf ( \"%n%n------------------------- sortiert ---------------------------%n%n\" ); sortieren ( circArr ); for ( Circle c : circArr ) { System . out . println ( c . toString ()); } } } Wir k\u00f6nnen nun alle Objekte sortieren lassen, die auf der Klasse Shape basieren. ------------------------ unsortiert -------------------------- [ 9 x 13 = 117 ,00 ] [ 4 x 17 = 68 ,00 ] [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 10 x 11 = 110 ,00 ] [ 5 x 15 = 75 ,00 ] ------------------------- sortiert --------------------------- [ 12 x 5 = 60 ,00 ] [ 8 x 9 = 72 ,00 ] [ 5 x 15 = 75 ,00 ] [ 4 x 17 = 68 ,00 ] [ 10 x 11 = 110 ,00 ] [ 9 x 13 = 117 ,00 ] ------------------------ unsortiert -------------------------- ( radius: 5 ,00 -> area: 78 ,54 ] ( radius: 5 ,50 -> area: 95 ,03 ] ( radius: 4 ,00 -> area: 50 ,27 ] ( radius: 2 ,50 -> area: 19 ,63 ] ( radius: 7 ,00 -> area: 153 ,94 ] ( radius: 1 ,00 -> area: 3 ,14 ] ------------------------- sortiert --------------------------- ( radius: 1 ,00 -> area: 3 ,14 ] ( radius: 2 ,50 -> area: 19 ,63 ] ( radius: 4 ,00 -> area: 50 ,27 ] ( radius: 5 ,00 -> area: 78 ,54 ] ( radius: 5 ,50 -> area: 95 ,03 ] ( radius: 7 ,00 -> area: 153 ,94 ]","title":"Eine bessere Implementierung"},{"location":"interfaces/#eine-noch-bessere-implementierung","text":"Obwohl wir nun in Shape das Interface Comparable implementieren, geben wir die Verantwortung der Implementierung der Methode compareTo() an die konkreten Klassen Rectangle und Circle weiter. Es stellt sich die Frage, ob sich die compareTo() -Methode nicht bereits in Shape implementieren lie\u00dfe. Die Antwort auf diese Frage sollte ja lauten, denn ansonsten sollten wir das Interface gar nicht bereits durch die abstrakte Klasse Shape implementieren lassen. Wir haben in Shape gen\u00fcgend Informationen, um die compareTo() -Methode zu implementieren. Wir k\u00f6nnen daf\u00fcr entweder perimeter() oder area() verwenden. Wir entscheiden uns f\u00fcr die Verwendung von area() : Shape.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public abstract class Shape implements Comparable < Shape > { public abstract double perimeter (); public abstract double area (); @Override public int compareTo ( Shape o ) { return ( this . area () - o . area ()); } } In abstrakten Klassen m\u00fcssen nicht, im Gegensatz zu Interfaces, alle Methoden abstrakt sein. Es k\u00f6nnen auch Methoden bereits implementiert werden. Diese Methoden m\u00fcssen dann nicht mehr in den Klassen implementiert werden, die von der abstrakten Klasse erben. Die Klassen Rectangle und Circle ben\u00f6tigen also keine eigene Implementierung der compareTo() -Methode mehr: Rectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public String toString () { String s = String . format ( \"[ %2d x %2d = %6.2f ] \" , this . width , this . height , this . area ()); return s ; } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } @Override public String toString () { String s = String . format ( \"(radius: %.2f -> area: %.2f ] \" , this . radius , this . area ()); return s ; } } Wir haben ausgenutzt, dass in der Klasse Shape bereits gen\u00fcgend Informationen vorliegen, um die Methode compareTo() korrekt f\u00fcr alle Klassen zu implementieren, die von Shape erben. Diese Methode muss dann von diesen konkreten Klassen nicht mehr implementiert werden. Wir vermeiden so doppelten Code. Die testklasseShape bleibt unver\u00e4ndert f\u00fcr alle abgeleiteten Klassen aus Shape anwendbar.","title":"Eine noch bessere Implementierung"},{"location":"junit/","text":"JUnit-Tests \u00b6 Testen von Programmen ist wichtig. Ohne Testen ist es kaum m\u00f6glich, Fehler in Programmen zu entdecken. Bis jetzt haben wir unsere Programme immer durch reines Anwenden getestet, d.h. wir haben die implementierten Methoden aufgerufen und ihnen unterschiedliche Parameterwerte \u00fcbergeben. Wir werden das jetzt \u00e4ndern und nutzen daf\u00fcr JUnit . Allgemeines zum (Unit-)Testen \u00b6 Der ber\u00fchmte Informatiker Edsger W. Dijkstra hat \u00fcber das Testen gesagt: Durch Testen kann man stets nur die Anwesenheit, nie aber die Abwesenheit von Fehlern beweisen Das bedeutet, wir k\u00f6nnen durch das Testen Fehler finden. Wenn wir aber keine finden, dann wissen wir nicht, ob das Programm dann auch keine Fehler mehr enth\u00e4lt. Es ist leider nicht m\u00f6glich, grunds\u00e4tzlich die Fehlerfreiheit von Programmen zu pr\u00fcfen. Aber das Testen stellt ein wichtiges Werkzeug dar, um Fehler zu entdecken. Es gibt verschiedene Arten von Tests: In der Abbildung erkennen wir, dass die Unit-tests, die wir hier kennenlernen wollen, am besten automatisierbar, am h\u00e4ufigsten und am einfachsten sind. Mit Unit-Tests k\u00f6nnen wir Methoden und Klassen testen, wobei wir die Tests implementieren. Die Idee ist, dass wir funktionale Einzelteile eines Programms separat und isoliert vom Rest auf ihre Korrektheit hin \u00fcberpr\u00fcfen. Wir versuchen extra, so wenig wie m\u00f6glich die Effekte anderer Funktionalit\u00e4ten bzw. Komponenten in die Tests einflie\u00dfen zu lassen. Das erfolgt dann in den Komponenten- bzw. Integrationstests. Das hat zwei Vorteile: einerseits ist der zu pr\u00fcfende Funktionsumfang \u00fcberschaubar und andererseits k\u00f6nnen diese Unit-Tests leicht automatisiert ausgef\u00fchrt werden. Es gibt, wie bereits eingangs erw\u00e4hnt, keine Garantie von Fehlerfreiheit. Ein Nachteil der Unit-Tests besteht darin, dass sie schwierig f\u00fcr Methoden zu gestalten sind, in denen es Abh\u00e4ngigkeiten von der Laufzeitumgebung oder anderen Komponenten gibt. JUnit \u00b6 F\u00fcr das Unit-Testen von Java-Programmen gibt es das Werkzeug JUnit . Wir zeigen die Verwendung von JUnit an einem einf\u00fchrenden Beispiel. Angenommen, wir haben folgende kleine Javaklasse Fakultaet : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Fakultaet { public long fakultaet ( int number ) throws IllegalArgumentException { if ( number < 1 ) { throw new IllegalArgumentException ( \"Zahl muss groesser gleich 1 sein!\" ); } long result = 1 ; for ( int i = 2 ; i <= number ; i ++ ) { long tmp = result ; result *= i ; if ( tmp > result ) { throw new IllegalArgumentException ( \"Overflow!\" ); } } return result ; } public void print ( int number ) { System . out . printf ( \"%3d! = %,d %n\" , number , fakultaet ( number )); } } Diese Klasse enth\u00e4lt eine Methode fakultaet() , welche ein int als Eingabeparameter erwartet und den Wert der Fakult\u00e4tsberechnung als long zur\u00fcckgibt. Ist der Eingabewert kleiner als 1 wird eine IllegalArgumentException geworfen. Tritt w\u00e4hrend der Berechnung der Fakult\u00e4t ein Wertebereichs\u00fcberlauf auf (der gr\u00f6\u00dfte Wert in long ist 9,223,372,036,854,775,807 ), dann wird ebenfalls eine IllegalArgumentException geworfen. Die print() -Methode gibt die Berechnung geeignet aus. Angenommen, eine main() -Methode (oder eine andere) w\u00fcrde die Klasse in der folgenden Form verwenden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { Fakultaet f1 = new Fakultaet (); int nr = 0 ; while ( nr < 22 ) { try { f1 . print ( nr ); } catch ( IllegalArgumentException e ) { System . out . println ( \"number = \" + nr + \" : \" + e . getMessage ()); } nr ++ ; } } , dann w\u00e4re die Ausgabe: number = 0 : Zahl muss gr\u00f6\u00dfer gleich 1 sein! 1 ! = 1 2 ! = 2 3 ! = 6 4 ! = 24 5 ! = 120 6 ! = 720 7 ! = 5 .040 8 ! = 40 .320 9 ! = 362 .880 10 ! = 3 .628.800 11 ! = 39 .916.800 12 ! = 479 .001.600 13 ! = 6 .227.020.800 14 ! = 87 .178.291.200 15 ! = 1 .307.674.368.000 16 ! = 20 .922.789.888.000 17 ! = 355 .687.428.096.000 18 ! = 6 .402.373.705.728.000 19 ! = 121 .645.100.408.832.000 20 ! = 2 .432.902.008.176.640.000 number = 21 : Overflow! Wir wollen diese Klasse Fakultaet nun mithilfe von JUnit testen. Dazu w\u00e4hlen wir File --> New --> JUnit Test Case : Es erscheint folgender Dialog: Beachten Sie, dass unter Class under test: die Klasse Fakultaet eingetragen ist (oder Sie geben Sie dort ein). Der Name der Klasse wird mit FakultaetTest vorgeschlagen. Beachten Sie auch, dass bei den RadioButtons oben New JUnit Jupiter test ausgew\u00e4hlt ist. Klicken Sie auf Finish . Es entsteht folgende FakultaetTest -Klasse: 1 2 3 4 5 6 7 8 9 10 11 12 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class FakultaetTest { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollte es bei Ihnen Probleme bei der Erstellung der JUnit-Testklasse geben, dann beachten Sie folgende 2 Anforderungen: Im Java Build Path muss JUnit enthalten sein: Hilfestellungen dazu finden Sie z.B. hier , hier oder hier . Beachten Sie, dass wir nicht JUnit 4 , sondern JUnit 5 (JUnit Jupiter) verwenden! In der module-info.java muss requires org.junit.jupiter.api; eingetragen sein. Eine JUnit-Testklasse enth\u00e4lt keine main() -Methode, ist aber ausf\u00fchrbar. Sie enth\u00e4lt stattdessen Methoden, die mit @Test annotiert sind. Diese @Test -Methoden enthalten Zusicherungen (sogenannte Assertions ). Mit diesen Assertions geben Sie das erwartete Ergebnis des Testfalls an. Assertions \u00b6 Es gibt unterschiedliche M\u00f6glichkeiten, das tats\u00e4chliche Ergebnis der Ausf\u00fchrung mit dem erwarteten Ergebnis zu vergleichen: Gleichheit, Ungleichheit, kleiner, gr\u00f6\u00dfer null , nicht null gleiche Objekte ( equals() ) Diese Vergleiche werden mittels Assertions durchgef\u00fchrt. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der am meisten verwendeten Assertions an. Alle Assertions, die es gibt, finden Sie hier . Assertion Beschreibung fail(message) L\u00e4sst den Test scheitern (fail) mit Nachricht message . Wird genutzt, um zu \u00fcberpr\u00fcfen, ob Code unerreichbar ist oder bevor der Test implementiert ist. assertTrue(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond wahr ist oder scheitert mit Nachricht m assertFalse(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond false ist oder scheitert mit Nachricht m assertEquals(a,b,m) \u00dcberpr\u00fcft, ob Parameter a und b gleich sind oder scheitert mit Nachricht m assertArrayEquals(a,b,m) \u00dcberpr\u00fcft, ob Inhalte der Arrays a und b gleich sind oder scheitert mit Nachricht m assertNull(o,m) \u00dcberpr\u00fcft, ob Object o==null ist oder scheitert mit Nachricht m assertNotNull(o,m) \u00dcberpr\u00fcft, ob Object o!=null ist oder scheitert mit Nachricht m assertSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1==o2 ist oder scheitert mit Nachricht m assertNotSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1!=o2 ist oder scheitert mit Nachricht m Derzeit verwenden wir in unserer Testklasse nur die Assertion fail() . Diese steht aber nur daf\u00fcr, dass wir diesen Test noch implementieren m\u00fcssen. Das machen wir gleich. Annotationen \u00b6 Neben den Assertions gibt es auch noch Annotationen , die beim Testen eine Rolle spielen. Eine Annotation haben wir bereits verwendet: @Test . Hier einen \u00dcberblick \u00fcber die h\u00e4ufigsten Annotationen: Annotation Beschreibung @Test public void method() Die Methode ist eine Testmethode @BeforeEach public void method() Die Methode wird vor jedem Test ausgef\u00fchrt @AfterEach public void method() Die Methode wird nach jedem Test ausgef\u00fchrt @BeforeAll public static void method() Die Methode wird einmalig ausgef\u00fchrt bevor die Tests starten (static!) @AfterAll public static void method() Die Methode wird einmalig ausgef\u00fchrt nachdem die Tests gelaufen sind Methode fakultaet() testen \u00b6 Wir schreiben unsere erste Testmethode und wollen darin die Methode fakultaet() testen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class FakultaetTest { @Test void testFakultaet6 () { // given Fakultaet f = new Fakultaet (); // when long result = f . fakultaet ( 6 ); // then assertEquals ( 720 , result , \"6! should be 720\" ); } } Wir haben dazu die Testmethode umbenant in testFakultaet6() , da wir f\u00fcr die Eingabe 6 die korrekte Ausf\u00fchrung testen wollen. Wir gehen nach dem given-when-then -Prinzip vor und haben es hier mithilfe von Zeilenkommentaren betont. Wir erzeugen zun\u00e4chst ein Fakultaet -Objekt und wenden dann die fakultaet() -Methode f\u00fcr den Eingabeparameter 6 an. Das Ergebnis speichern wir in result . Nun kommt unsere erste Assertion zum Einsatz. Wir verwenden die Assertion assertEquals . Diese erwartet mindestens zwei Parameter. Der erste Parameter gibt das erwartete Resultat an ( 720 ) und der zweite Parameter ist der berechnete Wert ( result ). Der dritte Parameter ist optional und steht f\u00fcr die Zeichenkette, die ausgegeben wird, falls der berechnete Wert nicht dem erwarteteten Wert entspricht. Wir h\u00e4tten hier auch die Assertion assertTrue(720==result, \"6! should be 720\") verwenden k\u00f6nnen. Test ausf\u00fchren \u00b6 Unter Run w\u00e4hlen Sie nun Coverage ( Strg-Umschalt-F11 ). Die Ansicht von Eclipse wechselt. Sie k\u00f6nnen unter Run auch Coverage As --> JUnit Test w\u00e4hlen. Das ist gleich. Auf der linken Seite in Eclipse erscheint ein gr\u00fcner Balken als Zeichen daf\u00fcr, dass alle Tests (derzeit nur einer) erfolgreich durchlaufen wurden. Darunter sind die Tests aufgef\u00fchrt mit einem kleinen gr\u00fcnen Check am Icon. Der Test war erfolgreich. Wenn wir uns nun unsere Fakultaet -Klasse anschauen, dann sehen wir folgendes Bild: Hier wird die Testabdeckung angezeigt. Die gr\u00fcn markierten Zeilen wurden durch den Test ausgef\u00fchrt. Die gelb markierten Zeilen sind Bedingungen, die false ergaben und f\u00fcr die es (noch) keinen Test gibt, der true f\u00fcr diese Bedingungen ergibt. Die roten Zeilen wurden in noch keinem Test ausgef\u00fchrt. Wir erstellen deshalb weitere Tests, um eine vollst\u00e4ndige Testabdeckung zu erzielen. Exceptions testen \u00b6 Um das Werfen einer Exception zu testen, bietet sich die Assertion assertThrows() an (siehe hier . Diese Assertion erwartet als ersten Parameter die erwartete Exception , in unserem Fall also IllegalArgumentException . Beachten Sie, dass der Typ Class (siehe hier ) erwartet wird. Diesen erhalten wir, indem wir .class an den Klasennamen (also hier IllegalArgumentException anh\u00e4ngen). Der Unterschied zwischen .class und .getClass() ist der, dass bei getClass() bereits ein Objekt der Klasse existieren muss (wird auf ein Objekt der Klasse angewendet), w\u00e4hrend .class auf die Klasse angewendet werden kann, ohne dass ein Objekt der Klasse existieren muss. Der zweite Parameter der assertThrows -Methode erwartet ein Executable (siehe hier ). Dies ist ein Interface mit genau einer Methode, n\u00e4mlich execute() . Es ist \u00fcblich, dieses Excutable in der Schreibweise der funktionalen Programmierung (sie z.B. hier ) zu definieren. Die Testmethode, um Eingabeparameter kleiner 1 zu testen, k\u00f6nnte z.B. so aussehen: 22 23 24 25 26 27 28 29 30 31 32 33 34 @Test void testFakultaetSmallerThan1 () { // given Fakultaet f = new Fakultaet (); // when Exception exception = assertThrows ( IllegalArgumentException . class , () -> f . fakultaet ( 0 )); // then assertEquals ( \"Zahl muss groesser gleich 1 sein!\" , exception . getMessage ()); } Nach dem gleichen Prinzip k\u00f6nnen wir auch den Wertebereichs\u00fcberlauf testen: 37 38 39 40 41 42 43 44 45 46 47 48 49 @Test void testFakultaetOverflow () { // given Fakultaet f = new Fakultaet (); // when Exception exception = assertThrows ( IllegalArgumentException . class , () -> f . fakultaet ( 22 )); // then assertEquals ( \"Overflow!\" , exception . getMessage ()); } Betrachten wir die Testabdeckung der Klasse Fakultaet , dann ist diese bereits sehr gut: Konsolenausgaben testen \u00b6 Es ist nicht \u00fcblich, Konsolenausgaben zu testen. Normalerweise werden die Ausgebestrings mit der toString() -Methode erzeugt und diese Methode wird dann auch getestet (z.B. mittels assertEquals() ). Wir haben hier aber keine toString() -Methode und zeigen deshalb, wie die print() -Methode getestet werden k\u00f6nnte. Dazu wird die Standardausgabe \"verbogen\". Wir merken uns, den urspr\u00fcnglichen System.out -Stream, der ein PrintStream aus dem Paket java.io ist. Dann erzeugen wir einen eigenen ByteArrayOutputStream (ebenfalls aus java.io ). Nachdem wir unsere Ausgabe abgeschlossen haben, setzen wir System.out wieder auf das urspr\u00fcngliche Ausgabeger\u00e4t, damit die Konsolenausgaben wieder erfolgen k\u00f6nnen. Unsere Testmethode f\u00fcr die print() -Methode k\u00f6nnte dann so aussehen: 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @Test void testFakultaetPrint6 () { PrintStream originalOut = System . out ; // System.out merken (Standardausgabegeraet Konsole) ByteArrayOutputStream out = new ByteArrayOutputStream (); System . setOut ( new PrintStream ( out )); // given Fakultaet f = new Fakultaet (); // when f . print ( 6 ); // then assertEquals ( \" 6! = 720 \\n\" , out . toString (), \"should print 6! = 720 with linebreak\" ); System . setOut ( originalOut ); // System.out wieder auf das Standardausgabegeraet setzen } Beachten Sie sowohl die Leerzeichen im Ausgabestring als auch den Zeilenumbruch. Nun haben wir eine vollst\u00e4ndige Testabdeckung unserer Fakultaet -Klasse: Success Wir haben unsere erste Klasse mit JUnit getestet. Die wesentlichen Assertions, die verwendet werden, sind assertEquals() , assertTrue() und assertThrows() . Mit diesen Assertions k\u00f6nnen die allermeisten Methoden getestet werden. Beim testen von Arrays wird auch h\u00e4ufig assertArrayEquals() verwendet. W\u00e4hlen Sie am besten eine beliebige Klasse aus den bisherigen \u00dcbungen oder Aufgaben aus, um selbst\u00e4ndig daf\u00fcr JUnit -Tests zu schreiben. Test-Driven Development \u00b6 Unit Tests k\u00f6nnen entweder nach Erstellung des Programmcodes geschrieben werden, um diesen nachtr\u00e4glich zu testen oder vor Erstellung des Programmcodes. Wenn wir die Tests vor der Erstellung des Programmcodes erstellen, dann beschreiben wir mit den Tests die Anforderungen an den zu erstellenden Code. Wir werden hier lernen, wie die Erstellung der Tests und des Programmcodes Hand-in_Hand erfolgen k\u00f6nnen. Diese Vorgehensweise nennt sich Test-driven developement (TDD) . Wir werden, wie \u00fcblich, TDD anhand eines Beispiels einf\u00fchren. Unser Vorgehen l\u00e4sst sich wie folgt beschreiben: Wir schreiben einen Test, der die Anforderung f\u00fcr einen m\u00f6glichst kleinen iterativen Schritt bei der Erstellung des Programmcodes beschreibt. Wir schreiben m\u00f6glichst wenig Programmcode, so dass der Test genau erf\u00fcllt wird. Wir gehen wieder zu 1. und beschreiben den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test. Wir wiederholen 2. f\u00fcr den neuen Test usw. Die folgende Abbildung visualisiert das Vorgehen. Ausgangspunkt ist immer ein Test. Wir implementieren solange, bis dieser und alle vorher implementierten Tests erfolgreich durchlaufen werden. Dann schreiben wir einen weiteren Test und implementieren wieder so lange, bis dieser und alle vorher geschreibenen Tests erfolgreich durchlaufen werden. Dieses Vorgehen wird so lange wiederholt, so lange wir weitere Testf\u00e4lle hinzuf\u00fcgen k\u00f6nnen, die jeweils neue Anforderungen beschreiben. Zur Implementierung des Codes geh\u00f6rt auch das Refactoring, d.h. wir verbessern bisher geschriebenen Code durch neue Tests. TDD f\u00fcr einen Time-Zeit-Umrechner \u00b6 Angenommen, wir wollen einen einfachen Konverter erstellen, der eine Uhrzeit im 12-Stunden-Zeitsystem (mit am und pm ) in eine 24-Stundendarstellung umwandelt (von String nach String ). Im Web findet man einige Beispiel, z.B. hier . Dazu erstellen wir uns zun\u00e4chst eine Klasse UmrechnungTimeZeit.java , die die Methode convert() enth\u00e4lt. Diese Methode erwartet einen String mit einer 12-Stunden-Zeit time und gibt einen String zur\u00fcck, der die time im 24-Stundenformat darstellt. UmrechnungTimeZeit.java public class UmrechnungTimeZeit { public String convert ( String time ) { return \"\" ; } } Das ist unsere Klasse in der Augangssituation. Bevor wir anfangen, zu implemntieren, wollen wir uns zun\u00e4chst einen ersten einfachen Test schreiben, der uns eine erste Anforderung (einen ersten Testfall) beschreibt. Dazu w\u00e4hlen wir in Eclipse File --> New --> JUnit Test Case . Es erscheint folgendes Fenster: Wir w\u00e4hlen New JUnit Jupiter test aus und benennen unsere Testklasse TestUmrechnungTimeZeit und geben an, dass die Class under test die Klasse UmrechnungTimeZeit ist (Auswahl durch Browse... ). Wenn wir dann auf Finish klicken, erscheint: Das best\u00e4tigen wir mit OK . Es wird die TestUmrechnungTimeZeit.java erstellt, die so aussieht: TestUmrechnungTimeZeit.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollten Fehler beim Import der junit.jupiter -Pakete angezeigt werden, dann m\u00fcssen Sie in Ihre module-info.java noch folgende Anweisung einf\u00fcgen: Einf\u00fcgen in die module-info.java requires org . junit . jupiter . api ; Die Klasse TestUmrechnungTimeZeit.java ist eine JUnit-Testklasse. Video zur testgetriebenen Entwicklung Die folgende testgetriebene Entwicklung wurde im folgenden Video gezeigt: Eine erste Testmethode f\u00fcr unser Beispiel \u00b6 Zun\u00e4chst einmal schauen wir uns an, wie wir unsere Testklasse ausf\u00fchren. Dazu w\u00e4hlen wir in Eclipse unter Run --> Run As ... --> JUnit Test . Oder Sie w\u00e4hlen gleich den mittleren der gezeigten drei Buttons . Dann erhalten Sie folgendes Bild: Auf der linken Seite sehen Sie im JUnit -Reiter einen roten Querbalken. Dieser zeigt an, dass ein Test fehlgeschlagen ist. Im Editor-Fenster wird der fehlgeschlagene Test rot markiert. Es ist klar, dass der Test fehlschl\u00e4gt, denn das bezweckt ja die Assertion fail() . Links unten sieht man den Failure trace . Dort ist in der ertsen Zeile die Fehlermeldung Not yet implemented zu sehen - das ist die Nachricht, die der fail() -Assertion \u00fcbergeben wurde. Wir implementieren nun die erste Testmethode. Dazu benennen wir die Methode test() um in testConvert1amTo1() . In unserem ersten Test wollen wir \u00fcberpr\u00fcfen, ob unsere Methode convert(String time) korrekt arbeitet, wenn ihr der String 1:00 am \u00fcbergeben wird. Die Idee ist nun die folgende: wir definieren unsere Testmethode so, dass wir angeben, welches Ergebnis wir erwarten, wenn der String 1:00 am \u00fcbergeben wird. Wir erwarten das Ergebnis 1:00 . Generell sollte eine Testmethode in der folgenden Form aufgebaut sein: given (preperation) : gibt die Voraussetzungen des Tests an, z.B. die Erzeugung eines Objektes; bei uns: die Erzeugung eines UmrechnungTimeZeit -Objektes, when (execution) : beschreibt, was und wie ausgef\u00fchrt werden soll; bei uns: die Ausf\u00fchrung der Methode convert() mit dem Parameterwert \"1:00 am\" , then (verification) : beschreibt, wie sich das Ergebnis der Ausf\u00fchrung in Bezug auf das erwartete Ergebnis verhalten soll; bei uns: assertEquals(tatsaechlichesErgebnis, \"1:00\") . Nach Umbenennung der Methode test() in TestUmrechnungTimeZeit.java in testConvert1amTo1(String time) und Implementierung dieser Methode sieht die Klasse TestUmrechnungTimeZeit.java nun so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } } In der Testmethode erzeugen wir uns also zun\u00e4chst ein Objekt von UmrechnungTimeZeit , damit wir die Objektmethode convert() \u00fcberhaupt aufrufen k\u00f6nnen (Zeile 9 ). Dann rufen wir die convert() -Methode auf und \u00fcbergeben ihr den String \"1:00 am\" . Das Ergebnis der Methode wird in der Variablen zeit gespeichert (Zeile 12 ). Dann vergleichen wir das tats\u00e4chliche Ergebnis ( zeit ) mit dem erwarteten Ergebnis ( \"1:00\" ) und wollen, dass beide gleich sind ( assertEquals() ). Somit haben wir einen m\u00f6glichst kleinen iterativen Schritt hin zur fertigen Implementierung als Test beschrieben. Unsere n\u00e4chste Aufgabe ist nun, m\u00f6glichst wenig Programmcode zu schreiben, so dass der Test genau erf\u00fcllt wird. Diese Aufgabe erledigen wir auf ganz simple Weise, indem unsere convert() -Methode einfach den String \"1:00\" zur\u00fcckgibt. UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return \"1:00\" ; } } Das erscheint uns auf den ersten Blick v\u00f6llig sinnlos - und das ist es nat\u00fcrlich irgendwie auch. Aber wir erinnern uns: wir wollen m\u00f6glichst wenig Programmcode schreiben, so dass der Test genau erf\u00fcllt wird. Und das machen wir hier. Wenn wir nun unsere Testklasse ausf\u00fchren, dann sehen wir: Auf der linken Seite ist nun ein gr\u00fcner Balken zu sehen, d.h. alle unsere Tests (bis jetzt haben wir nur einen) sind korrekt. Unsere Methode convert() arbeitet in Bezug auf unsere Tests korrekt. Nun f\u00fcgen wir einen zweiten Test hinzu. Dazu k\u00f6nnen wir die Methode testConvert1amTo1() einfach kopieren. Die neue Methode nennen wir testConvert1amTo1() , da wir nun testen wollen, ob unsere Methode auch den String \"2:00 am\" korrekt nach \"2:00\" umwandelt. Mit diesem Test beherzigen wir das Prinzip, den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test zu beschreiben. Dieser m\u00f6glichst kleine Schritt ist f\u00fcr uns der Schritt von \"1:00 am\" nach \"2:00 am\" . Die neue Testmethode sieht so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } @Test void testConvert2amTo2 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"2:00 am\" ); // verification --> then assertEquals ( zeit , \"2:00\" ); } } Wenn wir die Testklasse nun ausf\u00fchren, ohne die convert() -Methode zu \u00e4ndern, erhalten wir folgendes Bild: Der Balken im JUnit -Fenster ist rot. Darunter wird uns angegeben, dass der Testfall testConvert1amTo1() immer noch korrekt ist (gr\u00fcner Haken), aber der Testfall testConvert2amTo2() ist gescheitert (blaues Kreuz). Im Editorfenster ist rot unterlegt, welche Assertion gescheitert ist ( assertEquals(zeit, \"2:00\"); ). Wir brauchen nun also eine Idee, wie wir die convert() -Methode anpassen k\u00f6nnen, so dass beide Testf\u00e4lle korrekt ausgef\u00fchrt werden. Wir versuchen es mit der Idee, einfach die ersten vier Zeichen des \u00fcbergebenen Strings time zur\u00fcckzugeben: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return time . substring ( 0 , 4 ); } } Wenn wir nun unsere Testklasse ausf\u00fchren, dann sind beide Testf\u00e4lle korrekt. Auf diese Art und Weise entwickeln wir nach und nach eine Implementierung der convert() -Methode. Dazu f\u00fcgen wir nach und nach immer weitere Testf\u00e4lle unserer Testklasse hinzu. Mindestens noch f\u00fcr folgende F\u00e4lle: time erwartetes Ergebnis \"1:15 am\" \"1:15\" \"11:00 am\" \"11:00\" \"11:15 am\" \"11:15\" \"1:00 pm\" \"13:00\" \"2:00 pm\" \"14:00\" \"1:15 pm\" \"13:15\" \"11:00 pm\" \"23:00\" \"11:15 pm\" \"23:15\" \"12:00 am\" \"0:00\" \"12:01 am\" \"0:01\" \"12:00 pm\" \"12:00\" \"12:01 pm\" \"12:01\" \"12:00 noon\" \"12:00\" \"12:00 midnight\" \"0:00\" Das Auswahl der Testwerte ist ganz offensichtlich ein wichtiges Thema und bestimmt die Korrektheit der sp\u00e4teren Implementierung mit. Es ist wichtig, keinen Testfall zu vergessen. Leider gibt es daf\u00fcr keine formalen Regeln, sondern nur intuitive Vorgaben. Es wird immer versucht, \"Grenzwerte\" zu ermitteln, um wirklich alle Testf\u00e4lle abzudecken. Quellcode aus dem Video \u00b6 Im Video \u00fcber JUnit wurde folgender Quellcode erzeugt: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package videos.video4 ; import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; public class UmrechnungTimeZeit { public String convert ( String time ) { final int LAST_THREE_CHARS = 3 ; // \" pm\" or \" am\" if ( time . endsWith ( \"am\" )) { return time . substring ( 0 ,( time . length () - LAST_THREE_CHARS )); } else // ends with pm { final int DIFFERENCE_BETWEEN_H_TO_HH = 12 ; int hourInt = this . getHoursInt ( time ); hourInt += DIFFERENCE_BETWEEN_H_TO_HH ; String minutes = this . getMinutesStr ( time ); String zeit = hourInt + \":\" + minutes ; return zeit ; } } String getHoursStr ( String time ) { String [] allStr = time . split ( \":\" ); return allStr [ 0 ] ; } String getMinutesStr ( String time ) { final int FIRST_TWO_CHARS = 2 ; String [] allStr = time . split ( \":\" ); String afterDouble = allStr [ 1 ] ; String minutesStr = afterDouble . substring ( 0 , FIRST_TWO_CHARS ); return minutesStr ; } int getHoursInt ( String time ) { String hoursStr = this . getHoursStr ( time ); int hoursInt = Integer . valueOf ( hoursStr ); return hoursInt ; } } UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 package videos.video4 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class UmrechnungTimeZeitTest { @Test void testConvert1amTo1 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 am\" ); // than (verification) assertEquals ( zeit , \"1:00\" , \"1:00 am to 1:00 not working\" ); } @Test void testConvert2amTo2 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"2:00 am\" ); // than (verification) assertEquals ( zeit , \"2:00\" , \"2:00 am to 2:00 not working\" ); } @Test void testConvert9amTo9 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"9:00 am\" ); // than (verification) assertEquals ( \"9:00\" , zeit ); } @Test void testConvert10amTo10 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"10:00 am\" ); // than (verification) assertEquals ( \"10:00\" , zeit ); } @Test void testConvert1115amTo1115 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:15 am\" ); // than (verification) assertEquals ( \"11:15\" , zeit ); } @Test void testConvert1pmTo13 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 pm\" ); // than (verification) assertEquals ( \"13:00\" , zeit ); } @Test void testConvert3pmTo15 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"3:00 pm\" ); // than (verification) assertEquals ( \"15:00\" , zeit ); } @Test void testConvert545pmTo1745 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"5:45 pm\" ); // than (verification) assertEquals ( \"17:45\" , zeit ); } @Test void testConvert11pmTo23 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:00 pm\" ); // than (verification) assertEquals ( \"23:00\" , zeit ); } @Test void testGetHoursStr11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"11\" , hour ); } @Test void testGetHoursStr1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"1\" , hour ); } @Test void testGetHoursInt1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"1:00 pm\" ); // than (verification) assertEquals ( 1 , hours ); } @Test void testGetHoursInt11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"11:00 pm\" ); // than (verification) assertEquals ( 11 , hours ); } @Test void testGetMinutes1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } @Test void testGetMinutes11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } } module-info.java module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; } Noch ein kleines Beispiel \u00b6 Wir betrachten die Klasse Power mit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class Power { private int base ; private int exp ; public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public double value () { double value = 1.0 ; if ( exp > 0 ) { for ( int i = 0 ; i < exp ; i ++ ) { value *= base ; } } else { for ( int i = 0 ; i <- exp ; i ++ ) { value *= base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \"^\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Power p = ( Power ) o ; return ( this . base == p . base && this . exp == p . exp ); } @Override public int hashCode () { return 7 * this . base + 11 * this . exp ; } } F\u00fcr diese Klasse erstellen wir eine Testklasse, die neben der Annotation @Test auch die Annotationen @BeforeAll und @BeforeEach exemplarisch verwendet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; class PowerTest { static Power p1 , p2 , p3 , p4 ; static int testnr = 1 ; @BeforeAll public static void setup () { p1 = new Power ( 2 , 3 ); p2 = new Power ( 2 , 3 ); p3 = new Power ( - 2 , 3 ); p4 = new Power ( 2 , - 3 ); } @BeforeEach public void printBeforeTests () { System . out . printf ( \"%n %n --------------- Test %d ------------ %n\" , testnr ); p1 . print (); p2 . print (); testnr ++ ; } @Test void testToString () { String s = p1 . toString (); assertEquals ( \"(2^3)\" , s , \"Strings are not equal!\" ); } @Test void testPower () { assertNotNull ( p1 , \"no Power object\" ); } @Test void testValue () { double value = p1 . value (); assertEquals ( value , 8.0 , \"2^3 should be 8.0\" ); } @Test public void testEqualsObject () { assertTrue ( p1 . equals ( p2 ), \" 2^3 should be equal to 2^3!\" ); } } Diese Testklasse deckt nat\u00fcrlich viel zu wenige Testf\u00e4lle ab, aber es geht hier nur ums Prinzip. F\u00fchren Sie die Testklasse aus und beobachten Sie dabei auch die Konsole. Vor jeden Test ( @BeforeEach ) gibt es eine Ausgabe auf die Konsole. Bevor irgendein Test ( @Test ) ausgef\u00fchrt wird ( @BeforeAll ) werden verschiedene Objekte der Klasse Power erzeugt. In den Testf\u00e4llen werden aber nur p1 und p2 verwendet. Das m\u00fcsste nat\u00fcrlich noch deutlich erweitert werden. Success Wir haben JUnit-Testing kennengelernt. Unit-Tests sind eine gute M\u00f6glichkeit, einzelne Methoden automatisiert zu testen. Mithilfe von Unit-Tests k\u00f6nnen wir Code so entwicklen, dass alle formulierten Tests erfolgreich bestehen. Werden erst die Tests geschrieben und gegen die Tests implementiert, wird dieses Programmierverfahren Test-driven development genannt. Unit-Tests k\u00f6nnen aber auch verwendet werden, um existierenden Code zu testen. JUnit ist das Framework f\u00fcr Java-Unit-Tests. Ausf\u00fchrliche Informationen zu JUnit sind hier zu finden.","title":"JUnit-Testen"},{"location":"junit/#junit-tests","text":"Testen von Programmen ist wichtig. Ohne Testen ist es kaum m\u00f6glich, Fehler in Programmen zu entdecken. Bis jetzt haben wir unsere Programme immer durch reines Anwenden getestet, d.h. wir haben die implementierten Methoden aufgerufen und ihnen unterschiedliche Parameterwerte \u00fcbergeben. Wir werden das jetzt \u00e4ndern und nutzen daf\u00fcr JUnit .","title":"JUnit-Tests"},{"location":"junit/#allgemeines-zum-unit-testen","text":"Der ber\u00fchmte Informatiker Edsger W. Dijkstra hat \u00fcber das Testen gesagt: Durch Testen kann man stets nur die Anwesenheit, nie aber die Abwesenheit von Fehlern beweisen Das bedeutet, wir k\u00f6nnen durch das Testen Fehler finden. Wenn wir aber keine finden, dann wissen wir nicht, ob das Programm dann auch keine Fehler mehr enth\u00e4lt. Es ist leider nicht m\u00f6glich, grunds\u00e4tzlich die Fehlerfreiheit von Programmen zu pr\u00fcfen. Aber das Testen stellt ein wichtiges Werkzeug dar, um Fehler zu entdecken. Es gibt verschiedene Arten von Tests: In der Abbildung erkennen wir, dass die Unit-tests, die wir hier kennenlernen wollen, am besten automatisierbar, am h\u00e4ufigsten und am einfachsten sind. Mit Unit-Tests k\u00f6nnen wir Methoden und Klassen testen, wobei wir die Tests implementieren. Die Idee ist, dass wir funktionale Einzelteile eines Programms separat und isoliert vom Rest auf ihre Korrektheit hin \u00fcberpr\u00fcfen. Wir versuchen extra, so wenig wie m\u00f6glich die Effekte anderer Funktionalit\u00e4ten bzw. Komponenten in die Tests einflie\u00dfen zu lassen. Das erfolgt dann in den Komponenten- bzw. Integrationstests. Das hat zwei Vorteile: einerseits ist der zu pr\u00fcfende Funktionsumfang \u00fcberschaubar und andererseits k\u00f6nnen diese Unit-Tests leicht automatisiert ausgef\u00fchrt werden. Es gibt, wie bereits eingangs erw\u00e4hnt, keine Garantie von Fehlerfreiheit. Ein Nachteil der Unit-Tests besteht darin, dass sie schwierig f\u00fcr Methoden zu gestalten sind, in denen es Abh\u00e4ngigkeiten von der Laufzeitumgebung oder anderen Komponenten gibt.","title":"Allgemeines zum (Unit-)Testen"},{"location":"junit/#junit","text":"F\u00fcr das Unit-Testen von Java-Programmen gibt es das Werkzeug JUnit . Wir zeigen die Verwendung von JUnit an einem einf\u00fchrenden Beispiel. Angenommen, wir haben folgende kleine Javaklasse Fakultaet : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Fakultaet { public long fakultaet ( int number ) throws IllegalArgumentException { if ( number < 1 ) { throw new IllegalArgumentException ( \"Zahl muss groesser gleich 1 sein!\" ); } long result = 1 ; for ( int i = 2 ; i <= number ; i ++ ) { long tmp = result ; result *= i ; if ( tmp > result ) { throw new IllegalArgumentException ( \"Overflow!\" ); } } return result ; } public void print ( int number ) { System . out . printf ( \"%3d! = %,d %n\" , number , fakultaet ( number )); } } Diese Klasse enth\u00e4lt eine Methode fakultaet() , welche ein int als Eingabeparameter erwartet und den Wert der Fakult\u00e4tsberechnung als long zur\u00fcckgibt. Ist der Eingabewert kleiner als 1 wird eine IllegalArgumentException geworfen. Tritt w\u00e4hrend der Berechnung der Fakult\u00e4t ein Wertebereichs\u00fcberlauf auf (der gr\u00f6\u00dfte Wert in long ist 9,223,372,036,854,775,807 ), dann wird ebenfalls eine IllegalArgumentException geworfen. Die print() -Methode gibt die Berechnung geeignet aus. Angenommen, eine main() -Methode (oder eine andere) w\u00fcrde die Klasse in der folgenden Form verwenden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { Fakultaet f1 = new Fakultaet (); int nr = 0 ; while ( nr < 22 ) { try { f1 . print ( nr ); } catch ( IllegalArgumentException e ) { System . out . println ( \"number = \" + nr + \" : \" + e . getMessage ()); } nr ++ ; } } , dann w\u00e4re die Ausgabe: number = 0 : Zahl muss gr\u00f6\u00dfer gleich 1 sein! 1 ! = 1 2 ! = 2 3 ! = 6 4 ! = 24 5 ! = 120 6 ! = 720 7 ! = 5 .040 8 ! = 40 .320 9 ! = 362 .880 10 ! = 3 .628.800 11 ! = 39 .916.800 12 ! = 479 .001.600 13 ! = 6 .227.020.800 14 ! = 87 .178.291.200 15 ! = 1 .307.674.368.000 16 ! = 20 .922.789.888.000 17 ! = 355 .687.428.096.000 18 ! = 6 .402.373.705.728.000 19 ! = 121 .645.100.408.832.000 20 ! = 2 .432.902.008.176.640.000 number = 21 : Overflow! Wir wollen diese Klasse Fakultaet nun mithilfe von JUnit testen. Dazu w\u00e4hlen wir File --> New --> JUnit Test Case : Es erscheint folgender Dialog: Beachten Sie, dass unter Class under test: die Klasse Fakultaet eingetragen ist (oder Sie geben Sie dort ein). Der Name der Klasse wird mit FakultaetTest vorgeschlagen. Beachten Sie auch, dass bei den RadioButtons oben New JUnit Jupiter test ausgew\u00e4hlt ist. Klicken Sie auf Finish . Es entsteht folgende FakultaetTest -Klasse: 1 2 3 4 5 6 7 8 9 10 11 12 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class FakultaetTest { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollte es bei Ihnen Probleme bei der Erstellung der JUnit-Testklasse geben, dann beachten Sie folgende 2 Anforderungen: Im Java Build Path muss JUnit enthalten sein: Hilfestellungen dazu finden Sie z.B. hier , hier oder hier . Beachten Sie, dass wir nicht JUnit 4 , sondern JUnit 5 (JUnit Jupiter) verwenden! In der module-info.java muss requires org.junit.jupiter.api; eingetragen sein. Eine JUnit-Testklasse enth\u00e4lt keine main() -Methode, ist aber ausf\u00fchrbar. Sie enth\u00e4lt stattdessen Methoden, die mit @Test annotiert sind. Diese @Test -Methoden enthalten Zusicherungen (sogenannte Assertions ). Mit diesen Assertions geben Sie das erwartete Ergebnis des Testfalls an.","title":"JUnit"},{"location":"junit/#assertions","text":"Es gibt unterschiedliche M\u00f6glichkeiten, das tats\u00e4chliche Ergebnis der Ausf\u00fchrung mit dem erwarteten Ergebnis zu vergleichen: Gleichheit, Ungleichheit, kleiner, gr\u00f6\u00dfer null , nicht null gleiche Objekte ( equals() ) Diese Vergleiche werden mittels Assertions durchgef\u00fchrt. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der am meisten verwendeten Assertions an. Alle Assertions, die es gibt, finden Sie hier . Assertion Beschreibung fail(message) L\u00e4sst den Test scheitern (fail) mit Nachricht message . Wird genutzt, um zu \u00fcberpr\u00fcfen, ob Code unerreichbar ist oder bevor der Test implementiert ist. assertTrue(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond wahr ist oder scheitert mit Nachricht m assertFalse(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond false ist oder scheitert mit Nachricht m assertEquals(a,b,m) \u00dcberpr\u00fcft, ob Parameter a und b gleich sind oder scheitert mit Nachricht m assertArrayEquals(a,b,m) \u00dcberpr\u00fcft, ob Inhalte der Arrays a und b gleich sind oder scheitert mit Nachricht m assertNull(o,m) \u00dcberpr\u00fcft, ob Object o==null ist oder scheitert mit Nachricht m assertNotNull(o,m) \u00dcberpr\u00fcft, ob Object o!=null ist oder scheitert mit Nachricht m assertSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1==o2 ist oder scheitert mit Nachricht m assertNotSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1!=o2 ist oder scheitert mit Nachricht m Derzeit verwenden wir in unserer Testklasse nur die Assertion fail() . Diese steht aber nur daf\u00fcr, dass wir diesen Test noch implementieren m\u00fcssen. Das machen wir gleich.","title":"Assertions"},{"location":"junit/#annotationen","text":"Neben den Assertions gibt es auch noch Annotationen , die beim Testen eine Rolle spielen. Eine Annotation haben wir bereits verwendet: @Test . Hier einen \u00dcberblick \u00fcber die h\u00e4ufigsten Annotationen: Annotation Beschreibung @Test public void method() Die Methode ist eine Testmethode @BeforeEach public void method() Die Methode wird vor jedem Test ausgef\u00fchrt @AfterEach public void method() Die Methode wird nach jedem Test ausgef\u00fchrt @BeforeAll public static void method() Die Methode wird einmalig ausgef\u00fchrt bevor die Tests starten (static!) @AfterAll public static void method() Die Methode wird einmalig ausgef\u00fchrt nachdem die Tests gelaufen sind","title":"Annotationen"},{"location":"junit/#methode-fakultaet-testen","text":"Wir schreiben unsere erste Testmethode und wollen darin die Methode fakultaet() testen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class FakultaetTest { @Test void testFakultaet6 () { // given Fakultaet f = new Fakultaet (); // when long result = f . fakultaet ( 6 ); // then assertEquals ( 720 , result , \"6! should be 720\" ); } } Wir haben dazu die Testmethode umbenant in testFakultaet6() , da wir f\u00fcr die Eingabe 6 die korrekte Ausf\u00fchrung testen wollen. Wir gehen nach dem given-when-then -Prinzip vor und haben es hier mithilfe von Zeilenkommentaren betont. Wir erzeugen zun\u00e4chst ein Fakultaet -Objekt und wenden dann die fakultaet() -Methode f\u00fcr den Eingabeparameter 6 an. Das Ergebnis speichern wir in result . Nun kommt unsere erste Assertion zum Einsatz. Wir verwenden die Assertion assertEquals . Diese erwartet mindestens zwei Parameter. Der erste Parameter gibt das erwartete Resultat an ( 720 ) und der zweite Parameter ist der berechnete Wert ( result ). Der dritte Parameter ist optional und steht f\u00fcr die Zeichenkette, die ausgegeben wird, falls der berechnete Wert nicht dem erwarteteten Wert entspricht. Wir h\u00e4tten hier auch die Assertion assertTrue(720==result, \"6! should be 720\") verwenden k\u00f6nnen.","title":"Methode fakultaet() testen"},{"location":"junit/#test-ausfuhren","text":"Unter Run w\u00e4hlen Sie nun Coverage ( Strg-Umschalt-F11 ). Die Ansicht von Eclipse wechselt. Sie k\u00f6nnen unter Run auch Coverage As --> JUnit Test w\u00e4hlen. Das ist gleich. Auf der linken Seite in Eclipse erscheint ein gr\u00fcner Balken als Zeichen daf\u00fcr, dass alle Tests (derzeit nur einer) erfolgreich durchlaufen wurden. Darunter sind die Tests aufgef\u00fchrt mit einem kleinen gr\u00fcnen Check am Icon. Der Test war erfolgreich. Wenn wir uns nun unsere Fakultaet -Klasse anschauen, dann sehen wir folgendes Bild: Hier wird die Testabdeckung angezeigt. Die gr\u00fcn markierten Zeilen wurden durch den Test ausgef\u00fchrt. Die gelb markierten Zeilen sind Bedingungen, die false ergaben und f\u00fcr die es (noch) keinen Test gibt, der true f\u00fcr diese Bedingungen ergibt. Die roten Zeilen wurden in noch keinem Test ausgef\u00fchrt. Wir erstellen deshalb weitere Tests, um eine vollst\u00e4ndige Testabdeckung zu erzielen.","title":"Test ausf\u00fchren"},{"location":"junit/#exceptions-testen","text":"Um das Werfen einer Exception zu testen, bietet sich die Assertion assertThrows() an (siehe hier . Diese Assertion erwartet als ersten Parameter die erwartete Exception , in unserem Fall also IllegalArgumentException . Beachten Sie, dass der Typ Class (siehe hier ) erwartet wird. Diesen erhalten wir, indem wir .class an den Klasennamen (also hier IllegalArgumentException anh\u00e4ngen). Der Unterschied zwischen .class und .getClass() ist der, dass bei getClass() bereits ein Objekt der Klasse existieren muss (wird auf ein Objekt der Klasse angewendet), w\u00e4hrend .class auf die Klasse angewendet werden kann, ohne dass ein Objekt der Klasse existieren muss. Der zweite Parameter der assertThrows -Methode erwartet ein Executable (siehe hier ). Dies ist ein Interface mit genau einer Methode, n\u00e4mlich execute() . Es ist \u00fcblich, dieses Excutable in der Schreibweise der funktionalen Programmierung (sie z.B. hier ) zu definieren. Die Testmethode, um Eingabeparameter kleiner 1 zu testen, k\u00f6nnte z.B. so aussehen: 22 23 24 25 26 27 28 29 30 31 32 33 34 @Test void testFakultaetSmallerThan1 () { // given Fakultaet f = new Fakultaet (); // when Exception exception = assertThrows ( IllegalArgumentException . class , () -> f . fakultaet ( 0 )); // then assertEquals ( \"Zahl muss groesser gleich 1 sein!\" , exception . getMessage ()); } Nach dem gleichen Prinzip k\u00f6nnen wir auch den Wertebereichs\u00fcberlauf testen: 37 38 39 40 41 42 43 44 45 46 47 48 49 @Test void testFakultaetOverflow () { // given Fakultaet f = new Fakultaet (); // when Exception exception = assertThrows ( IllegalArgumentException . class , () -> f . fakultaet ( 22 )); // then assertEquals ( \"Overflow!\" , exception . getMessage ()); } Betrachten wir die Testabdeckung der Klasse Fakultaet , dann ist diese bereits sehr gut:","title":"Exceptions testen"},{"location":"junit/#konsolenausgaben-testen","text":"Es ist nicht \u00fcblich, Konsolenausgaben zu testen. Normalerweise werden die Ausgebestrings mit der toString() -Methode erzeugt und diese Methode wird dann auch getestet (z.B. mittels assertEquals() ). Wir haben hier aber keine toString() -Methode und zeigen deshalb, wie die print() -Methode getestet werden k\u00f6nnte. Dazu wird die Standardausgabe \"verbogen\". Wir merken uns, den urspr\u00fcnglichen System.out -Stream, der ein PrintStream aus dem Paket java.io ist. Dann erzeugen wir einen eigenen ByteArrayOutputStream (ebenfalls aus java.io ). Nachdem wir unsere Ausgabe abgeschlossen haben, setzen wir System.out wieder auf das urspr\u00fcngliche Ausgabeger\u00e4t, damit die Konsolenausgaben wieder erfolgen k\u00f6nnen. Unsere Testmethode f\u00fcr die print() -Methode k\u00f6nnte dann so aussehen: 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @Test void testFakultaetPrint6 () { PrintStream originalOut = System . out ; // System.out merken (Standardausgabegeraet Konsole) ByteArrayOutputStream out = new ByteArrayOutputStream (); System . setOut ( new PrintStream ( out )); // given Fakultaet f = new Fakultaet (); // when f . print ( 6 ); // then assertEquals ( \" 6! = 720 \\n\" , out . toString (), \"should print 6! = 720 with linebreak\" ); System . setOut ( originalOut ); // System.out wieder auf das Standardausgabegeraet setzen } Beachten Sie sowohl die Leerzeichen im Ausgabestring als auch den Zeilenumbruch. Nun haben wir eine vollst\u00e4ndige Testabdeckung unserer Fakultaet -Klasse: Success Wir haben unsere erste Klasse mit JUnit getestet. Die wesentlichen Assertions, die verwendet werden, sind assertEquals() , assertTrue() und assertThrows() . Mit diesen Assertions k\u00f6nnen die allermeisten Methoden getestet werden. Beim testen von Arrays wird auch h\u00e4ufig assertArrayEquals() verwendet. W\u00e4hlen Sie am besten eine beliebige Klasse aus den bisherigen \u00dcbungen oder Aufgaben aus, um selbst\u00e4ndig daf\u00fcr JUnit -Tests zu schreiben.","title":"Konsolenausgaben testen"},{"location":"junit/#test-driven-development","text":"Unit Tests k\u00f6nnen entweder nach Erstellung des Programmcodes geschrieben werden, um diesen nachtr\u00e4glich zu testen oder vor Erstellung des Programmcodes. Wenn wir die Tests vor der Erstellung des Programmcodes erstellen, dann beschreiben wir mit den Tests die Anforderungen an den zu erstellenden Code. Wir werden hier lernen, wie die Erstellung der Tests und des Programmcodes Hand-in_Hand erfolgen k\u00f6nnen. Diese Vorgehensweise nennt sich Test-driven developement (TDD) . Wir werden, wie \u00fcblich, TDD anhand eines Beispiels einf\u00fchren. Unser Vorgehen l\u00e4sst sich wie folgt beschreiben: Wir schreiben einen Test, der die Anforderung f\u00fcr einen m\u00f6glichst kleinen iterativen Schritt bei der Erstellung des Programmcodes beschreibt. Wir schreiben m\u00f6glichst wenig Programmcode, so dass der Test genau erf\u00fcllt wird. Wir gehen wieder zu 1. und beschreiben den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test. Wir wiederholen 2. f\u00fcr den neuen Test usw. Die folgende Abbildung visualisiert das Vorgehen. Ausgangspunkt ist immer ein Test. Wir implementieren solange, bis dieser und alle vorher implementierten Tests erfolgreich durchlaufen werden. Dann schreiben wir einen weiteren Test und implementieren wieder so lange, bis dieser und alle vorher geschreibenen Tests erfolgreich durchlaufen werden. Dieses Vorgehen wird so lange wiederholt, so lange wir weitere Testf\u00e4lle hinzuf\u00fcgen k\u00f6nnen, die jeweils neue Anforderungen beschreiben. Zur Implementierung des Codes geh\u00f6rt auch das Refactoring, d.h. wir verbessern bisher geschriebenen Code durch neue Tests.","title":"Test-Driven Development"},{"location":"junit/#tdd-fur-einen-time-zeit-umrechner","text":"Angenommen, wir wollen einen einfachen Konverter erstellen, der eine Uhrzeit im 12-Stunden-Zeitsystem (mit am und pm ) in eine 24-Stundendarstellung umwandelt (von String nach String ). Im Web findet man einige Beispiel, z.B. hier . Dazu erstellen wir uns zun\u00e4chst eine Klasse UmrechnungTimeZeit.java , die die Methode convert() enth\u00e4lt. Diese Methode erwartet einen String mit einer 12-Stunden-Zeit time und gibt einen String zur\u00fcck, der die time im 24-Stundenformat darstellt. UmrechnungTimeZeit.java public class UmrechnungTimeZeit { public String convert ( String time ) { return \"\" ; } } Das ist unsere Klasse in der Augangssituation. Bevor wir anfangen, zu implemntieren, wollen wir uns zun\u00e4chst einen ersten einfachen Test schreiben, der uns eine erste Anforderung (einen ersten Testfall) beschreibt. Dazu w\u00e4hlen wir in Eclipse File --> New --> JUnit Test Case . Es erscheint folgendes Fenster: Wir w\u00e4hlen New JUnit Jupiter test aus und benennen unsere Testklasse TestUmrechnungTimeZeit und geben an, dass die Class under test die Klasse UmrechnungTimeZeit ist (Auswahl durch Browse... ). Wenn wir dann auf Finish klicken, erscheint: Das best\u00e4tigen wir mit OK . Es wird die TestUmrechnungTimeZeit.java erstellt, die so aussieht: TestUmrechnungTimeZeit.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollten Fehler beim Import der junit.jupiter -Pakete angezeigt werden, dann m\u00fcssen Sie in Ihre module-info.java noch folgende Anweisung einf\u00fcgen: Einf\u00fcgen in die module-info.java requires org . junit . jupiter . api ; Die Klasse TestUmrechnungTimeZeit.java ist eine JUnit-Testklasse. Video zur testgetriebenen Entwicklung Die folgende testgetriebene Entwicklung wurde im folgenden Video gezeigt:","title":"TDD f\u00fcr einen Time-Zeit-Umrechner"},{"location":"junit/#eine-erste-testmethode-fur-unser-beispiel","text":"Zun\u00e4chst einmal schauen wir uns an, wie wir unsere Testklasse ausf\u00fchren. Dazu w\u00e4hlen wir in Eclipse unter Run --> Run As ... --> JUnit Test . Oder Sie w\u00e4hlen gleich den mittleren der gezeigten drei Buttons . Dann erhalten Sie folgendes Bild: Auf der linken Seite sehen Sie im JUnit -Reiter einen roten Querbalken. Dieser zeigt an, dass ein Test fehlgeschlagen ist. Im Editor-Fenster wird der fehlgeschlagene Test rot markiert. Es ist klar, dass der Test fehlschl\u00e4gt, denn das bezweckt ja die Assertion fail() . Links unten sieht man den Failure trace . Dort ist in der ertsen Zeile die Fehlermeldung Not yet implemented zu sehen - das ist die Nachricht, die der fail() -Assertion \u00fcbergeben wurde. Wir implementieren nun die erste Testmethode. Dazu benennen wir die Methode test() um in testConvert1amTo1() . In unserem ersten Test wollen wir \u00fcberpr\u00fcfen, ob unsere Methode convert(String time) korrekt arbeitet, wenn ihr der String 1:00 am \u00fcbergeben wird. Die Idee ist nun die folgende: wir definieren unsere Testmethode so, dass wir angeben, welches Ergebnis wir erwarten, wenn der String 1:00 am \u00fcbergeben wird. Wir erwarten das Ergebnis 1:00 . Generell sollte eine Testmethode in der folgenden Form aufgebaut sein: given (preperation) : gibt die Voraussetzungen des Tests an, z.B. die Erzeugung eines Objektes; bei uns: die Erzeugung eines UmrechnungTimeZeit -Objektes, when (execution) : beschreibt, was und wie ausgef\u00fchrt werden soll; bei uns: die Ausf\u00fchrung der Methode convert() mit dem Parameterwert \"1:00 am\" , then (verification) : beschreibt, wie sich das Ergebnis der Ausf\u00fchrung in Bezug auf das erwartete Ergebnis verhalten soll; bei uns: assertEquals(tatsaechlichesErgebnis, \"1:00\") . Nach Umbenennung der Methode test() in TestUmrechnungTimeZeit.java in testConvert1amTo1(String time) und Implementierung dieser Methode sieht die Klasse TestUmrechnungTimeZeit.java nun so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } } In der Testmethode erzeugen wir uns also zun\u00e4chst ein Objekt von UmrechnungTimeZeit , damit wir die Objektmethode convert() \u00fcberhaupt aufrufen k\u00f6nnen (Zeile 9 ). Dann rufen wir die convert() -Methode auf und \u00fcbergeben ihr den String \"1:00 am\" . Das Ergebnis der Methode wird in der Variablen zeit gespeichert (Zeile 12 ). Dann vergleichen wir das tats\u00e4chliche Ergebnis ( zeit ) mit dem erwarteten Ergebnis ( \"1:00\" ) und wollen, dass beide gleich sind ( assertEquals() ). Somit haben wir einen m\u00f6glichst kleinen iterativen Schritt hin zur fertigen Implementierung als Test beschrieben. Unsere n\u00e4chste Aufgabe ist nun, m\u00f6glichst wenig Programmcode zu schreiben, so dass der Test genau erf\u00fcllt wird. Diese Aufgabe erledigen wir auf ganz simple Weise, indem unsere convert() -Methode einfach den String \"1:00\" zur\u00fcckgibt. UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return \"1:00\" ; } } Das erscheint uns auf den ersten Blick v\u00f6llig sinnlos - und das ist es nat\u00fcrlich irgendwie auch. Aber wir erinnern uns: wir wollen m\u00f6glichst wenig Programmcode schreiben, so dass der Test genau erf\u00fcllt wird. Und das machen wir hier. Wenn wir nun unsere Testklasse ausf\u00fchren, dann sehen wir: Auf der linken Seite ist nun ein gr\u00fcner Balken zu sehen, d.h. alle unsere Tests (bis jetzt haben wir nur einen) sind korrekt. Unsere Methode convert() arbeitet in Bezug auf unsere Tests korrekt. Nun f\u00fcgen wir einen zweiten Test hinzu. Dazu k\u00f6nnen wir die Methode testConvert1amTo1() einfach kopieren. Die neue Methode nennen wir testConvert1amTo1() , da wir nun testen wollen, ob unsere Methode auch den String \"2:00 am\" korrekt nach \"2:00\" umwandelt. Mit diesem Test beherzigen wir das Prinzip, den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test zu beschreiben. Dieser m\u00f6glichst kleine Schritt ist f\u00fcr uns der Schritt von \"1:00 am\" nach \"2:00 am\" . Die neue Testmethode sieht so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } @Test void testConvert2amTo2 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"2:00 am\" ); // verification --> then assertEquals ( zeit , \"2:00\" ); } } Wenn wir die Testklasse nun ausf\u00fchren, ohne die convert() -Methode zu \u00e4ndern, erhalten wir folgendes Bild: Der Balken im JUnit -Fenster ist rot. Darunter wird uns angegeben, dass der Testfall testConvert1amTo1() immer noch korrekt ist (gr\u00fcner Haken), aber der Testfall testConvert2amTo2() ist gescheitert (blaues Kreuz). Im Editorfenster ist rot unterlegt, welche Assertion gescheitert ist ( assertEquals(zeit, \"2:00\"); ). Wir brauchen nun also eine Idee, wie wir die convert() -Methode anpassen k\u00f6nnen, so dass beide Testf\u00e4lle korrekt ausgef\u00fchrt werden. Wir versuchen es mit der Idee, einfach die ersten vier Zeichen des \u00fcbergebenen Strings time zur\u00fcckzugeben: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return time . substring ( 0 , 4 ); } } Wenn wir nun unsere Testklasse ausf\u00fchren, dann sind beide Testf\u00e4lle korrekt. Auf diese Art und Weise entwickeln wir nach und nach eine Implementierung der convert() -Methode. Dazu f\u00fcgen wir nach und nach immer weitere Testf\u00e4lle unserer Testklasse hinzu. Mindestens noch f\u00fcr folgende F\u00e4lle: time erwartetes Ergebnis \"1:15 am\" \"1:15\" \"11:00 am\" \"11:00\" \"11:15 am\" \"11:15\" \"1:00 pm\" \"13:00\" \"2:00 pm\" \"14:00\" \"1:15 pm\" \"13:15\" \"11:00 pm\" \"23:00\" \"11:15 pm\" \"23:15\" \"12:00 am\" \"0:00\" \"12:01 am\" \"0:01\" \"12:00 pm\" \"12:00\" \"12:01 pm\" \"12:01\" \"12:00 noon\" \"12:00\" \"12:00 midnight\" \"0:00\" Das Auswahl der Testwerte ist ganz offensichtlich ein wichtiges Thema und bestimmt die Korrektheit der sp\u00e4teren Implementierung mit. Es ist wichtig, keinen Testfall zu vergessen. Leider gibt es daf\u00fcr keine formalen Regeln, sondern nur intuitive Vorgaben. Es wird immer versucht, \"Grenzwerte\" zu ermitteln, um wirklich alle Testf\u00e4lle abzudecken.","title":"Eine erste Testmethode f\u00fcr unser Beispiel"},{"location":"junit/#quellcode-aus-dem-video","text":"Im Video \u00fcber JUnit wurde folgender Quellcode erzeugt: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package videos.video4 ; import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; public class UmrechnungTimeZeit { public String convert ( String time ) { final int LAST_THREE_CHARS = 3 ; // \" pm\" or \" am\" if ( time . endsWith ( \"am\" )) { return time . substring ( 0 ,( time . length () - LAST_THREE_CHARS )); } else // ends with pm { final int DIFFERENCE_BETWEEN_H_TO_HH = 12 ; int hourInt = this . getHoursInt ( time ); hourInt += DIFFERENCE_BETWEEN_H_TO_HH ; String minutes = this . getMinutesStr ( time ); String zeit = hourInt + \":\" + minutes ; return zeit ; } } String getHoursStr ( String time ) { String [] allStr = time . split ( \":\" ); return allStr [ 0 ] ; } String getMinutesStr ( String time ) { final int FIRST_TWO_CHARS = 2 ; String [] allStr = time . split ( \":\" ); String afterDouble = allStr [ 1 ] ; String minutesStr = afterDouble . substring ( 0 , FIRST_TWO_CHARS ); return minutesStr ; } int getHoursInt ( String time ) { String hoursStr = this . getHoursStr ( time ); int hoursInt = Integer . valueOf ( hoursStr ); return hoursInt ; } } UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 package videos.video4 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class UmrechnungTimeZeitTest { @Test void testConvert1amTo1 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 am\" ); // than (verification) assertEquals ( zeit , \"1:00\" , \"1:00 am to 1:00 not working\" ); } @Test void testConvert2amTo2 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"2:00 am\" ); // than (verification) assertEquals ( zeit , \"2:00\" , \"2:00 am to 2:00 not working\" ); } @Test void testConvert9amTo9 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"9:00 am\" ); // than (verification) assertEquals ( \"9:00\" , zeit ); } @Test void testConvert10amTo10 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"10:00 am\" ); // than (verification) assertEquals ( \"10:00\" , zeit ); } @Test void testConvert1115amTo1115 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:15 am\" ); // than (verification) assertEquals ( \"11:15\" , zeit ); } @Test void testConvert1pmTo13 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 pm\" ); // than (verification) assertEquals ( \"13:00\" , zeit ); } @Test void testConvert3pmTo15 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"3:00 pm\" ); // than (verification) assertEquals ( \"15:00\" , zeit ); } @Test void testConvert545pmTo1745 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"5:45 pm\" ); // than (verification) assertEquals ( \"17:45\" , zeit ); } @Test void testConvert11pmTo23 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:00 pm\" ); // than (verification) assertEquals ( \"23:00\" , zeit ); } @Test void testGetHoursStr11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"11\" , hour ); } @Test void testGetHoursStr1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"1\" , hour ); } @Test void testGetHoursInt1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"1:00 pm\" ); // than (verification) assertEquals ( 1 , hours ); } @Test void testGetHoursInt11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"11:00 pm\" ); // than (verification) assertEquals ( 11 , hours ); } @Test void testGetMinutes1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } @Test void testGetMinutes11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } } module-info.java module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; }","title":"Quellcode aus dem Video"},{"location":"junit/#noch-ein-kleines-beispiel","text":"Wir betrachten die Klasse Power mit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class Power { private int base ; private int exp ; public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public double value () { double value = 1.0 ; if ( exp > 0 ) { for ( int i = 0 ; i < exp ; i ++ ) { value *= base ; } } else { for ( int i = 0 ; i <- exp ; i ++ ) { value *= base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \"^\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Power p = ( Power ) o ; return ( this . base == p . base && this . exp == p . exp ); } @Override public int hashCode () { return 7 * this . base + 11 * this . exp ; } } F\u00fcr diese Klasse erstellen wir eine Testklasse, die neben der Annotation @Test auch die Annotationen @BeforeAll und @BeforeEach exemplarisch verwendet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; class PowerTest { static Power p1 , p2 , p3 , p4 ; static int testnr = 1 ; @BeforeAll public static void setup () { p1 = new Power ( 2 , 3 ); p2 = new Power ( 2 , 3 ); p3 = new Power ( - 2 , 3 ); p4 = new Power ( 2 , - 3 ); } @BeforeEach public void printBeforeTests () { System . out . printf ( \"%n %n --------------- Test %d ------------ %n\" , testnr ); p1 . print (); p2 . print (); testnr ++ ; } @Test void testToString () { String s = p1 . toString (); assertEquals ( \"(2^3)\" , s , \"Strings are not equal!\" ); } @Test void testPower () { assertNotNull ( p1 , \"no Power object\" ); } @Test void testValue () { double value = p1 . value (); assertEquals ( value , 8.0 , \"2^3 should be 8.0\" ); } @Test public void testEqualsObject () { assertTrue ( p1 . equals ( p2 ), \" 2^3 should be equal to 2^3!\" ); } } Diese Testklasse deckt nat\u00fcrlich viel zu wenige Testf\u00e4lle ab, aber es geht hier nur ums Prinzip. F\u00fchren Sie die Testklasse aus und beobachten Sie dabei auch die Konsole. Vor jeden Test ( @BeforeEach ) gibt es eine Ausgabe auf die Konsole. Bevor irgendein Test ( @Test ) ausgef\u00fchrt wird ( @BeforeAll ) werden verschiedene Objekte der Klasse Power erzeugt. In den Testf\u00e4llen werden aber nur p1 und p2 verwendet. Das m\u00fcsste nat\u00fcrlich noch deutlich erweitert werden. Success Wir haben JUnit-Testing kennengelernt. Unit-Tests sind eine gute M\u00f6glichkeit, einzelne Methoden automatisiert zu testen. Mithilfe von Unit-Tests k\u00f6nnen wir Code so entwicklen, dass alle formulierten Tests erfolgreich bestehen. Werden erst die Tests geschrieben und gegen die Tests implementiert, wird dieses Programmierverfahren Test-driven development genannt. Unit-Tests k\u00f6nnen aber auch verwendet werden, um existierenden Code zu testen. JUnit ist das Framework f\u00fcr Java-Unit-Tests. Ausf\u00fchrliche Informationen zu JUnit sind hier zu finden.","title":"Noch ein kleines Beispiel"},{"location":"klausurvorbereitung/","text":"Klausurvorbereitung \u00b6 Alle wesentlichen Konzepte, die wir f\u00fcr die Klausur ben\u00f6tigen, haben wir jetzt in diesem und im vergangenen Semester gelernt. Wir wollen diese Kenntnisse nun durch mehrere Anwendungen vertiefen. Ganz vereinzelt wird dabei auch etwas Neues auftauchen. Dabei handelt es sich aber nicht um ein neues Konzept, sondern bspw. um einen Listener, den wir noch nicht hatten. Solche \"\u00dcberraschungen\" werden Sie aber in der Klausur nicht erleben. Dieses Kapitel wird hier so aufgebaut sein, dass es immer eine Aufgabe (eine Probeklausur) gibt und die dazugeh\u00f6rige L\u00f6sung, die aber \"aufgeklappt\" werden muss. Sie k\u00f6nnen ja immer zuerst probieren, die L\u00f6sung selbst\u00e4ndig zu entwickeln. Wenn Sie am Ende alle Aufgaben selbst\u00e4ndig l\u00f6sen k\u00f6nnen, sind Sie mit Sicherheit sehr gut auf die Klausur vorbereitet. Wir beginnen aber noch kurz mit allgemeinen Betrachtungen zum Grundger\u00fcst. Eines der nachfolgend vorgestellten Grundger\u00fcste werden Sie mit Sicherheit bei der Klausur verwenden k\u00f6nnen. M\u00f6gliche Grundger\u00fcste \u00b6 Wie Sie wissen, ist das Fenster ( JFrame ) im BorderLayout . Das bedeutet, dass das Fenster in f\u00fcnf Bereiche ( Container ) unterteilt ist. Sie m\u00fcssen sich bei der Konfiguration \u00fcberlegen, ob \"gezeichnet\" werden soll, d.h. ob das JPanel im CENTER des Fensters eine eigene Klasse ist, oder ob es mithilfe einer Methode erzeugt werden kann und welche der f\u00fcndf Bereiche Sie ben\u00f6tigen. Wir erl\u00e4utern das an Beispielen und beginnen mit einem Grundger\u00fcst, welches wir f\u00fcr das Zeichnen verwenden k\u00f6nnen, welches also eine Canvas enth\u00e4lt. Grundger\u00fcst mit Canvas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestMitCanvas extends JFrame { Canvas canvas ; public GrundgeruestMitCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestMitCanvas (); } } In diesem Grundger\u00fcst werden alle f\u00fcnf Bereiche des Fensters mit JPanel bef\u00fcllt. Das CENTER wird mit einem Objekt der Klasse Canvas bef\u00fcllt, welche von JPanel erbt. Diese Klasse wird ben\u00f6tigt, um in die paintComponent() -Methode zu zeichnen. Sollten Sie z.B. kein Panel im EAST - und im WEST -Bereich des Fensters ben\u00f6tigen, dann l\u00f6schen Sie einfach die Zeilen 23 und 24 sowei die beiden Methoden initEast() und initWest() . Ein Grundger\u00fcst ohne Canvas , also ohne Zeichnen, k\u00f6nnte dann so aussehen: Grundger\u00fcst ohne Canvas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.awt.BorderLayout ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestOhneCanvas extends JFrame { JPanel content ; public GrundgeruestOhneCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . content = this . initCenter (); this . getContentPane (). add ( this . content , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initCenter () { JPanel center = new JPanel (); // hier das JPanel fuer CENTER befuellen return center ; } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestOhneCanvas (); } } Beachten Sie, dass JPanel ohne Angabe eines LayoutManagers im FlowLayout sind. Das k\u00f6nnen Sie \u00e4ndern und die einzelnen JPanel auch noch weiter verschachteln . Eines dieser beiden Grundger\u00fcste k\u00f6nnen wir nun stets verwenden. Es muss dann jeweils \"nur\" noch angepasst werden. Wir beginnen mal mit einer Aufgabe. Quadrat \u00b6 Aufgabe Quadrat Schreiben Sie eine Klasse Quadrat , die folgendes Fenster darstellt: Es gibt also eine Zeichenfl\u00e4che ( Canvas ) und zwei Buttons new und fill . Nach dem Klicken des Buttons new soll ein schwarzes unausgef\u00fclltes Quadrat mit der Strichst\u00e4rke 3.0 so in der Zeichenfl\u00e4che erscheinen, dass es mittig in der Zeichenfl\u00e4che angeordnet ist und der k\u00fcrzere der beiden Abst\u00e4nde (links/rechts oder oben/unten) ca. 10% der Zeichenfl\u00e4che gro\u00df ist. Nach dem Klicken des Buttons new steht darin nicht mehr new , sondern refresh . Nach Klicken des Buttons fill soll das Quadrat mit einer zuf\u00e4llig gew\u00e4hlten Farbe bef\u00fcllt werden. Es soll aber trotzdem noch der schwarze Rand bleiben (am einfachsten: einmal mit der zuf\u00e4llig gew\u00e4hlten Farbe bef\u00fcllt und danach nochmal unbef\u00fcllt schwarz malen). Der Button wechselt den Text auf unfill . Nach dem Klicken auf unfill soll das Quadrat wieder unausgef\u00fcllt sein. Die zuf\u00e4llig erzeugte Farbe soll so lange die Farbe zum Ausf\u00fcllen bleiben, bis der refresh -Button geklickt wird, d.h. durch mehrmaliges Klicken des Button fill und unfill \u00e4ndert sich die Farbe zum Bef\u00fcllen des Quadrats nicht, erst durch Klicken des Button refresh wird eine neue Farbe erzeugt, die dann wieder bis zum n\u00e4chsten Klicken von refresh bleibt. Implementieren Sie den MouseListener und den MouseMotionListener so, dass Sie bei gedr\u00fcckter Maustaste die Gr\u00f6\u00dfe des Quadrates \u00e4ndern. Wenn Sie mit der Maus auf eine Kante des Quadrates ( +/-10px ) klicken und dann die Maus gedr\u00fcckt halten, \u00e4ndert sich die Gr\u00f6\u00dfe des Quadrates entsprechend. Wenn Sie weit weg von (also mehr als 10px von der Kante entfernt) einer Kante klicken (egal, ob im Quadrat oder au\u00dferhalb), passiert gar nichts. Die Gr\u00f6\u00dfen\u00e4nderungen sollen stets sofort sichtbar sein. Nach Loslassen der Maustaste bleibt das Quadrat in der eingestellten Gr\u00f6\u00dfe. Das Quadrat bleibt stets m\u00f6glichst mittig. Tipp : An welche Kante Sie klicken, ist egal. Klicken Sie auf eine vertikale Kante (links oder rechts), brauchen Sie nur die \u00c4nderungen des x-Wertes zu ber\u00fccksichtigen, klicken Sie auf eine horizontale Kante (oben oder unten), brauchen Sie nur die \u00c4nderungen der y-Werte zu ber\u00fccksichtigen, um die neue Gr\u00f6\u00dfe des Quadrates zu ermitteln. L\u00f6sung Quadrat Zuerst \u00fcberlegen wir uns, welches Grundger\u00fcst wir verwenden und wie wir es anpassen. Wir m\u00fcssen zeichnen , also das Grundger\u00fcst mit Canvas . Von den Nord-, S\u00fcd-, Ost-, West-Bereichen ben\u00f6tigen wir nur den S\u00fcden (dort kommen die 'new'- und fill -Buttons rein). Also ist das unser Ausgangspunkt, in das wir schonmal die Buttons eingef\u00fcgt haben: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); JButton fillBtn = new JButton ( \"fill\" ); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Von den initXXX() -Methoden ben\u00f6tigen wir auch nur noch initSouth() . Die anderen drei sind deshalb gel\u00f6scht. Die Implementierung des ActionListener f\u00fcr den new -Button erledigen wir mit einer anonymen Klasse. Wir m\u00fcssen uns \u00fcberlegen, ob es notwendig ist, f\u00fcr das Quadrat eine eigene Datenstruktur (z.B. Klasse) anzulegen. Zun\u00e4chst machen wir das einmal ohne, sondern geben nur in einer globalen Variablen zeigeQuadrat an, ob das Quadrat gezeichnet werden soll oder nicht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Quadrat . this . zeigeQuadrat = true ; JButton thisBtn = ( JButton ) e . getSource (); // kann nur der newBtn sein! thisBtn . setText ( \"refresh\" ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Wenn die Variable zeigeQuadrat durch den Buttonklick auf true gesetzt wurde (Zeile 74 ), dann wird in der paintComponent() -Methode das Quadrat dargestellt (Zeile 40 ). Zur korrekten Darstellung des Quadrates ist es von Bedeutung, ob das Fenster (die Canvas ) h\u00f6her als breit ist oder umgedreht (Zeile 45 ). Ist es h\u00f6her als breit, dann wird es in die Breite der Canvas eingepasst, d.h. der Abstand nach links ist 1/10 der Canvas -Breite (Zeile 47 ) und die Seitenl\u00e4nge des Quadrates ist 8/10 der Breite (Zeile 48 ). Der Abstand des Quadrates nach oben muss entsprechend berechnet werden (Zeile 49 ). Ist es breiter als hoch, dann wird es in die H\u00f6he der Canvas eingepasst, d.h. der Abstand nach oben ist 1/10 der Canvas -H\u00f6he (Zeile 54 ) und die Seitenl\u00e4nge des Quadrates ist 8/10 der H\u00f6he (Zeile 55 ). Der Abstand des Quadrates nach links muss entsprechend berechnet werden (Zeile 56 ). In der actionPerformed() -Methode f\u00fcr den Button wird nicht nur zeigeQuadrat auf true gesetzt, sondern die Canvas auch neu gezeichnet (Zeile 77 )! Die Quelle des ActionEvent kann nur der Button selbst sein, da wir eine anonyme Klasse zur Implementierung des ActionListener verwenden. Deshalb k\u00f6nnen wir die Quelle ohne Pr\u00fcfung in einen JButton konvertieren (Zeile 75 ). Mithilfe der setText() -methode f\u00fcr JButton setzen wir den neuen Buttontext auf refresh (Zeile 76 ). Die Implementierung des ActionListener f\u00fcr den fill -Button erledigen wir erneut mit einer anonymen Klasse. Wir gehen \u00e4hnlich vor, wie beim new -Button und erstellen eine globale Variable fuelleQuadrat . Diese gibt an, ob das Quadrat bef\u00fcllt gezeichnet werden soll oder nicht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); g2 . setColor ( new Color ( rot , gruen , blau )); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Quadrat . this . zeigeQuadrat = true ; JButton thisBtn = ( JButton ) e . getSource (); // kann nur der newBtn sein! thisBtn . setText ( \"refresh\" ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Die Farbe zum Ausf\u00fcllen erzeugen wir zuf\u00e4llig mithilfe von Random (Zeilen 48-52 ). Es wird jeweils zuerst aus das ausgef\u00fcllte Quadrat gezeichnet (Zeile 61 bzw. 73 ) falls fuelleQuadrat den Wert true hat (Zeile 59 bzw. 71 ). Nach dem Zeichnen des bef\u00fcllten Quadrates wird die Zeichenfarbe wieder auf schwarz gestellt (Zeile 63 bzw. 75 ) und dann das nichtausgef\u00fcllte Quadrat gezeichnet. In der actionPerformed() _Methode m\u00fcssen wir unterscheiden, ob im Button fill steht oder unfill (zeile 108 ). Je nachdem wird fuelleQuadrat auf true oder false gesetzt und der Text im Button entsprechend ge\u00e4ndert. Um nicht bei jeden Aufruf von paintComponent() eine neue F\u00fcllfarbe zuf\u00e4llig zu erzeugen, muss das Erzeugen der Farbe ausgelagert werden. Da auf die Farbe sowohl in paintComponent() ( View ) als auch in actionPerfomed() ( Controller ) zugegriffen wird, muss diese als globale Referenz deklariert werden. Wahrscheinlich ist es gut, die Farbe beim ersten Mal zu erzeugen, wenn der new -Button geklickt wird und dann immer durch das Klicken des refresh -Buttons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } F\u00fcr eine geeignete Implementierung des MouseListener und des MouseMotionListener ben\u00f6tigen wir globalen Zugriff auf die Gr\u00f6\u00dfe und die Position des Quadrates. Wir m\u00fcssen ja mit der Maus erkennen k\u00f6nnen, ob wir eine Kante des Quadrates getroffen haben. Wir lagern deshalb einige Werte des Quadrates global aus (und Umbenennungen): int quadratLinks, quadratRechts, quadratOben, quadratUnten, quadratLaenge; In paintComponent() werden diese globalen Variablen nun mit Werten belegt: if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } Nun implementieren wir MouseListener und MouseMotionListener und melden canvas daran an. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; int quadratLinks , quadratRechts , quadratOben , quadratUnten , quadratLaenge ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } @Override public void mousePressed ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mousePressed x=\" + x + \", y=\" + y ); } @Override public void mouseDragged ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseDragged x=\" + x + \", y=\" + y ); } @Override public void mouseReleased ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseReleased x=\" + x + \", y=\" + y ); } @Override public void mouseMoved ( MouseEvent e ) {} @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } F\u00fcr das eigentliche Verschieben r\u00e4cht sich jetzt, dass wir uns anfangs keine gute Datenstruktur \u00fcberlegt hatten. Es wird jetzt alles ein wenig komplizierter, da wir mehrere Unterscheidungen treffen m\u00fcssen: Wir m\u00fcssen unterscheiden, ob das Quadrat nun gerade bewegt wird oder nicht. Wir m\u00fcssen unterscheiden, ob wir die linke Kante bewegen, oder die rechte oder die untere oder die obere. F\u00fcr alle dieses Unterscheidungen erstellen wir uns globale Variablen. if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } Nun implementieren wir MouseListener und MouseMotionListener und melden canvas daran an. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; int quadratLinks , quadratRechts , quadratOben , quadratUnten , quadratLaenge ; boolean bewegt = false ; boolean linkeKante = false ; boolean rechteKante = false ; boolean obereKante = false ; boolean untereKante = false ; int warX = 0 ; int warY = 0 ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( ! Quadrat . this . bewegt ) { if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } else // bewegt { if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } @Override public void mousePressed ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mousePressed x=\" + x + \", y=\" + y ); int linksX = this . quadratLinks ; int rechtsX = this . quadratRechts ; int obenY = this . quadratOben ; int untenY = this . quadratUnten ; if ( x > linksX - 10 && x < linksX + 10 ) { this . bewegt = true ; this . linkeKante = true ; this . warX = x ; } else if ( x > rechtsX - 10 && x < rechtsX + 10 ) { this . bewegt = true ; this . rechteKante = true ; this . warX = x ; } else if ( y > obenY - 10 && y < obenY + 10 ) { this . bewegt = true ; this . obereKante = true ; this . warY = y ; } else if ( y > untenY - 10 && y < untenY + 10 ) { this . bewegt = true ; this . untereKante = true ; this . warY = y ; } } @Override public void mouseDragged ( MouseEvent e ) { if ( this . bewegt ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseDragged x=\" + x + \", y=\" + y ); if ( this . linkeKante ) { int diffX = x - this . warX ; this . quadratLinks = this . quadratLinks + diffX ; this . quadratOben = this . quadratOben + diffX ; this . quadratLaenge = this . quadratLaenge - 2 * diffX ; this . warX = x ; } else if ( this . rechteKante ) { int diffX = x - this . warX ; this . quadratLinks = this . quadratLinks - diffX ; this . quadratOben = this . quadratOben - diffX ; this . quadratLaenge = this . quadratLaenge + 2 * diffX ; this . warX = x ; } else if ( this . obereKante ) { int diffY = y - this . warY ; this . quadratLinks = this . quadratLinks + diffY ; this . quadratOben = this . quadratOben + diffY ; this . quadratLaenge = this . quadratLaenge - 2 * diffY ; this . warY = y ; } else if ( this . untereKante ) { int diffY = y - this . warY ; this . quadratLinks = this . quadratLinks - diffY ; this . quadratOben = this . quadratOben - diffY ; this . quadratLaenge = this . quadratLaenge + 2 * diffY ; this . warY = y ; } Quadrat . this . canvas . repaint (); } } @Override public void mouseReleased ( MouseEvent e ) { this . bewegt = false ; Quadrat . this . canvas . repaint (); } @Override public void mouseMoved ( MouseEvent e ) {} @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } In mousePressed() bestimmen wir zun\u00e4chst, ob wir in der N\u00e4he der linken oder der rechten oder der oberen oder unteren Kante geklickt haben. Wenn ja, dann setzen wir die entsprechenden Variablen und merken uns, wo ( warX oder warY ) wir hingeklickt hatten. In mouseDragged() wird zun\u00e4chst ermittelt, ob wir \u00fcberhaupt im bewegt -Modus sind. Wenn ja, ermitteln wir, wie weit und wohin wir uns seit dem letzten Aufruf von mouseDragged() bewegt haben. Dementsprechend werden die Variablen f\u00fcr das Quadrat neu gesetzt. Wenn wir die Maus wieder loslassen ( mouseReleased() ) wird bewegt wieder auf false gesetzt und das Quadrat wird somit wieder \"normal\" durch die paintComponent() -Methode dargestellt. Schachbrett \u00b6 Aufgabe Schachbrett Schreiben Sie eine Klasse Schachbrett , die folgendes Fenster darstellt: Es werden 8x8 Rechtecke dargestellt \u2013 abwechselnd mit grauem und wei\u00dfem Hintergrund bitte beachten: die dargestellten Rechtecke sind gezeichnet, es handelt sich nicht um einzelne JPanels!!! (ist f\u00fcr sp\u00e4ter wichtig) das 8x8-Feld der Rechtecke f\u00fcllt die Zeichenfl\u00e4che vollst\u00e4ndig , d.h. wenn Sie die Gr\u00f6\u00dfe des Fensters ver\u00e4ndern, passt sich auch das 8x8-Feld entsprechend an Implementieren Sie den MausListener so, dass Sie durch Mausklick auf die Zeichenfl\u00e4che einen ausgef\u00fcllten Kreis in das Rechteck malen, in das Sie geklickt haben. Die Abbildung zeigt das Schachbrett nach einem Mausklick auf das Rechteck in der 2. Zeile und 4. Spalte. Versuchen Sie, die Kreise m\u00f6glichst zentriert in die Rechtecke zu malen. Eine gute Gr\u00f6\u00dfe f\u00fcr den Durchmesser der Kreise ist \u2153 der Breite oder H\u00f6he der Rechtecke. Klicken Sie mehrmals mit der Maus, werden entsprechend mehrere Kreise dargestellt. F\u00fcgen Sie dem S\u00fcden des Fensters ein JPanel hinzu. Dieses JPanel enth\u00e4lt einen JButton 'clear field' . Nach Dr\u00fccken dieses Buttons werden alle roten Kreise wieder gel\u00f6scht. Erweitern Sie Ihre Implementierung nun so, dass durch einen Mausklick nicht nur ein roter Kreis gezeichnet wird, sondern auch noch eine horizontale und eine vertikale Linie in der Zeile und der Spalte, in der der Kreis gezeichnet wird. in der Zeile und Spalte des Kreises erscheint jeweils mittig eine rote Linie Abbildung zeigt Schachbrett nach mehreren Mausklicks Die Linien m\u00fcssen nicht, wie im Bild dargestellt, in der Mitte der Rechtecke anfangen. Sie k\u00f6nnen auch komplett durchgezeichnet werden, d.h. vom Beginn bis zum Ende einer Zeile bzw. Spalte. Erweitern Sie Ihre Implementierung nun so, dass es nicht mehr m\u00f6glich ist, dass 2 Kreise in der gleichen Spalte oder in der gleichen Zeile erscheinen. Wenn Sie ein Rechteck anklicken, in dessen Zeile oder Spalte bereits ein anderer Kreis ist, so soll kein neuer Kreis gezeichnet werden, sondern das Rechteck als gr\u00fcnes Rechteck erscheinen. In das gr\u00fcne Rechteck wurde geklickt - es erscheint kein Kreis, da in der Zeile bereits ein Kreis ist \u2013 stattdessen ein gr\u00fcnes Rechteck. In das gr\u00fcne Rechteck wurde geklickt - es erscheint kein Kreis, da in der Zeile bereits ein Kreis ist - stattdessen ein gr\u00fcnes Rechteck. Das Rechteck bleibt nur bis zum n\u00e4chsten Klick markiert (gr\u00fcn). Zusatzaufgabe: Erweitern Sie die Schritte 5 und 6 auch auf die Diagonalen, d.h. es sollen auch die jeweiligen Diagonalen der Punkte eingezeichnet werden und keine zwei Punkte d\u00fcrfen in der gleichen Diagonalen liegen. L\u00f6sung Schachbrett Zuerst \u00fcberlegen wir uns, welches Grundger\u00fcst wir verwenden und wie wir es anpassen. Wir m\u00fcssen zeichnen , also das Grundger\u00fcst mit Canvas . Von den Nord-, S\u00fcd-, Ost-, West-Bereichen ben\u00f6tigen wir nur den S\u00fcden (dort kommt der 'clear field'-Button rein). Also ist das unser Ausgangspunkt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame { Canvas canvas ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } } Von den initXXX() -Methoden ben\u00f6tigen wir auch nur noch initSouth() . Die anderen drei sind deshalb gel\u00f6scht. Jetzt k\u00f6nnen wir mit dem Zeichnen des Schachbretts beginnen. Dazu k\u00f6nnten wir \"einfach\" 64 gleich gro\u00dfe Rechtecke in die Canvas zeichnen. Wir sollten hier aber unbedingt daf\u00fcr ein Model , d.h. eine Datenstruktur erstellen und diese dann in der View darstellen. F\u00fcr eine solche Datenstruktur (f\u00fcr ein Model ) gibt es drei Gr\u00fcnde: wir wollen sp\u00e4ter erkennen, in welches Feld geklickt wurde und wir wollen erkennen k\u00f6nnen, in welches Feld bereits geklickt wurde und wir wollen erkennen k\u00f6nnen, welche Felder Nachbarfelder sind. Da die Dimensionen hier fest sind (8x8), kann man das in einem (zweidimensionalen) Array erledigen. Als Typ jedes einzelnen Elementes sollte boolean gen\u00fcgen - markiert oder nicht markiert. Wenn Sie sich nicht sicher sind, ob zwei Zust\u00e4nde gen\u00fcgen, k\u00f6nnen Sie auch eine enum als Typ verwenden. Wir machen das mal, dann bleibt die L\u00f6sung flexibler und wir \u00fcben enum nochmal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } } Wir h\u00e4tten das field auch im Konstruktor erzeugen und bef\u00fcllen k\u00f6nnen, lagern es aber in eine eigene Methode aus und rufen diese im Konstruktor auf. Alles, was wir funktional in eine eigene Methode auslagern k\u00f6nnen, sollten wir auch auslagern - liest sich viel besser! Jetzt \u00fcberlegen wir, wie wir das Schachbrett darstellen (die View ). Die Darstellung erfolgt am besten mit der fillRect() -Methode. Diese erwartet die Koordinaten des linken oberen Punktes und die Breite und die H\u00f6he des Rechtecks. Breite und H\u00f6he ergeben sich aus der Breite und H\u00f6he der Canvas , jeweils geteilt durch 8 . Aus der Position des zu zeichnenden Rechtecks in einer Zeile ergibt sich dann der x -Wert f\u00fcr den linken oberen Punkt und aus der Position des zu zeichnenden Feldes in der Spalte ergibt sich der y -Wert des linken oberen Punktes. Wir \u00e4ndern nun nur die paintComponent() -Methode (die View ), da es nur um die Darstellung geht: 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); int heightRect = canvasHeight / 8 ; int widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit gleichen Farbe anfangen, wie aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , widthRect , heightRect ); } } } } Wir laufen also durch das field -Array und ermitteln f\u00fcr die aktuelle Zeile den y -Wert und f\u00fcr die jeweils aktuelle Spalte den x -Wert. Damit wir immer zwischen Grau und Wei\u00df umschalten, erstellen wir uns eine boole'sche Variable grey , die abwechselnd true und false wird, je nachdem, ob wir als n\u00e4chstes ein graues oder ein wei\u00dfes Feld zeichnen wollen. Nach jeder Zeile \u00e4ndert sich die Farbe jedoch nicht (wir fangen in der neuen Zeile mit der gleichen Farbe an, wie wir in der alten Zeile aufgeh\u00f6rt haben). Deshalb mussten wir noch die Anweisung in Zeile 61 hinzuf\u00fcgen. Das Schachbrett wird nun so gezeichnet, wie wir das wollten. Wenn das Fenster vergr\u00f6\u00dfert oder verkleinert wird, dann passen sich die Felder entsprechend an, da wir alles abh\u00e4ngig von der Breite und H\u00f6he der Canvas berechnen. Wir k\u00f6nnen aber die Fenstergr\u00f6\u00dfe aber gleich etwas quadratischer gestalten (z.B. this.setSize(400, 400); ). Jetzt k\u00fcmmern wir uns um die roten Punkte inmitten des Rechtecks, falls wir mit der Maus darauf geklickt haben. Dazu ben\u00f6tigen wir den MouseListener , denn es geht um einen Mausklick (also entweder mouseClicked() oder mousePressed() ) und nicht um eine Bewegung der Maus. Wir entscheiden uns f\u00fcr mouseClicked() - das ist nun also unser Controller . Wir implementieren zun\u00e4chst den MouseListener und pr\u00fcfen, ob damit alles funktioniert (ob wir z.B. nicht vergessen haben, an den MouseListener anzumelden.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); int heightRect = canvasHeight / 8 ; int widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , widthRect , heightRect ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Wir f\u00fcgen das implements MouseListener im Klassenkopf ein und importieren den MouseListener aus dem java.awt.event -Paket (lassen wir nat\u00fcrlich Eclipse erledigen). Wir lassen Eclipse durch Add unimplemented methods die Methoden aus dem MouseListener hinzuf\u00fcgen. Dabei wird auch MouseEvent importiert. Da wir uns f\u00fcr die Implementierung von mouseClicked() entschieden haben, k\u00f6nnen wir die anderen Methoden ein wenig verkleinern, um \u00dcbersicht zu bewahren. In mouseClicked() k\u00f6nnen wir schonmal die Koordinaten des MouseEvent abfragen und eine Ausgabe auf die Konsole durchf\u00fchren, um zu kontrollieren, ob alles funktioniert. Unbedingt m\u00fcssen wir nat\u00fcrlich canvas an den MouseListener anmelden (Zeile 25 ). mouseClicked() wird aufgerufen, wenn wir in das Feld klicken - die Koordinaten des Klicks in die Canvas werden auf der Konsole ausgegeben. Nun m\u00fcssten wir uns \u00fcberlegen, auf welches Rechteck aus dem field -Array wir geklickt haben. Dieses Rechteck wollen wir als MARKIERT speichern. Angenommen, wir kennen die Koordinaten x und y des Mausklicks in die Canvas . Um nun zu wissen, in welche \"Spalte\" oder \"Zeile\" wir geklickt haben, m\u00fcssen wir die Breite und H\u00f6he der Rechtecke kennen. Diese kennen wir aber in mouseClicked() nicht, da die Breite und H\u00f6he der Rechtecke jeweils von der Breite und H\u00f6he der Canvas abh\u00e4ngig ist (welche sich \u00e4ndern k\u00f6nnen). Die H\u00f6he und Breite der Rechtecke ist somit eine Eigenschaft der Canvas und um auf diese Eigenschaft zuzugreifen, m\u00fcssen wir sie global verf\u00fcgbar machen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { int heightRect = 0 ; int widthRect = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; this . field [ zeile ][ spalte ] = State . MARKIERT ; System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Die Variablen heightRect und widthRect werden in den Zeilen 50 und 51 als global deklariert. In den Zeilen 61 und 62 bekommen diese Variablen ihren Wert abh\u00e4ngig von der Gr\u00f6\u00dfe der Canvas . Nun k\u00f6nnen wir auf diese Werte in der mouseClicked() -Methode \u00fcber die canvas -Referenz zugreifen (Zeilen 105 und 106 ). F\u00fcr die Berechnung der zeile und spalte verwenden wir die Integer-Division (wie oft passt ein Rechteck in x bzw. in y ?). Das entsprechende Feld setzen wir auf MARKIERT (Zeile 108 ). Zur Kontrolle noch eine Konsolenausgabe (Zeile 109 ). Damit wir es nicht vergessen, sicherheitshalber schonmal das repaint() der canvas (Zeile 110 ). In alle als MARKIERT markierten Felder zeichnen wir nun einen roten Kreis. Gezeichnet wird immer in der paintComponent() : 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); } } } } Da die linke obere \"Ecke\" des Kreises weiter rechts und weiter unten als die linke obere Ecke des Rechtecks ist, f\u00fcgen wir noch einen abstandX und einen abstandY hinzu, der sich jeweils aus dem Drittel der Rechtecksbreite und der Recjtecksh\u00f6he ergibt (Zeilen 84 und 85 ). Der Durchmesser des Kreises ist dann ebenfalls ein Drittel (somit bleibt das dritte Dtrittel als Abstand rechts - der Kreis ist recht mittig) - Zeile 86 . Wir setzen die Farbe auf rot und zeichnen den Kreis (Zeilen 87 und 88 ). Die roten vertikalen und horizontalen Linien k\u00f6nnten wir nun auch noch gleich zeichnen: 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawLine (( this . widthRect / 2 ), y + ( this . heightRect / 2 ), canvasWidth - ( this . widthRect / 2 ), y + ( this . heightRect / 2 )); g2 . drawLine ( x + ( this . widthRect / 2 ), ( this . heightRect / 2 ), x + ( this . widthRect / 2 ), canvasHeight - ( this . heightRect / 2 )); } } } } Das Zeichnen passiert jetzt in zwei for -Schleifen. Zun\u00e4chst werden die grauen und wei\u00dfen Rechtecke gezeichnet und erst danach die roten Kreise und Linien. H\u00e4tten wir auch die Linien in der ersten for -Schleife gezeichnet, w\u00e4ren sie teilweise von den nachfolgenden Rechtecken abgedeckt und somit nur teilweise sichtbar gewesen. Das Zeichnen der beiden Linien (vertikal und horizontal) erfolgt in den Zeilen 99-101 . Zun\u00e4chst wird die Strichst\u00e4rke etwas erh\u00f6ht (auf 3.0f px). In Zeile 100 wird die horizontale Linie gezeichnet. Diese Linie k\u00f6nnte auch bei x=0 beginnen und bei canvasWidth aufh\u00f6ren. Um sie in der Mitte des ersten Rechtecks beginnen zu lassen, wird statt x=0 x=(this.rectWidth/2) gew\u00e4hlt. Um sie in der Mitte des letzten Rechtecks enden zu lassen, wird statt x=canvasWidth x=canvasWidth-(this.rectWidth/2) gew\u00e4hlt. In welcher Zeile diese Linie gezeichnet wird, ergibt sich aus dem Wert von y . Dieser Wert bestimmt aber die oberste Kante der Zeile. Um die Linie in die Mitte der Zeile zu zeichnen, wird jeweils this.heightRect/2 zu y addiert. Das Zeichnen der vertikalen Linie in Zeile 101 ist ganz \u00e4hnlich, nur dass der Wert von x bestimmt, in welche Spaqlte die Linie gezeichnet wird und die y -Werte jeweils so angepasst werden, dass die Linie nicht ganz oben beginnt und ganz oben endet, sondern jeweils mittig im Rechteck. Um zu verhindern, dass zwei rote Punkte in derselben Zeile bzw. in derselben Spalte sind, m\u00fcssen wir im Controller eine weitere Bedingung einbauen, die pr\u00fcft, ob das angeklickte Feld \u00fcberhaupt auf MARKIERT gesetzt werden darf. Dazu muss f\u00fcr eine gegebene zeile und eine gegebene spalte gepr\u00fcft werden, ob sich darin bereits ein MARKIERT es field befindet. Es wird also die mouseClicked() -Methode angepasst: 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } Wir erstellen uns eine Variable bereitsMarkiert , in der wir uns merken wollen, ob ein bereits MARKIERT es field in der zeile oder in der spalte existiert (Zeile 134 ). In den Zeilen 135-138 wird gepr\u00fcft, ob das Feld selbst in zeile und spalte bereits MARKIERT ist. In den Zeilen 140-146 wird gepr\u00fcft, ob in der spalte ein bereits MARKIERT es field existiert. In den Zeilen 148-154 wird gepr\u00fcft, ob in der zeile ein bereits MARKIERT es field existiert. Nur, wenn keine der drei Bedingungen erf\u00fcllt sind, kann das field[zeile][spalte] auf MARKIERT gesetzt werden. Somit wird die Anforderung , dass keine zwei Felder in einer Zeile bzw. in einer Spalte auf MARKIERT gesetzt sein d\u00fcrfen, erf\u00fcllt. Die Pr\u00fcfung geschieht \"nur\" im Controller ! Wie kann nun daf\u00fcr gesorgt werden, dass das Feld gr\u00fcn erscheint, wenn es zwar angeklickt wird, aber bereits ein markiertes Feld in der Zeile bzw. der Spalte existiert? Eine einfache M\u00f6glichkeit w\u00e4re, einfach einen neuen State hinzuzuf\u00fcgen, z.B. GRUEN . Wir k\u00f6nnen uns aber auch zwei globale Variablen gruenZeile und gruenSpalte erzeugen und wenn diese jeweils einen Wert besitzen, der innerhalb des field -Bereiches liegt, dann solll dieses Feld einen gr\u00fcnen Hintergrund bekommen. Es gibt viele M\u00f6glichkeiten, wir nehmen mal die erste: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT , GREEN }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { int heightRect = 0 ; int widthRect = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } if ( Schachbrett . this . field [ row ][ col ] == State . GREEN ) { g2 . setColor ( Color . GREEN ); Schachbrett . this . field [ row ][ col ] = State . UNMARKIERT ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawLine (( this . widthRect / 2 ), y + ( this . heightRect / 2 ), canvasWidth - ( this . widthRect / 2 ), y + ( this . heightRect / 2 )); g2 . drawLine ( x + ( this . widthRect / 2 ), ( this . heightRect / 2 ), x + ( this . widthRect / 2 ), canvasHeight - ( this . heightRect / 2 )); } } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } else { this . field [ zeile ][ spalte ] = State . GREEN ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Jetzt wird der clear field -Button erzeugt und f\u00fcr diesen Button der ActionListener implementiert. Das kann alles innerhalb der initSouth() -Methode passieren. Das L\u00f6schen des Feldes besteht darin, alle Felder auf UNMARKIERT zu setzen. Das erledigt bereits die initField() -Methode. Diese Methode muss also nur aufgerufen werden und danach die canvas neu gezeichnet: 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } Wir erstellen uns eine Variable bereitsMarkiert , in der wir uns merken wollen, ob ein bereits MARKIERT es field in der zeile oder in der spalte existiert (Zeile 134 ). In den Zeilen 135-138 wird gepr\u00fcft, ob das Feld selbst in zeile und spalte bereits MARKIERT ist. In den Zeilen 140-146 wird gepr\u00fcft, ob in der spalte ein bereits MARKIERT es field existiert. In den Zeilen 148-154 wird gepr\u00fcft, ob in der zeile ein bereits MARKIERT es field existiert. Nur, wenn keine der drei Bedingungen erf\u00fcllt sind, kann das field[zeile][spalte] auf MARKIERT gesetzt werden. Somit wird die Anforderung , dass keine zwei Felder in einer Zeile bzw. in einer Spalte auf MARKIERT gesetzt sein d\u00fcrfen, erf\u00fcllt. Die Pr\u00fcfung geschieht \"nur\" im Controller ! Wie kann nun daf\u00fcr gesorgt werden, dass das Feld gr\u00fcn erscheint, wenn es zwar angeklickt wird, aber bereits ein markiertes Feld in der Zeile bzw. der Spalte existiert? Eine einfache M\u00f6glichkeit w\u00e4re, einfach einen neuen State hinzuzuf\u00fcgen, z.B. GRUEN . Wir k\u00f6nnen uns aber auch zwei globale Variablen gruenZeile und gruenSpalte erzeugen und wenn diese jeweils einen Wert besitzen, der innerhalb des field -Bereiches liegt, dann solll dieses Feld einen gr\u00fcnen Hintergrund bekommen. Es gibt viele M\u00f6glichkeiten, wir nehmen mal die erste: 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 private JPanel initSouth () { JPanel south = new JPanel (); JButton clearBtn = new JButton ( \"clear field\" ); clearBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Schachbrett . this . initField (); Schachbrett . this . canvas . repaint (); } }); south . add ( clearBtn ); return south ; } Die \u00dcberpr\u00fcfung eines \"Konfliktfalls\" f\u00fcr die Diagonalen kann ebenfalls in der mouseClicked() -Methode als zus\u00e4tzliche Bedingung eingef\u00fcgt werden. Dazu m\u00fcssen wir nur die Frage beantworten, wie wir ermitteln k\u00f6nnen, ob ein Feld mit den Koordinaten zeile1 und spalte1 auf einer Diagonalen des Feldes zeile und spalte liegt. Nehmen wir an, zeile=3 und spalte=4 . Dann w\u00e4ren z.B. zeile1=0 und spalte1=1 auf einer Diagonalen und auch zeile1=1 und spalte1=2 und auch zeile1=2 und spalte1=3 und auch zeile1=4 und spalte1=5 und auch zeile1=5 und spalte1=6 und auch zeile1=6 und spalte1=7 . F\u00fcr die andere Diagonale gilt zeile1=2 und spalte1=5 und auch zeile1=1 und spalte1=6 und auch zeile1=0 und spalte1=7 , aber auch zeile1=4 und spalte1=3 und auch zeile1=5 und spalte1=2 und auch zeile1=6 und spalte1=1 und auch zeile1=7 und spalte1=0 . Es gilt also, dass | zeile1 - zeile | == | spalte1 - spalte | , damit die Felder in zeile, spalte und zeile1, spalte1 in einer Diagonalen liegen. 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } // Diagonalen for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length && ! bereitsMarkiert ; col ++ ) { if ( ! ( col == spalte && row == zeile )) // nicht das Feld selbst betrachten { if (( Math . abs ( col - spalte ) == Math . abs ( row - zeile )) && Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } else { this . field [ zeile ][ spalte ] = State . GREEN ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } Schiebepuzzle \u00b6 Aufgabe Schiebepuzzle Implementieren Sie folgendes Puzzle: obige Abbildung zeigt den Anfangszustand des Puzzles ( 2 \u00fcber 1 links) obige Abbildung zeigt den Endzustand des Puzzles ( 1 \u00fcber 2 links) Das Puzzle besteht aus 5 \u201eKacheln\u201c, 3 gelben und 2 roten. Die roten Kacheln sind mit einer 1 und einer 2 nummeriert. Am Anfang steht die rote Kachel mit der 2 \u00fcber der roten Kachel mit der 1 . (siehe erste Abb.) Ziel des Puzzles ist es, die beiden roten Kacheln zu vertauschen. Wenn links die 1 \u00fcber der 2 steht, ist das Puzzle beendet. Wo die gelben Kacheln im Endzustand sind, ist egal (siehe zweite Abb.). Ein Feld ist stets frei (grau dargestellt). In dieses Feld kann eine benachbarte Kachel geschoben werden. Zeigen Sie oben die Anzahl der Z\u00fcge an. Wenn der Endzustand erreicht ist, kann nicht mehr gezogen werden! Der Button Neustart setzt alles wieder auf Anfang. Die Programmierung bleibt ganz Ihnen \u00fcberlassen. Zum Schieben einer Kachel auf das leere Feld, klickt man auf die Kachel selbst. Diese \u201ebewegt\u201c sich dann auf das leere (graue) Feld und hinterl\u00e4sst ein leeres (graues) Feld (siehe folgende Abb.) Tipps: Sie ben\u00f6tigen keine Canvas und kein \u00dcberschreiben der paintComponent() -Methode! Am einfachsten bekommt man ein Label in die Mitte eines Panels gesetzt, wenn das Panel im GridLayout(1,1) (oder sogar parameterlos) ist und Sie f\u00fcr das Label label.setHorizontalAlignment(JLabel.CENTER); definieren die (Schrift-)Farbe eines Labels setzt man mit label.setForeground(Color); die (Hintergrund-Farbe eines Panels setzt man mit panel.setBackground(Color); f\u00fcr das Identifizieren des entsprechenden Panels, auf das man geklickt hat, k\u00f6nnte es hilfreich sein, sich daf\u00fcr eine eigene Klasse zu schreiben (die von JPanel erbt). Muss aber nicht. wahrscheinlich ist es am einfachsten, ein zweidimensionales Array 2x3 als Datenstruktur f\u00fcr Ihr Puzzle zu verwenden L\u00f6sung Schiebepuzzle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class Puzzle extends JFrame { JLabel infoLabel ; int anzMoves ; enum State { EINS , ZWEI , LEER , GELB } State [][] field ; MyPanel [][] panels ; JPanel mainPanel ; Puzzle () { super ( \"Puzzle\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . infoLabelPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . mainPanelStart (), BorderLayout . CENTER ); this . getContentPane (). add ( this . buttonPanel (), BorderLayout . SOUTH ); this . setSize ( 500 , 400 ); this . setVisible ( true ); } /**************************************** * erstmal alles fuer das Model * initiale Belegung von field */ void initialisiereField () { this . field = new State [ 2 ][ 3 ] ; this . field [ 0 ][ 0 ] = State . ZWEI ; this . field [ 0 ][ 1 ] = State . LEER ; this . field [ 0 ][ 2 ] = State . GELB ; this . field [ 1 ][ 0 ] = State . EINS ; this . field [ 1 ][ 1 ] = State . GELB ; this . field [ 1 ][ 2 ] = State . GELB ; } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return zeile von LEER */ int getLeerZeile () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return zeile ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return spalte von LEER */ int getLeerSpalte () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return spalte ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * von field[fromZeile][fromSpalte] aus wird gezogen * es wird geprueft, ob die leere Kachel entweder in der gleichen zeile * ist --> dann muss die spalte von LEER entweder links oder rechts sein (+/+ 1) * oder in der gleichen spalte --> dann muss die zeile von LEER entweder * darueber oder darunter sein (+/+ 1) * @param fromZeile * @param fromSpalte * @return ob zug ausgefuehrt wurde oder nicht */ boolean makeMove ( int fromZeile , int fromSpalte ) { if ( this . field [ fromZeile ][ fromSpalte ]!= State . LEER ) { int zeileLeer = this . getLeerZeile (); int spalteLeer = this . getLeerSpalte (); if (( Math . abs ( zeileLeer - fromZeile ) == 1 && spalteLeer - fromSpalte == 0 ) || ( zeileLeer - fromZeile == 0 && Math . abs ( spalteLeer - fromSpalte ) == 1 )) { this . field [ zeileLeer ][ spalteLeer ]= this . field [ fromZeile ][ fromSpalte ] ; this . field [ fromZeile ][ fromSpalte ]= State . LEER ; this . printField (); // nur zum debuggen this . anzMoves ++ ; return true ; } } return false ; } /** * definition des endzustands (links oben EINS, links unten ZWEI) * @return ob endzustand erreicht oder nicht */ boolean ende () { return ( this . field [ 0 ][ 0 ]== State . EINS && this . field [ 1 ][ 0 ]== State . ZWEI ); } /********************************************* * jetzt alles fuer die View - ganz zu Anfang */ JPanel initialiserePanels () { this . panels = new MyPanel [ 2 ][ 3 ] ; for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); this . mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return this . mainPanel ; } JPanel mainPanelStart () { this . mainPanel = new JPanel (); this . mainPanel . setLayout ( new GridLayout ( 2 , 3 , 3 , 3 )); this . initialisiereField (); // model this . initialiserePanels (); // view return mainPanel ; } JPanel infoLabelPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( \"Anzahl Zuege : \" + this . anzMoves ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel buttonPanel () { JPanel buttonPanel = new JPanel (); JButton neuStart = new JButton ( \"Neustart\" ); neuStart . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Puzzle . this . restart (); } }); buttonPanel . add ( neuStart ); return buttonPanel ; } /** * jetzt f\u00fcr Restart und Update * Restart: nach Druecken des Buttons \"Neustart\" * Update: nach jedem Zug */ void restart () { this . anzMoves = 0 ; this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); this . initialisiereField (); this . updatePanels (); } void updateLabel ( boolean ende ) { if ( ende ) { this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); this . infoLabel . setText ( \"Ende! Anzahl Zuege : \" + this . anzMoves ); } else { this . infoLabel . setText ( \"Anzahl Zuege : \" + this . anzMoves ); } } void updatePanels () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); } } this . updateLabel ( this . ende ()); } /** * das ist nur zum \"Debuggen\" - aber ganz nuetzlich */ void printField () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { if ( this . field [ zeile ][ spalte ]== State . LEER ) System . out . print ( \" -\" ); else if ( this . field [ zeile ][ spalte ]== State . EINS ) System . out . print ( \" 1\" ); else if ( this . field [ zeile ][ spalte ]== State . ZWEI ) System . out . print ( \" 2\" ); else if ( this . field [ zeile ][ spalte ]== State . GELB ) System . out . print ( \" o\" ); } System . out . println (); } System . out . println (); } /** * die Klasse f\u00fcr die \"Kacheln\" * die \"Kacheln\" sind JPanels (mit allen JPanel-Methoden) * ausserdem noch nuetzliche Objekteigenschaften: zeile, spalte und das Label, * das auf der Kachel ist (f\u00fcr GELB und LEER ist das Label leer) */ class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; JLabel label ; MyPanel ( int zeile , int spalte ) { super (); this . zeile = zeile ; this . spalte = spalte ; this . setLayout ( new GridLayout ()); this . label = new JLabel (); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . add ( label ); this . addMouseListener ( this ); } void view ( State state ) { switch ( state ) // geht natuerlich auch mit if(state==State.EINS) usw. { case EINS : this . setBackground ( Color . RED ); this . label . setText ( \"1\" ); break ; case ZWEI : this . setBackground ( Color . RED ); this . label . setText ( \"2\" ); break ; case LEER : this . setBackground ( Color . LIGHT_GRAY ); this . label . setText ( \"\" ); break ; case GELB : this . setBackground ( Color . YELLOW ); this . label . setText ( \"\" ); break ; } } @Override public void mouseClicked ( MouseEvent e ) { if ( ! Puzzle . this . ende () && Puzzle . this . makeMove ( this . zeile , this . spalte )) Puzzle . this . updatePanels (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new Puzzle (); } } Rechtecke anordnen \u00b6 Aufgabe Rechtecke anordnen Implementieren Sie folgende GUI: die Abbildung zeigt die Ausgangssituation Die Zeichenfl\u00e4che ist in 4 gleichgro\u00dfe Teile unterteilt. Diese Unterteilung wird durch Linien dargestellt. Durch Dr\u00fccken des Buttons rectangle erscheint (beim ersten Mal ein gr\u00fcnes) Rechteck. Dieses Rechteck kann dann mit gedr\u00fcckter Maustaste verschoben werden. Sobald es im linken oberen Feld ist, wird es dort fixiert und kann nicht mehr bewegt werden. die obige Abbildung zeigt die Situation, in der das gr\u00fcne Rechteck fixiert ist und nicht mehr bewegt werden kann Nachdem das gr\u00fcne (erste) Rechteck fixiert ist, kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein rotes Rechteck. Das rote Rechteck soll in das rechte obere Feld. Nachdem auch das rote Rechteck fixiert ist, kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein gelbes Rechteck. Das gelbe Rechteck soll in das linke untere Feld. Nun kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein dunkelgraues Rechteck. Das dunkelgraue Rechteck soll in das rechte untere Feld. Wenn auch das graue Rechteck fixiert ist, ist die Endesituation erreicht (siehe Label oben in der folgenden Abbildung): Nach Klick auf den Button clear wird wieder die Ausgangssituation hergestellt: L\u00f6sung Rechtecke anordnen MyRectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import java.awt.Color ; import java.awt.Point ; public class MyRectangle { int x1 , y1 , x2 , y2 ; Color color ; boolean fixed ; MyRectangle ( int x1 , int y1 , int x2 , int y2 , Color color ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; this . color = color ; this . fixed = false ; } boolean inside ( int x , int y ) { return ( this . x1 <= x && this . x2 >= x && this . y1 <= y && this . y2 >= y ); } boolean inside ( Point p ) { return inside ( p . x , p . y ); } void move ( int diffX , int diffY ) { if ( ! this . fixed ) { this . x1 = this . x1 + diffX ; this . y1 = this . y1 + diffY ; this . x2 = this . x2 + diffX ; this . y2 = this . y2 + diffY ; } } Color getColor () { return this . color ; } Point getLinksOben () { return new Point ( this . x1 , this . y1 ); } Point getRechtsOben () { return new Point ( this . x2 , this . y1 ); } Point getLinksUnten () { return new Point ( this . x1 , this . y2 ); } Point getRechtsUnten () { return new Point ( this . x2 , this . y2 ); } } RechteckeAnordnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.* ; public class RechteckeAnordnen extends JFrame { JButton resetButton , newRectButton ; MyRectangle aktRechteck = null ; List < MyRectangle > rectangles = new ArrayList <> (); Canvas canvas ; JLabel infoLabel ; int anzRectFixed = 0 ; RechteckeAnordnen () { super ( \"Rechtecke fixieren\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . createInfoPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . createButtons (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } JPanel createInfoPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( this . anzRectFixed + \" Rechtecke fixiert\" ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel createButtons () { JPanel buttonPanel = new JPanel (); this . resetButton = new JButton ( \"clear\" ); this . resetButton . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed = 0 ; RechteckeAnordnen . this . rectangles . clear (); RechteckeAnordnen . this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); RechteckeAnordnen . this . canvas . repaint (); } }); buttonPanel . add ( resetButton ); this . newRectButton = new JButton ( \"rectangle\" ); this . newRectButton . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { if ( RechteckeAnordnen . this . aktRechteck == null && RechteckeAnordnen . this . anzRectFixed < 4 ) { int x = RechteckeAnordnen . this . canvas . getWidth () / 4 ; int y = RechteckeAnordnen . this . canvas . getHeight () / 4 ; Color color = null ; switch ( RechteckeAnordnen . this . rectangles . size ()) { case 0 : color = Color . GREEN ; break ; case 1 : color = Color . RED ; break ; case 2 : color = Color . YELLOW ; break ; case 3 : color = Color . DARK_GRAY ; break ; default : color = Color . WHITE ; break ; } RechteckeAnordnen . this . aktRechteck = new MyRectangle ( x , y , x + 2 * x , y + 2 * y , color ); RechteckeAnordnen . this . canvas . repaint (); } } }); buttonPanel . add ( newRectButton ); return buttonPanel ; } class Canvas extends JPanel implements MouseListener , MouseMotionListener { boolean move = false ; Point from ; Canvas () { this . setBorder ( BorderFactory . createLineBorder ( Color . black )); this . addMouseListener ( this ); this . addMouseMotionListener ( this ); } @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; int widthPanel = this . getWidth (); // Breite der Canvas int heightPanel = this . getHeight (); // Hoehe der Canvas g2 . drawLine ( widthPanel / 2 , 0 , widthPanel / 2 , heightPanel ); g2 . drawLine ( 0 , heightPanel / 2 , widthPanel , heightPanel / 2 ); for ( MyRectangle rect : RechteckeAnordnen . this . rectangles ) { g2 . setColor ( rect . color ); int x = rect . x1 ; int y = rect . y1 ; int width = rect . x2 - rect . x1 ; int height = rect . y2 - rect . y1 ; g2 . fill3DRect ( x , y , width , height , true ); } if ( RechteckeAnordnen . this . aktRechteck != null ) { g2 . setColor ( RechteckeAnordnen . this . aktRechteck . color ); int x = RechteckeAnordnen . this . aktRechteck . x1 ; int y = RechteckeAnordnen . this . aktRechteck . y1 ; int width = RechteckeAnordnen . this . aktRechteck . x2 - RechteckeAnordnen . this . aktRechteck . x1 ; int height = RechteckeAnordnen . this . aktRechteck . y2 - RechteckeAnordnen . this . aktRechteck . y1 ; g2 . fill3DRect ( x , y , width , height , true ); } } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mousePressed ( MouseEvent e ) { this . from = e . getPoint (); if ( RechteckeAnordnen . this . aktRechteck != null && RechteckeAnordnen . this . aktRechteck . inside ( from )) { this . move = true ; } } @Override public void mouseReleased ( MouseEvent e ) { this . move = false ; } @Override public void mouseEntered ( MouseEvent e ) { } @Override public void mouseExited ( MouseEvent e ) { } @Override public void mouseDragged ( MouseEvent e ) { Point here = e . getPoint (); if ( move ) { int diffX = here . x - this . from . x ; int diffY = here . y - this . from . y ; RechteckeAnordnen . this . aktRechteck . move ( diffX , diffY ); this . from = here ; int diff = 15 ; switch ( RechteckeAnordnen . this . anzRectFixed ) { case 0 : Point goal = new Point ( 0 , 0 ); Point corner = RechteckeAnordnen . this . aktRechteck . getLinksOben (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( 0 , 0 , this . getWidth () / 2 , this . getHeight () / 2 , RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 1 : goal = new Point ( this . getWidth (), 0 ); corner = RechteckeAnordnen . this . aktRechteck . getRechtsOben (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( this . getWidth () / 2 + 1 , 0 , this . getWidth (), this . getHeight () / 2 , RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 2 : goal = new Point ( 0 , this . getHeight ()); corner = RechteckeAnordnen . this . aktRechteck . getLinksUnten (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( 0 , this . getHeight () / 2 + 1 , this . getWidth () / 2 , this . getHeight (), RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 3 : goal = new Point ( this . getWidth (), this . getHeight ()); corner = RechteckeAnordnen . this . aktRechteck . getRechtsUnten (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( this . getWidth () / 2 + 1 , this . getHeight () / 2 + 1 , this . getWidth (), this . getHeight (), RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert -- ENDE\" ); } break ; } this . repaint (); } } @Override public void mouseMoved ( MouseEvent e ) { } } public static void main ( String [] args ) { new RechteckeAnordnen (); } }","title":"Klausurvorbereitung"},{"location":"klausurvorbereitung/#klausurvorbereitung","text":"Alle wesentlichen Konzepte, die wir f\u00fcr die Klausur ben\u00f6tigen, haben wir jetzt in diesem und im vergangenen Semester gelernt. Wir wollen diese Kenntnisse nun durch mehrere Anwendungen vertiefen. Ganz vereinzelt wird dabei auch etwas Neues auftauchen. Dabei handelt es sich aber nicht um ein neues Konzept, sondern bspw. um einen Listener, den wir noch nicht hatten. Solche \"\u00dcberraschungen\" werden Sie aber in der Klausur nicht erleben. Dieses Kapitel wird hier so aufgebaut sein, dass es immer eine Aufgabe (eine Probeklausur) gibt und die dazugeh\u00f6rige L\u00f6sung, die aber \"aufgeklappt\" werden muss. Sie k\u00f6nnen ja immer zuerst probieren, die L\u00f6sung selbst\u00e4ndig zu entwickeln. Wenn Sie am Ende alle Aufgaben selbst\u00e4ndig l\u00f6sen k\u00f6nnen, sind Sie mit Sicherheit sehr gut auf die Klausur vorbereitet. Wir beginnen aber noch kurz mit allgemeinen Betrachtungen zum Grundger\u00fcst. Eines der nachfolgend vorgestellten Grundger\u00fcste werden Sie mit Sicherheit bei der Klausur verwenden k\u00f6nnen.","title":"Klausurvorbereitung"},{"location":"klausurvorbereitung/#mogliche-grundgeruste","text":"Wie Sie wissen, ist das Fenster ( JFrame ) im BorderLayout . Das bedeutet, dass das Fenster in f\u00fcnf Bereiche ( Container ) unterteilt ist. Sie m\u00fcssen sich bei der Konfiguration \u00fcberlegen, ob \"gezeichnet\" werden soll, d.h. ob das JPanel im CENTER des Fensters eine eigene Klasse ist, oder ob es mithilfe einer Methode erzeugt werden kann und welche der f\u00fcndf Bereiche Sie ben\u00f6tigen. Wir erl\u00e4utern das an Beispielen und beginnen mit einem Grundger\u00fcst, welches wir f\u00fcr das Zeichnen verwenden k\u00f6nnen, welches also eine Canvas enth\u00e4lt. Grundger\u00fcst mit Canvas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestMitCanvas extends JFrame { Canvas canvas ; public GrundgeruestMitCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestMitCanvas (); } } In diesem Grundger\u00fcst werden alle f\u00fcnf Bereiche des Fensters mit JPanel bef\u00fcllt. Das CENTER wird mit einem Objekt der Klasse Canvas bef\u00fcllt, welche von JPanel erbt. Diese Klasse wird ben\u00f6tigt, um in die paintComponent() -Methode zu zeichnen. Sollten Sie z.B. kein Panel im EAST - und im WEST -Bereich des Fensters ben\u00f6tigen, dann l\u00f6schen Sie einfach die Zeilen 23 und 24 sowei die beiden Methoden initEast() und initWest() . Ein Grundger\u00fcst ohne Canvas , also ohne Zeichnen, k\u00f6nnte dann so aussehen: Grundger\u00fcst ohne Canvas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.awt.BorderLayout ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestOhneCanvas extends JFrame { JPanel content ; public GrundgeruestOhneCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . content = this . initCenter (); this . getContentPane (). add ( this . content , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initCenter () { JPanel center = new JPanel (); // hier das JPanel fuer CENTER befuellen return center ; } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestOhneCanvas (); } } Beachten Sie, dass JPanel ohne Angabe eines LayoutManagers im FlowLayout sind. Das k\u00f6nnen Sie \u00e4ndern und die einzelnen JPanel auch noch weiter verschachteln . Eines dieser beiden Grundger\u00fcste k\u00f6nnen wir nun stets verwenden. Es muss dann jeweils \"nur\" noch angepasst werden. Wir beginnen mal mit einer Aufgabe.","title":"M\u00f6gliche Grundger\u00fcste"},{"location":"klausurvorbereitung/#quadrat","text":"Aufgabe Quadrat Schreiben Sie eine Klasse Quadrat , die folgendes Fenster darstellt: Es gibt also eine Zeichenfl\u00e4che ( Canvas ) und zwei Buttons new und fill . Nach dem Klicken des Buttons new soll ein schwarzes unausgef\u00fclltes Quadrat mit der Strichst\u00e4rke 3.0 so in der Zeichenfl\u00e4che erscheinen, dass es mittig in der Zeichenfl\u00e4che angeordnet ist und der k\u00fcrzere der beiden Abst\u00e4nde (links/rechts oder oben/unten) ca. 10% der Zeichenfl\u00e4che gro\u00df ist. Nach dem Klicken des Buttons new steht darin nicht mehr new , sondern refresh . Nach Klicken des Buttons fill soll das Quadrat mit einer zuf\u00e4llig gew\u00e4hlten Farbe bef\u00fcllt werden. Es soll aber trotzdem noch der schwarze Rand bleiben (am einfachsten: einmal mit der zuf\u00e4llig gew\u00e4hlten Farbe bef\u00fcllt und danach nochmal unbef\u00fcllt schwarz malen). Der Button wechselt den Text auf unfill . Nach dem Klicken auf unfill soll das Quadrat wieder unausgef\u00fcllt sein. Die zuf\u00e4llig erzeugte Farbe soll so lange die Farbe zum Ausf\u00fcllen bleiben, bis der refresh -Button geklickt wird, d.h. durch mehrmaliges Klicken des Button fill und unfill \u00e4ndert sich die Farbe zum Bef\u00fcllen des Quadrats nicht, erst durch Klicken des Button refresh wird eine neue Farbe erzeugt, die dann wieder bis zum n\u00e4chsten Klicken von refresh bleibt. Implementieren Sie den MouseListener und den MouseMotionListener so, dass Sie bei gedr\u00fcckter Maustaste die Gr\u00f6\u00dfe des Quadrates \u00e4ndern. Wenn Sie mit der Maus auf eine Kante des Quadrates ( +/-10px ) klicken und dann die Maus gedr\u00fcckt halten, \u00e4ndert sich die Gr\u00f6\u00dfe des Quadrates entsprechend. Wenn Sie weit weg von (also mehr als 10px von der Kante entfernt) einer Kante klicken (egal, ob im Quadrat oder au\u00dferhalb), passiert gar nichts. Die Gr\u00f6\u00dfen\u00e4nderungen sollen stets sofort sichtbar sein. Nach Loslassen der Maustaste bleibt das Quadrat in der eingestellten Gr\u00f6\u00dfe. Das Quadrat bleibt stets m\u00f6glichst mittig. Tipp : An welche Kante Sie klicken, ist egal. Klicken Sie auf eine vertikale Kante (links oder rechts), brauchen Sie nur die \u00c4nderungen des x-Wertes zu ber\u00fccksichtigen, klicken Sie auf eine horizontale Kante (oben oder unten), brauchen Sie nur die \u00c4nderungen der y-Werte zu ber\u00fccksichtigen, um die neue Gr\u00f6\u00dfe des Quadrates zu ermitteln. L\u00f6sung Quadrat Zuerst \u00fcberlegen wir uns, welches Grundger\u00fcst wir verwenden und wie wir es anpassen. Wir m\u00fcssen zeichnen , also das Grundger\u00fcst mit Canvas . Von den Nord-, S\u00fcd-, Ost-, West-Bereichen ben\u00f6tigen wir nur den S\u00fcden (dort kommen die 'new'- und fill -Buttons rein). Also ist das unser Ausgangspunkt, in das wir schonmal die Buttons eingef\u00fcgt haben: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); JButton fillBtn = new JButton ( \"fill\" ); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Von den initXXX() -Methoden ben\u00f6tigen wir auch nur noch initSouth() . Die anderen drei sind deshalb gel\u00f6scht. Die Implementierung des ActionListener f\u00fcr den new -Button erledigen wir mit einer anonymen Klasse. Wir m\u00fcssen uns \u00fcberlegen, ob es notwendig ist, f\u00fcr das Quadrat eine eigene Datenstruktur (z.B. Klasse) anzulegen. Zun\u00e4chst machen wir das einmal ohne, sondern geben nur in einer globalen Variablen zeigeQuadrat an, ob das Quadrat gezeichnet werden soll oder nicht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Quadrat . this . zeigeQuadrat = true ; JButton thisBtn = ( JButton ) e . getSource (); // kann nur der newBtn sein! thisBtn . setText ( \"refresh\" ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Wenn die Variable zeigeQuadrat durch den Buttonklick auf true gesetzt wurde (Zeile 74 ), dann wird in der paintComponent() -Methode das Quadrat dargestellt (Zeile 40 ). Zur korrekten Darstellung des Quadrates ist es von Bedeutung, ob das Fenster (die Canvas ) h\u00f6her als breit ist oder umgedreht (Zeile 45 ). Ist es h\u00f6her als breit, dann wird es in die Breite der Canvas eingepasst, d.h. der Abstand nach links ist 1/10 der Canvas -Breite (Zeile 47 ) und die Seitenl\u00e4nge des Quadrates ist 8/10 der Breite (Zeile 48 ). Der Abstand des Quadrates nach oben muss entsprechend berechnet werden (Zeile 49 ). Ist es breiter als hoch, dann wird es in die H\u00f6he der Canvas eingepasst, d.h. der Abstand nach oben ist 1/10 der Canvas -H\u00f6he (Zeile 54 ) und die Seitenl\u00e4nge des Quadrates ist 8/10 der H\u00f6he (Zeile 55 ). Der Abstand des Quadrates nach links muss entsprechend berechnet werden (Zeile 56 ). In der actionPerformed() -Methode f\u00fcr den Button wird nicht nur zeigeQuadrat auf true gesetzt, sondern die Canvas auch neu gezeichnet (Zeile 77 )! Die Quelle des ActionEvent kann nur der Button selbst sein, da wir eine anonyme Klasse zur Implementierung des ActionListener verwenden. Deshalb k\u00f6nnen wir die Quelle ohne Pr\u00fcfung in einen JButton konvertieren (Zeile 75 ). Mithilfe der setText() -methode f\u00fcr JButton setzen wir den neuen Buttontext auf refresh (Zeile 76 ). Die Implementierung des ActionListener f\u00fcr den fill -Button erledigen wir erneut mit einer anonymen Klasse. Wir gehen \u00e4hnlich vor, wie beim new -Button und erstellen eine globale Variable fuelleQuadrat . Diese gibt an, ob das Quadrat bef\u00fcllt gezeichnet werden soll oder nicht. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); g2 . setColor ( new Color ( rot , gruen , blau )); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Quadrat . this . zeigeQuadrat = true ; JButton thisBtn = ( JButton ) e . getSource (); // kann nur der newBtn sein! thisBtn . setText ( \"refresh\" ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } Die Farbe zum Ausf\u00fcllen erzeugen wir zuf\u00e4llig mithilfe von Random (Zeilen 48-52 ). Es wird jeweils zuerst aus das ausgef\u00fcllte Quadrat gezeichnet (Zeile 61 bzw. 73 ) falls fuelleQuadrat den Wert true hat (Zeile 59 bzw. 71 ). Nach dem Zeichnen des bef\u00fcllten Quadrates wird die Zeichenfarbe wieder auf schwarz gestellt (Zeile 63 bzw. 75 ) und dann das nichtausgef\u00fcllte Quadrat gezeichnet. In der actionPerformed() _Methode m\u00fcssen wir unterscheiden, ob im Button fill steht oder unfill (zeile 108 ). Je nachdem wird fuelleQuadrat auf true oder false gesetzt und der Text im Button entsprechend ge\u00e4ndert. Um nicht bei jeden Aufruf von paintComponent() eine neue F\u00fcllfarbe zuf\u00e4llig zu erzeugen, muss das Erzeugen der Farbe ausgelagert werden. Da auf die Farbe sowohl in paintComponent() ( View ) als auch in actionPerfomed() ( Controller ) zugegriffen wird, muss diese als globale Referenz deklariert werden. Wahrscheinlich ist es gut, die Farbe beim ersten Mal zu erzeugen, wenn der new -Button geklickt wird und dann immer durch das Klicken des refresh -Buttons. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( canvasHeight > canvasWidth ) { int abstand = ( int )( canvasWidth * 0.1 ); int seiteQuadrat = ( int )( canvasWidth * 0.8 ); int oben = ( canvasHeight - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( abstand , oben , seiteQuadrat , seiteQuadrat ); } else { int abstand = ( int )( canvasHeight * 0.1 ); int seiteQuadrat = ( int )( canvasHeight * 0.8 ); int links = ( canvasWidth - seiteQuadrat ) / 2 ; if ( fuelleQuadrat ) { g2 . fillRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( links , abstand , seiteQuadrat , seiteQuadrat ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } } F\u00fcr eine geeignete Implementierung des MouseListener und des MouseMotionListener ben\u00f6tigen wir globalen Zugriff auf die Gr\u00f6\u00dfe und die Position des Quadrates. Wir m\u00fcssen ja mit der Maus erkennen k\u00f6nnen, ob wir eine Kante des Quadrates getroffen haben. Wir lagern deshalb einige Werte des Quadrates global aus (und Umbenennungen): int quadratLinks, quadratRechts, quadratOben, quadratUnten, quadratLaenge; In paintComponent() werden diese globalen Variablen nun mit Werten belegt: if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } Nun implementieren wir MouseListener und MouseMotionListener und melden canvas daran an. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; int quadratLinks , quadratRechts , quadratOben , quadratUnten , quadratLaenge ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } @Override public void mousePressed ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mousePressed x=\" + x + \", y=\" + y ); } @Override public void mouseDragged ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseDragged x=\" + x + \", y=\" + y ); } @Override public void mouseReleased ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseReleased x=\" + x + \", y=\" + y ); } @Override public void mouseMoved ( MouseEvent e ) {} @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } F\u00fcr das eigentliche Verschieben r\u00e4cht sich jetzt, dass wir uns anfangs keine gute Datenstruktur \u00fcberlegt hatten. Es wird jetzt alles ein wenig komplizierter, da wir mehrere Unterscheidungen treffen m\u00fcssen: Wir m\u00fcssen unterscheiden, ob das Quadrat nun gerade bewegt wird oder nicht. Wir m\u00fcssen unterscheiden, ob wir die linke Kante bewegen, oder die rechte oder die untere oder die obere. F\u00fcr alle dieses Unterscheidungen erstellen wir uns globale Variablen. if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } Nun implementieren wir MouseListener und MouseMotionListener und melden canvas daran an. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Quadrat extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; boolean zeigeQuadrat = false ; boolean fuelleQuadrat = false ; Color aktuelleFuellfarbe = Color . WHITE ; int quadratLinks , quadratRechts , quadratOben , quadratUnten , quadratLaenge ; boolean bewegt = false ; boolean linkeKante = false ; boolean rechteKante = false ; boolean obereKante = false ; boolean untereKante = false ; int warX = 0 ; int warY = 0 ; public Quadrat () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( Quadrat . this . zeigeQuadrat ) { g2 . setStroke ( new BasicStroke ( 3.0f )); int canvasWidth = this . getWidth (); int canvasHeight = this . getHeight (); g2 . setColor ( Quadrat . this . aktuelleFuellfarbe ); if ( ! Quadrat . this . bewegt ) { if ( canvasHeight > canvasWidth ) { Quadrat . this . quadratLinks = ( int )( canvasWidth * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasWidth * 0.8 ); Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratOben = ( canvasHeight - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } else { Quadrat . this . quadratOben = ( int )( canvasHeight * 0.1 ); Quadrat . this . quadratLaenge = ( int )( canvasHeight * 0.8 ); Quadrat . this . quadratLinks = ( canvasWidth - Quadrat . this . quadratLaenge ) / 2 ; Quadrat . this . quadratRechts = Quadrat . this . quadratLinks + Quadrat . this . quadratLaenge ; Quadrat . this . quadratUnten = Quadrat . this . quadratOben + Quadrat . this . quadratLaenge ; if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } else // bewegt { if ( fuelleQuadrat ) { g2 . fillRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } g2 . setColor ( Color . BLACK ); g2 . drawRect ( Quadrat . this . quadratLinks , Quadrat . this . quadratOben , Quadrat . this . quadratLaenge , Quadrat . this . quadratLaenge ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); JButton newBtn = new JButton ( \"new\" ); newBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"new\" )) { Quadrat . this . zeigeQuadrat = true ; thisBtn . setText ( \"refresh\" ); } Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Quadrat . this . aktuelleFuellfarbe = new Color ( rot , gruen , blau ); Quadrat . this . canvas . repaint (); } }); JButton fillBtn = new JButton ( \"fill\" ); fillBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { JButton thisBtn = ( JButton ) e . getSource (); if ( thisBtn . getText (). equals ( \"fill\" )) { Quadrat . this . fuelleQuadrat = true ; thisBtn . setText ( \"unfill\" ); } else { Quadrat . this . fuelleQuadrat = false ; thisBtn . setText ( \"fill\" ); } Quadrat . this . canvas . repaint (); } }); south . add ( newBtn ); south . add ( fillBtn ); return south ; } public static void main ( String [] args ) { new Quadrat (); } @Override public void mousePressed ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mousePressed x=\" + x + \", y=\" + y ); int linksX = this . quadratLinks ; int rechtsX = this . quadratRechts ; int obenY = this . quadratOben ; int untenY = this . quadratUnten ; if ( x > linksX - 10 && x < linksX + 10 ) { this . bewegt = true ; this . linkeKante = true ; this . warX = x ; } else if ( x > rechtsX - 10 && x < rechtsX + 10 ) { this . bewegt = true ; this . rechteKante = true ; this . warX = x ; } else if ( y > obenY - 10 && y < obenY + 10 ) { this . bewegt = true ; this . obereKante = true ; this . warY = y ; } else if ( y > untenY - 10 && y < untenY + 10 ) { this . bewegt = true ; this . untereKante = true ; this . warY = y ; } } @Override public void mouseDragged ( MouseEvent e ) { if ( this . bewegt ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseDragged x=\" + x + \", y=\" + y ); if ( this . linkeKante ) { int diffX = x - this . warX ; this . quadratLinks = this . quadratLinks + diffX ; this . quadratOben = this . quadratOben + diffX ; this . quadratLaenge = this . quadratLaenge - 2 * diffX ; this . warX = x ; } else if ( this . rechteKante ) { int diffX = x - this . warX ; this . quadratLinks = this . quadratLinks - diffX ; this . quadratOben = this . quadratOben - diffX ; this . quadratLaenge = this . quadratLaenge + 2 * diffX ; this . warX = x ; } else if ( this . obereKante ) { int diffY = y - this . warY ; this . quadratLinks = this . quadratLinks + diffY ; this . quadratOben = this . quadratOben + diffY ; this . quadratLaenge = this . quadratLaenge - 2 * diffY ; this . warY = y ; } else if ( this . untereKante ) { int diffY = y - this . warY ; this . quadratLinks = this . quadratLinks - diffY ; this . quadratOben = this . quadratOben - diffY ; this . quadratLaenge = this . quadratLaenge + 2 * diffY ; this . warY = y ; } Quadrat . this . canvas . repaint (); } } @Override public void mouseReleased ( MouseEvent e ) { this . bewegt = false ; Quadrat . this . canvas . repaint (); } @Override public void mouseMoved ( MouseEvent e ) {} @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } In mousePressed() bestimmen wir zun\u00e4chst, ob wir in der N\u00e4he der linken oder der rechten oder der oberen oder unteren Kante geklickt haben. Wenn ja, dann setzen wir die entsprechenden Variablen und merken uns, wo ( warX oder warY ) wir hingeklickt hatten. In mouseDragged() wird zun\u00e4chst ermittelt, ob wir \u00fcberhaupt im bewegt -Modus sind. Wenn ja, ermitteln wir, wie weit und wohin wir uns seit dem letzten Aufruf von mouseDragged() bewegt haben. Dementsprechend werden die Variablen f\u00fcr das Quadrat neu gesetzt. Wenn wir die Maus wieder loslassen ( mouseReleased() ) wird bewegt wieder auf false gesetzt und das Quadrat wird somit wieder \"normal\" durch die paintComponent() -Methode dargestellt.","title":"Quadrat"},{"location":"klausurvorbereitung/#schachbrett","text":"Aufgabe Schachbrett Schreiben Sie eine Klasse Schachbrett , die folgendes Fenster darstellt: Es werden 8x8 Rechtecke dargestellt \u2013 abwechselnd mit grauem und wei\u00dfem Hintergrund bitte beachten: die dargestellten Rechtecke sind gezeichnet, es handelt sich nicht um einzelne JPanels!!! (ist f\u00fcr sp\u00e4ter wichtig) das 8x8-Feld der Rechtecke f\u00fcllt die Zeichenfl\u00e4che vollst\u00e4ndig , d.h. wenn Sie die Gr\u00f6\u00dfe des Fensters ver\u00e4ndern, passt sich auch das 8x8-Feld entsprechend an Implementieren Sie den MausListener so, dass Sie durch Mausklick auf die Zeichenfl\u00e4che einen ausgef\u00fcllten Kreis in das Rechteck malen, in das Sie geklickt haben. Die Abbildung zeigt das Schachbrett nach einem Mausklick auf das Rechteck in der 2. Zeile und 4. Spalte. Versuchen Sie, die Kreise m\u00f6glichst zentriert in die Rechtecke zu malen. Eine gute Gr\u00f6\u00dfe f\u00fcr den Durchmesser der Kreise ist \u2153 der Breite oder H\u00f6he der Rechtecke. Klicken Sie mehrmals mit der Maus, werden entsprechend mehrere Kreise dargestellt. F\u00fcgen Sie dem S\u00fcden des Fensters ein JPanel hinzu. Dieses JPanel enth\u00e4lt einen JButton 'clear field' . Nach Dr\u00fccken dieses Buttons werden alle roten Kreise wieder gel\u00f6scht. Erweitern Sie Ihre Implementierung nun so, dass durch einen Mausklick nicht nur ein roter Kreis gezeichnet wird, sondern auch noch eine horizontale und eine vertikale Linie in der Zeile und der Spalte, in der der Kreis gezeichnet wird. in der Zeile und Spalte des Kreises erscheint jeweils mittig eine rote Linie Abbildung zeigt Schachbrett nach mehreren Mausklicks Die Linien m\u00fcssen nicht, wie im Bild dargestellt, in der Mitte der Rechtecke anfangen. Sie k\u00f6nnen auch komplett durchgezeichnet werden, d.h. vom Beginn bis zum Ende einer Zeile bzw. Spalte. Erweitern Sie Ihre Implementierung nun so, dass es nicht mehr m\u00f6glich ist, dass 2 Kreise in der gleichen Spalte oder in der gleichen Zeile erscheinen. Wenn Sie ein Rechteck anklicken, in dessen Zeile oder Spalte bereits ein anderer Kreis ist, so soll kein neuer Kreis gezeichnet werden, sondern das Rechteck als gr\u00fcnes Rechteck erscheinen. In das gr\u00fcne Rechteck wurde geklickt - es erscheint kein Kreis, da in der Zeile bereits ein Kreis ist \u2013 stattdessen ein gr\u00fcnes Rechteck. In das gr\u00fcne Rechteck wurde geklickt - es erscheint kein Kreis, da in der Zeile bereits ein Kreis ist - stattdessen ein gr\u00fcnes Rechteck. Das Rechteck bleibt nur bis zum n\u00e4chsten Klick markiert (gr\u00fcn). Zusatzaufgabe: Erweitern Sie die Schritte 5 und 6 auch auf die Diagonalen, d.h. es sollen auch die jeweiligen Diagonalen der Punkte eingezeichnet werden und keine zwei Punkte d\u00fcrfen in der gleichen Diagonalen liegen. L\u00f6sung Schachbrett Zuerst \u00fcberlegen wir uns, welches Grundger\u00fcst wir verwenden und wie wir es anpassen. Wir m\u00fcssen zeichnen , also das Grundger\u00fcst mit Canvas . Von den Nord-, S\u00fcd-, Ost-, West-Bereichen ben\u00f6tigen wir nur den S\u00fcden (dort kommt der 'clear field'-Button rein). Also ist das unser Ausgangspunkt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame { Canvas canvas ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } } Von den initXXX() -Methoden ben\u00f6tigen wir auch nur noch initSouth() . Die anderen drei sind deshalb gel\u00f6scht. Jetzt k\u00f6nnen wir mit dem Zeichnen des Schachbretts beginnen. Dazu k\u00f6nnten wir \"einfach\" 64 gleich gro\u00dfe Rechtecke in die Canvas zeichnen. Wir sollten hier aber unbedingt daf\u00fcr ein Model , d.h. eine Datenstruktur erstellen und diese dann in der View darstellen. F\u00fcr eine solche Datenstruktur (f\u00fcr ein Model ) gibt es drei Gr\u00fcnde: wir wollen sp\u00e4ter erkennen, in welches Feld geklickt wurde und wir wollen erkennen k\u00f6nnen, in welches Feld bereits geklickt wurde und wir wollen erkennen k\u00f6nnen, welche Felder Nachbarfelder sind. Da die Dimensionen hier fest sind (8x8), kann man das in einem (zweidimensionalen) Array erledigen. Als Typ jedes einzelnen Elementes sollte boolean gen\u00fcgen - markiert oder nicht markiert. Wenn Sie sich nicht sicher sind, ob zwei Zust\u00e4nde gen\u00fcgen, k\u00f6nnen Sie auch eine enum als Typ verwenden. Wir machen das mal, dann bleibt die L\u00f6sung flexibler und wir \u00fcben enum nochmal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } } Wir h\u00e4tten das field auch im Konstruktor erzeugen und bef\u00fcllen k\u00f6nnen, lagern es aber in eine eigene Methode aus und rufen diese im Konstruktor auf. Alles, was wir funktional in eine eigene Methode auslagern k\u00f6nnen, sollten wir auch auslagern - liest sich viel besser! Jetzt \u00fcberlegen wir, wie wir das Schachbrett darstellen (die View ). Die Darstellung erfolgt am besten mit der fillRect() -Methode. Diese erwartet die Koordinaten des linken oberen Punktes und die Breite und die H\u00f6he des Rechtecks. Breite und H\u00f6he ergeben sich aus der Breite und H\u00f6he der Canvas , jeweils geteilt durch 8 . Aus der Position des zu zeichnenden Rechtecks in einer Zeile ergibt sich dann der x -Wert f\u00fcr den linken oberen Punkt und aus der Position des zu zeichnenden Feldes in der Spalte ergibt sich der y -Wert des linken oberen Punktes. Wir \u00e4ndern nun nur die paintComponent() -Methode (die View ), da es nur um die Darstellung geht: 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); int heightRect = canvasHeight / 8 ; int widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit gleichen Farbe anfangen, wie aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , widthRect , heightRect ); } } } } Wir laufen also durch das field -Array und ermitteln f\u00fcr die aktuelle Zeile den y -Wert und f\u00fcr die jeweils aktuelle Spalte den x -Wert. Damit wir immer zwischen Grau und Wei\u00df umschalten, erstellen wir uns eine boole'sche Variable grey , die abwechselnd true und false wird, je nachdem, ob wir als n\u00e4chstes ein graues oder ein wei\u00dfes Feld zeichnen wollen. Nach jeder Zeile \u00e4ndert sich die Farbe jedoch nicht (wir fangen in der neuen Zeile mit der gleichen Farbe an, wie wir in der alten Zeile aufgeh\u00f6rt haben). Deshalb mussten wir noch die Anweisung in Zeile 61 hinzuf\u00fcgen. Das Schachbrett wird nun so gezeichnet, wie wir das wollten. Wenn das Fenster vergr\u00f6\u00dfert oder verkleinert wird, dann passen sich die Felder entsprechend an, da wir alles abh\u00e4ngig von der Breite und H\u00f6he der Canvas berechnen. Wir k\u00f6nnen aber die Fenstergr\u00f6\u00dfe aber gleich etwas quadratischer gestalten (z.B. this.setSize(400, 400); ). Jetzt k\u00fcmmern wir uns um die roten Punkte inmitten des Rechtecks, falls wir mit der Maus darauf geklickt haben. Dazu ben\u00f6tigen wir den MouseListener , denn es geht um einen Mausklick (also entweder mouseClicked() oder mousePressed() ) und nicht um eine Bewegung der Maus. Wir entscheiden uns f\u00fcr mouseClicked() - das ist nun also unser Controller . Wir implementieren zun\u00e4chst den MouseListener und pr\u00fcfen, ob damit alles funktioniert (ob wir z.B. nicht vergessen haben, an den MouseListener anzumelden.) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); int heightRect = canvasHeight / 8 ; int widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , widthRect , heightRect ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Wir f\u00fcgen das implements MouseListener im Klassenkopf ein und importieren den MouseListener aus dem java.awt.event -Paket (lassen wir nat\u00fcrlich Eclipse erledigen). Wir lassen Eclipse durch Add unimplemented methods die Methoden aus dem MouseListener hinzuf\u00fcgen. Dabei wird auch MouseEvent importiert. Da wir uns f\u00fcr die Implementierung von mouseClicked() entschieden haben, k\u00f6nnen wir die anderen Methoden ein wenig verkleinern, um \u00dcbersicht zu bewahren. In mouseClicked() k\u00f6nnen wir schonmal die Koordinaten des MouseEvent abfragen und eine Ausgabe auf die Konsole durchf\u00fchren, um zu kontrollieren, ob alles funktioniert. Unbedingt m\u00fcssen wir nat\u00fcrlich canvas an den MouseListener anmelden (Zeile 25 ). mouseClicked() wird aufgerufen, wenn wir in das Feld klicken - die Koordinaten des Klicks in die Canvas werden auf der Konsole ausgegeben. Nun m\u00fcssten wir uns \u00fcberlegen, auf welches Rechteck aus dem field -Array wir geklickt haben. Dieses Rechteck wollen wir als MARKIERT speichern. Angenommen, wir kennen die Koordinaten x und y des Mausklicks in die Canvas . Um nun zu wissen, in welche \"Spalte\" oder \"Zeile\" wir geklickt haben, m\u00fcssen wir die Breite und H\u00f6he der Rechtecke kennen. Diese kennen wir aber in mouseClicked() nicht, da die Breite und H\u00f6he der Rechtecke jeweils von der Breite und H\u00f6he der Canvas abh\u00e4ngig ist (welche sich \u00e4ndern k\u00f6nnen). Die H\u00f6he und Breite der Rechtecke ist somit eine Eigenschaft der Canvas und um auf diese Eigenschaft zuzugreifen, m\u00fcssen wir sie global verf\u00fcgbar machen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { int heightRect = 0 ; int widthRect = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; this . field [ zeile ][ spalte ] = State . MARKIERT ; System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Die Variablen heightRect und widthRect werden in den Zeilen 50 und 51 als global deklariert. In den Zeilen 61 und 62 bekommen diese Variablen ihren Wert abh\u00e4ngig von der Gr\u00f6\u00dfe der Canvas . Nun k\u00f6nnen wir auf diese Werte in der mouseClicked() -Methode \u00fcber die canvas -Referenz zugreifen (Zeilen 105 und 106 ). F\u00fcr die Berechnung der zeile und spalte verwenden wir die Integer-Division (wie oft passt ein Rechteck in x bzw. in y ?). Das entsprechende Feld setzen wir auf MARKIERT (Zeile 108 ). Zur Kontrolle noch eine Konsolenausgabe (Zeile 109 ). Damit wir es nicht vergessen, sicherheitshalber schonmal das repaint() der canvas (Zeile 110 ). In alle als MARKIERT markierten Felder zeichnen wir nun einen roten Kreis. Gezeichnet wird immer in der paintComponent() : 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); } } } } Da die linke obere \"Ecke\" des Kreises weiter rechts und weiter unten als die linke obere Ecke des Rechtecks ist, f\u00fcgen wir noch einen abstandX und einen abstandY hinzu, der sich jeweils aus dem Drittel der Rechtecksbreite und der Recjtecksh\u00f6he ergibt (Zeilen 84 und 85 ). Der Durchmesser des Kreises ist dann ebenfalls ein Drittel (somit bleibt das dritte Dtrittel als Abstand rechts - der Kreis ist recht mittig) - Zeile 86 . Wir setzen die Farbe auf rot und zeichnen den Kreis (Zeilen 87 und 88 ). Die roten vertikalen und horizontalen Linien k\u00f6nnten wir nun auch noch gleich zeichnen: 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawLine (( this . widthRect / 2 ), y + ( this . heightRect / 2 ), canvasWidth - ( this . widthRect / 2 ), y + ( this . heightRect / 2 )); g2 . drawLine ( x + ( this . widthRect / 2 ), ( this . heightRect / 2 ), x + ( this . widthRect / 2 ), canvasHeight - ( this . heightRect / 2 )); } } } } Das Zeichnen passiert jetzt in zwei for -Schleifen. Zun\u00e4chst werden die grauen und wei\u00dfen Rechtecke gezeichnet und erst danach die roten Kreise und Linien. H\u00e4tten wir auch die Linien in der ersten for -Schleife gezeichnet, w\u00e4ren sie teilweise von den nachfolgenden Rechtecken abgedeckt und somit nur teilweise sichtbar gewesen. Das Zeichnen der beiden Linien (vertikal und horizontal) erfolgt in den Zeilen 99-101 . Zun\u00e4chst wird die Strichst\u00e4rke etwas erh\u00f6ht (auf 3.0f px). In Zeile 100 wird die horizontale Linie gezeichnet. Diese Linie k\u00f6nnte auch bei x=0 beginnen und bei canvasWidth aufh\u00f6ren. Um sie in der Mitte des ersten Rechtecks beginnen zu lassen, wird statt x=0 x=(this.rectWidth/2) gew\u00e4hlt. Um sie in der Mitte des letzten Rechtecks enden zu lassen, wird statt x=canvasWidth x=canvasWidth-(this.rectWidth/2) gew\u00e4hlt. In welcher Zeile diese Linie gezeichnet wird, ergibt sich aus dem Wert von y . Dieser Wert bestimmt aber die oberste Kante der Zeile. Um die Linie in die Mitte der Zeile zu zeichnen, wird jeweils this.heightRect/2 zu y addiert. Das Zeichnen der vertikalen Linie in Zeile 101 ist ganz \u00e4hnlich, nur dass der Wert von x bestimmt, in welche Spaqlte die Linie gezeichnet wird und die y -Werte jeweils so angepasst werden, dass die Linie nicht ganz oben beginnt und ganz oben endet, sondern jeweils mittig im Rechteck. Um zu verhindern, dass zwei rote Punkte in derselben Zeile bzw. in derselben Spalte sind, m\u00fcssen wir im Controller eine weitere Bedingung einbauen, die pr\u00fcft, ob das angeklickte Feld \u00fcberhaupt auf MARKIERT gesetzt werden darf. Dazu muss f\u00fcr eine gegebene zeile und eine gegebene spalte gepr\u00fcft werden, ob sich darin bereits ein MARKIERT es field befindet. Es wird also die mouseClicked() -Methode angepasst: 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } Wir erstellen uns eine Variable bereitsMarkiert , in der wir uns merken wollen, ob ein bereits MARKIERT es field in der zeile oder in der spalte existiert (Zeile 134 ). In den Zeilen 135-138 wird gepr\u00fcft, ob das Feld selbst in zeile und spalte bereits MARKIERT ist. In den Zeilen 140-146 wird gepr\u00fcft, ob in der spalte ein bereits MARKIERT es field existiert. In den Zeilen 148-154 wird gepr\u00fcft, ob in der zeile ein bereits MARKIERT es field existiert. Nur, wenn keine der drei Bedingungen erf\u00fcllt sind, kann das field[zeile][spalte] auf MARKIERT gesetzt werden. Somit wird die Anforderung , dass keine zwei Felder in einer Zeile bzw. in einer Spalte auf MARKIERT gesetzt sein d\u00fcrfen, erf\u00fcllt. Die Pr\u00fcfung geschieht \"nur\" im Controller ! Wie kann nun daf\u00fcr gesorgt werden, dass das Feld gr\u00fcn erscheint, wenn es zwar angeklickt wird, aber bereits ein markiertes Feld in der Zeile bzw. der Spalte existiert? Eine einfache M\u00f6glichkeit w\u00e4re, einfach einen neuen State hinzuzuf\u00fcgen, z.B. GRUEN . Wir k\u00f6nnen uns aber auch zwei globale Variablen gruenZeile und gruenSpalte erzeugen und wenn diese jeweils einen Wert besitzen, der innerhalb des field -Bereiches liegt, dann solll dieses Feld einen gr\u00fcnen Hintergrund bekommen. Es gibt viele M\u00f6glichkeiten, wir nehmen mal die erste: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Schachbrett extends JFrame implements MouseListener { Canvas canvas ; enum State { MARKIERT , UNMARKIERT , GREEN }; State [][] field ; public Schachbrett () { super (); this . setTitle ( \"Schachbrett\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . initField (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // NORTH, EAST, WEST geloescht this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private void initField () { this . field = new State [ 8 ][ 8 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { this . field [ row ][ col ] = State . UNMARKIERT ; } } } private class Canvas extends JPanel { int heightRect = 0 ; int widthRect = 0 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int canvasHeight = this . getHeight (); int canvasWidth = this . getWidth (); this . heightRect = canvasHeight / 8 ; this . widthRect = canvasWidth / 8 ; boolean grey = true ; for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; // y-Wert des linken oberen Punktes grey = ! grey ; // mit einer anderen Farbe anfangen, als aufgehoert for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; // x-Wert des linken oberen Punktes if ( grey ) { g2 . setColor ( Color . LIGHT_GRAY ); grey = false ; } else { g2 . setColor ( Color . WHITE ); grey = true ; } if ( Schachbrett . this . field [ row ][ col ] == State . GREEN ) { g2 . setColor ( Color . GREEN ); Schachbrett . this . field [ row ][ col ] = State . UNMARKIERT ; } g2 . fillRect ( x , y , this . widthRect , this . heightRect ); } } for ( int row = 0 ; row < Schachbrett . this . field . length ; row ++ ) { int y = row * this . heightRect ; for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length ; col ++ ) { int x = col * this . widthRect ; if ( Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { int abstandX = this . widthRect / 3 ; int abstandY = this . heightRect / 3 ; int durchmesser = this . widthRect / 3 ; g2 . setColor ( Color . RED ); g2 . fillOval ( x + abstandX , y + abstandY , durchmesser , durchmesser ); g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawLine (( this . widthRect / 2 ), y + ( this . heightRect / 2 ), canvasWidth - ( this . widthRect / 2 ), y + ( this . heightRect / 2 )); g2 . drawLine ( x + ( this . widthRect / 2 ), ( this . heightRect / 2 ), x + ( this . widthRect / 2 ), canvasHeight - ( this . heightRect / 2 )); } } } } } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } public static void main ( String [] args ) { new Schachbrett (); } @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } else { this . field [ zeile ][ spalte ] = State . GREEN ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Jetzt wird der clear field -Button erzeugt und f\u00fcr diesen Button der ActionListener implementiert. Das kann alles innerhalb der initSouth() -Methode passieren. Das L\u00f6schen des Feldes besteht darin, alle Felder auf UNMARKIERT zu setzen. Das erledigt bereits die initField() -Methode. Diese Methode muss also nur aufgerufen werden und danach die canvas neu gezeichnet: 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); } Wir erstellen uns eine Variable bereitsMarkiert , in der wir uns merken wollen, ob ein bereits MARKIERT es field in der zeile oder in der spalte existiert (Zeile 134 ). In den Zeilen 135-138 wird gepr\u00fcft, ob das Feld selbst in zeile und spalte bereits MARKIERT ist. In den Zeilen 140-146 wird gepr\u00fcft, ob in der spalte ein bereits MARKIERT es field existiert. In den Zeilen 148-154 wird gepr\u00fcft, ob in der zeile ein bereits MARKIERT es field existiert. Nur, wenn keine der drei Bedingungen erf\u00fcllt sind, kann das field[zeile][spalte] auf MARKIERT gesetzt werden. Somit wird die Anforderung , dass keine zwei Felder in einer Zeile bzw. in einer Spalte auf MARKIERT gesetzt sein d\u00fcrfen, erf\u00fcllt. Die Pr\u00fcfung geschieht \"nur\" im Controller ! Wie kann nun daf\u00fcr gesorgt werden, dass das Feld gr\u00fcn erscheint, wenn es zwar angeklickt wird, aber bereits ein markiertes Feld in der Zeile bzw. der Spalte existiert? Eine einfache M\u00f6glichkeit w\u00e4re, einfach einen neuen State hinzuzuf\u00fcgen, z.B. GRUEN . Wir k\u00f6nnen uns aber auch zwei globale Variablen gruenZeile und gruenSpalte erzeugen und wenn diese jeweils einen Wert besitzen, der innerhalb des field -Bereiches liegt, dann solll dieses Feld einen gr\u00fcnen Hintergrund bekommen. Es gibt viele M\u00f6glichkeiten, wir nehmen mal die erste: 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 private JPanel initSouth () { JPanel south = new JPanel (); JButton clearBtn = new JButton ( \"clear field\" ); clearBtn . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Schachbrett . this . initField (); Schachbrett . this . canvas . repaint (); } }); south . add ( clearBtn ); return south ; } Die \u00dcberpr\u00fcfung eines \"Konfliktfalls\" f\u00fcr die Diagonalen kann ebenfalls in der mouseClicked() -Methode als zus\u00e4tzliche Bedingung eingef\u00fcgt werden. Dazu m\u00fcssen wir nur die Frage beantworten, wie wir ermitteln k\u00f6nnen, ob ein Feld mit den Koordinaten zeile1 und spalte1 auf einer Diagonalen des Feldes zeile und spalte liegt. Nehmen wir an, zeile=3 und spalte=4 . Dann w\u00e4ren z.B. zeile1=0 und spalte1=1 auf einer Diagonalen und auch zeile1=1 und spalte1=2 und auch zeile1=2 und spalte1=3 und auch zeile1=4 und spalte1=5 und auch zeile1=5 und spalte1=6 und auch zeile1=6 und spalte1=7 . F\u00fcr die andere Diagonale gilt zeile1=2 und spalte1=5 und auch zeile1=1 und spalte1=6 und auch zeile1=0 und spalte1=7 , aber auch zeile1=4 und spalte1=3 und auch zeile1=5 und spalte1=2 und auch zeile1=6 und spalte1=1 und auch zeile1=7 und spalte1=0 . Es gilt also, dass | zeile1 - zeile | == | spalte1 - spalte | , damit die Felder in zeile, spalte und zeile1, spalte1 in einer Diagonalen liegen. 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked: [x=\" + x + \", \" + y + \"]\" ); int spalte = x / this . canvas . widthRect ; int zeile = y / this . canvas . heightRect ; boolean bereitsMarkiert = false ; if ( Schachbrett . this . field [ zeile ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { if ( Schachbrett . this . field [ row ][ spalte ] == State . MARKIERT ) { bereitsMarkiert = true ; } } for ( int col = 0 ; col < Schachbrett . this . field [ zeile ] . length && ! bereitsMarkiert ; col ++ ) { if ( Schachbrett . this . field [ zeile ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } // Diagonalen for ( int row = 0 ; row < Schachbrett . this . field . length && ! bereitsMarkiert ; row ++ ) { for ( int col = 0 ; col < Schachbrett . this . field [ row ] . length && ! bereitsMarkiert ; col ++ ) { if ( ! ( col == spalte && row == zeile )) // nicht das Feld selbst betrachten { if (( Math . abs ( col - spalte ) == Math . abs ( row - zeile )) && Schachbrett . this . field [ row ][ col ] == State . MARKIERT ) { bereitsMarkiert = true ; } } } } if ( ! bereitsMarkiert ) { this . field [ zeile ][ spalte ] = State . MARKIERT ; } else { this . field [ zeile ][ spalte ] = State . GREEN ; } System . out . println ( \"mouseClicked: [zeile = \" + zeile + \", spalte = \" + spalte + \"]\" ); this . canvas . repaint (); }","title":"Schachbrett"},{"location":"klausurvorbereitung/#schiebepuzzle","text":"Aufgabe Schiebepuzzle Implementieren Sie folgendes Puzzle: obige Abbildung zeigt den Anfangszustand des Puzzles ( 2 \u00fcber 1 links) obige Abbildung zeigt den Endzustand des Puzzles ( 1 \u00fcber 2 links) Das Puzzle besteht aus 5 \u201eKacheln\u201c, 3 gelben und 2 roten. Die roten Kacheln sind mit einer 1 und einer 2 nummeriert. Am Anfang steht die rote Kachel mit der 2 \u00fcber der roten Kachel mit der 1 . (siehe erste Abb.) Ziel des Puzzles ist es, die beiden roten Kacheln zu vertauschen. Wenn links die 1 \u00fcber der 2 steht, ist das Puzzle beendet. Wo die gelben Kacheln im Endzustand sind, ist egal (siehe zweite Abb.). Ein Feld ist stets frei (grau dargestellt). In dieses Feld kann eine benachbarte Kachel geschoben werden. Zeigen Sie oben die Anzahl der Z\u00fcge an. Wenn der Endzustand erreicht ist, kann nicht mehr gezogen werden! Der Button Neustart setzt alles wieder auf Anfang. Die Programmierung bleibt ganz Ihnen \u00fcberlassen. Zum Schieben einer Kachel auf das leere Feld, klickt man auf die Kachel selbst. Diese \u201ebewegt\u201c sich dann auf das leere (graue) Feld und hinterl\u00e4sst ein leeres (graues) Feld (siehe folgende Abb.) Tipps: Sie ben\u00f6tigen keine Canvas und kein \u00dcberschreiben der paintComponent() -Methode! Am einfachsten bekommt man ein Label in die Mitte eines Panels gesetzt, wenn das Panel im GridLayout(1,1) (oder sogar parameterlos) ist und Sie f\u00fcr das Label label.setHorizontalAlignment(JLabel.CENTER); definieren die (Schrift-)Farbe eines Labels setzt man mit label.setForeground(Color); die (Hintergrund-Farbe eines Panels setzt man mit panel.setBackground(Color); f\u00fcr das Identifizieren des entsprechenden Panels, auf das man geklickt hat, k\u00f6nnte es hilfreich sein, sich daf\u00fcr eine eigene Klasse zu schreiben (die von JPanel erbt). Muss aber nicht. wahrscheinlich ist es am einfachsten, ein zweidimensionales Array 2x3 als Datenstruktur f\u00fcr Ihr Puzzle zu verwenden L\u00f6sung Schiebepuzzle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class Puzzle extends JFrame { JLabel infoLabel ; int anzMoves ; enum State { EINS , ZWEI , LEER , GELB } State [][] field ; MyPanel [][] panels ; JPanel mainPanel ; Puzzle () { super ( \"Puzzle\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . infoLabelPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . mainPanelStart (), BorderLayout . CENTER ); this . getContentPane (). add ( this . buttonPanel (), BorderLayout . SOUTH ); this . setSize ( 500 , 400 ); this . setVisible ( true ); } /**************************************** * erstmal alles fuer das Model * initiale Belegung von field */ void initialisiereField () { this . field = new State [ 2 ][ 3 ] ; this . field [ 0 ][ 0 ] = State . ZWEI ; this . field [ 0 ][ 1 ] = State . LEER ; this . field [ 0 ][ 2 ] = State . GELB ; this . field [ 1 ][ 0 ] = State . EINS ; this . field [ 1 ][ 1 ] = State . GELB ; this . field [ 1 ][ 2 ] = State . GELB ; } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return zeile von LEER */ int getLeerZeile () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return zeile ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return spalte von LEER */ int getLeerSpalte () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return spalte ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * von field[fromZeile][fromSpalte] aus wird gezogen * es wird geprueft, ob die leere Kachel entweder in der gleichen zeile * ist --> dann muss die spalte von LEER entweder links oder rechts sein (+/+ 1) * oder in der gleichen spalte --> dann muss die zeile von LEER entweder * darueber oder darunter sein (+/+ 1) * @param fromZeile * @param fromSpalte * @return ob zug ausgefuehrt wurde oder nicht */ boolean makeMove ( int fromZeile , int fromSpalte ) { if ( this . field [ fromZeile ][ fromSpalte ]!= State . LEER ) { int zeileLeer = this . getLeerZeile (); int spalteLeer = this . getLeerSpalte (); if (( Math . abs ( zeileLeer - fromZeile ) == 1 && spalteLeer - fromSpalte == 0 ) || ( zeileLeer - fromZeile == 0 && Math . abs ( spalteLeer - fromSpalte ) == 1 )) { this . field [ zeileLeer ][ spalteLeer ]= this . field [ fromZeile ][ fromSpalte ] ; this . field [ fromZeile ][ fromSpalte ]= State . LEER ; this . printField (); // nur zum debuggen this . anzMoves ++ ; return true ; } } return false ; } /** * definition des endzustands (links oben EINS, links unten ZWEI) * @return ob endzustand erreicht oder nicht */ boolean ende () { return ( this . field [ 0 ][ 0 ]== State . EINS && this . field [ 1 ][ 0 ]== State . ZWEI ); } /********************************************* * jetzt alles fuer die View - ganz zu Anfang */ JPanel initialiserePanels () { this . panels = new MyPanel [ 2 ][ 3 ] ; for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); this . mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return this . mainPanel ; } JPanel mainPanelStart () { this . mainPanel = new JPanel (); this . mainPanel . setLayout ( new GridLayout ( 2 , 3 , 3 , 3 )); this . initialisiereField (); // model this . initialiserePanels (); // view return mainPanel ; } JPanel infoLabelPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( \"Anzahl Zuege : \" + this . anzMoves ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel buttonPanel () { JPanel buttonPanel = new JPanel (); JButton neuStart = new JButton ( \"Neustart\" ); neuStart . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Puzzle . this . restart (); } }); buttonPanel . add ( neuStart ); return buttonPanel ; } /** * jetzt f\u00fcr Restart und Update * Restart: nach Druecken des Buttons \"Neustart\" * Update: nach jedem Zug */ void restart () { this . anzMoves = 0 ; this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); this . initialisiereField (); this . updatePanels (); } void updateLabel ( boolean ende ) { if ( ende ) { this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); this . infoLabel . setText ( \"Ende! Anzahl Zuege : \" + this . anzMoves ); } else { this . infoLabel . setText ( \"Anzahl Zuege : \" + this . anzMoves ); } } void updatePanels () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); } } this . updateLabel ( this . ende ()); } /** * das ist nur zum \"Debuggen\" - aber ganz nuetzlich */ void printField () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { if ( this . field [ zeile ][ spalte ]== State . LEER ) System . out . print ( \" -\" ); else if ( this . field [ zeile ][ spalte ]== State . EINS ) System . out . print ( \" 1\" ); else if ( this . field [ zeile ][ spalte ]== State . ZWEI ) System . out . print ( \" 2\" ); else if ( this . field [ zeile ][ spalte ]== State . GELB ) System . out . print ( \" o\" ); } System . out . println (); } System . out . println (); } /** * die Klasse f\u00fcr die \"Kacheln\" * die \"Kacheln\" sind JPanels (mit allen JPanel-Methoden) * ausserdem noch nuetzliche Objekteigenschaften: zeile, spalte und das Label, * das auf der Kachel ist (f\u00fcr GELB und LEER ist das Label leer) */ class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; JLabel label ; MyPanel ( int zeile , int spalte ) { super (); this . zeile = zeile ; this . spalte = spalte ; this . setLayout ( new GridLayout ()); this . label = new JLabel (); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . add ( label ); this . addMouseListener ( this ); } void view ( State state ) { switch ( state ) // geht natuerlich auch mit if(state==State.EINS) usw. { case EINS : this . setBackground ( Color . RED ); this . label . setText ( \"1\" ); break ; case ZWEI : this . setBackground ( Color . RED ); this . label . setText ( \"2\" ); break ; case LEER : this . setBackground ( Color . LIGHT_GRAY ); this . label . setText ( \"\" ); break ; case GELB : this . setBackground ( Color . YELLOW ); this . label . setText ( \"\" ); break ; } } @Override public void mouseClicked ( MouseEvent e ) { if ( ! Puzzle . this . ende () && Puzzle . this . makeMove ( this . zeile , this . spalte )) Puzzle . this . updatePanels (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new Puzzle (); } }","title":"Schiebepuzzle"},{"location":"klausurvorbereitung/#rechtecke-anordnen","text":"Aufgabe Rechtecke anordnen Implementieren Sie folgende GUI: die Abbildung zeigt die Ausgangssituation Die Zeichenfl\u00e4che ist in 4 gleichgro\u00dfe Teile unterteilt. Diese Unterteilung wird durch Linien dargestellt. Durch Dr\u00fccken des Buttons rectangle erscheint (beim ersten Mal ein gr\u00fcnes) Rechteck. Dieses Rechteck kann dann mit gedr\u00fcckter Maustaste verschoben werden. Sobald es im linken oberen Feld ist, wird es dort fixiert und kann nicht mehr bewegt werden. die obige Abbildung zeigt die Situation, in der das gr\u00fcne Rechteck fixiert ist und nicht mehr bewegt werden kann Nachdem das gr\u00fcne (erste) Rechteck fixiert ist, kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein rotes Rechteck. Das rote Rechteck soll in das rechte obere Feld. Nachdem auch das rote Rechteck fixiert ist, kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein gelbes Rechteck. Das gelbe Rechteck soll in das linke untere Feld. Nun kann der Button rectangle ein weiteres Mal gedr\u00fcckt werden. Es erscheint ein dunkelgraues Rechteck. Das dunkelgraue Rechteck soll in das rechte untere Feld. Wenn auch das graue Rechteck fixiert ist, ist die Endesituation erreicht (siehe Label oben in der folgenden Abbildung): Nach Klick auf den Button clear wird wieder die Ausgangssituation hergestellt: L\u00f6sung Rechtecke anordnen MyRectangle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import java.awt.Color ; import java.awt.Point ; public class MyRectangle { int x1 , y1 , x2 , y2 ; Color color ; boolean fixed ; MyRectangle ( int x1 , int y1 , int x2 , int y2 , Color color ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; this . color = color ; this . fixed = false ; } boolean inside ( int x , int y ) { return ( this . x1 <= x && this . x2 >= x && this . y1 <= y && this . y2 >= y ); } boolean inside ( Point p ) { return inside ( p . x , p . y ); } void move ( int diffX , int diffY ) { if ( ! this . fixed ) { this . x1 = this . x1 + diffX ; this . y1 = this . y1 + diffY ; this . x2 = this . x2 + diffX ; this . y2 = this . y2 + diffY ; } } Color getColor () { return this . color ; } Point getLinksOben () { return new Point ( this . x1 , this . y1 ); } Point getRechtsOben () { return new Point ( this . x2 , this . y1 ); } Point getLinksUnten () { return new Point ( this . x1 , this . y2 ); } Point getRechtsUnten () { return new Point ( this . x2 , this . y2 ); } } RechteckeAnordnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.* ; public class RechteckeAnordnen extends JFrame { JButton resetButton , newRectButton ; MyRectangle aktRechteck = null ; List < MyRectangle > rectangles = new ArrayList <> (); Canvas canvas ; JLabel infoLabel ; int anzRectFixed = 0 ; RechteckeAnordnen () { super ( \"Rechtecke fixieren\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . createInfoPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . getContentPane (). add ( this . createButtons (), BorderLayout . SOUTH ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } JPanel createInfoPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( this . anzRectFixed + \" Rechtecke fixiert\" ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel createButtons () { JPanel buttonPanel = new JPanel (); this . resetButton = new JButton ( \"clear\" ); this . resetButton . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed = 0 ; RechteckeAnordnen . this . rectangles . clear (); RechteckeAnordnen . this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); RechteckeAnordnen . this . canvas . repaint (); } }); buttonPanel . add ( resetButton ); this . newRectButton = new JButton ( \"rectangle\" ); this . newRectButton . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { if ( RechteckeAnordnen . this . aktRechteck == null && RechteckeAnordnen . this . anzRectFixed < 4 ) { int x = RechteckeAnordnen . this . canvas . getWidth () / 4 ; int y = RechteckeAnordnen . this . canvas . getHeight () / 4 ; Color color = null ; switch ( RechteckeAnordnen . this . rectangles . size ()) { case 0 : color = Color . GREEN ; break ; case 1 : color = Color . RED ; break ; case 2 : color = Color . YELLOW ; break ; case 3 : color = Color . DARK_GRAY ; break ; default : color = Color . WHITE ; break ; } RechteckeAnordnen . this . aktRechteck = new MyRectangle ( x , y , x + 2 * x , y + 2 * y , color ); RechteckeAnordnen . this . canvas . repaint (); } } }); buttonPanel . add ( newRectButton ); return buttonPanel ; } class Canvas extends JPanel implements MouseListener , MouseMotionListener { boolean move = false ; Point from ; Canvas () { this . setBorder ( BorderFactory . createLineBorder ( Color . black )); this . addMouseListener ( this ); this . addMouseMotionListener ( this ); } @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; int widthPanel = this . getWidth (); // Breite der Canvas int heightPanel = this . getHeight (); // Hoehe der Canvas g2 . drawLine ( widthPanel / 2 , 0 , widthPanel / 2 , heightPanel ); g2 . drawLine ( 0 , heightPanel / 2 , widthPanel , heightPanel / 2 ); for ( MyRectangle rect : RechteckeAnordnen . this . rectangles ) { g2 . setColor ( rect . color ); int x = rect . x1 ; int y = rect . y1 ; int width = rect . x2 - rect . x1 ; int height = rect . y2 - rect . y1 ; g2 . fill3DRect ( x , y , width , height , true ); } if ( RechteckeAnordnen . this . aktRechteck != null ) { g2 . setColor ( RechteckeAnordnen . this . aktRechteck . color ); int x = RechteckeAnordnen . this . aktRechteck . x1 ; int y = RechteckeAnordnen . this . aktRechteck . y1 ; int width = RechteckeAnordnen . this . aktRechteck . x2 - RechteckeAnordnen . this . aktRechteck . x1 ; int height = RechteckeAnordnen . this . aktRechteck . y2 - RechteckeAnordnen . this . aktRechteck . y1 ; g2 . fill3DRect ( x , y , width , height , true ); } } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mousePressed ( MouseEvent e ) { this . from = e . getPoint (); if ( RechteckeAnordnen . this . aktRechteck != null && RechteckeAnordnen . this . aktRechteck . inside ( from )) { this . move = true ; } } @Override public void mouseReleased ( MouseEvent e ) { this . move = false ; } @Override public void mouseEntered ( MouseEvent e ) { } @Override public void mouseExited ( MouseEvent e ) { } @Override public void mouseDragged ( MouseEvent e ) { Point here = e . getPoint (); if ( move ) { int diffX = here . x - this . from . x ; int diffY = here . y - this . from . y ; RechteckeAnordnen . this . aktRechteck . move ( diffX , diffY ); this . from = here ; int diff = 15 ; switch ( RechteckeAnordnen . this . anzRectFixed ) { case 0 : Point goal = new Point ( 0 , 0 ); Point corner = RechteckeAnordnen . this . aktRechteck . getLinksOben (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( 0 , 0 , this . getWidth () / 2 , this . getHeight () / 2 , RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 1 : goal = new Point ( this . getWidth (), 0 ); corner = RechteckeAnordnen . this . aktRechteck . getRechtsOben (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( this . getWidth () / 2 + 1 , 0 , this . getWidth (), this . getHeight () / 2 , RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 2 : goal = new Point ( 0 , this . getHeight ()); corner = RechteckeAnordnen . this . aktRechteck . getLinksUnten (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( 0 , this . getHeight () / 2 + 1 , this . getWidth () / 2 , this . getHeight (), RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert\" ); } break ; case 3 : goal = new Point ( this . getWidth (), this . getHeight ()); corner = RechteckeAnordnen . this . aktRechteck . getRechtsUnten (); if ( Math . abs ( goal . x - corner . x ) < 5 && Math . abs ( goal . y - corner . y ) < diff ) { this . move = false ; RechteckeAnordnen . this . rectangles . add ( new MyRectangle ( this . getWidth () / 2 + 1 , this . getHeight () / 2 + 1 , this . getWidth (), this . getHeight (), RechteckeAnordnen . this . aktRechteck . getColor ())); RechteckeAnordnen . this . aktRechteck = null ; RechteckeAnordnen . this . anzRectFixed ++ ; RechteckeAnordnen . this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); RechteckeAnordnen . this . infoLabel . setText ( RechteckeAnordnen . this . anzRectFixed + \" Rechtecke fixiert -- ENDE\" ); } break ; } this . repaint (); } } @Override public void mouseMoved ( MouseEvent e ) { } } public static void main ( String [] args ) { new RechteckeAnordnen (); } }","title":"Rechtecke anordnen"},{"location":"klausurvorbereitung2022/","text":"Klausurvorbereitung \u00b6 Wir beginnen mit allgemeinen Betrachtungen zum Grundger\u00fcst. M\u00f6gliches Grundger\u00fcst \u00b6 Wie Sie wissen, ist das Fenster ( JFrame ) im BorderLayout . Das bedeutet, dass das Fenster in f\u00fcnf Bereiche ( Container ) unterteilt ist. Sie m\u00fcssen sich bei der Konfiguration \u00fcberlegen, welche der f\u00fcnf Bereiche Sie ben\u00f6tigen. Grundger\u00fcst 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.awt.BorderLayout ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestOhneCanvas extends JFrame { JPanel content ; public GrundgeruestOhneCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . content = this . initCenter (); this . getContentPane (). add ( this . content , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initCenter () { JPanel center = new JPanel (); // hier das JPanel fuer CENTER befuellen return center ; } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestOhneCanvas (); } } In diesem Grundger\u00fcst werden alle f\u00fcnf Bereiche des Fensters mit JPanel bef\u00fcllt. Sollten Sie z.B. kein Panel im EAST - und im WEST -Bereich des Fensters ben\u00f6tigen, dann l\u00f6schen Sie einfach die Zeilen 21 und 22 sowie die beiden Methoden initEast() und initWest() . Beachten Sie, dass JPanel ohne Angabe eines LayoutManagers im FlowLayout sind. Das k\u00f6nnen Sie \u00e4ndern und die einzelnen JPanel auch noch weiter verschachteln . Schiebepuzzle \u00b6 Aufgabe Schiebepuzzle Implementieren Sie folgendes Puzzle: obige Abbildung zeigt den Anfangszustand des Puzzles ( 2 \u00fcber 1 links) obige Abbildung zeigt den Endzustand des Puzzles ( 1 \u00fcber 2 links) Das Puzzle besteht aus 5 \u201eKacheln\u201c, 3 gelben und 2 roten. Die roten Kacheln sind mit einer 1 und einer 2 nummeriert. Am Anfang steht die rote Kachel mit der 2 \u00fcber der roten Kachel mit der 1 . (siehe erste Abb.) Ziel des Puzzles ist es, die beiden roten Kacheln zu vertauschen. Wenn links die 1 \u00fcber der 2 steht, ist das Puzzle beendet. Wo die gelben Kacheln im Endzustand sind, ist egal (siehe zweite Abb.). Ein Feld ist stets frei (grau dargestellt). In dieses Feld kann eine benachbarte Kachel geschoben werden. Zeigen Sie oben die Anzahl der Z\u00fcge an. Wenn der Endzustand erreicht ist, kann nicht mehr gezogen werden! Der Button Neustart setzt alles wieder auf Anfang. Die Programmierung bleibt ganz Ihnen \u00fcberlassen. Zum Schieben einer Kachel auf das leere Feld, klickt man auf die Kachel selbst. Diese \u201ebewegt\u201c sich dann auf das leere (graue) Feld und hinterl\u00e4sst ein leeres (graues) Feld (siehe folgende Abb.) Tipps: Am einfachsten bekommt man ein Label in die Mitte eines Panels gesetzt, wenn das Panel im GridLayout(1,1) (oder sogar parameterlos) ist und Sie f\u00fcr das Label label.setHorizontalAlignment(JLabel.CENTER); definieren die (Schrift-)Farbe eines Labels setzt man mit label.setForeground(Color); die (Hintergrund-Farbe eines Panels setzt man mit panel.setBackground(Color); f\u00fcr das Identifizieren des entsprechenden Panels, auf das man geklickt hat, k\u00f6nnte es hilfreich sein, sich daf\u00fcr eine eigene Klasse zu schreiben (die von JPanel erbt). Muss aber nicht. Sie k\u00f6nnen auch die Quelle des MouseEvent identifizieren. wahrscheinlich ist es am einfachsten, ein zweidimensionales Array 2x3 als Datenstruktur f\u00fcr Ihr Puzzle zu verwenden L\u00f6sung Schiebepuzzle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class Puzzle extends JFrame { JLabel infoLabel ; int anzMoves ; enum State { EINS , ZWEI , LEER , GELB } State [][] field ; MyPanel [][] panels ; JPanel mainPanel ; Puzzle () { super ( \"Puzzle\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . infoLabelPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . mainPanelStart (), BorderLayout . CENTER ); this . getContentPane (). add ( this . buttonPanel (), BorderLayout . SOUTH ); this . setSize ( 500 , 400 ); this . setVisible ( true ); } /**************************************** * erstmal alles fuer das Model * initiale Belegung von field */ void initialisiereField () { this . field = new State [ 2 ][ 3 ] ; this . field [ 0 ][ 0 ] = State . ZWEI ; this . field [ 0 ][ 1 ] = State . LEER ; this . field [ 0 ][ 2 ] = State . GELB ; this . field [ 1 ][ 0 ] = State . EINS ; this . field [ 1 ][ 1 ] = State . GELB ; this . field [ 1 ][ 2 ] = State . GELB ; } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return zeile von LEER */ int getLeerZeile () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return zeile ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return spalte von LEER */ int getLeerSpalte () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return spalte ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * von field[fromZeile][fromSpalte] aus wird gezogen * es wird geprueft, ob die leere Kachel entweder in der gleichen zeile * ist --> dann muss die spalte von LEER entweder links oder rechts sein (+/+ 1) * oder in der gleichen spalte --> dann muss die zeile von LEER entweder * darueber oder darunter sein (+/+ 1) * @param fromZeile * @param fromSpalte * @return ob zug ausgefuehrt wurde oder nicht */ boolean makeMove ( int fromZeile , int fromSpalte ) { if ( this . field [ fromZeile ][ fromSpalte ]!= State . LEER ) { int zeileLeer = this . getLeerZeile (); int spalteLeer = this . getLeerSpalte (); if (( Math . abs ( zeileLeer - fromZeile ) == 1 && spalteLeer - fromSpalte == 0 ) || ( zeileLeer - fromZeile == 0 && Math . abs ( spalteLeer - fromSpalte ) == 1 )) { this . field [ zeileLeer ][ spalteLeer ]= this . field [ fromZeile ][ fromSpalte ] ; this . field [ fromZeile ][ fromSpalte ]= State . LEER ; this . printField (); // nur zum debuggen this . anzMoves ++ ; return true ; } } return false ; } /** * definition des endzustands (links oben EINS, links unten ZWEI) * @return ob endzustand erreicht oder nicht */ boolean ende () { return ( this . field [ 0 ][ 0 ]== State . EINS && this . field [ 1 ][ 0 ]== State . ZWEI ); } /********************************************* * jetzt alles fuer die View - ganz zu Anfang */ JPanel initialiserePanels () { this . panels = new MyPanel [ 2 ][ 3 ] ; for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); this . mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return this . mainPanel ; } JPanel mainPanelStart () { this . mainPanel = new JPanel (); this . mainPanel . setLayout ( new GridLayout ( 2 , 3 , 3 , 3 )); this . initialisiereField (); // model this . initialiserePanels (); // view return mainPanel ; } JPanel infoLabelPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( \"Anzahl Zuege : \" + this . anzMoves ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel buttonPanel () { JPanel buttonPanel = new JPanel (); JButton neuStart = new JButton ( \"Neustart\" ); neuStart . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Puzzle . this . restart (); } }); buttonPanel . add ( neuStart ); return buttonPanel ; } /** * jetzt f\u00fcr Restart und Update * Restart: nach Druecken des Buttons \"Neustart\" * Update: nach jedem Zug */ void restart () { this . anzMoves = 0 ; this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); this . initialisiereField (); this . updatePanels (); } void updateLabel ( boolean ende ) { if ( ende ) { this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); this . infoLabel . setText ( \"Ende! Anzahl Zuege : \" + this . anzMoves ); } else { this . infoLabel . setText ( \"Anzahl Zuege : \" + this . anzMoves ); } } void updatePanels () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); } } this . updateLabel ( this . ende ()); } /** * das ist nur zum \"Debuggen\" - aber ganz nuetzlich */ void printField () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { if ( this . field [ zeile ][ spalte ]== State . LEER ) System . out . print ( \" -\" ); else if ( this . field [ zeile ][ spalte ]== State . EINS ) System . out . print ( \" 1\" ); else if ( this . field [ zeile ][ spalte ]== State . ZWEI ) System . out . print ( \" 2\" ); else if ( this . field [ zeile ][ spalte ]== State . GELB ) System . out . print ( \" o\" ); } System . out . println (); } System . out . println (); } /** * die Klasse f\u00fcr die \"Kacheln\" * die \"Kacheln\" sind JPanels (mit allen JPanel-Methoden) * ausserdem noch nuetzliche Objekteigenschaften: zeile, spalte und das Label, * das auf der Kachel ist (f\u00fcr GELB und LEER ist das Label leer) */ class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; JLabel label ; MyPanel ( int zeile , int spalte ) { super (); this . zeile = zeile ; this . spalte = spalte ; this . setLayout ( new GridLayout ()); this . label = new JLabel (); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . add ( label ); this . addMouseListener ( this ); } void view ( State state ) { switch ( state ) // geht natuerlich auch mit if(state==State.EINS) usw. { case EINS : this . setBackground ( Color . RED ); this . label . setText ( \"1\" ); break ; case ZWEI : this . setBackground ( Color . RED ); this . label . setText ( \"2\" ); break ; case LEER : this . setBackground ( Color . LIGHT_GRAY ); this . label . setText ( \"\" ); break ; case GELB : this . setBackground ( Color . YELLOW ); this . label . setText ( \"\" ); break ; } } @Override public void mouseClicked ( MouseEvent e ) { if ( ! Puzzle . this . ende () && Puzzle . this . makeMove ( this . zeile , this . spalte )) Puzzle . this . updatePanels (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new Puzzle (); } } Zur Klausurvorbereitung eignet sich auch die \u00dcbung Klicks z\u00e4hlen .","title":"Klausurvorbereitung"},{"location":"klausurvorbereitung2022/#klausurvorbereitung","text":"Wir beginnen mit allgemeinen Betrachtungen zum Grundger\u00fcst.","title":"Klausurvorbereitung"},{"location":"klausurvorbereitung2022/#mogliches-grundgerust","text":"Wie Sie wissen, ist das Fenster ( JFrame ) im BorderLayout . Das bedeutet, dass das Fenster in f\u00fcnf Bereiche ( Container ) unterteilt ist. Sie m\u00fcssen sich bei der Konfiguration \u00fcberlegen, welche der f\u00fcnf Bereiche Sie ben\u00f6tigen. Grundger\u00fcst 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.awt.BorderLayout ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GrundgeruestOhneCanvas extends JFrame { JPanel content ; public GrundgeruestOhneCanvas () { super (); this . setTitle ( \"GrundgeruestMitCanvas\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . content = this . initCenter (); this . getContentPane (). add ( this . content , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initCenter () { JPanel center = new JPanel (); // hier das JPanel fuer CENTER befuellen return center ; } private JPanel initNorth () { JPanel north = new JPanel (); // hier das JPanel fuer NORTH befuellen return north ; } private JPanel initSouth () { JPanel south = new JPanel (); // hier das JPanel fuer SOUTH befuellen return south ; } private JPanel initEast () { JPanel east = new JPanel (); // hier das JPanel fuer EAST befuellen return east ; } private JPanel initWest () { JPanel west = new JPanel (); // hier das JPanel fuer WEST befuellen return west ; } public static void main ( String [] args ) { new GrundgeruestOhneCanvas (); } } In diesem Grundger\u00fcst werden alle f\u00fcnf Bereiche des Fensters mit JPanel bef\u00fcllt. Sollten Sie z.B. kein Panel im EAST - und im WEST -Bereich des Fensters ben\u00f6tigen, dann l\u00f6schen Sie einfach die Zeilen 21 und 22 sowie die beiden Methoden initEast() und initWest() . Beachten Sie, dass JPanel ohne Angabe eines LayoutManagers im FlowLayout sind. Das k\u00f6nnen Sie \u00e4ndern und die einzelnen JPanel auch noch weiter verschachteln .","title":"M\u00f6gliches Grundger\u00fcst"},{"location":"klausurvorbereitung2022/#schiebepuzzle","text":"Aufgabe Schiebepuzzle Implementieren Sie folgendes Puzzle: obige Abbildung zeigt den Anfangszustand des Puzzles ( 2 \u00fcber 1 links) obige Abbildung zeigt den Endzustand des Puzzles ( 1 \u00fcber 2 links) Das Puzzle besteht aus 5 \u201eKacheln\u201c, 3 gelben und 2 roten. Die roten Kacheln sind mit einer 1 und einer 2 nummeriert. Am Anfang steht die rote Kachel mit der 2 \u00fcber der roten Kachel mit der 1 . (siehe erste Abb.) Ziel des Puzzles ist es, die beiden roten Kacheln zu vertauschen. Wenn links die 1 \u00fcber der 2 steht, ist das Puzzle beendet. Wo die gelben Kacheln im Endzustand sind, ist egal (siehe zweite Abb.). Ein Feld ist stets frei (grau dargestellt). In dieses Feld kann eine benachbarte Kachel geschoben werden. Zeigen Sie oben die Anzahl der Z\u00fcge an. Wenn der Endzustand erreicht ist, kann nicht mehr gezogen werden! Der Button Neustart setzt alles wieder auf Anfang. Die Programmierung bleibt ganz Ihnen \u00fcberlassen. Zum Schieben einer Kachel auf das leere Feld, klickt man auf die Kachel selbst. Diese \u201ebewegt\u201c sich dann auf das leere (graue) Feld und hinterl\u00e4sst ein leeres (graues) Feld (siehe folgende Abb.) Tipps: Am einfachsten bekommt man ein Label in die Mitte eines Panels gesetzt, wenn das Panel im GridLayout(1,1) (oder sogar parameterlos) ist und Sie f\u00fcr das Label label.setHorizontalAlignment(JLabel.CENTER); definieren die (Schrift-)Farbe eines Labels setzt man mit label.setForeground(Color); die (Hintergrund-Farbe eines Panels setzt man mit panel.setBackground(Color); f\u00fcr das Identifizieren des entsprechenden Panels, auf das man geklickt hat, k\u00f6nnte es hilfreich sein, sich daf\u00fcr eine eigene Klasse zu schreiben (die von JPanel erbt). Muss aber nicht. Sie k\u00f6nnen auch die Quelle des MouseEvent identifizieren. wahrscheinlich ist es am einfachsten, ein zweidimensionales Array 2x3 als Datenstruktur f\u00fcr Ihr Puzzle zu verwenden L\u00f6sung Schiebepuzzle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class Puzzle extends JFrame { JLabel infoLabel ; int anzMoves ; enum State { EINS , ZWEI , LEER , GELB } State [][] field ; MyPanel [][] panels ; JPanel mainPanel ; Puzzle () { super ( \"Puzzle\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( this . infoLabelPanel (), BorderLayout . NORTH ); this . getContentPane (). add ( this . mainPanelStart (), BorderLayout . CENTER ); this . getContentPane (). add ( this . buttonPanel (), BorderLayout . SOUTH ); this . setSize ( 500 , 400 ); this . setVisible ( true ); } /**************************************** * erstmal alles fuer das Model * initiale Belegung von field */ void initialisiereField () { this . field = new State [ 2 ][ 3 ] ; this . field [ 0 ][ 0 ] = State . ZWEI ; this . field [ 0 ][ 1 ] = State . LEER ; this . field [ 0 ][ 2 ] = State . GELB ; this . field [ 1 ][ 0 ] = State . EINS ; this . field [ 1 ][ 1 ] = State . GELB ; this . field [ 1 ][ 2 ] = State . GELB ; } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return zeile von LEER */ int getLeerZeile () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return zeile ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * Hilfsmethode, um zu wissen, in welcher Zeile sich das leere Feld befindet * damit ist makeMove() etwas kuerzer * @return spalte von LEER */ int getLeerSpalte () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) if ( this . field [ zeile ][ spalte ]== State . LEER ) return spalte ; return - 1 ; // fehlerfall - kommt aber nicht vor } /** * von field[fromZeile][fromSpalte] aus wird gezogen * es wird geprueft, ob die leere Kachel entweder in der gleichen zeile * ist --> dann muss die spalte von LEER entweder links oder rechts sein (+/+ 1) * oder in der gleichen spalte --> dann muss die zeile von LEER entweder * darueber oder darunter sein (+/+ 1) * @param fromZeile * @param fromSpalte * @return ob zug ausgefuehrt wurde oder nicht */ boolean makeMove ( int fromZeile , int fromSpalte ) { if ( this . field [ fromZeile ][ fromSpalte ]!= State . LEER ) { int zeileLeer = this . getLeerZeile (); int spalteLeer = this . getLeerSpalte (); if (( Math . abs ( zeileLeer - fromZeile ) == 1 && spalteLeer - fromSpalte == 0 ) || ( zeileLeer - fromZeile == 0 && Math . abs ( spalteLeer - fromSpalte ) == 1 )) { this . field [ zeileLeer ][ spalteLeer ]= this . field [ fromZeile ][ fromSpalte ] ; this . field [ fromZeile ][ fromSpalte ]= State . LEER ; this . printField (); // nur zum debuggen this . anzMoves ++ ; return true ; } } return false ; } /** * definition des endzustands (links oben EINS, links unten ZWEI) * @return ob endzustand erreicht oder nicht */ boolean ende () { return ( this . field [ 0 ][ 0 ]== State . EINS && this . field [ 1 ][ 0 ]== State . ZWEI ); } /********************************************* * jetzt alles fuer die View - ganz zu Anfang */ JPanel initialiserePanels () { this . panels = new MyPanel [ 2 ][ 3 ] ; for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); this . mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return this . mainPanel ; } JPanel mainPanelStart () { this . mainPanel = new JPanel (); this . mainPanel . setLayout ( new GridLayout ( 2 , 3 , 3 , 3 )); this . initialisiereField (); // model this . initialiserePanels (); // view return mainPanel ; } JPanel infoLabelPanel () { JPanel infoPanel = new JPanel (); this . infoLabel = new JLabel ( \"Anzahl Zuege : \" + this . anzMoves ); this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); infoPanel . add ( this . infoLabel ); return infoPanel ; } JPanel buttonPanel () { JPanel buttonPanel = new JPanel (); JButton neuStart = new JButton ( \"Neustart\" ); neuStart . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Puzzle . this . restart (); } }); buttonPanel . add ( neuStart ); return buttonPanel ; } /** * jetzt f\u00fcr Restart und Update * Restart: nach Druecken des Buttons \"Neustart\" * Update: nach jedem Zug */ void restart () { this . anzMoves = 0 ; this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC , 18 )); this . initialisiereField (); this . updatePanels (); } void updateLabel ( boolean ende ) { if ( ende ) { this . infoLabel . setFont ( new Font ( \"Verdana\" , Font . ITALIC | Font . BOLD , 18 )); this . infoLabel . setText ( \"Ende! Anzahl Zuege : \" + this . anzMoves ); } else { this . infoLabel . setText ( \"Anzahl Zuege : \" + this . anzMoves ); } } void updatePanels () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { this . panels [ zeile ][ spalte ] . view ( this . field [ zeile ][ spalte ] ); } } this . updateLabel ( this . ende ()); } /** * das ist nur zum \"Debuggen\" - aber ganz nuetzlich */ void printField () { for ( int zeile = 0 ; zeile < 2 ; zeile ++ ) { for ( int spalte = 0 ; spalte < 3 ; spalte ++ ) { if ( this . field [ zeile ][ spalte ]== State . LEER ) System . out . print ( \" -\" ); else if ( this . field [ zeile ][ spalte ]== State . EINS ) System . out . print ( \" 1\" ); else if ( this . field [ zeile ][ spalte ]== State . ZWEI ) System . out . print ( \" 2\" ); else if ( this . field [ zeile ][ spalte ]== State . GELB ) System . out . print ( \" o\" ); } System . out . println (); } System . out . println (); } /** * die Klasse f\u00fcr die \"Kacheln\" * die \"Kacheln\" sind JPanels (mit allen JPanel-Methoden) * ausserdem noch nuetzliche Objekteigenschaften: zeile, spalte und das Label, * das auf der Kachel ist (f\u00fcr GELB und LEER ist das Label leer) */ class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; JLabel label ; MyPanel ( int zeile , int spalte ) { super (); this . zeile = zeile ; this . spalte = spalte ; this . setLayout ( new GridLayout ()); this . label = new JLabel (); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . add ( label ); this . addMouseListener ( this ); } void view ( State state ) { switch ( state ) // geht natuerlich auch mit if(state==State.EINS) usw. { case EINS : this . setBackground ( Color . RED ); this . label . setText ( \"1\" ); break ; case ZWEI : this . setBackground ( Color . RED ); this . label . setText ( \"2\" ); break ; case LEER : this . setBackground ( Color . LIGHT_GRAY ); this . label . setText ( \"\" ); break ; case GELB : this . setBackground ( Color . YELLOW ); this . label . setText ( \"\" ); break ; } } @Override public void mouseClicked ( MouseEvent e ) { if ( ! Puzzle . this . ende () && Puzzle . this . makeMove ( this . zeile , this . spalte )) Puzzle . this . updatePanels (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new Puzzle (); } } Zur Klausurvorbereitung eignet sich auch die \u00dcbung Klicks z\u00e4hlen .","title":"Schiebepuzzle"},{"location":"maps/","text":"Maps \u00b6 Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel ( keys ) enth\u00e4lt und die rechte Spalte die Werte ( values ). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine Set . Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map . F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial . Statt add() und addAll() hier put() und putAll() \u00b6 Da nicht das Collections -Interface f\u00fcr Maps implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer Map leider auch nicht \u00fcber add() bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber addAll() , sondern \u00fcber put(K key, V value) und putAll(Map m) . K ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und V ein Platzhalter f\u00fcr den Typ der Werte. Typ einer Map und Typ eines Schl\u00fcssel-Werte-Paares \u00b6 Eine Map wird also mit zwei Typen typisiert: Map<K, V> wobei K den Typ der Schl\u00fcssel und V den Typ der Werte definiert. Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. Entry ist eine innere Klasse in der Klasse Map (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer Map ist Map<K,V> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser Map ist Map.Entry<K,V> . Statt iterator() hier entrySet() \u00b6 Die Objektmethode iterator() gibt es f\u00fcr Map leider auch nicht. Stattdessen wird hier die Methode entrySet() verwendet. Da es sich bei einer Map um eine Set von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ Map.Entry<K,V> ) handelt, liefert entrySet() eine Set<Map.Entry<K,V>> zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine Set . Diese ist typisiert und zwar mit dem Typ Map.Entry , welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. Map.Entry ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel K und dem Typ der Werte V . F\u00fcr K und V werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter. Klassenbaum f\u00fcr Map \u00b6 Der Klassenbaum f\u00fcr Map hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr Collection . Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder. Auch hier ist es wieder so, dass wir Map als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen EnumMap , HashMap und TreeMap verwenden. Die am h\u00e4ufigsten verwendete Klasse ist HashMap , da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird TreeMap verwendet. Erstes Beispiel \u00b6 Wir betrachten ein erstes Beispiel. Wir erstellen eine HashMap und f\u00fcgen vier Eintr\u00e4ge hinzu: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap ; import java.util.Map ; public class Maps { public static void main ( String [] args ) { Map < String , Double > m = new HashMap <> (); m . put ( \"s0512345\" , 1.7 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0587654\" , 2.3 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0512345\" , 2.7 ); // Schluessel existiert bereits --> Wert geaendert m . put ( \"s0555555\" , 3.0 ); // neues Schluessel-Werte-Paar hinzugefuegt } } In Zeile 8 wird unsere Map erzeugt. Die Referenzvariable auf die Map hei\u00dft m . Die Schl\u00fcssel sind vom Typ String und die Werte sind vom Typ Double . Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse HashMap erzeugt. In Zeile 9 f\u00fcgen wir mithilfe der put() -Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0512345\" , der Wert ( value ) ist 1.7 . Beachten Sie, dass hier ein Auto-Boxing des double -Wertes 1.7 in ein Double stattfindet. In Zeile 10 f\u00fcgen wir mithilfe der put() -Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0587654\" , der Wert ( value ) ist 2.3 (erneut Auto-Boxing ). In Zeile 11 wird erneut die put() -Methode aufgerufen. Der Schl\u00fcssel \"s0512345\" existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert 1.7 wird nun 2.7 . Die Map enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. In Zeile 12 f\u00fcgen wir mithilfe der put() -Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0555555\" , der Wert ( value ) ist 3.0 (erneut Auto-Boxing ). Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung): Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten: Die Anwendung dieser Methoden auf unsere Map m zeigen die folgenden Anweisungen: 1 2 3 Set < String > keys = m . keySet (); // Menge aller Schluessel Collection < Double > values = m . values (); // Collection aller Werte Set < Map . Entry < String , Double >> entries = m . entrySet (); // Menge aller Schluessel-Werte-Paare die Objektmethode keySet() liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist Set<K> , die Objektmethode values() liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist Collection<V> , die Objektmethode entrySet() liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist Set<Map.Entry<K,V>> Durch eine Map laufen \u00b6 Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode entrySet() verwenden. F\u00fcr den R\u00fcckgabetyp Map.Entry<K,V> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung: getKey() liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist K , getValue() liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist V . Wir betrachten f\u00fcr unsere Map m ein Beispiel: 1 2 3 4 for ( Map . Entry < String , Double > eintrag : m . entrySet ()) { System . out . println ( eintrag . getKey () + \" : \" + eintrag . getValue ()); } - In Zeile 1 wird die Methode m.entrySet() aufgerufen, diese gibt eine Set<Map.Entry<String, Double>> zur\u00fcck. Jeder einzelne Eintrag in dieser Set ist also vom Typ Map.Entry<String,Double> . Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable eintrag . Wir nutzen hier also erneut die for-each -Schleife, um durch eine Set zu laufen. - In Zeile 3 verwenden wir die Objektmethoden getKey() und getValue() , die uns von Map.Entry zur Verf\u00fcgung gestellt werden. getKey() gibt uns hier einen String zur\u00fcck (den Schl\u00fcssel) und getValue() gibt hier ein Double zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von Double nach String (impliziter Aufruf von toString() f\u00fcr Double ). Es erfolgt folgende Ausgabe: s0512345 : 2 .7 s0555555 : 3 .0 s0587654 : 2 .3 Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. Wir probieren auch noch die Objektmethoden keySet() und value() aus, die f\u00fcr eine Map zur Verf\u00fcgung stehen: for ( String schluessel : m . keySet ()) { System . out . println ( \"key : \" + schluessel ); } erzeugt: key : s0512345 key : s0555555 key : s0587654 und for ( Double wert : m . values ()) { System . out . println ( \"value : \" + wert . toString ()); // toString() wuerde auch implizit aufgerufen } erzeugt: value : 2 .7 value : 3 .0 value : 2 .3 \u00dcbung Was wird ausgegeben? Map < String , String > accounts = new HashMap <> (); accounts . put ( \"anton\" , \"anton@email.de\" ); accounts . put ( \"berta\" , \"berta@email.de\" ); accounts . put ( \"caesar\" , \"caesar@email.de\" ); accounts . put ( \"anton\" , \"antonius@email.de\" ); // Iteration ueber alle Eintraege (Map.Entry) der Map for ( Map . Entry < String , String > entry : accounts . entrySet ()) { System . out . println ( \"Account : \" + entry . getKey () + \" E-Mail : \" + entry . getValue ()); } Zusammenfassung Maps \u00b6 Maps speichern Referenztypen als Schl\u00fcssel und Werte Maps werden typisiert mit K (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und V (Platzhalter f\u00fcr den Referenztyp des Wertes) Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt) der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine Map . Weitere Methoden finden Sie hier . Objektmethode Beschreibung V get(K key) Gibt den Wert zum Schl\u00fcssel key zur\u00fcck. Ist der Schl\u00fcssel key nicht in der Map enthalten, wird null zur\u00fcckgegeben. V put(K key, V value) F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel key und dem Wert value in die Map ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel key bereits existiert, wird der value \u00fcberschrieben . void putAll(Map m) F\u00fcgt alle Element der Map m in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben . void clear() Entfernt alle Elemente aus der Map. boolean containsKey(Object k) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel k in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt k erfolgt mit der equals() -Methode. boolean containsValue(Object v) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Wert v in der Map gibt. Der Vergleich der Werte mit dem Objekt v erfolgt mit der equals() -Methode. boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Map befinden. V remove(Object key) Entfernt den Eintrag mit dem Schl\u00fcssel key aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn key in der Map enthalten ist, sonst null ). int size() Gibt die Anzahl der Elemente in der Map zur\u00fcck. Set keySet() Gibt eine Set mit allen Schl\u00fcsseln der Map zur\u00fcck. Collection values() Gibt eine Collection mit allen Werten der Map zur\u00fcck. Set > entrySet() Gibt eine Set mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als Map.Entry der Map zur\u00fcck.","title":"Maps"},{"location":"maps/#maps","text":"Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel ( keys ) enth\u00e4lt und die rechte Spalte die Werte ( values ). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine Set . Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map . F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial .","title":"Maps"},{"location":"maps/#statt-add-und-addall-hier-put-und-putall","text":"Da nicht das Collections -Interface f\u00fcr Maps implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer Map leider auch nicht \u00fcber add() bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber addAll() , sondern \u00fcber put(K key, V value) und putAll(Map m) . K ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und V ein Platzhalter f\u00fcr den Typ der Werte.","title":"Statt add() und addAll() hier put() und putAll()"},{"location":"maps/#typ-einer-map-und-typ-eines-schlussel-werte-paares","text":"Eine Map wird also mit zwei Typen typisiert: Map<K, V> wobei K den Typ der Schl\u00fcssel und V den Typ der Werte definiert. Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. Entry ist eine innere Klasse in der Klasse Map (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer Map ist Map<K,V> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser Map ist Map.Entry<K,V> .","title":"Typ einer Map und Typ eines Schl\u00fcssel-Werte-Paares"},{"location":"maps/#statt-iterator-hier-entryset","text":"Die Objektmethode iterator() gibt es f\u00fcr Map leider auch nicht. Stattdessen wird hier die Methode entrySet() verwendet. Da es sich bei einer Map um eine Set von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ Map.Entry<K,V> ) handelt, liefert entrySet() eine Set<Map.Entry<K,V>> zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine Set . Diese ist typisiert und zwar mit dem Typ Map.Entry , welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. Map.Entry ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel K und dem Typ der Werte V . F\u00fcr K und V werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter.","title":"Statt iterator() hier entrySet()"},{"location":"maps/#klassenbaum-fur-map","text":"Der Klassenbaum f\u00fcr Map hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr Collection . Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder. Auch hier ist es wieder so, dass wir Map als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen EnumMap , HashMap und TreeMap verwenden. Die am h\u00e4ufigsten verwendete Klasse ist HashMap , da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird TreeMap verwendet.","title":"Klassenbaum f\u00fcr Map"},{"location":"maps/#erstes-beispiel","text":"Wir betrachten ein erstes Beispiel. Wir erstellen eine HashMap und f\u00fcgen vier Eintr\u00e4ge hinzu: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap ; import java.util.Map ; public class Maps { public static void main ( String [] args ) { Map < String , Double > m = new HashMap <> (); m . put ( \"s0512345\" , 1.7 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0587654\" , 2.3 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0512345\" , 2.7 ); // Schluessel existiert bereits --> Wert geaendert m . put ( \"s0555555\" , 3.0 ); // neues Schluessel-Werte-Paar hinzugefuegt } } In Zeile 8 wird unsere Map erzeugt. Die Referenzvariable auf die Map hei\u00dft m . Die Schl\u00fcssel sind vom Typ String und die Werte sind vom Typ Double . Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse HashMap erzeugt. In Zeile 9 f\u00fcgen wir mithilfe der put() -Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0512345\" , der Wert ( value ) ist 1.7 . Beachten Sie, dass hier ein Auto-Boxing des double -Wertes 1.7 in ein Double stattfindet. In Zeile 10 f\u00fcgen wir mithilfe der put() -Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0587654\" , der Wert ( value ) ist 2.3 (erneut Auto-Boxing ). In Zeile 11 wird erneut die put() -Methode aufgerufen. Der Schl\u00fcssel \"s0512345\" existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert 1.7 wird nun 2.7 . Die Map enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. In Zeile 12 f\u00fcgen wir mithilfe der put() -Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0555555\" , der Wert ( value ) ist 3.0 (erneut Auto-Boxing ). Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung): Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten: Die Anwendung dieser Methoden auf unsere Map m zeigen die folgenden Anweisungen: 1 2 3 Set < String > keys = m . keySet (); // Menge aller Schluessel Collection < Double > values = m . values (); // Collection aller Werte Set < Map . Entry < String , Double >> entries = m . entrySet (); // Menge aller Schluessel-Werte-Paare die Objektmethode keySet() liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist Set<K> , die Objektmethode values() liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist Collection<V> , die Objektmethode entrySet() liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist Set<Map.Entry<K,V>>","title":"Erstes Beispiel"},{"location":"maps/#durch-eine-map-laufen","text":"Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode entrySet() verwenden. F\u00fcr den R\u00fcckgabetyp Map.Entry<K,V> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung: getKey() liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist K , getValue() liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist V . Wir betrachten f\u00fcr unsere Map m ein Beispiel: 1 2 3 4 for ( Map . Entry < String , Double > eintrag : m . entrySet ()) { System . out . println ( eintrag . getKey () + \" : \" + eintrag . getValue ()); } - In Zeile 1 wird die Methode m.entrySet() aufgerufen, diese gibt eine Set<Map.Entry<String, Double>> zur\u00fcck. Jeder einzelne Eintrag in dieser Set ist also vom Typ Map.Entry<String,Double> . Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable eintrag . Wir nutzen hier also erneut die for-each -Schleife, um durch eine Set zu laufen. - In Zeile 3 verwenden wir die Objektmethoden getKey() und getValue() , die uns von Map.Entry zur Verf\u00fcgung gestellt werden. getKey() gibt uns hier einen String zur\u00fcck (den Schl\u00fcssel) und getValue() gibt hier ein Double zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von Double nach String (impliziter Aufruf von toString() f\u00fcr Double ). Es erfolgt folgende Ausgabe: s0512345 : 2 .7 s0555555 : 3 .0 s0587654 : 2 .3 Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. Wir probieren auch noch die Objektmethoden keySet() und value() aus, die f\u00fcr eine Map zur Verf\u00fcgung stehen: for ( String schluessel : m . keySet ()) { System . out . println ( \"key : \" + schluessel ); } erzeugt: key : s0512345 key : s0555555 key : s0587654 und for ( Double wert : m . values ()) { System . out . println ( \"value : \" + wert . toString ()); // toString() wuerde auch implizit aufgerufen } erzeugt: value : 2 .7 value : 3 .0 value : 2 .3 \u00dcbung Was wird ausgegeben? Map < String , String > accounts = new HashMap <> (); accounts . put ( \"anton\" , \"anton@email.de\" ); accounts . put ( \"berta\" , \"berta@email.de\" ); accounts . put ( \"caesar\" , \"caesar@email.de\" ); accounts . put ( \"anton\" , \"antonius@email.de\" ); // Iteration ueber alle Eintraege (Map.Entry) der Map for ( Map . Entry < String , String > entry : accounts . entrySet ()) { System . out . println ( \"Account : \" + entry . getKey () + \" E-Mail : \" + entry . getValue ()); }","title":"Durch eine Map laufen"},{"location":"maps/#zusammenfassung-maps","text":"Maps speichern Referenztypen als Schl\u00fcssel und Werte Maps werden typisiert mit K (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und V (Platzhalter f\u00fcr den Referenztyp des Wertes) Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt) der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine Map . Weitere Methoden finden Sie hier . Objektmethode Beschreibung V get(K key) Gibt den Wert zum Schl\u00fcssel key zur\u00fcck. Ist der Schl\u00fcssel key nicht in der Map enthalten, wird null zur\u00fcckgegeben. V put(K key, V value) F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel key und dem Wert value in die Map ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel key bereits existiert, wird der value \u00fcberschrieben . void putAll(Map m) F\u00fcgt alle Element der Map m in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben . void clear() Entfernt alle Elemente aus der Map. boolean containsKey(Object k) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel k in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt k erfolgt mit der equals() -Methode. boolean containsValue(Object v) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Wert v in der Map gibt. Der Vergleich der Werte mit dem Objekt v erfolgt mit der equals() -Methode. boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Map befinden. V remove(Object key) Entfernt den Eintrag mit dem Schl\u00fcssel key aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn key in der Map enthalten ist, sonst null ). int size() Gibt die Anzahl der Elemente in der Map zur\u00fcck. Set keySet() Gibt eine Set mit allen Schl\u00fcsseln der Map zur\u00fcck. Collection values() Gibt eine Collection mit allen Werten der Map zur\u00fcck. Set > entrySet() Gibt eine Set mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als Map.Entry der Map zur\u00fcck.","title":"Zusammenfassung Maps"},{"location":"mausereignisse/","text":"Mausereignisse \u00b6 In der letzten Lektion haben wir uns angeschaut, wie wir eigene geometrische Objekte in einer GUI erzeugen k\u00f6nnen, d.h. wie haben \"Zeichnen\" in einer GUI gelernt. Um Zeichnen zu k\u00f6nnen, haben wir eine innere Klasse erstellt, die von JPanel geerbt hat, darin die Methode paintComponent() \u00fcberschrieben und in dieser Methode Objektmethoden der Klasse Graphics2D aufgerufen, welche das Zeichnen von geometrischen Objekten erm\u00f6glichen. Nun wollen wir uns anschauen, wie wir Ereignisse der Maus behandeln. Bei den Mausereignissen unterscheiden wir zwei Arten von Ereignissen: Ereignisse der Maus, die einmalig von der Maus ausgel\u00f6st werden. Dazu geh\u00f6ren die Ereignisse, wenn die linke Maustaste gedr\u00fcckt wird, wenn die gedr\u00fcckte Taste losgelassen wird, wenn sich die Maus auf eine Komponente bewegt, die sich an den Mauslistener angemeldet hat oder wenn der Mauszeiger diese Komponente wieder verl\u00e4sst. Ereignisse der Maus, die durch Bewegung der Maus permanent ausgel\u00f6st werden. Dazu geh\u00f6rt die Mausbewegung selbst oder auch die Bewegung der Maus bei gedr\u00fcckter Taste. Die erste Art von Mausereignissen k\u00f6nnen wir behandeln, indem wir den MouseListener implementieren und eine Komponente (z.B. unsere Canvas ) an den MouseListener anmelden. Die zweite Art von Maus(-Bewegungs-)ereignissen k\u00f6nnen wir behandeln, indem wir den MouseMotionListener implementieren und eine Komponente (z.B. unsere Canvas ) an den MouseMotionListener anmelden. Wir starten wieder mit einem einfachen Beispiel, welches auf unserem Gr\u00fcndger\u00fcst f\u00fcr das Zeichnen basiert: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame { public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } } Der MouseListener \u00b6 In dieser Klasse implementieren wir zun\u00e4chst den MouseListener , d.h. wir f\u00fcgen in den Klassenkopf implements MouseListener ein und lassen durch Eclipse die zu implementierenden Methoden einf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } } Wie wir sehen, sind es nun nicht mehr nur eine Methode, wie beim ActionListener , sondern gleich f\u00fcnf Methoden, die wir implementieren k\u00f6nnen. Unsere zun\u00e4chst einfachste Implementierung (aber zumindest am Anfang stets empfohlen!) ist die einfache Ausgabe auf die Konsole. Noch passiert aber nichts, denn wir d\u00fcrfen nicht vergessen, uns an den MouseListener anzumelden ! Canvas meldet sich an den MouseListener an \u00b6 Wir k\u00f6nnten nun das gesamte Fenster an den MouseListener anmelden. Dazu w\u00fcrden wir in den Konstruktor von Mausereignisse ein this.addMouseListener(this); einf\u00fcgen. Damit w\u00fcrde this (also das Objekt von Mausereignisse , welches ja selbst ein JFrame ist) an den MouseListener angemeldet. Die Methode addMouseListener() erwartet ein Objekt der Implementierung von MouseListener . Das w\u00e4re ebenfalls this , da der MouseListener in der Klasse Mausereignisse implementiert ist. Weil jedoch sp\u00e4ter der Umgang mit den Mausereignissen etwas leichter ist, wollen wir das Canvas -Objekt an den MouseListener anmelden. Es soll also nur die Zeichenfl\u00e4che (geerbt von JPanel ) an den MouseListener angemeldet werden und nicht das gesamte Fenster. Dazu speichern wir das Canvas -Objekt in eine Variable - und wir vereinfachen die Sache auch gleich ein bisschen, indem es keine lokale Variable im Konstruktor von Mausereignisse wird, sondern eine Objektvariable der Klasse. Diese \u00c4nderungen und das Anmelden von canvas an den MouseListener sehen so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { Canvas canvas ; public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } } Wir erstellen uns also eine Objektvariable canvas (Zeile 10 ), welche eine Referenz auf das Canvas -Objekt ist, das wir im Konstruktor erzeugen (Zeile 18 ). Diese Referenz \u00fcbergeben wir dann auch der ContentPane (Zeile 20 ). Mithilfe der Methode addMouseListener() melden wir das Canvas -Objekt an den MouseListener an (Zeile 19 ). Da der MouseListener in der Klasse Mausereignisse implementiert ist, wird als Implementierung des MouseListeners this \u00fcbergeben (Zeile 19 ). Die Methoden des MouseListener \u00b6 Nun ist der MouseListener implementiert und das Canvas -Objekt ist an den MouseListener angemeldet. Wir k\u00f6nnen nun die einzelnen Methoden des MouseListener ausprobieren: mousePressed() wird aufgerufen, wenn die (linke) Maustaste heruntergedr\u00fcckt wird. Dr\u00fccken Sie die Maustaste und halten Sie sie gedr\u00fcckt. In der Konsole erscheint mousePressed . mouseReleased() wird aufgerufen, wenn die (linke) Maustaste nach dem Dr\u00fccken wieder losgelassen wird. Lassen Sie die Maustaste, nachdem auf der Konsole mousePressed erschienen ist, wieder los. In der Konsole erscheint mouseReleased . mouseClicked() wird aufgerufen, wenn erst mousePressed() und dann mouseReleased() aufgerufen wurde. mouseClicked() beschreibt also die Kombination aus Maustaste gedr\u00fcckt und Maustaste losgelassen - einen Maus-Klick also. mouseEntered() wird aufgerufen, wenn Sie den Mauszeiger auf die Komponente bewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus in die Zeichenfl\u00e4che canvas bewegen, dann wird die Methode mouseEntered() einmalig ausgef\u00fchrt. mouseExited() wird aufgerufen, wenn Sie den Mauszeiger von der Komponente wieder wegbewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus von der Zeichenfl\u00e4che in die Titelleiste des Fensters oder ganz aus dem Fenster (der ContentPane ) bewegen, dann wird die Methode mouseExited() einmalig ausgef\u00fchrt. \u00dcbung Probieren Sie intensiv aus, wann welche Methoden aufgerufen werden! 1. Schaffen Sie es, dass zwar mousePressed und danach mouseReleased auf der Konsole erscheint, nicht aber mouseClicked ? Wann ist das der Fall? 2. Erzeugen Sie folgende Ausgabereihenfolge auf der Konsole: mousePressed , mouseExited , mouseReleased , mouseEntered ! Die Methoden des MouseMotionListener \u00b6 Wir implementieren jetzt auch noch den MouseMotionListener . Wir d\u00fcrfen erneut nicht die beiden Schritte vergessen: Implementieren des MouseMotionListener (also implements MouseMotionListener ) und Anmelden an den MouseMotionListener (also canvas.addMouseMotionListener(this); ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } /* * die naechtsten fuenf Methoden sind Methoden * von MouseListener */ @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } /* * die naechtsten beiden Methoden sind Methoden * von MouseMotionListener */ @Override public void mouseDragged ( MouseEvent e ) { System . out . println ( \"mouseDragged\" ); } @Override public void mouseMoved ( MouseEvent e ) { System . out . println ( \"mouseMoved\" ); } } Beachten Sie, dass die Methoden mouseDragged() bzw. mouseMoved() permanent, d.h. bei jeder (kleinsten) Bewegung der Maus aufgerufen werden. mouseMoved() wird bei jeder (kleinsten) Mausbewegung aufgerufen, wobei die Maustaste nicht gedr\u00fcckt ist. mouseDragged() wird bei jeder (kleinsten) Mausbewegung aufgerufen, wobei die Maustaste gedr\u00fcckt gehalten wird. Wenn Sie anhand der Konsolenausgaben gepr\u00fcft haben, dass die Methoden \"funktionieren\", dann k\u00f6nnen Sie dort die Konsolenausgaben auch wieder auskommentieren, da Ihre Konsole ansonsten zu \"vollgeschreiben\" wird. Objektmethoden der Klasse MouseEvent \u00b6 All diesen Methoden, sowohl vom MouseListener als auch vom MouseMotionListener wird ein MouseEvent als Parameter \u00fcbergeben. Dieses Objekt besitzt einige n\u00fctzliche Objektmethoden. Die wichtigsten dabei sind sicherlich die Ausk\u00fcnfte dar\u00fcber, wo das Mausereignis ausgel\u00f6st wurde. Wir betrachten einige Objektmethoden des MouseEvent -Objekts am Beispiel der mouseClicked(MouseEvent e) -Methode (kommentieren Sie die Konsolenausgabe der beiden Methoden vom MouseMotionListener aus, damit Sie sich auf die Ausgabe von mouseClicked() konzentrieren k\u00f6nnen). die Methode getX() gibt den x -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat. Die Koordinate bezieht sich auf die Komponente, die an den MouseListener (bzw. MouseMotionListener ) angemeldet ist. Das ist auch der Grund, warum wir nicht das gesamte Fenster an den MouseListener (und MouseMotionListener ) angemeldet haben. Der Punkt [x=0, y=0] befindet sich bei dem Canvas -Objekt in der linken oberen Ecke der ContentPane . Der Punkt mit den Koordinaten [x=0, y=0] beim Fenster ist der linke obere Punkt des Fensters, d.h. der linke obere Punkt der Titelleiste. die Methode getY() gibt den y -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat (Koordinate der Komponente). die Methode getPoint() gibt ein Point -Objekt (von java.awt ) zur\u00fcck. Ein Point -Objekt besitzt die sichtbaren Objektvariablen x und y f\u00fcr die Koordinaten. Wir probieren beide M\u00f6glichkeiten aus, die Koordinaten zu erfragen: 49 50 51 52 53 54 55 56 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseClicked bei [ x = 388 ,y = 215 ] mouseClicked bei [ x = 388 ,y = 215 ] Beachten Sie, dass Sie in allen Methoden, in denen das MouseEvent \u00fcbergeben wird, die Koordinaten des Ereignisses auslesen k\u00f6nnen. F\u00fcr mouseMoved() sieht die Implementierung gleich aus. Die Ausgabe ist nur deutlich h\u00e4ufiger, da jede Mausbewegung (ohne gedr\u00fcckte Maustaste) zum Aufruf der Methode f\u00fchrt. 90 91 92 93 94 @Override public void mouseMoved ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseMoved bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseMoved bei [ x = 267 ,y = 242 ] mouseMoved bei [ x = 282 ,y = 261 ] mouseMoved bei [ x = 282 ,y = 261 ] mouseMoved bei [ x = 298 ,y = 280 ] mouseMoved bei [ x = 298 ,y = 280 ] mouseMoved bei [ x = 309 ,y = 292 ] mouseMoved bei [ x = 309 ,y = 292 ] Manchmal sind die Mausbewegungen, die ein Ausl\u00f6sen des Ereignisses zur Folge haben, sogar so klein, dass sich die Koordinaten gar nicht \u00e4ndern. Weiterhin kann mithilfe des MouseEvent -Objektes \u00fcberpr\u00fcft werden, ob w\u00e4hrend des ausl\u00f6senden Mausereignisses eine besondere Taste auf der Tastatur gedr\u00fcckt wurde, z.B. die Alt -Taste (linke option -Taste beim Mac), die AltGraph -Taste (rechte option -Taste beim Mac), die Ctrl -Taste, oder die Meta -Taste ( Windows -Taste bzw. Apple -Taste): 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); } Probieren Sie die Maus-Klicks bei unterschiedlich gedr\u00fcckter Taste auf der Tastatur aus! Mithilfe der Objektmethode getClickCount() l\u00e4sst sich die Anzahl die Klicks abfragen: 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); if ( e . getClickCount () == 2 ) System . out . println ( \"Doppelklick\" ); } Nochmal, weil es wichtig ist: alle diese Objektmethoden stehen allen Methoden zur Verf\u00fcgung, denen ein MouseEvent \u00fcbergeben wird. Wir k\u00f6nnen sie also in allen Methoden aus MouseListener und MouseMotionListener anwenden. Zeichnen mit der Maus \u00b6 Wir k\u00f6nnen nun zwei Sachen: Zeichnen und Mausereignisse behandeln. Diese beiden F\u00e4higkeiten wollen wir nun miteinander verbinden. Dazu zun\u00e4chst einige theoretische Vor\u00fcberlegungen. Model-View-Controller \u00b6 Unter Model-View-Controller versteht man ein Entwurfsmuster (ein Design Pattern ), welches ein wesentliches Konzept bei Anwendungen darstellt, die eine GUI besitzen. Wir werden es in diesem Semester nicht mehr schaffen, ausf\u00fchrlich auf dieses Konzept einzugehen, aber wir betrachten ein paar wesentliche Grunds\u00e4tze daraus, die auch f\u00fcr unsere Anwendungen wichtig sind. Die Grundidee bei Model-View-Controlle (MVC) ist die Unterscheidung von drei Aufgaben: Das Model k\u00fcmmert sich um die Datenverwaltung. Es gibt eine oder mehrere Datenstrukturen, in denen Daten gespeichert werden. Das Model k\u00fcmmert sich darum, diese Datenstrukturen zu erstellen und Daten in diese Datenstrukturen einzuf\u00fcgen, zu \u00e4ndern oder zu l\u00f6schen. Der Controller verwaltet die Nutzerinteraktionen. Auf der Basis bestimmter Aktionen, die durch die Nutzerin verursacht werden (Mausklicks, Tatstureingaben, ...) st\u00f6\u00dft der Controller beim Model eine \u00c4nderung der der Datenverwaltung an (Daten hinzuf\u00fcgen, \u00e4ndern oder l\u00f6schen) und er st\u00f6\u00dft bei der View die Darstellung der Daten an. Der Controller hat also Zugriff auf das Model und auf die View . Die View k\u00fcmmert sich um die Darstellung der Daten in der GUI. Die View hat also Zugriff auf das Model , denn die View verwendet die vom Model verwalteten Daten, um diese darzustellen. Diese drei Aufgaben sollten m\u00f6glichst losgel\u00f6st voneinander gel\u00f6st werden, d.h. es sollte m\u00f6glichst keine \u00dcberschneidungen zwischen diesen Komponenten geben. F\u00fcr uns ist es in diesem Zusammenhang wichtig, dass die paintComponent() -Methode unsere View ist. In der paintComponent() -Methode k\u00f6nnen wir zeichnen, d.h. Daten visualisieren. Wir sollten keine weitere Methode (au\u00dfer die paintComponent() -Methode) haben, die etwas zeichnet und wir sollten in der paintComponent() -Methode keine Verwaltung von Daten durchf\u00fchren. Unser Controller ist die Implementierung der Listener , je nachdem, welche Nutzerinteraktionen wir unterst\u00fctzen und behandeln wollen, also z.B. ActionListener , MouseListener und/oder MouseMotionListener . Unsere Herausforderung ist nun, ein Model zu erstellen. Dazu m\u00fcssen wir stets \u00fcberlegen, welche Daten wir ben\u00f6tigen, damit die View (die paintComponent() -Methode) die Objekte zeichnen kann, die gew\u00fcnscht sind. Wir wollen diese theoretischen \u00dcberlegungen an einigen Beispielen erl\u00e4utern. Beispiel 1: Kreise zeichnen \u00b6 Unser erstes Beispiel ist einfach. Wir wollen mit der Maus in unsere Canvas klicken und dort, wo wir hingeklickt haben, soll ein schwarzer, ausgef\u00fcllter Kreis erscheinen. Alle Kreise haben den gleichen (einen festen) Durchmesser. Dazu folgende \u00dcberlegungen: View : in der paintComponent() -Methode k\u00f6nnen wir z.B. mithilfe der fillOval() -Methode Kreise zeichnen. Wir m\u00fcssen nur die Koordinaten x und y kennen, an denen der jeweilige Kreis gezeichnet werden soll. Controller : um zu wissen, wo wir mit der Maus in die Canvas geklickt haben, m\u00fcssen wir den MouseListener implementieren. Model : wir m\u00fcssen Koordinaten speichern, also entweder int -Werte x und y oder gleich Objekte vom Typ Point . Wir entscheiden uns f\u00fcr Letzteres. Da wir nicht wissen, wie viele Point -Objekte gespeichert werden sollen, kommt ein Array nicht in Frage. Wir ben\u00f6tigen Eine Collection . Hier ist es egal, ob List oder Set . Wir entscheiden uns f\u00fcr List . Wir starten erneut mit unserem Grundger\u00fcst f\u00fcr das Zeichnen, haben dort aber bereits den MouseListener implementiert: KreiseZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class KreiseZeichnen extends JFrame implements MouseListener { Canvas canvas ; public KreiseZeichnen () { super (); this . setTitle ( \"Kreise zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; // hier koennen wir zeichnen } } public static void main ( String [] args ) { new KreiseZeichnen (); } // der Controller @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Im Sinne des Controllers sind wir nur daran interessiert, die mouseClicked() -Methode des MouseListener zu implementieren, aber nat\u00fcrlich m\u00fcssen die anderen Methoden des MouseListener auch \"implementiert\" werden, ansonsten bliben sie abstrakt und somit die ganze Klasse. Wir lassen sie aber leer. Wir f\u00fcgen nun das Model ein, n\u00e4mlich eine Liste aus lauter Punkten, d.h. ein List<Point , die wir points nennen. Wir erzeugen die Liste im Konstruktor der Klasse, da wir sowohl in mouseClicked() , als auch in paintComponent() auf diese Liste zugreifen wollen, deklarieren wir sie als globale Variable. Einf\u00fcgen des Models 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class KreiseZeichnen extends JFrame implements MouseListener { Canvas canvas ; List < Point > points ; public KreiseZeichnen () { super (); this . setTitle ( \"Kreise zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . points = new ArrayList <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { final static int DURCHMESSER = 20 ; // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; for ( Point p : KreiseZeichnen . this . points ) { g2 . fillOval ( p . x , p . y , DURCHMESSER , DURCHMESSER ); } } } public static void main ( String [] args ) { new KreiseZeichnen (); } // der Controller @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); this . points . add ( p ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Wir betrachten die \u00c4nderungen im Detail: Die Klasse Point existiert in java.awt -Paket und muss von dort importiert werden (Zeile 3 ). Die Klasse List gibt es zwei Mal! Wir wollen hier die Collection verwenden und nutzen deshalb die Klasse List aus dem java.util -Paket. Hier m\u00fcssen Sie aufpassen, dass Sie die richtige List -Klasse importieren (Zeile 7 ). Die Klasse ArrayList ist aber eindeutig und wird aus dem java.util -Paket importiert (Zeile 6 ). In Zeile 14 wird die globale Variable points vom Typ List<Point> deklariert. Sie muss global sein, damit wir sowohl in der mouseClicked() -, als auch in der paintComponent() -Methode darauf Zugriff haben. In Zeile 22 erzeugen wir ein Objekt der Klasse ArrayList f\u00fcr die points -Referenz. In Zeile 34 erstellen wir eine Konstante DURCHMESSER , mit der wir den Durchmesser der Kreise festlegen, die wir durch die Maus-Klicks erzeugen wollen. Hier ist es Geschmackssache, ob sie diese Konstante als static deklarieren oder nicht. Die Unterscheidung liegt darin, ob Sie allen Objekten aus Canvas diesen Wert mitgeben sollen oder ob jedes Canvas -Objekt \"seinen eigenen\" DURCHMESSER haben soll. Da wir eh nur ein Objekt von Canvas erzeugen, macht es hier keinen Unterschied. In den Zeilen 43-46 wird die Datenstruktur List ausgelesen und jeder einzelne Point darin verwendet, um einen Kreis an diese Stelle zu zeichnen. Hier greift die View auf das Model zu (aber nur lesend!). Hier ist also unsere einzige Verbindung zwischen Model und View . Es sei an dieser Stelle angemerkt, dass die View das Model auch dazu verwenden k\u00f6nnte, um z.B. Quadrate mit der Gr\u00f6\u00dfe 100x100 zu zeichnen oder rote Kreise oder ... Insofern ist das Model unabh\u00e4ngig von der View und genau das wollen wir auch erreichen. Wir sehen hier auch den Zugriff auf eine Objekteigenschaft von der inneren in die \u00e4u\u00dfere Klasse. Um auf die Objekteigenschaft points der \u00e4u\u00dferen Klasse zuzugreifen, schreiben wir KreiseZeichnen.this.points (siehe auch ) In Zeile 60 wird die Liste (also das Model ) durch die Interaktionen der Nutzerin (also durch den Controller ) bef\u00fcllt. Immer dort, wohin mit der Maus geklickt wird, wird dieser Point in der Datenstruktur Liste (also im Model ) gespeichert. Hier sehen wir die einzige Verbindung zwischen Controller und Model . Der Controller greift auf das Model zu und st\u00f6\u00dft das Speichern eines Datums an. Zeile 62 ist sehr wichtig und wird h\u00e4ufig vergessen. Hier \"triggert\" der Controller die View . Wenn wir uns an die Einf\u00fchrung des Zeichnens erinnern, dann wird ein Fenster mit allen seinen Komponenten \"gezeichnet\". Wenn wir die Canvas mit neuen Kreisen \"bef\u00fcllen\", dann bewirkt das nicht automatisch ein Neuzeichnen der Canvas . Ein Neuzeichnen w\u00fcrde nur erfolgen, wenn wir bspw. die Fenstergr\u00f6\u00dfe \u00e4ndern oder das Fenster in die Taskleiste bewegen und wieder \u00f6ffnen. Um ein Neuzeichnen aus dem Programm heraus anzusto\u00dfen, ben\u00f6tigen wir die Methode repaint() . Wir h\u00e4tten auch this.repaint(); angeben k\u00f6nnen, dann w\u00e4re das gesamte Fenster neu gezeichnet worden (inkl. der Canvas ). Mit this.canvas.repaint(); wird \"nur\" die Canvas neu gezeichnet. \u00dcbung \u00c4ndern Sie das Programm so, dass die Punkte als Mittelpunkte der Kreise verwendet werden! \u00c4ndern Sie das Programm so, dass rote Quadrate der Gr\u00f6\u00dfe 30x30 anstelle der schwarzen Kreise gezeichnet werden! \u00c4ndern Sie das Programm so, dass die Punkte nur durch einen Doppelklick der Maus erfasst werden (einfacher Mausklick gen\u00fcgt nicht)! Beispiel 2: Linien zeichnen \u00b6 In unserem zweiten Beispiel wollen wir Linien zeichnen. Dabei soll das Vorgehen so sein: Wir klicken mit der Maus und legen dabei den Anfangspunkt der Linie fest. Wir halten die Maustaste gedr\u00fcckt und bewegen bei gedr\u00fcckter Maustaste die Maus. Dabei wird die Linie bereits gezeichnet. Wir lassen die Maustaste los. dadurch steht der Endpunkt der Linie fest. F\u00fcr Punkt 1. implementieren wir die Methode mousePressed() und wir ben\u00f6tigen somit den MouseListener . F\u00fcr Punkt 2. implementieren wir die Methode mouseDragged() und wir ben\u00f6tigen somit den MouseMotionListener . F\u00fcr Punkt 3. implementieren wir die Methode mouseReleased() aus dem MouseListener . Wir starten erneut mit unserem Grundger\u00fcst f\u00fcr das Zeichnen, haben dort aber bereits den MouseListener und den MouseMotionListener implementiert und die Methoden, die uns nicht interessieren, zusammengek\u00fcrzt: LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Wir \u00fcberlegen uns nun das Model . Dies ist etwas komplexer, als das Model f\u00fcr das Zeichnen der Kreise. Es gibt gespeicherte Linien. Diese Linien sind bereits fertig erstellt. Diese Linien sollten in einer Collection gespeichert werden. Es bietet sich wieder eine Liste an (Menge ginge auch). Das Typisieren dieser Liste liegt jedoch nicht auf der Hand, da es im Gegensatz zu Point keine Klasse f\u00fcr eine Linie gibt, die wir benutzen k\u00f6nnten. M\u00fcssen wir uns also selber schreiben. eine aktuelle Linie. Das ist die Linie, die gerade gezeichnet wird. Diese Linie ist noch nicht gespeichert, d.h. die Maustaste wurde noch nicht losgelassen. Es kann auch sein, dass aktuell keine Linie gezeichnet wird, dann ist der Wert daf\u00fcr null . Auch diese aktuelle Linie sollte vom Typ Linie sein, den wir uns zun\u00e4chst erstellen. Linie.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.awt.Point ; public class Linie { private Point start ; private Point ende ; public Linie ( Point start , Point ende ) { this . start = start ; this . ende = ende ; } public void setEnde ( Point newEnde ) { this . ende = newEnde ; } public int getXstart () { return this . start . x ; } public int getYstart () { return this . start . y ; } public int getXende () { return this . ende . x ; } public int getYende () { return this . ende . y ; } } Mit dem Konstruktor k\u00f6nnen wir uns ein Objekt von Linie erstellen (im Controller bei mousePressed() ) und haben dann mithilfe von setEnde() die M\u00f6glichkeit, den Endpunkt der Linie noch zu \u00e4ndern (im Controller bei mouseDragged() . Die Getter ben\u00f6tigen wir in der View , um die Werte der Start- und Endpunkte der Linie auszulesen. Wir beginnen zun\u00e4chst damit, eine Linie zu erzeugen: LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Linie aktLinie ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( LinienZeichnen . this . aktLinie != null ) { int x1 = LinienZeichnen . this . aktLinie . getXstart (); int y1 = LinienZeichnen . this . aktLinie . getYstart (); int x2 = LinienZeichnen . this . aktLinie . getXende (); int y2 = LinienZeichnen . this . aktLinie . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie = new Linie ( p , p ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie . setEnde ( p ); this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Die Variable aktLinie ist global , weil wir sowohl in den Methoden mousepressed() und mouseDragged als auch in paintComponent() darauf zugreifen wollen (Zeile 13 ). In der paintComponent() -Methode (unserer View ) lesen wir diese Linie aus, um sie grafisch als Linie darzustellen. Der Zugriff auf die Eigenschaften des Objektes aktLinie erfolgt aber nur, wenn aktLinie auch tats\u00e4chlich auf ein Objekt zeigt. Wir pr\u00fcfen deshalb zun\u00e4chst, ob aktLinie nicht null ist (Zeile 40 ). Nachdem wir die x - und y -Werte des start - und des ende -Punktes der aktLinie ausgelesen haben (Zeilen 42-45 ), stellen wir eine Linie grafisch mithilfe der drawLine() -Methode dar. Das Objekt einer Linie wird in der mousePressed() -Methode erstellt. Der start - und der ende -Punkt dieser Linie sind zun\u00e4chst gleich (die Linie ist also am Anfang nur ein Punkt) - Zeile 61 . Wenn wir bei gedr\u00fcckter Maustaste die Maus bewegen, wird permanent die mouseDragged() -Methode aufgerufen. Dort setzen wir die aktuelle Position der Maus als neuen ende -Punkt von aktLinie (Zeile 67 ). Zeile 69 ist wieder sehr wichtig (und wird h\u00e4ufig vergessen). Hier \"triggert\" der Controller die View . Wenn wir die Canvas mit einer neuen Linie \"bef\u00fcllen\", dann bewirkt das nicht automatisch ein Neuzeichnen der Canvas . Das Neuzeichnen erfolgt erst durch den Aufruf this.canvas.repaint(); . Wir k\u00f6nnen nun viele Linien zeichnen, aber diese werden noch nicht gespeichert. Zum Speichern der Linien ben\u00f6tigen wir wieder eine Collection. Das Speichern der aktuellen Linie in diese Collection erfolgt in dem Moment, indem wir die Maustaste wieder loslassen, also in mouseReleased() . Die Collection muss wieder global verf\u00fcgbar sein. LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Linie aktLinie ; List < Linie > linien ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . linien = new ArrayList <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( LinienZeichnen . this . aktLinie != null ) { int x1 = LinienZeichnen . this . aktLinie . getXstart (); int y1 = LinienZeichnen . this . aktLinie . getYstart (); int x2 = LinienZeichnen . this . aktLinie . getXende (); int y2 = LinienZeichnen . this . aktLinie . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } for ( Linie l : LinienZeichnen . this . linien ) { int x1 = l . getXstart (); int y1 = l . getYstart (); int x2 = l . getXende (); int y2 = l . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie = new Linie ( p , p ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie . setEnde ( p ); this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); this . linien . add ( aktLinie ); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } \u00dcbung \u00c4ndern Sie das Programm so, dass nicht Linien gezeichnet werden, sondern Kreise! \u00c4ndern Sie aber nur die View , d.h. die paintComponent() . Die gespeicherten Linien geben den Durchmesser der Kreise an.","title":"Mausereignisse"},{"location":"mausereignisse/#mausereignisse","text":"In der letzten Lektion haben wir uns angeschaut, wie wir eigene geometrische Objekte in einer GUI erzeugen k\u00f6nnen, d.h. wie haben \"Zeichnen\" in einer GUI gelernt. Um Zeichnen zu k\u00f6nnen, haben wir eine innere Klasse erstellt, die von JPanel geerbt hat, darin die Methode paintComponent() \u00fcberschrieben und in dieser Methode Objektmethoden der Klasse Graphics2D aufgerufen, welche das Zeichnen von geometrischen Objekten erm\u00f6glichen. Nun wollen wir uns anschauen, wie wir Ereignisse der Maus behandeln. Bei den Mausereignissen unterscheiden wir zwei Arten von Ereignissen: Ereignisse der Maus, die einmalig von der Maus ausgel\u00f6st werden. Dazu geh\u00f6ren die Ereignisse, wenn die linke Maustaste gedr\u00fcckt wird, wenn die gedr\u00fcckte Taste losgelassen wird, wenn sich die Maus auf eine Komponente bewegt, die sich an den Mauslistener angemeldet hat oder wenn der Mauszeiger diese Komponente wieder verl\u00e4sst. Ereignisse der Maus, die durch Bewegung der Maus permanent ausgel\u00f6st werden. Dazu geh\u00f6rt die Mausbewegung selbst oder auch die Bewegung der Maus bei gedr\u00fcckter Taste. Die erste Art von Mausereignissen k\u00f6nnen wir behandeln, indem wir den MouseListener implementieren und eine Komponente (z.B. unsere Canvas ) an den MouseListener anmelden. Die zweite Art von Maus(-Bewegungs-)ereignissen k\u00f6nnen wir behandeln, indem wir den MouseMotionListener implementieren und eine Komponente (z.B. unsere Canvas ) an den MouseMotionListener anmelden. Wir starten wieder mit einem einfachen Beispiel, welches auf unserem Gr\u00fcndger\u00fcst f\u00fcr das Zeichnen basiert: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.awt.Graphics ; import java.awt.Graphics2D ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame { public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } }","title":"Mausereignisse"},{"location":"mausereignisse/#der-mouselistener","text":"In dieser Klasse implementieren wir zun\u00e4chst den MouseListener , d.h. wir f\u00fcgen in den Klassenkopf implements MouseListener ein und lassen durch Eclipse die zu implementierenden Methoden einf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } } Wie wir sehen, sind es nun nicht mehr nur eine Methode, wie beim ActionListener , sondern gleich f\u00fcnf Methoden, die wir implementieren k\u00f6nnen. Unsere zun\u00e4chst einfachste Implementierung (aber zumindest am Anfang stets empfohlen!) ist die einfache Ausgabe auf die Konsole. Noch passiert aber nichts, denn wir d\u00fcrfen nicht vergessen, uns an den MouseListener anzumelden !","title":"Der MouseListener"},{"location":"mausereignisse/#canvas-meldet-sich-an-den-mouselistener-an","text":"Wir k\u00f6nnten nun das gesamte Fenster an den MouseListener anmelden. Dazu w\u00fcrden wir in den Konstruktor von Mausereignisse ein this.addMouseListener(this); einf\u00fcgen. Damit w\u00fcrde this (also das Objekt von Mausereignisse , welches ja selbst ein JFrame ist) an den MouseListener angemeldet. Die Methode addMouseListener() erwartet ein Objekt der Implementierung von MouseListener . Das w\u00e4re ebenfalls this , da der MouseListener in der Klasse Mausereignisse implementiert ist. Weil jedoch sp\u00e4ter der Umgang mit den Mausereignissen etwas leichter ist, wollen wir das Canvas -Objekt an den MouseListener anmelden. Es soll also nur die Zeichenfl\u00e4che (geerbt von JPanel ) an den MouseListener angemeldet werden und nicht das gesamte Fenster. Dazu speichern wir das Canvas -Objekt in eine Variable - und wir vereinfachen die Sache auch gleich ein bisschen, indem es keine lokale Variable im Konstruktor von Mausereignisse wird, sondern eine Objektvariable der Klasse. Diese \u00c4nderungen und das Anmelden von canvas an den MouseListener sehen so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { Canvas canvas ; public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } } Wir erstellen uns also eine Objektvariable canvas (Zeile 10 ), welche eine Referenz auf das Canvas -Objekt ist, das wir im Konstruktor erzeugen (Zeile 18 ). Diese Referenz \u00fcbergeben wir dann auch der ContentPane (Zeile 20 ). Mithilfe der Methode addMouseListener() melden wir das Canvas -Objekt an den MouseListener an (Zeile 19 ). Da der MouseListener in der Klasse Mausereignisse implementiert ist, wird als Implementierung des MouseListeners this \u00fcbergeben (Zeile 19 ).","title":"Canvas meldet sich an den MouseListener an"},{"location":"mausereignisse/#die-methoden-des-mouselistener","text":"Nun ist der MouseListener implementiert und das Canvas -Objekt ist an den MouseListener angemeldet. Wir k\u00f6nnen nun die einzelnen Methoden des MouseListener ausprobieren: mousePressed() wird aufgerufen, wenn die (linke) Maustaste heruntergedr\u00fcckt wird. Dr\u00fccken Sie die Maustaste und halten Sie sie gedr\u00fcckt. In der Konsole erscheint mousePressed . mouseReleased() wird aufgerufen, wenn die (linke) Maustaste nach dem Dr\u00fccken wieder losgelassen wird. Lassen Sie die Maustaste, nachdem auf der Konsole mousePressed erschienen ist, wieder los. In der Konsole erscheint mouseReleased . mouseClicked() wird aufgerufen, wenn erst mousePressed() und dann mouseReleased() aufgerufen wurde. mouseClicked() beschreibt also die Kombination aus Maustaste gedr\u00fcckt und Maustaste losgelassen - einen Maus-Klick also. mouseEntered() wird aufgerufen, wenn Sie den Mauszeiger auf die Komponente bewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus in die Zeichenfl\u00e4che canvas bewegen, dann wird die Methode mouseEntered() einmalig ausgef\u00fchrt. mouseExited() wird aufgerufen, wenn Sie den Mauszeiger von der Komponente wieder wegbewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus von der Zeichenfl\u00e4che in die Titelleiste des Fensters oder ganz aus dem Fenster (der ContentPane ) bewegen, dann wird die Methode mouseExited() einmalig ausgef\u00fchrt. \u00dcbung Probieren Sie intensiv aus, wann welche Methoden aufgerufen werden! 1. Schaffen Sie es, dass zwar mousePressed und danach mouseReleased auf der Konsole erscheint, nicht aber mouseClicked ? Wann ist das der Fall? 2. Erzeugen Sie folgende Ausgabereihenfolge auf der Konsole: mousePressed , mouseExited , mouseReleased , mouseEntered !","title":"Die Methoden des MouseListener"},{"location":"mausereignisse/#die-methoden-des-mousemotionlistener","text":"Wir implementieren jetzt auch noch den MouseMotionListener . Wir d\u00fcrfen erneut nicht die beiden Schritte vergessen: Implementieren des MouseMotionListener (also implements MouseMotionListener ) und Anmelden an den MouseMotionListener (also canvas.addMouseMotionListener(this); ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; public Mausereignisse () { super (); this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier koennen wir zeichnen } } public static void main ( String [] args ) { new Mausereignisse (); } /* * die naechtsten fuenf Methoden sind Methoden * von MouseListener */ @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouseClicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mousePressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouseReleased\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouseEntered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouseExited\" ); } /* * die naechtsten beiden Methoden sind Methoden * von MouseMotionListener */ @Override public void mouseDragged ( MouseEvent e ) { System . out . println ( \"mouseDragged\" ); } @Override public void mouseMoved ( MouseEvent e ) { System . out . println ( \"mouseMoved\" ); } } Beachten Sie, dass die Methoden mouseDragged() bzw. mouseMoved() permanent, d.h. bei jeder (kleinsten) Bewegung der Maus aufgerufen werden. mouseMoved() wird bei jeder (kleinsten) Mausbewegung aufgerufen, wobei die Maustaste nicht gedr\u00fcckt ist. mouseDragged() wird bei jeder (kleinsten) Mausbewegung aufgerufen, wobei die Maustaste gedr\u00fcckt gehalten wird. Wenn Sie anhand der Konsolenausgaben gepr\u00fcft haben, dass die Methoden \"funktionieren\", dann k\u00f6nnen Sie dort die Konsolenausgaben auch wieder auskommentieren, da Ihre Konsole ansonsten zu \"vollgeschreiben\" wird.","title":"Die Methoden des MouseMotionListener"},{"location":"mausereignisse/#objektmethoden-der-klasse-mouseevent","text":"All diesen Methoden, sowohl vom MouseListener als auch vom MouseMotionListener wird ein MouseEvent als Parameter \u00fcbergeben. Dieses Objekt besitzt einige n\u00fctzliche Objektmethoden. Die wichtigsten dabei sind sicherlich die Ausk\u00fcnfte dar\u00fcber, wo das Mausereignis ausgel\u00f6st wurde. Wir betrachten einige Objektmethoden des MouseEvent -Objekts am Beispiel der mouseClicked(MouseEvent e) -Methode (kommentieren Sie die Konsolenausgabe der beiden Methoden vom MouseMotionListener aus, damit Sie sich auf die Ausgabe von mouseClicked() konzentrieren k\u00f6nnen). die Methode getX() gibt den x -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat. Die Koordinate bezieht sich auf die Komponente, die an den MouseListener (bzw. MouseMotionListener ) angemeldet ist. Das ist auch der Grund, warum wir nicht das gesamte Fenster an den MouseListener (und MouseMotionListener ) angemeldet haben. Der Punkt [x=0, y=0] befindet sich bei dem Canvas -Objekt in der linken oberen Ecke der ContentPane . Der Punkt mit den Koordinaten [x=0, y=0] beim Fenster ist der linke obere Punkt des Fensters, d.h. der linke obere Punkt der Titelleiste. die Methode getY() gibt den y -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat (Koordinate der Komponente). die Methode getPoint() gibt ein Point -Objekt (von java.awt ) zur\u00fcck. Ein Point -Objekt besitzt die sichtbaren Objektvariablen x und y f\u00fcr die Koordinaten. Wir probieren beide M\u00f6glichkeiten aus, die Koordinaten zu erfragen: 49 50 51 52 53 54 55 56 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseClicked bei [ x = 388 ,y = 215 ] mouseClicked bei [ x = 388 ,y = 215 ] Beachten Sie, dass Sie in allen Methoden, in denen das MouseEvent \u00fcbergeben wird, die Koordinaten des Ereignisses auslesen k\u00f6nnen. F\u00fcr mouseMoved() sieht die Implementierung gleich aus. Die Ausgabe ist nur deutlich h\u00e4ufiger, da jede Mausbewegung (ohne gedr\u00fcckte Maustaste) zum Aufruf der Methode f\u00fchrt. 90 91 92 93 94 @Override public void mouseMoved ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseMoved bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseMoved bei [ x = 267 ,y = 242 ] mouseMoved bei [ x = 282 ,y = 261 ] mouseMoved bei [ x = 282 ,y = 261 ] mouseMoved bei [ x = 298 ,y = 280 ] mouseMoved bei [ x = 298 ,y = 280 ] mouseMoved bei [ x = 309 ,y = 292 ] mouseMoved bei [ x = 309 ,y = 292 ] Manchmal sind die Mausbewegungen, die ein Ausl\u00f6sen des Ereignisses zur Folge haben, sogar so klein, dass sich die Koordinaten gar nicht \u00e4ndern. Weiterhin kann mithilfe des MouseEvent -Objektes \u00fcberpr\u00fcft werden, ob w\u00e4hrend des ausl\u00f6senden Mausereignisses eine besondere Taste auf der Tastatur gedr\u00fcckt wurde, z.B. die Alt -Taste (linke option -Taste beim Mac), die AltGraph -Taste (rechte option -Taste beim Mac), die Ctrl -Taste, oder die Meta -Taste ( Windows -Taste bzw. Apple -Taste): 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); } Probieren Sie die Maus-Klicks bei unterschiedlich gedr\u00fcckter Taste auf der Tastatur aus! Mithilfe der Objektmethode getClickCount() l\u00e4sst sich die Anzahl die Klicks abfragen: 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); if ( e . getClickCount () == 2 ) System . out . println ( \"Doppelklick\" ); } Nochmal, weil es wichtig ist: alle diese Objektmethoden stehen allen Methoden zur Verf\u00fcgung, denen ein MouseEvent \u00fcbergeben wird. Wir k\u00f6nnen sie also in allen Methoden aus MouseListener und MouseMotionListener anwenden.","title":"Objektmethoden der Klasse MouseEvent"},{"location":"mausereignisse/#zeichnen-mit-der-maus","text":"Wir k\u00f6nnen nun zwei Sachen: Zeichnen und Mausereignisse behandeln. Diese beiden F\u00e4higkeiten wollen wir nun miteinander verbinden. Dazu zun\u00e4chst einige theoretische Vor\u00fcberlegungen.","title":"Zeichnen mit der Maus"},{"location":"mausereignisse/#model-view-controller","text":"Unter Model-View-Controller versteht man ein Entwurfsmuster (ein Design Pattern ), welches ein wesentliches Konzept bei Anwendungen darstellt, die eine GUI besitzen. Wir werden es in diesem Semester nicht mehr schaffen, ausf\u00fchrlich auf dieses Konzept einzugehen, aber wir betrachten ein paar wesentliche Grunds\u00e4tze daraus, die auch f\u00fcr unsere Anwendungen wichtig sind. Die Grundidee bei Model-View-Controlle (MVC) ist die Unterscheidung von drei Aufgaben: Das Model k\u00fcmmert sich um die Datenverwaltung. Es gibt eine oder mehrere Datenstrukturen, in denen Daten gespeichert werden. Das Model k\u00fcmmert sich darum, diese Datenstrukturen zu erstellen und Daten in diese Datenstrukturen einzuf\u00fcgen, zu \u00e4ndern oder zu l\u00f6schen. Der Controller verwaltet die Nutzerinteraktionen. Auf der Basis bestimmter Aktionen, die durch die Nutzerin verursacht werden (Mausklicks, Tatstureingaben, ...) st\u00f6\u00dft der Controller beim Model eine \u00c4nderung der der Datenverwaltung an (Daten hinzuf\u00fcgen, \u00e4ndern oder l\u00f6schen) und er st\u00f6\u00dft bei der View die Darstellung der Daten an. Der Controller hat also Zugriff auf das Model und auf die View . Die View k\u00fcmmert sich um die Darstellung der Daten in der GUI. Die View hat also Zugriff auf das Model , denn die View verwendet die vom Model verwalteten Daten, um diese darzustellen. Diese drei Aufgaben sollten m\u00f6glichst losgel\u00f6st voneinander gel\u00f6st werden, d.h. es sollte m\u00f6glichst keine \u00dcberschneidungen zwischen diesen Komponenten geben. F\u00fcr uns ist es in diesem Zusammenhang wichtig, dass die paintComponent() -Methode unsere View ist. In der paintComponent() -Methode k\u00f6nnen wir zeichnen, d.h. Daten visualisieren. Wir sollten keine weitere Methode (au\u00dfer die paintComponent() -Methode) haben, die etwas zeichnet und wir sollten in der paintComponent() -Methode keine Verwaltung von Daten durchf\u00fchren. Unser Controller ist die Implementierung der Listener , je nachdem, welche Nutzerinteraktionen wir unterst\u00fctzen und behandeln wollen, also z.B. ActionListener , MouseListener und/oder MouseMotionListener . Unsere Herausforderung ist nun, ein Model zu erstellen. Dazu m\u00fcssen wir stets \u00fcberlegen, welche Daten wir ben\u00f6tigen, damit die View (die paintComponent() -Methode) die Objekte zeichnen kann, die gew\u00fcnscht sind. Wir wollen diese theoretischen \u00dcberlegungen an einigen Beispielen erl\u00e4utern.","title":"Model-View-Controller"},{"location":"mausereignisse/#beispiel-1-kreise-zeichnen","text":"Unser erstes Beispiel ist einfach. Wir wollen mit der Maus in unsere Canvas klicken und dort, wo wir hingeklickt haben, soll ein schwarzer, ausgef\u00fcllter Kreis erscheinen. Alle Kreise haben den gleichen (einen festen) Durchmesser. Dazu folgende \u00dcberlegungen: View : in der paintComponent() -Methode k\u00f6nnen wir z.B. mithilfe der fillOval() -Methode Kreise zeichnen. Wir m\u00fcssen nur die Koordinaten x und y kennen, an denen der jeweilige Kreis gezeichnet werden soll. Controller : um zu wissen, wo wir mit der Maus in die Canvas geklickt haben, m\u00fcssen wir den MouseListener implementieren. Model : wir m\u00fcssen Koordinaten speichern, also entweder int -Werte x und y oder gleich Objekte vom Typ Point . Wir entscheiden uns f\u00fcr Letzteres. Da wir nicht wissen, wie viele Point -Objekte gespeichert werden sollen, kommt ein Array nicht in Frage. Wir ben\u00f6tigen Eine Collection . Hier ist es egal, ob List oder Set . Wir entscheiden uns f\u00fcr List . Wir starten erneut mit unserem Grundger\u00fcst f\u00fcr das Zeichnen, haben dort aber bereits den MouseListener implementiert: KreiseZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class KreiseZeichnen extends JFrame implements MouseListener { Canvas canvas ; public KreiseZeichnen () { super (); this . setTitle ( \"Kreise zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; // hier koennen wir zeichnen } } public static void main ( String [] args ) { new KreiseZeichnen (); } // der Controller @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Im Sinne des Controllers sind wir nur daran interessiert, die mouseClicked() -Methode des MouseListener zu implementieren, aber nat\u00fcrlich m\u00fcssen die anderen Methoden des MouseListener auch \"implementiert\" werden, ansonsten bliben sie abstrakt und somit die ganze Klasse. Wir lassen sie aber leer. Wir f\u00fcgen nun das Model ein, n\u00e4mlich eine Liste aus lauter Punkten, d.h. ein List<Point , die wir points nennen. Wir erzeugen die Liste im Konstruktor der Klasse, da wir sowohl in mouseClicked() , als auch in paintComponent() auf diese Liste zugreifen wollen, deklarieren wir sie als globale Variable. Einf\u00fcgen des Models 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class KreiseZeichnen extends JFrame implements MouseListener { Canvas canvas ; List < Point > points ; public KreiseZeichnen () { super (); this . setTitle ( \"Kreise zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . points = new ArrayList <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { final static int DURCHMESSER = 20 ; // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; for ( Point p : KreiseZeichnen . this . points ) { g2 . fillOval ( p . x , p . y , DURCHMESSER , DURCHMESSER ); } } } public static void main ( String [] args ) { new KreiseZeichnen (); } // der Controller @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); this . points . add ( p ); this . canvas . repaint (); } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } Wir betrachten die \u00c4nderungen im Detail: Die Klasse Point existiert in java.awt -Paket und muss von dort importiert werden (Zeile 3 ). Die Klasse List gibt es zwei Mal! Wir wollen hier die Collection verwenden und nutzen deshalb die Klasse List aus dem java.util -Paket. Hier m\u00fcssen Sie aufpassen, dass Sie die richtige List -Klasse importieren (Zeile 7 ). Die Klasse ArrayList ist aber eindeutig und wird aus dem java.util -Paket importiert (Zeile 6 ). In Zeile 14 wird die globale Variable points vom Typ List<Point> deklariert. Sie muss global sein, damit wir sowohl in der mouseClicked() -, als auch in der paintComponent() -Methode darauf Zugriff haben. In Zeile 22 erzeugen wir ein Objekt der Klasse ArrayList f\u00fcr die points -Referenz. In Zeile 34 erstellen wir eine Konstante DURCHMESSER , mit der wir den Durchmesser der Kreise festlegen, die wir durch die Maus-Klicks erzeugen wollen. Hier ist es Geschmackssache, ob sie diese Konstante als static deklarieren oder nicht. Die Unterscheidung liegt darin, ob Sie allen Objekten aus Canvas diesen Wert mitgeben sollen oder ob jedes Canvas -Objekt \"seinen eigenen\" DURCHMESSER haben soll. Da wir eh nur ein Objekt von Canvas erzeugen, macht es hier keinen Unterschied. In den Zeilen 43-46 wird die Datenstruktur List ausgelesen und jeder einzelne Point darin verwendet, um einen Kreis an diese Stelle zu zeichnen. Hier greift die View auf das Model zu (aber nur lesend!). Hier ist also unsere einzige Verbindung zwischen Model und View . Es sei an dieser Stelle angemerkt, dass die View das Model auch dazu verwenden k\u00f6nnte, um z.B. Quadrate mit der Gr\u00f6\u00dfe 100x100 zu zeichnen oder rote Kreise oder ... Insofern ist das Model unabh\u00e4ngig von der View und genau das wollen wir auch erreichen. Wir sehen hier auch den Zugriff auf eine Objekteigenschaft von der inneren in die \u00e4u\u00dfere Klasse. Um auf die Objekteigenschaft points der \u00e4u\u00dferen Klasse zuzugreifen, schreiben wir KreiseZeichnen.this.points (siehe auch ) In Zeile 60 wird die Liste (also das Model ) durch die Interaktionen der Nutzerin (also durch den Controller ) bef\u00fcllt. Immer dort, wohin mit der Maus geklickt wird, wird dieser Point in der Datenstruktur Liste (also im Model ) gespeichert. Hier sehen wir die einzige Verbindung zwischen Controller und Model . Der Controller greift auf das Model zu und st\u00f6\u00dft das Speichern eines Datums an. Zeile 62 ist sehr wichtig und wird h\u00e4ufig vergessen. Hier \"triggert\" der Controller die View . Wenn wir uns an die Einf\u00fchrung des Zeichnens erinnern, dann wird ein Fenster mit allen seinen Komponenten \"gezeichnet\". Wenn wir die Canvas mit neuen Kreisen \"bef\u00fcllen\", dann bewirkt das nicht automatisch ein Neuzeichnen der Canvas . Ein Neuzeichnen w\u00fcrde nur erfolgen, wenn wir bspw. die Fenstergr\u00f6\u00dfe \u00e4ndern oder das Fenster in die Taskleiste bewegen und wieder \u00f6ffnen. Um ein Neuzeichnen aus dem Programm heraus anzusto\u00dfen, ben\u00f6tigen wir die Methode repaint() . Wir h\u00e4tten auch this.repaint(); angeben k\u00f6nnen, dann w\u00e4re das gesamte Fenster neu gezeichnet worden (inkl. der Canvas ). Mit this.canvas.repaint(); wird \"nur\" die Canvas neu gezeichnet. \u00dcbung \u00c4ndern Sie das Programm so, dass die Punkte als Mittelpunkte der Kreise verwendet werden! \u00c4ndern Sie das Programm so, dass rote Quadrate der Gr\u00f6\u00dfe 30x30 anstelle der schwarzen Kreise gezeichnet werden! \u00c4ndern Sie das Programm so, dass die Punkte nur durch einen Doppelklick der Maus erfasst werden (einfacher Mausklick gen\u00fcgt nicht)!","title":"Beispiel 1: Kreise zeichnen"},{"location":"mausereignisse/#beispiel-2-linien-zeichnen","text":"In unserem zweiten Beispiel wollen wir Linien zeichnen. Dabei soll das Vorgehen so sein: Wir klicken mit der Maus und legen dabei den Anfangspunkt der Linie fest. Wir halten die Maustaste gedr\u00fcckt und bewegen bei gedr\u00fcckter Maustaste die Maus. Dabei wird die Linie bereits gezeichnet. Wir lassen die Maustaste los. dadurch steht der Endpunkt der Linie fest. F\u00fcr Punkt 1. implementieren wir die Methode mousePressed() und wir ben\u00f6tigen somit den MouseListener . F\u00fcr Punkt 2. implementieren wir die Methode mouseDragged() und wir ben\u00f6tigen somit den MouseMotionListener . F\u00fcr Punkt 3. implementieren wir die Methode mouseReleased() aus dem MouseListener . Wir starten erneut mit unserem Grundger\u00fcst f\u00fcr das Zeichnen, haben dort aber bereits den MouseListener und den MouseMotionListener implementiert und die Methoden, die uns nicht interessieren, zusammengek\u00fcrzt: LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Wir \u00fcberlegen uns nun das Model . Dies ist etwas komplexer, als das Model f\u00fcr das Zeichnen der Kreise. Es gibt gespeicherte Linien. Diese Linien sind bereits fertig erstellt. Diese Linien sollten in einer Collection gespeichert werden. Es bietet sich wieder eine Liste an (Menge ginge auch). Das Typisieren dieser Liste liegt jedoch nicht auf der Hand, da es im Gegensatz zu Point keine Klasse f\u00fcr eine Linie gibt, die wir benutzen k\u00f6nnten. M\u00fcssen wir uns also selber schreiben. eine aktuelle Linie. Das ist die Linie, die gerade gezeichnet wird. Diese Linie ist noch nicht gespeichert, d.h. die Maustaste wurde noch nicht losgelassen. Es kann auch sein, dass aktuell keine Linie gezeichnet wird, dann ist der Wert daf\u00fcr null . Auch diese aktuelle Linie sollte vom Typ Linie sein, den wir uns zun\u00e4chst erstellen. Linie.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.awt.Point ; public class Linie { private Point start ; private Point ende ; public Linie ( Point start , Point ende ) { this . start = start ; this . ende = ende ; } public void setEnde ( Point newEnde ) { this . ende = newEnde ; } public int getXstart () { return this . start . x ; } public int getYstart () { return this . start . y ; } public int getXende () { return this . ende . x ; } public int getYende () { return this . ende . y ; } } Mit dem Konstruktor k\u00f6nnen wir uns ein Objekt von Linie erstellen (im Controller bei mousePressed() ) und haben dann mithilfe von setEnde() die M\u00f6glichkeit, den Endpunkt der Linie noch zu \u00e4ndern (im Controller bei mouseDragged() . Die Getter ben\u00f6tigen wir in der View , um die Werte der Start- und Endpunkte der Linie auszulesen. Wir beginnen zun\u00e4chst damit, eine Linie zu erzeugen: LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Linie aktLinie ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( LinienZeichnen . this . aktLinie != null ) { int x1 = LinienZeichnen . this . aktLinie . getXstart (); int y1 = LinienZeichnen . this . aktLinie . getYstart (); int x2 = LinienZeichnen . this . aktLinie . getXende (); int y2 = LinienZeichnen . this . aktLinie . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie = new Linie ( p , p ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie . setEnde ( p ); this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Die Variable aktLinie ist global , weil wir sowohl in den Methoden mousepressed() und mouseDragged als auch in paintComponent() darauf zugreifen wollen (Zeile 13 ). In der paintComponent() -Methode (unserer View ) lesen wir diese Linie aus, um sie grafisch als Linie darzustellen. Der Zugriff auf die Eigenschaften des Objektes aktLinie erfolgt aber nur, wenn aktLinie auch tats\u00e4chlich auf ein Objekt zeigt. Wir pr\u00fcfen deshalb zun\u00e4chst, ob aktLinie nicht null ist (Zeile 40 ). Nachdem wir die x - und y -Werte des start - und des ende -Punktes der aktLinie ausgelesen haben (Zeilen 42-45 ), stellen wir eine Linie grafisch mithilfe der drawLine() -Methode dar. Das Objekt einer Linie wird in der mousePressed() -Methode erstellt. Der start - und der ende -Punkt dieser Linie sind zun\u00e4chst gleich (die Linie ist also am Anfang nur ein Punkt) - Zeile 61 . Wenn wir bei gedr\u00fcckter Maustaste die Maus bewegen, wird permanent die mouseDragged() -Methode aufgerufen. Dort setzen wir die aktuelle Position der Maus als neuen ende -Punkt von aktLinie (Zeile 67 ). Zeile 69 ist wieder sehr wichtig (und wird h\u00e4ufig vergessen). Hier \"triggert\" der Controller die View . Wenn wir die Canvas mit einer neuen Linie \"bef\u00fcllen\", dann bewirkt das nicht automatisch ein Neuzeichnen der Canvas . Das Neuzeichnen erfolgt erst durch den Aufruf this.canvas.repaint(); . Wir k\u00f6nnen nun viele Linien zeichnen, aber diese werden noch nicht gespeichert. Zum Speichern der Linien ben\u00f6tigen wir wieder eine Collection. Das Speichern der aktuellen Linie in diese Collection erfolgt in dem Moment, indem wir die Maustaste wieder loslassen, also in mouseReleased() . Die Collection muss wieder global verf\u00fcgbar sein. LinienZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class LinienZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Linie aktLinie ; List < Linie > linien ; public LinienZeichnen () { super (); this . setTitle ( \"Linien zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . linien = new ArrayList <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( LinienZeichnen . this . aktLinie != null ) { int x1 = LinienZeichnen . this . aktLinie . getXstart (); int y1 = LinienZeichnen . this . aktLinie . getYstart (); int x2 = LinienZeichnen . this . aktLinie . getXende (); int y2 = LinienZeichnen . this . aktLinie . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } for ( Linie l : LinienZeichnen . this . linien ) { int x1 = l . getXstart (); int y1 = l . getYstart (); int x2 = l . getXende (); int y2 = l . getYende (); g2 . drawLine ( x1 , y1 , x2 , y2 ); } } } public static void main ( String [] args ) { new LinienZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie = new Linie ( p , p ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); this . aktLinie . setEnde ( p ); this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); this . linien . add ( aktLinie ); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } \u00dcbung \u00c4ndern Sie das Programm so, dass nicht Linien gezeichnet werden, sondern Kreise! \u00c4ndern Sie aber nur die View , d.h. die paintComponent() . Die gespeicherten Linien geben den Durchmesser der Kreise an.","title":"Beispiel 2: Linien zeichnen"},{"location":"mausereignisse2022/","text":"Mausereignisse \u00b6 Bei den Mausereignissen unterscheiden wir zwei Arten von Ereignissen: Ereignisse der Maus, die einmalig von der Maus ausgel\u00f6st werden. Dazu geh\u00f6ren die Ereignisse, wenn die linke Maustaste gedr\u00fcckt wird, wenn die gedr\u00fcckte Taste losgelassen wird, wenn sich die Maus auf eine Komponente bewegt, die sich an den Mauslistener angemeldet hat oder wenn der Mauszeiger diese Komponente wieder verl\u00e4sst. Ereignisse der Maus, die durch Bewegung der Maus permanent ausgel\u00f6st werden. Dazu geh\u00f6rt die Mausbewegung selbst oder auch die Bewegung der Maus bei gedr\u00fcckter Taste. Die erste Art von Mausereignissen k\u00f6nnen wir behandeln, indem wir den MouseListener implementieren und eine Komponente (z.B. ein JPanel ) an den MouseListener anmelden. Die zweite Art von Maus(-Bewegungs-)ereignissen k\u00f6nnen wir behandeln, indem wir den MouseMotionListener implementieren und eine Komponente (z.B. ein JPanel ) an den MouseMotionListener anmelden. Wir betrachten dieses Semester aber nur den MouseListener . Der MouseListener \u00b6 Wir betrachten ein einfaches Beispiel mit JPanels , die in einem size x size -Gitter angeordnet sind. Diese JPanels haben alle eine zuf\u00e4llig erzeugte Hintergrundfarbe (siehe randomColor() . In dieser Klasse implementieren wir zun\u00e4chst den MouseListener , d.h. wir f\u00fcgen in den Klassenkopf implements MouseListener ein und lassen durch Eclipse die zu implementierenden Methoden einf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panel . addMouseListener ( this ); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouse clicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mouse pressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouse released\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouse entered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouse exited\" ); } } Wie wir sehen, sind es nun nicht mehr nur eine Methode, wie beim ActionListener , sondern gleich f\u00fcnf Methoden, die wir implementieren k\u00f6nnen. Unsere zun\u00e4chst einfachste Implementierung (aber zumindest am Anfang stets empfohlen!) ist die einfache Ausgabe auf die Konsole. Wir d\u00fcrfen auf keinen Fall vergessen, uns an den MouseListener anzumelden ! In diesem Beispiel melden wir das panel , das eine Objektvariable ist, an den MouseListener an (siehe Zeile 49 ). Wir k\u00f6nnten auch das gesamte Fenster an den MouseListener anmelden. Dazu w\u00fcrden wir in den Konstruktor von Mausereignisse ein this.addMouseListener(this); einf\u00fcgen. Damit w\u00fcrde this (also das Objekt von Mausereignisse , welches ja selbst ein JFrame ist) an den MouseListener angemeldet. Die Methode addMouseListener() erwartet ein Objekt der Implementierung von MouseListener . Das w\u00e4re ebenfalls this , da der MouseListener in der Klasse Mausereignisse implementiert ist. Weil jedoch sp\u00e4ter der Umgang mit den Mausereignissen etwas leichter ist, melden wir das panel -Objekt an den MouseListener an. Wir h\u00e4tten auch jedes einzelne JPanel anmelden k\u00f6nnen. Das zeigen wir sp\u00e4ter. Die Methoden des MouseListener \u00b6 Nun ist der MouseListener implementiert und das panel -Objekt ist an den MouseListener angemeldet. Wir k\u00f6nnen nun die einzelnen Methoden des MouseListener ausprobieren: mousePressed() wird aufgerufen, wenn die (linke) Maustaste heruntergedr\u00fcckt wird. Dr\u00fccken Sie die Maustaste und halten Sie sie gedr\u00fcckt. In der Konsole erscheint mousePressed . mouseReleased() wird aufgerufen, wenn die (linke) Maustaste nach dem Dr\u00fccken wieder losgelassen wird. Lassen Sie die Maustaste, nachdem auf der Konsole mousePressed erschienen ist, wieder los. In der Konsole erscheint mouseReleased . mouseClicked() wird aufgerufen, wenn erst mousePressed() und dann mouseReleased() aufgerufen wurde. mouseClicked() beschreibt also die Kombination aus Maustaste gedr\u00fcckt und Maustaste losgelassen - einen Maus-Klick also. mouseEntered() wird aufgerufen, wenn Sie den Mauszeiger auf die Komponente bewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus in die Zeichenfl\u00e4che canvas bewegen, dann wird die Methode mouseEntered() einmalig ausgef\u00fchrt. mouseExited() wird aufgerufen, wenn Sie den Mauszeiger von der Komponente wieder wegbewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus von der Zeichenfl\u00e4che in die Titelleiste des Fensters oder ganz aus dem Fenster (der ContentPane ) bewegen, dann wird die Methode mouseExited() einmalig ausgef\u00fchrt. \u00dcbung Probieren Sie intensiv aus, wann welche Methoden aufgerufen werden! 1. Schaffen Sie es, dass zwar mouse pressed und danach mouse released auf der Konsole erscheint, nicht aber mouse clicked ? Wann ist das der Fall? 2. Erzeugen Sie folgende Ausgabereihenfolge auf der Konsole: mouse pressed , mouse exited , mouse released , mouse entered ! Objektmethoden der Klasse MouseEvent \u00b6 All diesen Methoden wird ein MouseEvent als Parameter \u00fcbergeben. Dieses Objekt besitzt einige n\u00fctzliche Objektmethoden. Die wichtigsten dabei sind sicherlich die Ausk\u00fcnfte dar\u00fcber, wo das Mausereignis ausgel\u00f6st wurde. Wir betrachten einige Objektmethoden des MouseEvent -Objekts am Beispiel der mouseClicked(MouseEvent e) -Methode. die Methode getX() gibt den x -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat. Die Koordinate bezieht sich auf die Komponente, die an den MouseListener (bzw. MouseMotionListener ) angemeldet ist. Das ist auch der Grund, warum wir nicht das gesamte Fenster an den MouseListener (und MouseMotionListener ) angemeldet haben. Der Punkt [x=0, y=0] befindet sich bei dem Canvas -Objekt in der linken oberen Ecke der ContentPane . Der Punkt mit den Koordinaten [x=0, y=0] beim Fenster ist der linke obere Punkt des Fensters, d.h. der linke obere Punkt der Titelleiste. die Methode getY() gibt den y -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat (Koordinate der Komponente). die Methode getPoint() gibt ein Point -Objekt (von java.awt ) zur\u00fcck. Ein Point -Objekt besitzt die sichtbaren Objektvariablen x und y f\u00fcr die Koordinaten. Wir probieren beide M\u00f6glichkeiten aus, die Koordinaten zu erfragen: 49 50 51 52 53 54 55 56 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseClicked bei [ x = 388 ,y = 215 ] mouseClicked bei [ x = 388 ,y = 215 ] Beachten Sie, dass Sie in allen Methoden, in denen das MouseEvent \u00fcbergeben wird, die Koordinaten des Ereignisses auslesen k\u00f6nnen. Weiterhin kann mithilfe des MouseEvent -Objektes \u00fcberpr\u00fcft werden, ob w\u00e4hrend des ausl\u00f6senden Mausereignisses eine besondere Taste auf der Tastatur gedr\u00fcckt wurde, z.B. die Alt -Taste (linke option -Taste beim Mac), die AltGraph -Taste (rechte option -Taste beim Mac), die Ctrl -Taste, oder die Meta -Taste ( Windows -Taste bzw. Apple -Taste): 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); } Probieren Sie die Maus-Klicks bei unterschiedlich gedr\u00fcckter Taste auf der Tastatur aus! Mithilfe der Objektmethode getClickCount() l\u00e4sst sich die Anzahl die Klicks abfragen: 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); if ( e . getClickCount () == 2 ) System . out . println ( \"Doppelklick\" ); } Nochmal, weil es wichtig ist: alle diese Objektmethoden stehen allen Methoden zur Verf\u00fcgung, denen ein MouseEvent \u00fcbergeben wird. Wir k\u00f6nnen sie also in allen Methoden aus MouseListener (und MouseMotionListener ) anwenden. Farben \u00e4ndern mit Mausklick \u00b6 Wir implementieren nun die mouseClicked() -Methode, um die Farbe des JPanels zu \u00e4ndern, in das wir geklickt haben. Um das JPanel zu ermitteln, in das wir geklickt haben, ben\u00f6tigen wir folgende Daten: den x - und den y -Wert der Koordinate, in die wir die Maus innerhalb des panel -Objektes geklickt haben, die Breite und die H\u00f6he jedes einzelnen JPanels, um die Breite und die H\u00f6he jedes einzelnen JPanels zu berechnen, ben\u00f6tigen wir die H\u00f6he und die Breite des panel -Objektes. 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); int width = this . panel . getWidth (); int height = this . panel . getHeight (); int panelWidth = width / this . size ; int panelHeight = height / this . size ; int row = y / panelHeight ; int col = x / panelWidth ; System . out . println ( \"mouse clicked [x=\" + x + \", y=\" + y + \"]\" ); System . out . println ( \"width : \" + width + \", height : \" + height ); System . out . println ( \"row : \" + row + \" , col : \" + col ); this . panels [ row ][ col ] . setBackground ( randomColor ()); } In den Zeilen 77 und 78 fragen wir die Koordinaten des Mausklicks ab. In den Zeilen 79 und 80 ermizteln wir die Breite und H\u00f6he des panel -Objektes. In den Zeilen 81 und 82 berechnen wir die Breite und H\u00f6he jedes einzelnen JPanels . In den Zeilen 84 und 85 berechnen wir mit den obigen Informationen den Zeilen- und Spalten-Index des angeklickten JPanels im panels -Array. Nach Ausgabe aller Informationen auf die Konsole (Zeilen 87-89 ) wird f\u00fcr dieses angeklickte JPanel die Hintergrundfarbe neu gesetzt (Zeile 90 ). Jedes JPanel einzeln anmelden \u00b6 Wir haben den MouseListener an das panel -Objekt angemeldet, das alle JPanels enth\u00e4lt. Wir \u00e4ndern dies nun und melden stattdessen jedes einzelne JPanel aus dem panels -Array an den MouseListener an. Dies erledigen wir mithilfe einer anonymen Klasse , die den MouseListener implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); this . panels [ row ][ col ] . addMouseListener ( new MouseListener () { @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"einzelnes JPanel clicked\" ); Object src = e . getSource (); if ( src instanceof JPanel ) { JPanel here = ( JPanel ) src ; here . setBackground ( Mausereignisse . this . randomColor ()); } } @Override public void mousePressed ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseReleased ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } } Beachten Sie, dass nun nicht mehr die Mausereignisse -Klasse den MouseListener implementiert, sondern die Implementierung innerhalb der anonymen Klasse erfolgt (siehe Zeilen 63-100 ). Die Anmeldung an den MouseListener erfolgt nun f\u00fcr jedes einzelne JPanel aus dem panels -Array. Jedes dieser JPanel besitzt nun also sein eigenes MouseListener -Objekt. \u00dcbung Lassen Sie sich erneut die Koordinaten der Mausklicks auf die Konsole ausgeben.","title":"Mausereignisse"},{"location":"mausereignisse2022/#mausereignisse","text":"Bei den Mausereignissen unterscheiden wir zwei Arten von Ereignissen: Ereignisse der Maus, die einmalig von der Maus ausgel\u00f6st werden. Dazu geh\u00f6ren die Ereignisse, wenn die linke Maustaste gedr\u00fcckt wird, wenn die gedr\u00fcckte Taste losgelassen wird, wenn sich die Maus auf eine Komponente bewegt, die sich an den Mauslistener angemeldet hat oder wenn der Mauszeiger diese Komponente wieder verl\u00e4sst. Ereignisse der Maus, die durch Bewegung der Maus permanent ausgel\u00f6st werden. Dazu geh\u00f6rt die Mausbewegung selbst oder auch die Bewegung der Maus bei gedr\u00fcckter Taste. Die erste Art von Mausereignissen k\u00f6nnen wir behandeln, indem wir den MouseListener implementieren und eine Komponente (z.B. ein JPanel ) an den MouseListener anmelden. Die zweite Art von Maus(-Bewegungs-)ereignissen k\u00f6nnen wir behandeln, indem wir den MouseMotionListener implementieren und eine Komponente (z.B. ein JPanel ) an den MouseMotionListener anmelden. Wir betrachten dieses Semester aber nur den MouseListener .","title":"Mausereignisse"},{"location":"mausereignisse2022/#der-mouselistener","text":"Wir betrachten ein einfaches Beispiel mit JPanels , die in einem size x size -Gitter angeordnet sind. Diese JPanels haben alle eine zuf\u00e4llig erzeugte Hintergrundfarbe (siehe randomColor() . In dieser Klasse implementieren wir zun\u00e4chst den MouseListener , d.h. wir f\u00fcgen in den Klassenkopf implements MouseListener ein und lassen durch Eclipse die zu implementierenden Methoden einf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame implements MouseListener { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panel . addMouseListener ( this ); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"mouse clicked\" ); } @Override public void mousePressed ( MouseEvent e ) { System . out . println ( \"mouse pressed\" ); } @Override public void mouseReleased ( MouseEvent e ) { System . out . println ( \"mouse released\" ); } @Override public void mouseEntered ( MouseEvent e ) { System . out . println ( \"mouse entered\" ); } @Override public void mouseExited ( MouseEvent e ) { System . out . println ( \"mouse exited\" ); } } Wie wir sehen, sind es nun nicht mehr nur eine Methode, wie beim ActionListener , sondern gleich f\u00fcnf Methoden, die wir implementieren k\u00f6nnen. Unsere zun\u00e4chst einfachste Implementierung (aber zumindest am Anfang stets empfohlen!) ist die einfache Ausgabe auf die Konsole. Wir d\u00fcrfen auf keinen Fall vergessen, uns an den MouseListener anzumelden ! In diesem Beispiel melden wir das panel , das eine Objektvariable ist, an den MouseListener an (siehe Zeile 49 ). Wir k\u00f6nnten auch das gesamte Fenster an den MouseListener anmelden. Dazu w\u00fcrden wir in den Konstruktor von Mausereignisse ein this.addMouseListener(this); einf\u00fcgen. Damit w\u00fcrde this (also das Objekt von Mausereignisse , welches ja selbst ein JFrame ist) an den MouseListener angemeldet. Die Methode addMouseListener() erwartet ein Objekt der Implementierung von MouseListener . Das w\u00e4re ebenfalls this , da der MouseListener in der Klasse Mausereignisse implementiert ist. Weil jedoch sp\u00e4ter der Umgang mit den Mausereignissen etwas leichter ist, melden wir das panel -Objekt an den MouseListener an. Wir h\u00e4tten auch jedes einzelne JPanel anmelden k\u00f6nnen. Das zeigen wir sp\u00e4ter.","title":"Der MouseListener"},{"location":"mausereignisse2022/#die-methoden-des-mouselistener","text":"Nun ist der MouseListener implementiert und das panel -Objekt ist an den MouseListener angemeldet. Wir k\u00f6nnen nun die einzelnen Methoden des MouseListener ausprobieren: mousePressed() wird aufgerufen, wenn die (linke) Maustaste heruntergedr\u00fcckt wird. Dr\u00fccken Sie die Maustaste und halten Sie sie gedr\u00fcckt. In der Konsole erscheint mousePressed . mouseReleased() wird aufgerufen, wenn die (linke) Maustaste nach dem Dr\u00fccken wieder losgelassen wird. Lassen Sie die Maustaste, nachdem auf der Konsole mousePressed erschienen ist, wieder los. In der Konsole erscheint mouseReleased . mouseClicked() wird aufgerufen, wenn erst mousePressed() und dann mouseReleased() aufgerufen wurde. mouseClicked() beschreibt also die Kombination aus Maustaste gedr\u00fcckt und Maustaste losgelassen - einen Maus-Klick also. mouseEntered() wird aufgerufen, wenn Sie den Mauszeiger auf die Komponente bewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus in die Zeichenfl\u00e4che canvas bewegen, dann wird die Methode mouseEntered() einmalig ausgef\u00fchrt. mouseExited() wird aufgerufen, wenn Sie den Mauszeiger von der Komponente wieder wegbewegen, die an den MouseListener angemeldet ist. Wenn Sie in unserem Fall also die Maus von der Zeichenfl\u00e4che in die Titelleiste des Fensters oder ganz aus dem Fenster (der ContentPane ) bewegen, dann wird die Methode mouseExited() einmalig ausgef\u00fchrt. \u00dcbung Probieren Sie intensiv aus, wann welche Methoden aufgerufen werden! 1. Schaffen Sie es, dass zwar mouse pressed und danach mouse released auf der Konsole erscheint, nicht aber mouse clicked ? Wann ist das der Fall? 2. Erzeugen Sie folgende Ausgabereihenfolge auf der Konsole: mouse pressed , mouse exited , mouse released , mouse entered !","title":"Die Methoden des MouseListener"},{"location":"mausereignisse2022/#objektmethoden-der-klasse-mouseevent","text":"All diesen Methoden wird ein MouseEvent als Parameter \u00fcbergeben. Dieses Objekt besitzt einige n\u00fctzliche Objektmethoden. Die wichtigsten dabei sind sicherlich die Ausk\u00fcnfte dar\u00fcber, wo das Mausereignis ausgel\u00f6st wurde. Wir betrachten einige Objektmethoden des MouseEvent -Objekts am Beispiel der mouseClicked(MouseEvent e) -Methode. die Methode getX() gibt den x -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat. Die Koordinate bezieht sich auf die Komponente, die an den MouseListener (bzw. MouseMotionListener ) angemeldet ist. Das ist auch der Grund, warum wir nicht das gesamte Fenster an den MouseListener (und MouseMotionListener ) angemeldet haben. Der Punkt [x=0, y=0] befindet sich bei dem Canvas -Objekt in der linken oberen Ecke der ContentPane . Der Punkt mit den Koordinaten [x=0, y=0] beim Fenster ist der linke obere Punkt des Fensters, d.h. der linke obere Punkt der Titelleiste. die Methode getY() gibt den y -Wert der Koordinate zur\u00fcck, bei dem das MouseEvent stattgefunden hat (Koordinate der Komponente). die Methode getPoint() gibt ein Point -Objekt (von java.awt ) zur\u00fcck. Ein Point -Objekt besitzt die sichtbaren Objektvariablen x und y f\u00fcr die Koordinaten. Wir probieren beide M\u00f6glichkeiten aus, die Koordinaten zu erfragen: 49 50 51 52 53 54 55 56 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); } Beide Ausgaben zeigen (nat\u00fcrlich) die gleichen Koordinaten an, z.B. mouseClicked bei [ x = 388 ,y = 215 ] mouseClicked bei [ x = 388 ,y = 215 ] Beachten Sie, dass Sie in allen Methoden, in denen das MouseEvent \u00fcbergeben wird, die Koordinaten des Ereignisses auslesen k\u00f6nnen. Weiterhin kann mithilfe des MouseEvent -Objektes \u00fcberpr\u00fcft werden, ob w\u00e4hrend des ausl\u00f6senden Mausereignisses eine besondere Taste auf der Tastatur gedr\u00fcckt wurde, z.B. die Alt -Taste (linke option -Taste beim Mac), die AltGraph -Taste (rechte option -Taste beim Mac), die Ctrl -Taste, oder die Meta -Taste ( Windows -Taste bzw. Apple -Taste): 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); } Probieren Sie die Maus-Klicks bei unterschiedlich gedr\u00fcckter Taste auf der Tastatur aus! Mithilfe der Objektmethode getClickCount() l\u00e4sst sich die Anzahl die Klicks abfragen: 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @Override public void mouseClicked ( MouseEvent e ) { Point p = e . getPoint (); int x = e . getX (); int y = e . getY (); System . out . println ( \"mouseClicked bei [x=\" + p . x + \" ,y=\" + p . y + \"]\" ); System . out . println ( \"mouseClicked bei [x=\" + x + \" ,y=\" + y + \"]\" ); if ( e . isAltDown ()) System . out . println ( \"Alt-Taste gedrueckt\" ); if ( e . isAltGraphDown ()) System . out . println ( \"AltGraph-Taste gedrueckt\" ); if ( e . isControlDown ()) System . out . println ( \"Ctrl-Taste gedrueckt\" ); if ( e . isMetaDown ()) System . out . println ( \"Meta-Taste gedrueckt\" ); if ( e . isShiftDown ()) System . out . println ( \"Shift-Taste gedrueckt\" ); if ( e . getClickCount () == 2 ) System . out . println ( \"Doppelklick\" ); } Nochmal, weil es wichtig ist: alle diese Objektmethoden stehen allen Methoden zur Verf\u00fcgung, denen ein MouseEvent \u00fcbergeben wird. Wir k\u00f6nnen sie also in allen Methoden aus MouseListener (und MouseMotionListener ) anwenden.","title":"Objektmethoden der Klasse MouseEvent"},{"location":"mausereignisse2022/#farben-andern-mit-mausklick","text":"Wir implementieren nun die mouseClicked() -Methode, um die Farbe des JPanels zu \u00e4ndern, in das wir geklickt haben. Um das JPanel zu ermitteln, in das wir geklickt haben, ben\u00f6tigen wir folgende Daten: den x - und den y -Wert der Koordinate, in die wir die Maus innerhalb des panel -Objektes geklickt haben, die Breite und die H\u00f6he jedes einzelnen JPanels, um die Breite und die H\u00f6he jedes einzelnen JPanels zu berechnen, ben\u00f6tigen wir die H\u00f6he und die Breite des panel -Objektes. 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @Override public void mouseClicked ( MouseEvent e ) { int x = e . getX (); int y = e . getY (); int width = this . panel . getWidth (); int height = this . panel . getHeight (); int panelWidth = width / this . size ; int panelHeight = height / this . size ; int row = y / panelHeight ; int col = x / panelWidth ; System . out . println ( \"mouse clicked [x=\" + x + \", y=\" + y + \"]\" ); System . out . println ( \"width : \" + width + \", height : \" + height ); System . out . println ( \"row : \" + row + \" , col : \" + col ); this . panels [ row ][ col ] . setBackground ( randomColor ()); } In den Zeilen 77 und 78 fragen wir die Koordinaten des Mausklicks ab. In den Zeilen 79 und 80 ermizteln wir die Breite und H\u00f6he des panel -Objektes. In den Zeilen 81 und 82 berechnen wir die Breite und H\u00f6he jedes einzelnen JPanels . In den Zeilen 84 und 85 berechnen wir mit den obigen Informationen den Zeilen- und Spalten-Index des angeklickten JPanels im panels -Array. Nach Ausgabe aller Informationen auf die Konsole (Zeilen 87-89 ) wird f\u00fcr dieses angeklickte JPanel die Hintergrundfarbe neu gesetzt (Zeile 90 ).","title":"Farben \u00e4ndern mit Mausklick"},{"location":"mausereignisse2022/#jedes-jpanel-einzeln-anmelden","text":"Wir haben den MouseListener an das panel -Objekt angemeldet, das alle JPanels enth\u00e4lt. Wir \u00e4ndern dies nun und melden stattdessen jedes einzelne JPanel aus dem panels -Array an den MouseListener an. Dies erledigen wir mithilfe einer anonymen Klasse , die den MouseListener implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; public class Mausereignisse extends JFrame { private int size ; private JPanel [][] panels ; private JPanel panel ; public Mausereignisse ( int size ) { super (); this . size = size ; this . setTitle ( \"Mausereignisse\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel mainPanel = initContent ( size ); this . getContentPane (). add ( mainPanel , BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); } private Color randomColor () { Random r = new Random (); int red = r . nextInt ( 256 ); int blue = r . nextInt ( 256 ); int green = r . nextInt ( 256 ); Color c = new Color ( red , blue , green ); return c ; } private JPanel initContent ( int size ) { this . panel = new JPanel (); this . panel . setLayout ( new GridLayout ( size , size )); this . panels = new JPanel [ size ][ size ] ; for ( int row = 0 ; row < panels . length ; row ++ ) { for ( int col = 0 ; col < panels [ row ] . length ; col ++ ) { this . panels [ row ][ col ] = new JPanel (); this . panels [ row ][ col ] . setLayout ( new BorderLayout ()); JLabel label = new JLabel ( row + \" \" + col ); label . setHorizontalAlignment ( JLabel . CENTER ); label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); label . setForeground ( Color . WHITE ); this . panels [ row ][ col ] . add ( label ); this . panels [ row ][ col ] . setBackground ( randomColor ()); this . panels [ row ][ col ] . addMouseListener ( new MouseListener () { @Override public void mouseClicked ( MouseEvent e ) { System . out . println ( \"einzelnes JPanel clicked\" ); Object src = e . getSource (); if ( src instanceof JPanel ) { JPanel here = ( JPanel ) src ; here . setBackground ( Mausereignisse . this . randomColor ()); } } @Override public void mousePressed ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseReleased ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }); panel . add ( this . panels [ row ][ col ] ); } } return this . panel ; } public static void main ( String [] args ) { new Mausereignisse ( 4 ); } } Beachten Sie, dass nun nicht mehr die Mausereignisse -Klasse den MouseListener implementiert, sondern die Implementierung innerhalb der anonymen Klasse erfolgt (siehe Zeilen 63-100 ). Die Anmeldung an den MouseListener erfolgt nun f\u00fcr jedes einzelne JPanel aus dem panels -Array. Jedes dieser JPanel besitzt nun also sein eigenes MouseListener -Objekt. \u00dcbung Lassen Sie sich erneut die Koordinaten der Mausklicks auf die Konsole ausgeben.","title":"Jedes JPanel einzeln anmelden"},{"location":"mdarrays/","text":"Mehrdimensionale Arrays \u00b6 Arrays sind Objekte. Der Typ eines Arrays ergibt sich aus TypDerElemente[] Wir geben also den Typ der Elemente an (alle Elemente in einem Array sind vom selben Typ) und schreiben eckige Klammern [] dahinter. Dabei kann der Typ der Elemente sowohl ein Wertetyp sein als auch ein Referenztyp. Es k\u00f6nnte also sein, dass der Typ der Elemente selbst wieder ein Array ist. Wir w\u00fcrden dann f\u00fcr TypDerElemente[] f\u00fcr den Typ selbst wieder ein TypDerElemente[] einsetzen und bek\u00e4men TypDerElemente[][] . Und genau das geht auch - wir sprechen von mehrdimensionalen Arrays: Wir werden zweidimensionale Arrays betrachten. Vorstellen k\u00f6nnen wir uns gerade noch dreidimensionale, aber h\u00f6here Dimensionen sollten wir gar nicht verwenden, da dies eigentlich nur mit Fehlern behaftet sein kann. In zweidimensionalen Arrays haben wir nun anstelle eines Indexes zwei. Man kann sich diese Indizes so vorstellen, als w\u00fcrde der eine Index die Spalten nummerieren und der andere die Zeilen. Welcher Index wof\u00fcr steht, bleibt Ihnen \u00fcberlassen. Wir betrachten ein einf\u00fchrendes Beispiel: zweidimensionales Array f\u00fcr das kleine Einmaleins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } } In Zeile 6 wird das zweidiensionale int -Array deklariert ( int[][] einmaleins ) und auch gleichzeitig erzeugt ( new int[anzZeilen][anzSpalten] ). Das passiert genau so, wie wir es bereits von den eindimensionalen Arrays kennen, nur dass wir nun zwei Klammerpaare ( [][] ) und zwei Indizes haben. Da wir zwei Indizes haben, haben wir auch eine verschachtelte for -Schleife, um alle Elemente des Arrays betrachten zu k\u00f6nnen. Die Wertzuweisung erfolgt in Zeile 12 . Beachten Sie, dass die Abbruchbedingung der \u00e4u\u00dferen for -Schleife die Anzahl der Zeilen ermittelt ( einmaleins.length ) und in der inneren for -Schleife die Anzahl der Spalten in jeder Zeile ( einmaleins[i].length ) abgefragt wird. Den Zugriff auf ein solches zweidimensionales Array kann man sich so vorstellen: Der erste Index gibt danach die jeweilige Zeile an und der zweite die Spalte. Das bleibt aber Ihrer Interpretation \u00fcberlassen - k\u00f6nnte auch genau andersherum sein. Manche stellen sich ja ein eindimensionales Array auch vertikal vor und andere horizontal. Wichtig ist nur, dass Sie sich f\u00fcr eine Interpretation entscheiden und diese dann auch konsistent umsetzen. Zur Festigung f\u00fcgen wir in den obigen Code noch eine Ausgabe des zweidimensionalen Arrays ein: Einmaleins mit Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; // Wertezuweisungen for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } // Ausgabe auf Konsole for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { System . out . printf ( \"%4d\" , einmaleins [ i ][ j ] ); } System . out . println (); } } ergibt folgnde Ausgabe: 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Wir werden zweidimensionale Arrays in Aufgabe 3 noch weiter \u00fcben.","title":"Mehrdimensionale Arrays"},{"location":"mdarrays/#mehrdimensionale-arrays","text":"Arrays sind Objekte. Der Typ eines Arrays ergibt sich aus TypDerElemente[] Wir geben also den Typ der Elemente an (alle Elemente in einem Array sind vom selben Typ) und schreiben eckige Klammern [] dahinter. Dabei kann der Typ der Elemente sowohl ein Wertetyp sein als auch ein Referenztyp. Es k\u00f6nnte also sein, dass der Typ der Elemente selbst wieder ein Array ist. Wir w\u00fcrden dann f\u00fcr TypDerElemente[] f\u00fcr den Typ selbst wieder ein TypDerElemente[] einsetzen und bek\u00e4men TypDerElemente[][] . Und genau das geht auch - wir sprechen von mehrdimensionalen Arrays: Wir werden zweidimensionale Arrays betrachten. Vorstellen k\u00f6nnen wir uns gerade noch dreidimensionale, aber h\u00f6here Dimensionen sollten wir gar nicht verwenden, da dies eigentlich nur mit Fehlern behaftet sein kann. In zweidimensionalen Arrays haben wir nun anstelle eines Indexes zwei. Man kann sich diese Indizes so vorstellen, als w\u00fcrde der eine Index die Spalten nummerieren und der andere die Zeilen. Welcher Index wof\u00fcr steht, bleibt Ihnen \u00fcberlassen. Wir betrachten ein einf\u00fchrendes Beispiel: zweidimensionales Array f\u00fcr das kleine Einmaleins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } } In Zeile 6 wird das zweidiensionale int -Array deklariert ( int[][] einmaleins ) und auch gleichzeitig erzeugt ( new int[anzZeilen][anzSpalten] ). Das passiert genau so, wie wir es bereits von den eindimensionalen Arrays kennen, nur dass wir nun zwei Klammerpaare ( [][] ) und zwei Indizes haben. Da wir zwei Indizes haben, haben wir auch eine verschachtelte for -Schleife, um alle Elemente des Arrays betrachten zu k\u00f6nnen. Die Wertzuweisung erfolgt in Zeile 12 . Beachten Sie, dass die Abbruchbedingung der \u00e4u\u00dferen for -Schleife die Anzahl der Zeilen ermittelt ( einmaleins.length ) und in der inneren for -Schleife die Anzahl der Spalten in jeder Zeile ( einmaleins[i].length ) abgefragt wird. Den Zugriff auf ein solches zweidimensionales Array kann man sich so vorstellen: Der erste Index gibt danach die jeweilige Zeile an und der zweite die Spalte. Das bleibt aber Ihrer Interpretation \u00fcberlassen - k\u00f6nnte auch genau andersherum sein. Manche stellen sich ja ein eindimensionales Array auch vertikal vor und andere horizontal. Wichtig ist nur, dass Sie sich f\u00fcr eine Interpretation entscheiden und diese dann auch konsistent umsetzen. Zur Festigung f\u00fcgen wir in den obigen Code noch eine Ausgabe des zweidimensionalen Arrays ein: Einmaleins mit Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; // Wertezuweisungen for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } // Ausgabe auf Konsole for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { System . out . printf ( \"%4d\" , einmaleins [ i ][ j ] ); } System . out . println (); } } ergibt folgnde Ausgabe: 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Wir werden zweidimensionale Arrays in Aufgabe 3 noch weiter \u00fcben.","title":"Mehrdimensionale Arrays"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbung 1 (Wiederholung und Codereview) \u00b6 \u00dcbung 1 (12. + 14.4.) \u00dcbung bringt Frau Busjahn mit in die \u00dcbung \u00dcbung 2 (String und algorithmisches Denken) \u00b6 \u00dcbung 2 (19. + 21.4.) Erstellen Sie im Paket uebungen.uebung2 eine Java-Klasse Uebung2 mit main() -Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String . \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten. Implementieren Sie eine Methode static boolean isBinaryNumber(String s) . Diese Methode \u00fcberpr\u00fcft, ob der String s einer Bin\u00e4rzahl entspricht, d.h. ob er nur 0 und 1 enth\u00e4lt. Testen Sie die Methode isBinaryNumber(String s) z.B. mit den folgenden Aufrufen: System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false Implementieren Sie eine Methode static int binaryToDecimal(String s) . Diese Methode wandelt den String s in eine Dezimalzahl um, wenn s einer Bin\u00e4rzahl entspricht. Wenn s keiner Bin\u00e4rzahl entspricht, wird -1 zur\u00fcckgegeben. Testen Sie die Methode binaryToDecimal(String s) z.B. mit den folgenden Aufrufen: System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 Implementieren Sie eine Methode static String toLowerCase(String input) . Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an. Testen Sie die Methode toLowerCase(String input) z.B. mit den folgenden Aufrufen: System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% Zusatz: Implementieren Sie eine Methode static boolean isPalindrome(String input) . Diese Methode pr\u00fcft, ob es sich bei input um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus String ist dabei wahrscheinlich n\u00fctzlich! Testen Sie die Methode isPalindrome(String input) z.B. mit den folgenden Aufrufen: System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false Angenommen, Sie sollen f\u00fcr einen gegebenen String angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: ((()))()(()) // korrekt ((()) // nicht korrekt (())) // nicht korrekt ())( // nicht korrekt Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 package uebungen.uebung2.loesung ; public class Uebung2 { public static boolean isBinaryNumber ( String s ) { for ( int index = 0 ; index < s . length (); index ++ ) { char c = s . charAt ( index ); if ( ! ( c == '0' || c == '1' )) { return false ; } } return true ; } public static int binaryToDecimal ( String s ) { if ( isBinaryNumber ( s )) { int decimalValue = 0 ; for ( int index = 0 ; index < s . length (); index ++ ) { char c = s . charAt ( index ); int value = c - '0' ; decimalValue = decimalValue * 2 + value ; } return decimalValue ; } else return - 1 ; } public static String toLowerCase ( String input ) { String output = \"\" ; for ( int index = 0 ; index < input . length (); index ++ ) { char c = input . charAt ( index ); if ( c >= 'A' && c <= 'Z' ) { c = ( char )( c + 32 ); } output += c ; } return output ; } public static boolean isPalindrome ( String input ) { String s = toLowerCase ( input ); boolean palindrome = true ; while ( palindrome && s . length () > 1 ) { char c1 = s . charAt ( 0 ); char c2 = s . charAt ( s . length () - 1 ); if ( c1 == c2 ) { s = s . substring ( 1 , s . length () - 1 ); } else { palindrome = false ; } } return palindrome ; } public static boolean checkBraces ( String input ) { int nrOpening = 0 ; // man koennte auch fuer jede oeffnende ++ und int nrClosing = 0 ; // jede schliessende -- und dann nur eine Variable boolean correct = true ; for ( int index = 0 ; correct && index < input . length (); index ++ ) { char c = input . charAt ( index ); if ( c == '(' ) { nrOpening ++ ; } else if ( c == ')' ) { nrClosing ++ ; } if ( nrClosing > nrOpening ) // dann waere hier < 0 { correct = false ; } } if ( nrOpening != nrClosing ) // dann waere hier == 0 { correct = false ; } return correct ; } public static void main ( String [] args ) { System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false // das letzte waere okay, wenn man bei der Pruefung // die Leerzeichen ignorieren wuerde, waere auch moeglich } } \u00dcbung 3 (Exceptions) \u00b6 \u00dcbung 3 (26. + 28.4.) Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse JOptionPane aus dem und deren Division! Fangen Sie folgende Ausnahmen ab: Falls die Eingabe keiner Zahl entspricht. Falls die zweite Zahl eine 0 ist. Scenario : Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich: falsche Eingabe - keine Zahl: Fenster \u00f6ffnet sich erneut (andere Nachricht!): Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich: die Division Zahl1/Zahl2 schl\u00e4gt fehl ( ArithmeticException ), deshalb (andere Nachricht!): Ergebnis Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. public int inputInt(int min, int max) , welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich [min, max] liegen muss. Lesen Sie eine Zahl ein und geben Sie die Zahl umgedreht (r\u00fcckw\u00e4rts gelesen) wieder aus (f\u00fchrende Nullen entfallen): 3456789 --> 9876543 1000 --> 1 Lesen Sie eine Zahl ein und geben Sie die Quersumme der Zahl aus. 123456 --> 21 1000 --> 1 Viel Spa\u00df! Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 package uebungen.uebung3.loesung ; import javax.swing.JOptionPane ; public class Uebung3 { public static int inputInt ( String message ) { int number = 0 ; boolean notANumber = true ; while ( notANumber ) { String input = JOptionPane . showInputDialog ( message ); try { number = Integer . parseInt ( input ); notANumber = false ; } catch ( NumberFormatException e ) { message = \"Ihre Eingabe war keine Zahl!\" ; } } return number ; } public static int inputInt ( String message , int min , int max ) { int number = 0 ; boolean notANumber = true ; while ( notANumber ) { String input = JOptionPane . showInputDialog ( message ); try { number = Integer . parseInt ( input ); if ( number >= min && number <= max ) { notANumber = false ; } else { message = \"Zahl nicht zwischen \" + min + \" und \" + max + \" !\" ; } } catch ( NumberFormatException e ) { message = \"Ihre Eingabe war keine Zahl!\" ; } } return number ; } public static void printDivide () { int number1 = inputInt ( \"Zahl 1:\" ); int number2 = 0 ; double result = 0.0 ; boolean isZero = true ; String message = \"Zahl 2:\" ; while ( isZero ) { number2 = inputInt ( message ); try { result = number1 / number2 ; isZero = false ; } catch ( ArithmeticException e ) { message = \"Zahl darf nicht 0 sein\" ; } } String output = number1 + \" / \" + number2 + \" = \" + result ; JOptionPane . showMessageDialog ( null , output ); } public static void printReverse () { int number = inputInt ( \"Zahl : \" ); int copyNumber = number ; // fuer spaetere Ausgabe int reverse = 0 ; while ( number != 0 ) { int last = number % 10 ; reverse = reverse * 10 + last ; number = number / 10 ; } String output = copyNumber + \" --> \" + reverse ; JOptionPane . showMessageDialog ( null , output ); } public static void printChecksum () { int number = inputInt ( \"Zahl : \" ); int copyNumber = number ; // fuer spaetere Ausgabe int checksum = 0 ; while ( number != 0 ) { int last = number % 10 ; checksum = checksum + last ; number = number / 10 ; } String output = \"Die Quersumme von \" + copyNumber + \" ist \" + checksum ; JOptionPane . showMessageDialog ( null , output ); } public static void main ( String [] args ) { int number1 = inputInt ( \"Geben Sie eine Zahl ein :\" ); System . out . println ( number1 ); int choice = JOptionPane . showConfirmDialog ( null , \"Wollen Sie weiterspielen?\" , \"Abfrage\" , JOptionPane . YES_NO_OPTION ); System . out . println ( choice ); if ( choice == JOptionPane . YES_OPTION ) { System . out . println ( \"yes geklickt\" ); } if ( choice == JOptionPane . NO_OPTION ) { System . out . println ( \"no geklickt\" ); } if ( choice == JOptionPane . CANCEL_OPTION ) { System . out . println ( \"no geklickt\" ); } printDivide (); printReverse (); printChecksum (); } } \u00dcbung 4 (String) \u00b6 \u00dcbung 4 (3. + 5.5.) Gegeben ist die Klasse StringPi . Sie enth\u00e4lt nur eine einzige Konstante PI vom Typ String . Dieser String enth\u00e4lt die ersten 100 000 Nachkommastellen von \u03c0. Die Klasse StringPi.java k\u00f6nnen Sie hier herunterladen . Klasse StringPi mit der Konstanten PI ```java public class StringPi { public static final String PI = new StringBuilder(\"3\" + \"141592653589793238462643383279502884197169399375105820974944592307816406286\" + \"208998628034825342117067982148086513282306647093844609550582231725359408128481\" + \"117450284102701938521105559644622948954930381964428810975665933446128475648233\" + \"786783165271201909145648566923460348610454326648213393607260249141273724587006\" + \"606315588174881520920962829254091715364367892590360011330530548820466521384146\" + \"951941511609433057270365759591953092186117381932611793105118548074462379962749\" + \"567351885752724891227938183011949129833673362440656643086021394946395224737190\" + \"702179860943702770539217176293176752384674818467669405132000568127145263560827\" + \"785771342757789609173637178721468440901224953430146549585371050792279689258923\" + \"542019956112129021960864034418159813629774771309960518707211349999998372978049\" + \"951059731732816096318595024459455346908302642522308253344685035261931188171010\" + \"003137838752886587533208381420617177669147303598253490428755468731159562863882\" + \"353787593751957781857780532171226806613001927876611195909216420198938095257201\" + \"065485863278865936153381827968230301952035301852968995773622599413891249721775\" + \"283479131515574857242454150695950829533116861727855889075098381754637464939319\" + \"255060400927701671139009848824012858361603563707660104710181942955596198946767\" + \"837449448255379774726847104047534646208046684259069491293313677028989152104752\" + \"162056966024058038150193511253382430035587640247496473263914199272604269922796\" + \"782354781636009341721641219924586315030286182974555706749838505494588586926995\" + \"690927210797509302955321165344987202755960236480665499119881834797753566369807\" + \"426542527862551818417574672890977772793800081647060016145249192173217214772350\" + \"141441973568548161361157352552133475741849468438523323907394143334547762416862\" + \"518983569485562099219222184272550254256887671790494601653466804988627232791786\" + \"085784383827967976681454100953883786360950680064225125205117392984896084128488\" + \"626945604241965285022210661186306744278622039194945047123713786960956364371917\" + \"287467764657573962413890865832645995813390478027590099465764078951269468398352\" + \"595709825822620522489407726719478268482601476990902640136394437455305068203496\" + \"252451749399651431429809190659250937221696461515709858387410597885959772975498\" + \"930161753928468138268683868942774155991855925245953959431049972524680845987273\" + \"644695848653836736222626099124608051243884390451244136549762780797715691435997\" + \"700129616089441694868555848406353422072225828488648158456028506016842739452267\" + \"467678895252138522549954666727823986456596116354886230577456498035593634568174\" + \"324112515076069479451096596094025228879710893145669136867228748940560101503308\" + \"617928680920874760917824938589009714909675985261365549781893129784821682998948\" + \"722658804857564014270477555132379641451523746234364542858444795265867821051141\" + \"354735739523113427166102135969536231442952484937187110145765403590279934403742\" + \"007310578539062198387447808478489683321445713868751943506430218453191048481005\" + \"370614680674919278191197939952061419663428754440643745123718192179998391015919\" + \"561814675142691239748940907186494231961567945208095146550225231603881930142093\" + \"762137855956638937787083039069792077346722182562599661501421503068038447734549\" + \"202605414665925201497442850732518666002132434088190710486331734649651453905796\" + \"268561005508106658796998163574736384052571459102897064140110971206280439039759\" + \"515677157700420337869936007230558763176359421873125147120532928191826186125867\" + \"321579198414848829164470609575270695722091756711672291098169091528017350671274\" + \"858322287183520935396572512108357915136988209144421006751033467110314126711136\" + \"990865851639831501970165151168517143765761835155650884909989859982387345528331\" + \"635507647918535893226185489632132933089857064204675259070915481416549859461637\" + \"180270981994309924488957571282890592323326097299712084433573265489382391193259\" + \"746366730583604142813883032038249037589852437441702913276561809377344403070746\" + \"921120191302033038019762110110044929321516084244485963766983895228684783123552\" + \"658213144957685726243344189303968642624341077322697802807318915441101044682325\" + \"271620105265227211166039666557309254711055785376346682065310989652691862056476\" + \"931257058635662018558100729360659876486117910453348850346113657686753249441668\" + \"039626579787718556084552965412665408530614344431858676975145661406800700237877\" + \"659134401712749470420562230538994561314071127000407854733269939081454664645880\" + \"797270826683063432858785698305235808933065757406795457163775254202114955761581\" + \"400250126228594130216471550979259230990796547376125517656751357517829666454779\" + \"174501129961489030463994713296210734043751895735961458901938971311179042978285\" + \"647503203198691514028708085990480109412147221317947647772622414254854540332157\" + \"185306142288137585043063321751829798662237172159160771669254748738986654949450\" + \"114654062843366393790039769265672146385306736096571209180763832716641627488880\" + \"078692560290228472104031721186082041900042296617119637792133757511495950156604\" + \"963186294726547364252308177036751590673502350728354056704038674351362222477158\" + \"915049530984448933309634087807693259939780541934144737744184263129860809988868\" + \"741326047215695162396586457302163159819319516735381297416772947867242292465436\" + \"680098067692823828068996400482435403701416314965897940924323789690706977942236\" + \"250822168895738379862300159377647165122893578601588161755782973523344604281512\" + \"627203734314653197777416031990665541876397929334419521541341899485444734567383\" + \"162499341913181480927777103863877343177207545654532207770921201905166096280490\" + \"926360197598828161332316663652861932668633606273567630354477628035045077723554\" + \"710585954870279081435624014517180624643626794561275318134078330336254232783944\" + \"975382437205835311477119926063813346776879695970309833913077109870408591337464\" + \"144282277263465947047458784778720192771528073176790770715721344473060570073349\" + \"243693113835049316312840425121925651798069411352801314701304781643788518529092\" + \"854520116583934196562134914341595625865865570552690496520985803385072242648293\" + \"972858478316305777756068887644624824685792603953527734803048029005876075825104\" + \"747091643961362676044925627420420832085661190625454337213153595845068772460290\" + \"161876679524061634252257719542916299193064553779914037340432875262888963995879\" + \"475729174642635745525407909145135711136941091193932519107602082520261879853188\" + \"770584297259167781314969900901921169717372784768472686084900337702424291651300\" + \"500516832336435038951702989392233451722013812806965011784408745196012122859937\" + \"162313017114448464090389064495444006198690754851602632750529834918740786680881\" + \"833851022833450850486082503930213321971551843063545500766828294930413776552793\" + \"975175461395398468339363830474611996653858153842056853386218672523340283087112\" + \"328278921250771262946322956398989893582116745627010218356462201349671518819097\" + \"303811980049734072396103685406643193950979019069963955245300545058068550195673\" + \"022921913933918568034490398205955100226353536192041994745538593810234395544959\" + \"778377902374216172711172364343543947822181852862408514006660443325888569867054\" + \"315470696574745855033232334210730154594051655379068662733379958511562578432298\" + \"827372319898757141595781119635833005940873068121602876496286744604774649159950\" + \"549737425626901049037781986835938146574126804925648798556145372347867330390468\" + \"838343634655379498641927056387293174872332083760112302991136793862708943879936\" + \"201629515413371424892830722012690147546684765357616477379467520049075715552781\" + \"965362132392640616013635815590742202020318727760527721900556148425551879253034\" + \"351398442532234157623361064250639049750086562710953591946589751413103482276930\" + \"624743536325691607815478181152843667957061108615331504452127473924544945423682\" + \"886061340841486377670096120715124914043027253860764823634143346235189757664521\" + \"641376796903149501910857598442391986291642193994907236234646844117394032659184\" + \"044378051333894525742399508296591228508555821572503107125701266830240292952522\" + \"011872676756220415420516184163484756516999811614101002996078386909291603028840\" + \"026910414079288621507842451670908700069928212066041837180653556725253256753286\" + \"129104248776182582976515795984703562226293486003415872298053498965022629174878\" + \"820273420922224533985626476691490556284250391275771028402799806636582548892648\" + \"802545661017296702664076559042909945681506526530537182941270336931378517860904\" + \"070866711496558343434769338578171138645587367812301458768712660348913909562009\" + \"939361031029161615288138437909904231747336394804575931493140529763475748119356\" + \"709110137751721008031559024853090669203767192203322909433467685142214477379393\" + \"751703443661991040337511173547191855046449026365512816228824462575916333039107\" + \"225383742182140883508657391771509682887478265699599574490661758344137522397096\" + \"834080053559849175417381883999446974867626551658276584835884531427756879002909\" + \"517028352971634456212964043523117600665101241200659755851276178583829204197484\" + \"423608007193045761893234922927965019875187212726750798125547095890455635792122\" + \"103334669749923563025494780249011419521238281530911407907386025152274299581807\" + \"247162591668545133312394804947079119153267343028244186041426363954800044800267\" + \"049624820179289647669758318327131425170296923488962766844032326092752496035799\" + \"646925650493681836090032380929345958897069536534940603402166544375589004563288\" + \"225054525564056448246515187547119621844396582533754388569094113031509526179378\" + \"002974120766514793942590298969594699556576121865619673378623625612521632086286\" + \"922210327488921865436480229678070576561514463204692790682120738837781423356282\" + \"360896320806822246801224826117718589638140918390367367222088832151375560037279\" + \"839400415297002878307667094447456013455641725437090697939612257142989467154357\" + \"846878861444581231459357198492252847160504922124247014121478057345510500801908\" + \"699603302763478708108175450119307141223390866393833952942578690507643100638351\" + \"983438934159613185434754649556978103829309716465143840700707360411237359984345\" + \"225161050702705623526601276484830840761183013052793205427462865403603674532865\" + \"105706587488225698157936789766974220575059683440869735020141020672358502007245\" + \"225632651341055924019027421624843914035998953539459094407046912091409387001264\" + \"560016237428802109276457931065792295524988727584610126483699989225695968815920\" + \"560010165525637567856672279661988578279484885583439751874454551296563443480396\" + \"642055798293680435220277098429423253302257634180703947699415979159453006975214\" + \"829336655566156787364005366656416547321704390352132954352916941459904160875320\" + \"186837937023488868947915107163785290234529244077365949563051007421087142613497\" + \"459561513849871375704710178795731042296906667021449863746459528082436944578977\" + \"233004876476524133907592043401963403911473202338071509522201068256342747164602\" + \"433544005152126693249341967397704159568375355516673027390074972973635496453328\" + \"886984406119649616277344951827369558822075735517665158985519098666539354948106\" + \"887320685990754079234240230092590070173196036225475647894064754834664776041146\" + \"323390565134330684495397907090302346046147096169688688501408347040546074295869\" + \"913829668246818571031887906528703665083243197440477185567893482308943106828702\" + \"722809736248093996270607472645539925399442808113736943388729406307926159599546\" + \"262462970706259484556903471197299640908941805953439325123623550813494900436427\" + \"852713831591256898929519642728757394691427253436694153236100453730488198551706\" + \"594121735246258954873016760029886592578662856124966552353382942878542534048308\" + \"330701653722856355915253478445981831341129001999205981352205117336585640782648\" + \"494276441137639386692480311836445369858917544264739988228462184490087776977631\" + \"279572267265556259628254276531830013407092233436577916012809317940171859859993\" + \"384923549564005709955856113498025249906698423301735035804408116855265311709957\" + \"089942732870925848789443646005041089226691783525870785951298344172953519537885\" + \"534573742608590290817651557803905946408735061232261120093731080485485263572282\" + \"576820341605048466277504500312620080079980492548534694146977516493270950493463\" + \"938243222718851597405470214828971117779237612257887347718819682546298126868581\" + \"705074027255026332904497627789442362167411918626943965067151577958675648239939\" + \"176042601763387045499017614364120469218237076488783419689686118155815873606293\" + \"860381017121585527266830082383404656475880405138080163363887421637140643549556\" + \"186896411228214075330265510042410489678352858829024367090488711819090949453314\" + \"421828766181031007354770549815968077200947469613436092861484941785017180779306\" + \"810854690009445899527942439813921350558642219648349151263901280383200109773868\" + \"066287792397180146134324457264009737425700735921003154150893679300816998053652\" + \"027600727749674584002836240534603726341655425902760183484030681138185510597970\" + \"566400750942608788573579603732451414678670368809880609716425849759513806930944\" + \"940151542222194329130217391253835591503100333032511174915696917450271494331515\" + \"588540392216409722910112903552181576282328318234254832611191280092825256190205\" + \"263016391147724733148573910777587442538761174657867116941477642144111126358355\" + \"387136101102326798775641024682403226483464176636980663785768134920453022408197\" + \"278564719839630878154322116691224641591177673225326433568614618654522268126887\" + \"268445968442416107854016768142080885028005414361314623082102594173756238994207\" + \"571362751674573189189456283525704413354375857534269869947254703165661399199968\" + \"262824727064133622217892390317608542894373393561889165125042440400895271983787\" + \"386480584726895462438823437517885201439560057104811949884239060613695734231559\" + \"079670346149143447886360410318235073650277859089757827273130504889398900992391\" + \"350337325085598265586708924261242947367019390772713070686917092646254842324074\" + \"855036608013604668951184009366860954632500214585293095000090715105823626729326\" + \"453738210493872499669933942468551648326113414611068026744663733437534076429402\" + \"668297386522093570162638464852851490362932019919968828517183953669134522244470\" + \"804592396602817156551565666111359823112250628905854914509715755390024393153519\" + \"090210711945730024388017661503527086260253788179751947806101371500448991721002\" + \"220133501310601639154158957803711779277522597874289191791552241718958536168059\" + \"474123419339842021874564925644346239253195313510331147639491199507285843065836\" + \"193536932969928983791494193940608572486396883690326556436421664425760791471086\" + \"998431573374964883529276932822076294728238153740996154559879825989109371712621\" + \"828302584811238901196822142945766758071865380650648702613389282299497257453033\" + \"283896381843944770779402284359883410035838542389735424395647555684095224844554\" + \"139239410001620769363684677641301781965937997155746854194633489374843912974239\" + \"143365936041003523437770658886778113949861647874714079326385873862473288964564\" + \"359877466763847946650407411182565837887845485814896296127399841344272608606187\" + \"245545236064315371011274680977870446409475828034876975894832824123929296058294\" + \"861919667091895808983320121031843034012849511620353428014412761728583024355983\" + \"003204202451207287253558119584014918096925339507577840006746552603144616705082\" + \"768277222353419110263416315714740612385042584598841990761128725805911393568960\" + \"143166828317632356732541707342081733223046298799280490851409479036887868789493\" + \"054695570307261900950207643349335910602454508645362893545686295853131533718386\" + \"826561786227363716975774183023986006591481616404944965011732131389574706208847\" + \"480236537103115089842799275442685327797431139514357417221975979935968525228574\" + \"526379628961269157235798662057340837576687388426640599099350500081337543245463\" + \"596750484423528487470144354541957625847356421619813407346854111766883118654489\" + \"377697956651727966232671481033864391375186594673002443450054499539974237232871\" + \"249483470604406347160632583064982979551010954183623503030945309733583446283947\" + \"630477564501500850757894954893139394489921612552559770143685894358587752637962\" + \"559708167764380012543650237141278346792610199558522471722017772370041780841942\" + \"394872540680155603599839054898572354674564239058585021671903139526294455439131\" + \"663134530893906204678438778505423939052473136201294769187497519101147231528932\" + \"677253391814660730008902776896311481090220972452075916729700785058071718638105\" + \"496797310016787085069420709223290807038326345345203802786099055690013413718236\" + \"837099194951648960075504934126787643674638490206396401976668559233565463913836\" + \"318574569814719621084108096188460545603903845534372914144651347494078488442377\" + \"217515433426030669883176833100113310869042193903108014378433415137092435301367\" + \"763108491351615642269847507430329716746964066653152703532546711266752246055119\" + \"958183196376370761799191920357958200759560530234626775794393630746305690108011\" + \"494271410093913691381072581378135789400559950018354251184172136055727522103526\" + \"803735726527922417373605751127887218190844900617801388971077082293100279766593\" + \"583875890939568814856026322439372656247277603789081445883785501970284377936240\" + \"782505270487581647032458129087839523245323789602984166922548964971560698119218\" + \"658492677040395648127810217991321741630581055459880130048456299765112124153637\" + \"451500563507012781592671424134210330156616535602473380784302865525722275304999\" + \"883701534879300806260180962381516136690334111138653851091936739383522934588832\" + \"255088706450753947395204396807906708680644509698654880168287434378612645381583\" + \"428075306184548590379821799459968115441974253634439960290251001588827216474500\" + \"682070419376158454712318346007262933955054823955713725684023226821301247679452\" + \"264482091023564775272308208106351889915269288910845557112660396503439789627825\" + \"001611015323516051965590421184494990778999200732947690586857787872098290135295\" + \"661397888486050978608595701773129815531495168146717695976099421003618355913877\" + \"781769845875810446628399880600616229848616935337386578773598336161338413385368\" + \"421197893890018529569196780455448285848370117096721253533875862158231013310387\" + \"766827211572694951817958975469399264219791552338576623167627547570354699414892\" + \"904130186386119439196283887054367774322427680913236544948536676800000106526248\" + \"547305586159899914017076983854831887501429389089950685453076511680333732226517\" + \"566220752695179144225280816517166776672793035485154204023817460892328391703275\" + \"425750867655117859395002793389592057668278967764453184040418554010435134838953\" + \"120132637836928358082719378312654961745997056745071833206503455664403449045362\" + \"756001125018433560736122276594927839370647842645676338818807565612168960504161\" + \"139039063960162022153684941092605387688714837989559999112099164646441191856827\" + \"700457424343402167227644558933012778158686952506949936461017568506016714535431\" + \"581480105458860564550133203758645485840324029871709348091055621167154684847780\" + \"394475697980426318099175642280987399876697323769573701580806822904599212366168\" + \"902596273043067931653114940176473769387351409336183321614280214976339918983548\" + \"487562529875242387307755955595546519639440182184099841248982623673771467226061\" + \"633643296406335728107078875816404381485018841143188598827694490119321296827158\" + \"884133869434682859006664080631407775772570563072940049294030242049841656547973\" + \"670548558044586572022763784046682337985282710578431975354179501134727362577408\" + \"021347682604502285157979579764746702284099956160156910890384582450267926594205\" + \"550395879229818526480070683765041836562094555434613513415257006597488191634135\" + \"955671964965403218727160264859304903978748958906612725079482827693895352175362\" + \"185079629778514618843271922322381015874445052866523802253284389137527384589238\" + \"442253547265309817157844783421582232702069028723233005386216347988509469547200\" + \"479523112015043293226628272763217790884008786148022147537657810581970222630971\" + \"749507212724847947816957296142365859578209083073323356034846531873029302665964\" + \"501371837542889755797144992465403868179921389346924474198509733462679332107268\" + \"687076806263991936196504409954216762784091466985692571507431574079380532392523\" + \"947755744159184582156251819215523370960748332923492103451462643744980559610330\" + \"799414534778457469999212859999939961228161521931488876938802228108300198601654\" + \"941654261696858678837260958774567618250727599295089318052187292461086763995891\" + \"614585505839727420980909781729323930106766386824040111304024700735085782872462\" + \"713494636853181546969046696869392547251941399291465242385776255004748529547681\" + \"479546700705034799958886769501612497228204030399546327883069597624936151010243\" + \"655535223069061294938859901573466102371223547891129254769617600504797492806072\" + \"126803922691102777226102544149221576504508120677173571202718024296810620377657\" + \"883716690910941807448781404907551782038565390991047759414132154328440625030180\" + \"275716965082096427348414695726397884256008453121406593580904127113592004197598\" + \"513625479616063228873618136737324450607924411763997597461938358457491598809766\" + \"744709300654634242346063423747466608043170126005205592849369594143408146852981\" + \"505394717890045183575515412522359059068726487863575254191128887737176637486027\" + \"660634960353679470269232297186832771739323619200777452212624751869833495151019\" + \"864269887847171939664976907082521742336566272592844062043021411371992278526998\" + \"469884770232382384005565551788908766136013047709843861168705231055314916251728\" + \"373272867600724817298763756981633541507460883866364069347043720668865127568826\" + \"614973078865701568501691864748854167915459650723428773069985371390430026653078\" + \"398776385032381821553559732353068604301067576083890862704984188859513809103042\" + \"359578249514398859011318583584066747237029714978508414585308578133915627076035\" + \"639076394731145549583226694570249413983163433237897595568085683629725386791327\" + \"505554252449194358912840504522695381217913191451350099384631177401797151228378\" + \"546011603595540286440590249646693070776905548102885020808580087811577381719174\" + \"177601733073855475800605601433774329901272867725304318251975791679296996504146\" + \"070664571258883469797964293162296552016879730003564630457930884032748077181155\" + \"533090988702550520768046303460865816539487695196004408482065967379473168086415\" + \"645650530049881616490578831154345485052660069823093157776500378070466126470602\" + \"145750579327096204782561524714591896522360839664562410519551052235723973951288\" + \"181640597859142791481654263289200428160913693777372229998332708208296995573772\" + \"737566761552711392258805520189887620114168005468736558063347160373429170390798\" + \"639652296131280178267971728982293607028806908776866059325274637840539769184808\" + \"204102194471971386925608416245112398062011318454124478205011079876071715568315\" + \"407886543904121087303240201068534194723047666672174986986854707678120512473679\" + \"247919315085644477537985379973223445612278584329684664751333657369238720146472\" + \"367942787004250325558992688434959287612400755875694641370562514001179713316620\" + \"715371543600687647731867558714878398908107429530941060596944315847753970094398\" + \"839491443235366853920994687964506653398573888786614762944341401049888993160051\" + \"207678103588611660202961193639682134960750111649832785635316145168457695687109\" + \"002999769841263266502347716728657378579085746646077228341540311441529418804782\" + \"543876177079043000156698677679576090996693607559496515273634981189641304331166\" + \"277471233881740603731743970540670310967676574869535878967003192586625941051053\" + \"358438465602339179674926784476370847497833365557900738419147319886271352595462\" + \"518160434225372996286326749682405806029642114638643686422472488728343417044157\" + \"348248183330164056695966886676956349141632842641497453334999948000266998758881\" + \"593507357815195889900539512085351035726137364034367534714104836017546488300407\" + \"846416745216737190483109676711344349481926268111073994825060739495073503169019\" + \"731852119552635632584339099822498624067031076831844660729124874754031617969941\" + \"139738776589986855417031884778867592902607004321266617919223520938227878880988\" + \"633599116081923535557046463491132085918979613279131975649097600013996234445535\" + \"014346426860464495862476909434704829329414041114654092398834443515913320107739\" + \"441118407410768498106634724104823935827401944935665161088463125678529776973468\" + \"430306146241803585293315973458303845541033701091676776374276210213701354854450\" + \"926307190114731848574923318167207213727935567952844392548156091372812840633303\" + \"937356242001604566455741458816605216660873874804724339121295587776390696903707\" + \"882852775389405246075849623157436917113176134783882719416860662572103685132156\" + \"647800147675231039357860689611125996028183930954870905907386135191459181951029\" + \"732787557104972901148717189718004696169777001791391961379141716270701895846921\" + \"434369676292745910994006008498356842520191559370370101104974733949387788598941\" + \"743303178534870760322198297057975119144051099423588303454635349234982688362404\" + \"332726741554030161950568065418093940998202060999414021689090070821330723089662\" + \"119775530665918814119157783627292746156185710372172471009521423696483086410259\" + \"288745799932237495519122195190342445230753513380685680735446499512720317448719\" + \"540397610730806026990625807602029273145525207807991418429063884437349968145827\" + \"337207266391767020118300464819000241308350884658415214899127610651374153943565\" + \"721139032857491876909441370209051703148777346165287984823533829726013611098451\" + \"484182380812054099612527458088109948697221612852489742555551607637167505489617\" + \"301680961380381191436114399210638005083214098760459930932485102516829446726066\" + \"613815174571255975495358023998314698220361338082849935670557552471290274539776\" + \"214049318201465800802156653606776550878380430413431059180460680083459113664083\" + \"488740800574127258670479225831912741573908091438313845642415094084913391809684\" + \"025116399193685322555733896695374902662092326131885589158083245557194845387562\" + \"878612885900410600607374650140262782402734696252821717494158233174923968353013\" + \"617865367376064216677813773995100658952887742766263684183068019080460984980946\" + \"976366733566228291513235278880615776827815958866918023894033307644191240341202\" + \"231636857786035727694154177882643523813190502808701857504704631293335375728538\" + \"660588890458311145077394293520199432197117164223500564404297989208159430716701\" + \"985746927384865383343614579463417592257389858800169801475742054299580124295810\" + \"545651083104629728293758416116253256251657249807849209989799062003593650993472\" + \"158296517413579849104711166079158743698654122234834188772292944633517865385673\" + \"196255985202607294767407261676714557364981210567771689348491766077170527718760\" + \"119990814411305864557791052568430481144026193840232247093924980293355073184589\" + \"035539713308844617410795916251171486487446861124760542867343670904667846867027\" + \"409188101424971114965781772427934707021668829561087779440504843752844337510882\" + \"826477197854000650970403302186255614733211777117441335028160884035178145254196\" + \"432030957601869464908868154528562134698835544456024955666843660292219512483091\" + \"060537720198021831010327041783866544718126039719068846237085751808003532704718\" + \"565949947612424811099928867915896904956394762460842406593094862150769031498702\" + \"067353384834955083636601784877106080980426924713241000946401437360326564518456\" + \"679245666955100150229833079849607994988249706172367449361226222961790814311414\" + \"660941234159359309585407913908720832273354957208075716517187659944985693795623\" + \"875551617575438091780528029464200447215396280746360211329425591600257073562812\" + \"638733106005891065245708024474937543184149401482119996276453106800663118382376\" + \"163966318093144467129861552759820145141027560068929750246304017351489194576360\" + \"789352855505317331416457050499644389093630843874484783961684051845273288403234\" + \"520247056851646571647713932377551729479512613239822960239454857975458651745878\" + \"771331813875295980941217422730035229650808917770506825924882232215493804837145\" + \"478164721397682096332050830564792048208592047549985732038887639160199524091893\" + \"894557676874973085695595801065952650303626615975066222508406742889826590751063\" + \"756356996821151094966974458054728869363102036782325018232370845979011154847208\" + \"761821247781326633041207621658731297081123075815982124863980721240786887811450\" + \"165582513617890307086087019897588980745664395515741536319319198107057533663373\" + \"803827215279884935039748001589051942087971130805123393322190346624991716915094\" + \"854140187106035460379464337900589095772118080446574396280618671786101715674096\" + \"766208029576657705129120990794430463289294730615951043090222143937184956063405\" + \"618934251305726829146578329334052463502892917547087256484260034962961165413823\" + \"007731332729830500160256724014185152041890701154288579920812198449315699905918\" + \"201181973350012618772803681248199587707020753240636125931343859554254778196114\" + \"293516356122349666152261473539967405158499860355295332924575238881013620234762\" + \"466905581643896786309762736550472434864307121849437348530060638764456627218666\" + \"170123812771562137974614986132874411771455244470899714452288566294244023018479\" + \"120547849857452163469644897389206240194351831008828348024924908540307786387516\" + \"591130287395878709810077271827187452901397283661484214287170553179654307650453\" + \"432460053636147261818096997693348626407743519992868632383508875668359509726557\" + \"481543194019557685043724800102041374983187225967738715495839971844490727914196\" + \"584593008394263702087563539821696205532480321226749891140267852859967340524203\" + \"109179789990571882194939132075343170798002373659098537552023891164346718558290\" + \"685371189795262623449248339249634244971465684659124891855662958932990903523923\" + \"333364743520370770101084388003290759834217018554228386161721041760301164591878\" + \"053936744747205998502358289183369292233732399948043710841965947316265482574809\" + \"948250999183300697656936715968936449334886474421350084070066088359723503953234\" + \"017958255703601693699098867113210979889707051728075585519126993067309925070407\" + \"024556850778679069476612629808225163313639952117098452809263037592242674257559\" + \"989289278370474445218936320348941552104459726188380030067761793138139916205806\" + \"270165102445886924764924689192461212531027573139084047000714356136231699237169\" + \"484813255420091453041037135453296620639210547982439212517254013231490274058589\" + \"206321758949434548906846399313757091034633271415316223280552297297953801880162\" + \"859073572955416278867649827418616421878988574107164906919185116281528548679417\" + \"363890665388576422915834250067361245384916067413734017357277995634104332688356\" + \"950781493137800736235418007061918026732855119194267609122103598746924117283749\" + \"312616339500123959924050845437569850795704622266461900010350049018303415354584\" + \"283376437811198855631877779253720116671853954183598443830520376281944076159410\" + \"682071697030228515225057312609304689842343315273213136121658280807521263154773\" + \"060442377475350595228717440266638914881717308643611138906942027908814311944879\" + \"941715404210341219084709408025402393294294549387864023051292711909751353600092\" + \"197110541209668311151632870542302847007312065803262641711616595761327235156666\" + \"253667271899853419989523688483099930275741991646384142707798870887422927705389\" + \"122717248632202889842512528721782603050099451082478357290569198855546788607946\" + \"280537122704246654319214528176074148240382783582971930101788834567416781139895\" + \"475044833931468963076339665722672704339321674542182455706252479721997866854279\" + \"897799233957905758189062252547358220523642485078340711014498047872669199018643\" + \"882293230538231855973286978092225352959101734140733488476100556401824239219269\" + \"506208318381454698392366461363989101210217709597670490830508185470419466437131\" + \"229969235889538493013635657618610606222870559942337163102127845744646398973818\" + \"856674626087948201864748767272722206267646533809980196688368099415907577685263\" + \"986514625333631245053640261056960551318381317426118442018908885319635698696279\" + \"503673842431301133175330532980201668881748134298868158557781034323175306478498\" + \"321062971842518438553442762012823457071698853051832617964117857960888815032960\" + \"229070561447622091509473903594664691623539680920139457817589108893199211226007\" + \"392814916948161527384273626429809823406320024402449589445612916704950823581248\" + \"739179964864113348032475777521970893277226234948601504665268143987705161531702\" + \"669692970492831628550421289814670619533197026950721437823047687528028735412616\" + \"639170824592517001071418085480063692325946201900227808740985977192180515853214\" + \"739265325155903541020928466592529991435379182531454529059841581763705892790690\" + \"989691116438118780943537152133226144362531449012745477269573939348154691631162\" + \"492887357471882407150399500944673195431619385548520766573882513963916357672315\" + \"100555603726339486720820780865373494244011579966750736071115935133195919712094\" + \"896471755302453136477094209463569698222667377520994516845064362382421185353488\" + \"798939567318780660610788544000550827657030558744854180577889171920788142335113\" + \"866292966717964346876007704799953788338787034871802184243734211227394025571769\" + \"081960309201824018842705704609262256417837526526335832424066125331152942345796\" + \"556950250681001831090041124537901533296615697052237921032570693705109083078947\" + \"999900499939532215362274847660361367769797856738658467093667958858378879562594\" + \"646489137665219958828693380183601193236857855855819555604215625088365020332202\" + \"451376215820461810670519533065306060650105488716724537794283133887163139559690\" + \"583208341689847606560711834713621812324622725884199028614208728495687963932546\" + \"428534307530110528571382964370999035694888528519040295604734613113826387889755\" + \"178856042499874831638280404684861893818959054203988987265069762020199554841265\" + \"000539442820393012748163815853039643992547020167275932857436666164411096256633\" + \"730540921951967514832873480895747777527834422109107311135182804603634719818565\" + \"557295714474768255285786334934285842311874944000322969069775831590385803935352\" + \"135886007960034209754739229673331064939560181223781285458431760556173386112673\" + \"478074585067606304822940965304111830667108189303110887172816751957967534718853\" + \"722930961614320400638132246584111115775835858113501856904781536893813771847281\" + \"475199835050478129771859908470762197460588742325699582889253504193795826061621\" + \"184236876851141831606831586799460165205774052942305360178031335726326705479033\" + \"840125730591233960188013782542192709476733719198728738524805742124892118347087\" + \"662966720727232565056512933312605950577772754247124164831283298207236175057467\" + \"387012820957554430596839555568686118839713552208445285264008125202766555767749\" + \"596962661260456524568408613923826576858338469849977872670655519185446869846947\" + \"849573462260629421962455708537127277652309895545019303773216664918257815467729\" + \"200521266714346320963789185232321501897612603437368406719419303774688099929687\" + \"758244104787812326625318184596045385354383911449677531286426092521153767325886\" + \"672260404252349108702695809964759580579466397341906401003636190404203311357933\" + \"654242630356145700901124480089002080147805660371015412232889146572239314507607\" + \"167064355682743774396578906797268743847307634645167756210309860409271709095128\" + \"086309029738504452718289274968921210667008164858339553773591913695015316201890\" + \"888748421079870689911480466927065094076204650277252865072890532854856143316081\" + \"269300569378541786109696920253886503457718317668688592368148847527649846882194\" + \"973972970773718718840041432312763650481453112285099002074240925585925292610302\" + \"106736815434701525234878635164397623586041919412969769040526483234700991115424\" + \"260127343802208933109668636789869497799400126016422760926082349304118064382913\" + \"834735467972539926233879158299848645927173405922562074910530853153718291168163\" + \"721939518870095778818158685046450769934394098743351443162633031724774748689791\" + \"820923948083314397084067308407958935810896656477585990556376952523265361442478\" + \"023082681183103773588708924061303133647737101162821461466167940409051861526036\" + \"009252194721889091810733587196414214447865489952858234394705007983038853886083\" + \"103571930600277119455802191194289992272235345870756624692617766317885514435021\" + \"828702668561066500353105021631820601760921798468493686316129372795187307897263\" + \"735371715025637873357977180818487845886650433582437700414771041493492743845758\" + \"710715973155943942641257027096512510811554824793940359768118811728247215825010\" + \"949609662539339538092219559191818855267806214992317276316321833989693807561685\" + \"591175299845013206712939240414459386239880938124045219148483164621014738918251\" + \"010909677386906640415897361047643650006807710565671848628149637111883219244566\" + \"394581449148616550049567698269030891118568798692947051352481609174324301538368\" + \"470729289898284602223730145265567989862776796809146979837826876431159883210904\" + \"371561129976652153963546442086919756737000573876497843768628768179249746943842\" + \"746525631632300555130417422734164645512781278457777245752038654375428282567141\" + \"288583454443513256205446424101103795546419058116862305964476958705407214198521\" + \"210673433241075676757581845699069304604752277016700568454396923404171108988899\" + \"341635058515788735343081552081177207188037910404698306957868547393765643363197\" + \"978680367187307969392423632144845035477631567025539006542311792015346497792906\" + \"624150832885839529054263768766896880503331722780018588506973623240389470047189\" + \"761934734430843744375992503417880797223585913424581314404984770173236169471976\" + \"571535319775499716278566311904691260918259124989036765417697990362375528652637\" + \"573376352696934435440047306719886890196814742876779086697968852250163694985673\" + \"021752313252926537589641517147955953878427849986645630287883196209983049451987\" + \"439636907068276265748581043911223261879405994155406327013198989570376110532360\" + \"629867480377915376751158304320849872092028092975264981256916342500052290887264\" + \"692528466610466539217148208013050229805263783642695973370705392278915351056888\" + \"393811324975707133102950443034671598944878684711643832805069250776627450012200\" + \"352620370946602341464899839025258883014867816219677519458316771876275720050543\" + \"979441245990077115205154619930509838698254284640725554092740313257163264079293\" + \"418334214709041254253352324802193227707535554679587163835875018159338717423606\" + \"155117101312352563348582036514614187004920570437201826173319471570086757853933\" + \"607862273955818579758725874410254207710547536129404746010009409544495966288148\" + \"691590389907186598056361713769222729076419775517772010427649694961105622059250\" + \"242021770426962215495872645398922769766031052498085575947163107587013320886146\" + \"326641259114863388122028444069416948826152957762532501987035987067438046982194\" + \"205638125583343642194923227593722128905642094308235254408411086454536940496927\" + \"149400331978286131818618881111840825786592875742638445005994422956858646048103\" + \"301538891149948693543603022181094346676400002236255057363129462629609619876056\" + \"425996394613869233083719626595473923462413459779574852464783798079569319865081\" + \"597767535055391899115133525229873611277918274854200868953965835942196333150286\" + \"956119201229888988700607999279541118826902307891310760361763477948943203210277\" + \"335941690865007193280401716384064498787175375678118532132840821657110754952829\" + \"497493621460821558320568723218557406516109627487437509809223021160998263303391\" + \"546949464449100451528092508974507489676032409076898365294065792019831526541065\" + \"813682379198409064571246894847020935776119313998024681340520039478194986620262\" + \"400890215016616381353838151503773502296607462795291038406868556907015751662419\" + \"298724448271942933100485482445458071889763300323252582158128032746796200281476\" + \"243182862217105435289834820827345168018613171959332471107466222850871066611770\" + \"346535283957762599774467218571581612641114327179434788599089280848669491413909\" + \"771673690027775850268664654056595039486784111079011610400857274456293842549416\" + \"759460548711723594642910585090995021495879311219613590831588262068233215615308\" + \"683373083817327932819698387508708348388046388478441884003184712697454370937329\" + \"836240287519792080232187874488287284372737801782700805878241074935751488997891\" + \"173974612932035108143270325140903048746226294234432757126008664250833318768865\" + \"075642927160552528954492153765175149219636718104943531785838345386525565664065\" + \"725136357506435323650893679043170259787817719031486796384082881020946149007971\" + \"513771709906195496964007086766710233004867263147551053723175711432231741141168\" + \"062286420638890621019235522354671166213749969326932173704310598722503945657492\" + \"461697826097025335947502091383667377289443869640002811034402608471289900074680\" + \"776484408871134135250336787731679770937277868216611786534423173226463784769787\" + \"514433209534000165069213054647689098505020301504488083426184520873053097318949\" + \"291642532293361243151430657826407028389840984160295030924189712097160164926561\" + \"341343342229882790992178604267981245728534580133826099587717811310216734025656\" + \"274400729683406619848067661580502169183372368039902793160642043681207990031626\" + \"444914619021945822969099212278855394878353830564686488165556229431567312827439\" + \"082645061162894280350166133669782405177015521962652272545585073864058529983037\" + \"918035043287670380925216790757120406123759632768567484507915114731344000183257\" + \"034492090971243580944790046249431345502890068064870429353403743603262582053579\" + \"011839564908935434510134296961754524957396062149028872893279252069653538639644\" + \"322538832752249960598697475988232991626354597332444516375533437749292899058117\" + \"578635555562693742691094711700216541171821975051983178713710605106379555858890\" + \"556885288798908475091576463907469361988150781468526213325247383765119299015610\" + \"918977792200870579339646382749068069876916819749236562422608715417610043060890\" + \"437797667851966189140414492527048088197149880154205778700652159400928977760133\" + \"075684796699295543365613984773806039436889588764605498387147896848280538470173\" + \"087111776115966350503997934386933911978988710915654170913308260764740630571141\" + \"109883938809548143782847452883836807941888434266622207043872288741394780101772\" + \"139228191199236540551639589347426395382482960903690028835932774585506080131798\" + \"840716244656399794827578365019551422155133928197822698427863839167971509126241\" + \"054872570092407004548848569295044811073808799654748156891393538094347455697212\" + \"891982717702076661360248958146811913361412125878389557735719498631721084439890\" + \"142394849665925173138817160266326193106536653504147307080441493916936326237376\" + \"777709585031325599009576273195730864804246770121232702053374266705314244820816\" + \"813030639737873664248367253983748769098060218278578621651273856351329014890350\" + \"988327061725893257536399397905572917516009761545904477169226580631511102803843\" + \"601737474215247608515209901615858231257159073342173657626714239047827958728150\" + \"509563309280266845893764964977023297364131906098274063353108979246424213458374\" + \"090116939196425045912881340349881063540088759682005440836438651661788055760895\" + \"689672753153808194207733259791727843762566118431989102500749182908647514979400\" + \"316070384554946538594602745244746681231468794344161099333890899263841184742525\" + \"704457251745932573898956518571657596148126602031079762825416559050604247911401\" + \"695790033835657486925280074302562341949828646791447632277400552946090394017753\" + \"633565547193100017543004750471914489984104001586794617924161001645471655133707\" + \"407395026044276953855383439755054887109978520540117516974758134492607943368954\" + \"378322117245068734423198987884412854206474280973562580706698310697993526069339\" + \"213568588139121480735472846322778490808700246777630360555123238665629517885371\" + \"967303463470122293958160679250915321748903084088651606111901149844341235012464\" + \"692802880599613428351188471544977127847336176628506216977871774382436256571177\" + \"945006447771837022199910669502165675764404499794076503799995484500271066598781\" + \"360380231412683690578319046079276529727769404361302305178708054651154246939526\" + \"512710105292707030667302444712597393995051462840476743136373997825918454117641\" + \"332790646063658415292701903027601733947486696034869497654175242930604072700505\" + \"903950314852292139257559484507886797792525393176515641619716844352436979444735\" + \"596426063339105512682606159572621703669850647328126672452198906054988028078288\" + \"142979633669674412480598219214633956574572210229867759974673812606936706913408\" + \"155941201611596019023775352555630060624798326124988128819293734347686268921923\" + \"977783391073310658825681377717232831532908252509273304785072497713944833389255\" + \"208117560845296659055394096556854170600117985729381399825831929367910039184409\" + \"928657560599359891000296986446097471471847010153128376263114677420914557404181\" + \"590880006494323785583930853082830547607679952435739163122188605754967383224319\" + \"565065546085288120190236364471270374863442172725787950342848631294491631847534\" + \"753143504139209610879605773098720135248407505763719925365047090858251393686346\" + \"386336804289176710760211115982887553994012007601394703366179371539630613986365\" + \"549221374159790511908358829009765664730073387931467891318146510931676157582135\" + \"142486044229244530411316065270097433008849903467540551864067734260358340960860\" + \"553374736276093565885310976099423834738222208729246449768456057956251676557408\" + \"841032173134562773585605235823638953203853402484227337163912397321599544082842\" + \"166663602329654569470357718487344203422770665383738750616921276801576618109542\" + \"009770836360436111059240911788954033802142652394892968643980892611463541457153\" + \"519434285072135345301831587562827573389826889852355779929572764522939156747756\" + \"667605108788764845349363606827805056462281359888587925994094644604170520447004\" + \"631513797543173718775603981596264750141090665886616218003826698996196558058720\" + \"863972117699521946678985701179833244060181157565807428418291061519391763005919\" + \"431443460515404771057005433900018245311773371895585760360718286050635647997900\" + \"413976180895536366960316219311325022385179167205518065926351803625121457592623\" + \"836934822266589557699466049193811248660909979812857182349400661555219611220720\" + \"309227764620099931524427358948871057662389469388944649509396033045434084210246\" + \"240104872332875008174917987554387938738143989423801176270083719605309438394006\" + \"375611645856094312951759771393539607432279248922126704580818331376416581826956\" + \"210587289244774003594700926866265965142205063007859200248829186083974373235384\" + \"908396432614700053242354064704208949921025040472678105908364400746638002087012\" + \"666420945718170294675227854007450855237772089058168391844659282941701828823301\" + \"497155423523591177481862859296760504820386434310877956289292540563894662194826\" + \"871104282816389397571175778691543016505860296521745958198887868040811032843273\" + \"986719862130620555985526603640504628215230615459447448990883908199973874745296\" + \"981077620148713400012253552224669540931521311533791579802697955571050850747387\" + \"475075806876537644578252443263804614304288923593485296105826938210349800040524\" + \"840708440356116781717051281337880570564345061611933042444079826037795119854869\" + \"455915205196009304127100727784930155503889536033826192934379708187432094991415\" + \"959339636811062755729527800425486306005452383915106899891357882001941178653568\" + \"214911852820785213012551851849371150342215954224451190020739353962740020811046\" + \"553020793286725474054365271759589350071633607632161472581540764205302004534018\" + \"357233829266191530835409512022632916505442612361919705161383935732669376015691\" + \"442994494374485680977569630312958871916112929468188493633864739274760122696415\" + \"884890096571708616059814720446742866420876533479985822209061980217321161423041\" + \"947775499073873856794118982466091309169177227420723336763503267834058630193019\" + \"324299639720444517928812285447821195353089891012534297552472763573022628138209\" + \"180743974867145359077863353016082155991131414420509144729353502223081719366350\" + \"934686585865631485557586244781862010871188976065296989926932817870557643514338\" + \"206014107732926106343152533718224338526352021773544071528189813769875515757454\" + \"693972715048846979361950047772097056179391382898984532742622728864710888327017\" + \"372325881824465843624958059256033810521560620615571329915608489206434030339526\" + \"226345145428367869828807425142256745180618414956468611163540497189768215422772\" + \"247947403357152743681940989205011365340012384671429655186734415374161504256325\" + \"671343024765512521921803578016924032669954174608759240920700466934039651017813\" + \"485783569444076047023254075555776472845075182689041829396611331016013111907739\" + \"863246277821902365066037404160672496249013743321724645409741299557052914243820\" + \"807609836482346597388669134991978401310801558134397919485283043673901248208244\" + \"481412809544377389832005986490915950532285791457688496257866588599917986752055\" + \"455809900455646117875524937012455321717019428288461740273664997847550829422802\" + \"023290122163010230977215156944642790980219082668986883426307160920791408519769\" + \"523555348865774342527753119724743087304361951139611908003025587838764420608504\" + \"473063129927788894272918972716989057592524467966018970748296094919064876469370\" + \"275077386643239191904225429023531892337729316673608699622803255718530891928440\" + \"380507103006477684786324319100022392978525537237556621364474009676053943983823\" + \"576460699246526008909062410590421545392790441152958034533450025624410100635953\" + \"003959886446616959562635187806068851372346270799732723313469397145628554261546\" + \"765063246567662027924520858134771760852169134094652030767339184114750414016892\" + \"412131982688156866456148538028753933116023229255561894104299533564009578649534\" + \"093511526645402441877594931693056044868642086275720117231952640502309977456764\" + \"783848897346431721598062678767183800524769688408498918508614900343240347674268\" + \"624595239589035858213500645099817824463608731775437885967767291952611121385919\" + \"472545140030118050343787527766440276261894101757687268042817662386068047788524\" + \"288743025914524707395054652513533945959878961977891104189029294381856720507096\" + \"460626354173294464957661265195349570186001541262396228641389779673332907056737\" + \"696215649818450684226369036784955597002607986799626101903933126376855696876702\" + \"929537116252800554310078640872893922571451248113577862766490242516199027747109\" + \"033593330930494838059785662884478744146984149906712376478958226329490467981208\" + \"998485716357108783119184863025450162092980582920833481363840542172005612198935\" + \"366937133673339246441612522319694347120641737549121635700857369439730597970971\" + \"972666664226743111776217640306868131035189911227133972403688700099686292254646\" + \"500638528862039380050477827691283560337254825579391298525150682996910775425764\" + \"748832534141213280062671709400909822352965795799780301828242849022147074811112\" + \"401860761341515038756983091865278065889668236252393784527263453042041880250844\" + \"236319038331838455052236799235775292910692504326144695010986108889991465855188\" + \"187358252816430252093928525807796973762084563748211443398816271003170315133440\" + \"230952635192958868069082135585368016100021374085115448491268584126869589917414\" + \"913382057849280069825519574020181810564129725083607035685105533178784082900004\" + \"155251186577945396331753853209214972052660783126028196116485809868458752512999\" + \"740409279768317663991465538610893758795221497173172813151793290443112181587102\" + \"351874075722210012376872194474720934931232410706508061856237252673254073332487\" + \"575448296757345001932190219911996079798937338367324257610393898534927877747398\" + \"050808001554476406105352220232540944356771879456543040673589649101761077594836\" + \"454082348613025471847648518957583667439979150851285802060782055446299172320202\" + \"822291488695939972997429747115537185892423849385585859540743810488262464878805\" + \"330427146301194158989632879267832732245610385219701113046658710050008328517731\" + \"177648973523092666123458887310288351562644602367199664455472760831011878838915\" + \"114934093934475007302585581475619088139875235781233134227986650352272536717123\" + \"075686104500454897036007956982762639234410714658489578024140815840522953693749\" + \"971066559489445924628661996355635065262340533943914211127181069105229002465742\" + \"360413009369188925586578466846121567955425660541600507127664176605687427420032\" + \"957716064344860620123982169827172319782681662824993871499544913730205184366907\" + \"672357740005393266262276032365975171892590180110429038427418550789488743883270\" + \"306328327996300720069801224436511639408692222074532024462412115580435454206421\" + \"512158505689615735641431306888344318528085397592773443365538418834030351782294\" + \"625370201578215737326552318576355409895403323638231921989217117744946940367829\" + \"618592080340386757583411151882417743914507736638407188048935825686854201164503\" + \"135763335550944031923672034865101056104987272647213198654343545040913185951314\" + \"518127643731043897250700498198705217627249406521461995923214231443977654670835\" + \"171474936798618655279171582408065106379950018429593879915835017158075988378496\" + \"225739851212981032637937621832245659423668537679911314010804313973233544909082\" + \"491049914332584329882103398469814171575601082970658306521134707680368069532297\" + \"199059990445120908727577622535104090239288877942463048328031913271049547859918\" + \"019696783532146444118926063152661816744319355081708187547705080265402529410921\" + \"826485821385752668815558411319856002213515888721036569608751506318753300294211\" + \"868222189377554602722729129050429225978771066787384000061677215463844129237119\" + \"352182849982435092089180168557279815642185819119749098573057033266764646072875\" + \"743056537260276898237325974508447964954564803077159815395582777913937360171742\" + \"299602735310276871944944491793978514463159731443535185049141394155732938204854\" + \"212350817391254974981930871439661513294204591938010623142177419918406018034794\" + \"988769105155790555480695387854006645337598186284641990522045280330626369562649\" + \"091082762711590385699505124652999606285544383833032763859980079292284665950355\" + \"121124528408751622906026201185777531374794936205549640107300134885315073548735\" + \"390560290893352640071327473262196031177343394367338575912450814933573691166454\" + \"128178817145402305475066713651825828489809951213919399563324133655677709800308\" + \"191027204099714868741813466700609405102146269028044915964654533010775469541308\" + \"871416531254481306119240782118869005602778182423502269618934435254763357353648\" + \"561936325441775661398170393063287216690572225974520919291726219984440964615826\" + \"945638023950283712168644656178523556516412771282691868861557271620147493405227\" + \"694659571219831494338162211400693630743044417328478610177774383797703723179525\" + \"543410722344551255558999864618387676490397246116795901810003509892864120419516\" + \"355110876320426761297982652942588295114127584126273279079880755975185157684126\" + \"474220947972184330935297266521001566251455299474512763155091763673025946213293\" + \"019040283795424632325855030109670692272022707486341900543830265068121414213505\" + \"715417505750863990767394633514620908288893493837643939925690060406731142209331\" + \"219593620298297235116325938677224147791162957278075239505625158160313335938231\" + \"150051862689053065836812998810866326327198061127154885879809348791291370749823\" + \"057592909186293919501472119758606727009254771802575033773079939713453953264619\" + \"526999659638565491759045833358579910201271320458390320085387888163363768518208\" + \"372788513117522776960978796214237216254521459128183179821604411131167140691482\" + \"717098101545778193920231156387195080502467972579249760577262591332855972637121\" + \"120190572077140914864507409492671803581515757151405039761096384675556929897038\" + \"354731410022380258346876735012977541327953206097115450648421218593649099791776\" + \"687477448188287063231551586503289816422828823274686610659273219790716238464215\" + \"348985247621678905026099804526648392954235728734397768049577409144953839157556\" + \"548545905897649519851380100795801078375994577529919670054760225255203445398871\" + \"253878017196071816407812484784725791240782454436168234523957068951427226975043\" + \"187363326301110305342333582160933319121880660826834142891041517324721605335584\" + \"999322454873077882290525232423486153152097693846104258284971496347534183756200\" + \"301491570327968530186863157248840152663983568956363465743532178349319982554211\" + \"730846774529708583950761645822963032442432823773745051702856069806788952176819\" + \"815671078163340526675953942492628075696832610749532339053622309080708145591983\" + \"735537774874202903901814293731152933464446815121294509759653430628421531944572\" + \"711861490001765055817709530246887526325011970520947615941676872778447200019278\" + \"913725184162285778379228443908430118112149636642465903363419454065718354477191\" + \"244662125939265662030688852005559912123536371822692253178145879259375044144893\" + \"398160865790087616502463519704582889548179375668104647461410514249887025213993\" + \"687050937230544773411264135489280684105910771667782123833281026218558775131272\" + \"117934444820144042574508306394473836379390628300897330624138061458941422769474\" + \"793166571762318247216835067807648757342049155762821758397297513447899069658953\" + \"254894033561561316740327647246921250575911625152965456854463349811431767025729\" + \"566184477548746937846423373723898192066204851189437886822480727935202250179654\" + \"534375727416391079197295295081294292220534771730418447791567399173841831171036\" + \"252439571615271466900581470000263301045264354786590329073320546833887207873544\" + \"476264792529769017091200787418373673508771337697768349634425241994995138831507\" + \"487753743384945825976556099655595431804092017849718468549737069621208852437701\" + \"385375768141663272241263442398215294164537800049250726276515078908507126599703\" + \"670872669276430837722968598516912230503746274431085293430527307886528397733524\" + \"601746352770320593817912539691562106363762588293757137384075440646896478310070\" + \"458061344673127159119460843593582598778283526653115106504162329532904777217408\" + \"355934972375855213804830509000964667608830154061282430874064559443185341375522\" + \"016630581211103345312074508682433943215904359443031243122747138584203039010607\" + \"094031523555617276799416002039397509989762933532585557562480899669182986422267\" + \"750236019325797472674257821111973470940235745722227121252685238429587427350156\" + \"366009318804549333898974157149054418255973808087156528143010267046028431681923\" + \"039253529779576586241439270154974087927313105163611913757700892956482332364829\" + \"826302460797587576774537716010249080462430185652416175665560016085912153455626\" + \"760219268998285537787258314514408265458348440947846317877737479465358016996077\" + \"940556870119232860804113090462935087182712593466871276669487389982459852778649\" + \"956916546402945893506496433580982476596516514209098675520380830920323048734270\" + \"346828875160407154665383461961122301375945157925269674364253192739003603860823\" + \"645076269882749761872357547676288995075211480485252795084503395857083813047693\" + \"788132112367428131948795022806632017002246033198967197064916374117585485187848\" + \"401205484467258885140156272501982171906696081262778548596481836962141072171421\" + \"498636191877475450965030895709947093433785698167446582826791194061195603784539\" + \"785583924076127634410576675102430755981455278616781594965706255975507430652108\" + \"530159790807334373607943286675789053348366955548680391343372015649883422089339\" + \"997164147974693869690548008919306713805717150585730714881564992071408675825960\" + \"287605645978242377024246980532805663278704192676846711626687946348695046450742\" + \"021937394525926266861355294062478136120620263649819999949840514386828525895634\" + \"226432870766329930489172340072547176418868535137233266787792173834754148002280\" + \"339299735793615241275582956927683723123479898944627433045456679006203242051639\" + \"628258844308543830720149567210646053323853720314324211260742448584509458049408\" + \"182092763914000854042202355626021856434899414543995041098059181794888262805206\" + \"644108631900168856815516922948620301073889718100770929059048074909242714101893\" + \"354281842999598816966099383696164438152887721408526808875748829325873580990567\" + \"075581701794916190611400190855374488272620093668560447559655747648567400817738\" + \"170330738030547697360978654385938218722058390234444350886749986650604064587434\" + \"600533182743629617786251808189314436325120510709469081358644051922951293245007\" + \"883339878842933934243512634336520438581291283434529730865290978330067126179813\" + \"031679438553572629699874035957045845223085639009891317947594875212639707837594\" + \"486113945196028675121056163897600888009274611586080020780334159145179707303683\" + \"519697776607637378533301202412011204698860920933908536577322239241244905153278\" + \"095095586645947763448226998607481329730263097502881210351772312446509534965369\" + \"309001863776409409434983731325132186208021480992268550294845466181471555744470\" + \"966953017769043427203189277060471778452793916047228153437980353967986142437095\" + \"668322149146543801459382927739339603275404800955223181666738035718393275707714\" + \"204672383862461780397629237713120958078936384144792980258806552212926209362393\" + \"063731349664018661951081158347117331202580586672763999276357907806381881306915\" + \"636627412543125958993611964762610140556350339952314032311381965623632719896183\" + \"725484533370206256346422395276694356837676136871196292181875457608161705303159\" + \"072882870071231366630872275491866139577373054606599743781098764980241401124214\" + \"277366808275139095931340415582626678951084677611866595766016599817808941498575\" + \"497628438785610026379654317831363402513581416115190209649913354873313111502270\" + \"068193013592959597164019719605362503355847998096348871803911161281359596856547\" + \"886832585643789617315976200241962155289629790481982219946226948713746244472909\" + \"345647002853769495885959160678928249105441251599630078136836749020937491573289\" + \"627002865682934443134234735123929825916673950342599586897069726733258273590312\" + \"128874666045146148785034614282776599160809039865257571726308183349444182019353\" + \"338507129234577437557934406217871133006310600332405399169368260374617663856575\" + \"887758020122936635327026710068126182517291460820254189288593524449107013820621\" + \"155382779356529691457650204864328286555793470720963480737269214118689546732276\" + \"775133569019015372366903686538916129168888787640752549349424973342718117889275\" + \"993159671935475898809792452526236365903632007085444078454479734829180208204492\" + \"667063442043755532505052752283377888704080403353192340768563010934777212563908\" + \"864041310107381785333831603813528082811904083256440184205374679299262203769871\" + \"801806112262449090924264198582086175117711378905160914038157500336642415609521\" + \"632819712233502316742260056794128140621721964184270578432895980288233505982820\" + \"819666624903585778994033315227481777695284368163008853176969478369058067106482\" + \"808359804669884109813515865490693331952239436328792399053481098783027450017206\" + \"543369906611778455436468772363184446476806914282800455107468664539280539940910\" + \"875493916609573161971503316696830992946634914279878084225722069714887558063748\" + \"030886299511847318712477729191007022758889348693945628951580296537215040960310\" + \"776128983126358996489341024703603664505868728758905140684123812424738638542790\" + \"828273382797332688550493587430316027474906312957234974261122151741715313361862\" + \"241091386950068883589896234927631731647834007746088665559873338211382992877691\" + \"149549218419208777160606847287467368188616750722101726110383067178785669481294\" + \"878504894306308616994879870316051588410828235127415353851336589533294862949449\" + \"506186851477910580469603906937266267038651290520113781085861618888694795760741\" + \"358553458515176805197333443349523012039577073962377131603024288720053732099825\" + \"300897761897312981788194467173116064723147624845755192873278282512718244680782\" + \"421521646956781929409823892628494376024885227900362021938669648221562809360537\" + \"317804086372726842669642192994681921490870170753336109479138180406328738759384\" + \"826953558307739576144799727000347288018278528138950321798634521611106660883931\" + \"405322694490545552786789441757920244002145078019209980446138254780585804844241\" + \"640477503153605490659143007815837243012313751156228401583864427089071828481675\" + \"752712384678245953433444962201009607105137060846180118754312072549133499424761\" + \"711563332140893460915656155060031738421870157022610310191660388706466143889773\" + \"631878094071152752817468957640158104701696524755774089164456867771715850058326\" + \"994340167720215676772406812836656526412298243946513319735919970940327593850266\" + \"955747023181320324371642058614103360652453693916005064495306016126782264894243\" + \"739716671766123104897503188573216555498834212180284691252908610148552781527762\" + \"562375045637576949773433684601560772703550962904939248708840628106794362241870\" + \"474700836884267102255830240359984164595112248527263363264511401739524808619463\" + \"584078375355688562231711552094722306543709260679735100056554938122457548372854\" + \"571179739361575616764169289580525729752233855861138832217110736226581621884244\" + \"317885748879810902665379342666421699091405653643224930133486798815488662866505\" + \"234699723557473842483059042367714327879231642240387776433019260019228477831383\" + \"763253612102533693581262408686669973827597736568222790721583247888864236934639\" + \"616436330873013981421143030600873066616480367898409133592629340230432497492688\" + \"783164360268101130957071614191283068657732353263965367739031766136131596555358\" + \"499939860056515592193675997771793301974468814837110320650369319289452140265091\" + \"546518430993655349333718342529843367991593941746622390038952767381333061774762\" + \"957494386871697845376721949350659087571191772087547710718993796089477451265475\" + \"750187119487073873678589020061737332107569330221632062843206567119209695058576\" + \"117396163232621770894542621460985841023781321581772760222273813349541048100307\" + \"327510779994899197796388353073444345753297591426376840544226478421606312276964\" + \"696715647399904371590332390656072664411643860540483884716191210900870101913072\" + \"607104411414324197679682854788552477947648180295973604943970047959604029274629\" + \"920357209976195014034831538094771460105633344699882082212058728151072918297121\" + \"191787642488035467231691654185225672923442918712816323259696541354858957713320\" + \"833991128877591722611527337901034136208561457799239877832508355073019981845902\" + \"595835598926055329967377049172245493532968330000223018151722657578752405883224\" + \"908582128008974790932610076257877042865600699617621217684547899644070506624171\" + \"021332748679623743022915535820078014116534806564748823061500339206898379476625\" + \"503654982280532966286211793062843017049240230198571997894883689718304380518217\" + \"441914766042975243725168343541121703863137941142209529588579806015293875275379\" + \"903093887168357209576071522190027937929278630363726876582268124199338480816602\" + \"160372215471014300737753779269906958712128928801905203160128586182549441335382\" + \"078488346531163265040764242839087012101519423196165226842200371123046430067344\" + \"206474771802135307012409886035339915266792387110170622186588357378121093517977\" + \"560442563469499978725112544085452227481091487430725986960204027594117894258128\" + \"188215995235965897918114407765335432175759525553615812800116384672031934650729\" + \"680799079396371496177431211940202129757312516525376801735910155733815377200195\" + \"244454362007184847566341540744232862106099761324348754884743453966598133871746\" + \"609302053507027195298394327142537115576660002578442303107342955153394506048622\" + \"276496668762407932435319299263925373107689213535257232108088981933916866827894\" + \"828117047262450194840970097576092098372409007471797334078814182519584259809624\" + \"174761013825264395513525931188504563626418830033853965243599741693132289471987\" + \"830842760040136807470390409723847394583489618653979059411859931035616843686921\" + \"948538205578039577388136067954990008512325944252972448666676683464140218991594\" + \"456530942344065066785194841776677947047204195882204329538032631053749488312218\" + \"039127967844610013972675389219511911783658766252808369005324900459741094706877\" + \"291232821430463533728351995364827432583311914445901780960778288358373011185754\" + \"365995898272453192531058811502630754257149394302445393187017992360816661130542\" + \"625399583389794297160207033876781503301028012009599725222228080142357109476035\" + \"192554443492998676781789104555906301595380976187592035893734197896235893112598\" + \"390259831026719330418921510968915622506965911982832345550305908173073519550372\" + \"166587028805399213857603703537710517802128012956684198414036287272562321442875\" + \"430221090947272107347413497551419073704331827662617727599688882602722524713368\" + \"335345281669277959132886138176634985772893690096574956228710302436259077241221\" + \"909430087175569262575806570991201665962243608024287002454736203639484125595488\" + \"172727247365346778364720191830399871762703751572464992228946793232269361917764\" + \"161461879561395669956778306829031658969943076733350823499079062410020250613405\" + \"734430069574547468217569044165154063658468046369262127421107539904218871612761\" + \"778701425886482577522388918459952337629237791558574454947736129552595222657863\" + \"646211837759847370034797140820699414558071908021359073226923310083175951065901\" + \"912129479540860364075735875020589020870457967000705526250581142066390745921527\" + \"330940682364944159089100922029668052332526619891131184201629163107689408472356\" + \"436680818216865721968826835840278550078280404345371018365109695178233574303050\" + \"485265373807353107418591770561039739506264035544227515610110726177937063472380\" + \"499066692216197119425912044508464174638358993823994651739550900085947999013602\" + \"667426149429006646711506717542217703877450767356374215478290591101261915755587\" + \"023895700140511782264698994491790830179547587676016809410013583761357859135692\" + \"445564776446417866711539195135769610486492249008344671548638305447791433009768\" + \"048687834818467273375843689272431044740680768527862558516509208826381323362314\" + \"873333671476452045087662761495038994950480956046098960432912335834885999029452\" + \"640028499428087862403981181488476730121675416110662999555366819312328742570206\" + \"373835202008686369131173346973174121915363324674532563087134730279217495622701\" + \"468732586789173455837996435135880095935087755635624881049385299900767513551352\" + \"779241242927748856588856651324730251471021057535251651181485090275047684551825\" + \"209633189906852761443513821366215236889057878669943228881602837748203550601602\" + \"989400911971385017987168363374413927597364401700701476370665570350433812111357\" + \"641501845182141361982349515960106475271257593518530433287553778305750956742544\" + \"268471221961870917856078393614451138333564910325640573389866717812397223751931\" + \"643061701385953947436784339267098671245221118969084023632741149660124348309892\" + \"994173803058841716661307304006758838043211155537944060549772170594282151488616\" + \"567277124090338772774562909711013488518437411869565544974573684521806698291104\" + \"505800429988795389902780438359628240942186055628778842880212755388480372864001\" + \"944161425749990427200959520465417059810498996750451193647117277222043610261407\" + \"975080968697517660023718774834801612031023468056711264476612374762785219024120\" + \"256994353471622666089367521983311181351114650385489502512065577263614547360442\" + \"685949807439693233129712737715734709971395229118265348515558713733662912024271\" + \"430250376326950135091161295299378586468130722648600827088133353819370368259886\" + \"789332123832705329762585738279009782646054559855513183668884462826513379849166\" + \"783940976135376625179825824966345877195012438404035914084920973375464247448817\" + \"618407002356958017741017769692507781489338667255789856458985105689196092439884\" + \"156928069698335224022563457049731224526935419383700484318335719651662672157552\" + \"419340193309901831930919658292096965624766768365964701959575473934551433741370\" + \"876151732367720422738567427917069820454995309591887243493952409444167899884631\" + \"984550485239366297207977745281439941825678945779571255242682608994086331737153\" + \"889626288962940211210888442737656862452761213037101730078513571540453304150795\" + \"944777614359743780374243664697324713841049212431413890357909241603640631403814\" + \"983148190525172093710396402680899483257229795456404270175772290417323479607361\" + \"878788991331830584306939482596131871381642346721873084513387721908697510494284\" + \"376932502498165667381626061594176825250999374167288395174406693254965340310145\" + \"222531618900923537648637848288134420987004809622717122640748957193900291857330\" + \"746010436072919094576799461492929042798168772942648772995285843464777538690695\" + \"014898413392454039414468026362540211861431703125111757764282991464453340892097\" + \"696169909837265236176874560589470496817013697490952307208268288789073019001825\" + \"342580534342170592871393173799314241085264739094828459641809361413847583113613\" + \"057610846236683723769591349261582451622155213487924414504175684806412063652017\" + \"038633012953277769902311864802006755690568229501635493199230591424639621702532\" + \"974757311409422018019936803502649563695586642590676268568737211033915679383989\" + \"576556519317788300024161353956243777784080174881937309502069990089089932808839\" + \"743036773659552489130015663329407790713961546453408879151030065132193448667324\" + \"827590794680787981942501958262232039513125201410996053126069655540424867054998\" + \"678692302174698900954785072567297879476988883109348746442640071818316033165551\" + \"153427615562240547447337804924621495213325852769884733626918264917433898782478\" + \"927846891882805466998230368993978341374758702580571634941356843392939606819206\" + \"177333179173820856243643363535986349449689078106401967407443658366707158692452\" + \"118299789380407713750129085864657890577142683358276897855471768718442772612050\" + \"926648610205153564284063236848180728794071712796682006072755955590404023317874\" + \"944734645476062818954151213916291844429765106694796935401686601005519607768733\" + \"539651161493093757096855455938151378956903925101495326562814701199832699220006\" + \"639287537471313523642158926512620407288771657835840521964605410543544364216656\" + \"224456504299901025658692727914275293117208279393775132610605288123537345106837\" + \"293989358087124386938593438917571337630072031976081660446468393772580690923729\" + \"752348670291691042636926209019960520412102407764819031601408586355842760953708\" + \"655816427399534934654631450404019952853725200495780525465625115410925243799132\" + \"626271360909940290226206283675213230506518393405745011209934146491843332364656\" + \"937172591448932415900624202061288573292613359680872650004562828455757459659212\" + \"053034131011182750130696150983551563200431078460190656549380654252522916199181\" + \"995960275232770224985573882489988270746593635576858256051806896428537685077201\" + \"222034792099393617926820659014216561592530673794456894907085326356819683186177\" + \"226824991147261573203580764629811624401331673789278868922903259334986179702199\" + \"498192573961767307583441709855922217017182571277753449150820527843090461946083\" + \"521740200583867284970941102326695392144546106621500641067474020700918991195137\" + \"646690448126725369153716229079138540393756007783515337416774794210038400230895\" + \"185099454877903934612222086506016050035177626483161115332558770507354127924990\" + \"985937347378708119425305512143697974991495186053592040383023571635272763087469\" + \"321962219006426088618367610334600225547747781364101269190656968649501268837629\" + \"690723396127628722304114181361006026404403003599698891994582739762411461374480\" + \"405969706257676472376606554161857469052722923822827518679915698339074767114610\" + \"302277660602006124687647772881909679161335401988140275799217416767879923160396\" + \"356949285151363364721954061117176738737255572852294005436178517650230754469386\" + \"930787349911035218253292972604455321079788771144989887091151123725060423875373\" + \"484125708606406905205845212275453384800820530245045651766951857691320004281675\" + \"805492481178051983264603244579282973012910531838563682120621553128866856495651\" + \"261389226136706409395333457052698695969235035309422454386527867767302754040270\" + \"224638448355323991475136344104405009233036127149608135549053153902100229959575\" + \"658370538126196568314428605795669662215472169562087001372776853696084070483332\" + \"513279311223250714863020695124539500373572334680709465648308920980153487870563\" + \"349109236605755405086411152144148143463043727327104502776866195310785832333485\" + \"784029716092521532609255893265560067212435946425506599677177038844539618163287\" + \"961446081778927217183690888012677820743010642252463480745430047649288555340906\" + \"218515365435547412547615276977266776977277705831580141218568801170502836527554\" + \"321480348800444297999806215790456416195721278450892848980642649742709057912906\" + \"921780729876947797511244730599140605062994689428093103421641662993561482813099\" + \"887074529271604843363081840412646963792584309418544221635908457614607855856247\" + \"381493142707826621518554160387020687698046174740080832434366538235455510944949\" + \"843109349475994467267366535251766270677219418319197719637801570216993367508376\" + \"005716345464367177672338758864340564487156696432104128259564534984138841289042\" + \"068204700761559691684303899934836679354254921032811336318472259230555438305820\" + \"694167562999201337317548912203723034907268106853445403599356182357631283776764\" + \"063101312533521214199461186935083317658785204711236433122676512996417132521751\" + \"355326186768194233879036546890800182713528358488844411176123410117991870923650\" + \"718485785622102110400977699445312179502247957806950653296594038398736990724079\" + \"767904082679400761872954783596349279390457697366164340535979221928587057495748\" + \"169669406233427261973351813662606373598257555249650980726012366828360592834185\" + \"584802695841377255897088378994291054980033111388460340193916612218669605849157\" + \"148573356828614950001909759112521880039641976216355937574371801148055944229873\" + \"041819680808564726571354761283162920044988031540210553059707666636274932830891\" + \"688093235929008178741198573831719261672883491840242972129043496552694272640255\" + \"964146352591434840067586769035038232057293413298159353304444649682944136732344\" + \"215838076169483121933311981906109614295220153617029857510559432646146850545268\" + \"497576480780800922133581137819774927176854507553832876887447459159373116247060\" + \"109124460982942484128752022446259447763874949199784044682925736096853454984326\" + \"653686284448936570411181779380644161653122360021491876876946739840751717630751\" + \"684985635920148689294310594020245796962292456664488196757629434953532638217161\" + \"339575779076637076456957025973880043841580589433613710655185998760075492418721\" + \"171488929522173772114608115434498266547987258005667472405112200738345927157572\" + \"771521858994694811794064446639943237004429114074721818022482583773601734668530\" + \"074498556471542003612359339731291445859152288740871950870863221883728826282288\" + \"463184371726190330577714765156414382230679184738603914768310814135827575585364\" + \"359772165002827780371342286968878734979509603110889919614338666406845069742078\" + \"770028050936720338723262963785603865321643234881555755701846908907464787912243\" + \"637555666867806761054495501726079114293083128576125448194444947324481909379536\" + \"900820638463167822506480953181040657025432760438570350592281891987806586541218\" + \"429921727372095510324225107971807783304260908679427342895573555925272380551144\" + \"043800123904168771644518022649168164192740110645162243110170005669112173318942\" + \"340054795968466980429801736257040673328212996215368488140410219446342464622074\" + \"557564396045298531307140908460849965376780379320189914086581466217531933766597\" + \"011433060862500982956691763884605676297293146491149370462446935198403953444913\" + \"514119366793330193661766365255514917498230798707228086085962611266050428929696\" + \"653565251668888557211227680277274370891738963977225756489053340103885593112567\" + \"999151658902501648696142720700591605616615970245198905183296927893555030393468\" + \"121976158218398048396056252309146263844738629603984892438618729850777592879272\" + \"206855480721049781765328621018747676689724884113956034948037672703631692100735\" + \"083407386526168450748249644859742813493648037242611670426687083192504099761531\" + \"907685577032742178501000644198412420739640013960360158381056592841368457411910\" + \"273642027416372348821452410134771652960312840865841978795111651152982781462037\" + \"913985500639996032659124852530849369031313010079997719136223086601109992914287\" + \"124938854161203802041134018888721969347790449752745428807280350930582875442075\" + \"513481666092787935356652125562013998824962847872621443236285367650259145046837\" + \"763528258765213915648097214192967554938437558260025316853635673137926247587804\" + \"944594418342917275698837622626184636545274349766241113845130548144983631178978\" + \"448973207671950878415861887969295581973325069995140260151167552975057543781024\" + \"223895792578656212843273120220071673057406928686936393018676595825132649914595\" + \"026091706934751940897535746401683081179884645247361895605647942635807056256328\" + \"118926966302647953595109712765913623318086692153578860781275991053717140220450\" + \"618607537486630635059148391646765672320571451688617079098469593223672494673758\" + \"309960704258922048155079913275208858378111768521426933478692189524062265792104\" + \"362034885292626798401395321645879115157905046057971083898337186403802441751134\" + \"722647254701079479399695355466961972676325522991465493349966323418595145036098\" + \"034409221220671256769872342794070885707047429317332918852389672197135392449242\" + \"617864118863779096281448691786946817759171715066911148002075943201206196963779\" + \"510322708902956608556222545260261046073613136886900928172106819861855378098201\" + \"847115416363032626569928342415502360097804641710852553761272890533504550613568\" + \"414377585442967797701466029438768722511536380119175815402812081825560648541078\" + \"793359892106442724489861896162941341800129513068363860929410008313667337215300\" + \"835269623573717533073865333820484219030818644918409372394403340524490955455801\" + \"640646076158101030176748847501766190869294609876920169120218168829104087070956\" + \"095147041692114702741339005225334083481287035303102391969997859741390859360543\" + \"359969707560446013424245368249609877258131102473279856207212657249900346829388\" + \"687230489556225320446360263985422525841646432427161141981780248259556354490721\" + \"922658386366266375083594431487763515614571074552801615967704844271419443518327\" + \"569840755267792641126176525061596523545718795667317091331935876162825592078308\" + \"018520689015150471334038610031005591481785211038475454293338918844412051794396\" + \"997019411269511952656491959418997541839323464742429070271887522353439367363366\" + \"320030723274703740712398256202466265197409019976245205619855762576000870817308\" + \"328834438183107005451449354588542267857855191537229237955549433341017442016960\" + \"009069641561273229777022121795186837635908225512881647002199234886404395915301\" + \"846400471432118636062252701154112228380277853891109849020134274101412155976996\" + \"543887719748537643115822983853312307175113296190455900793806427669581901484262\" + \"799122179294798734890186847167650382732855205908298452980625925035212845192592\" + \"798659350613296194679625237397256558415785374456755899803240549218696288849033\" + \"256085145534439166022625777551291620077279685262938793753045418108072928589198\" + \"971538179734349618723292761474785019261145041327487324297058340847111233374627\" + \"461727462658241532427105932250625530231473875925172478732288149145591560503633\" + \"457542423377916037495250249302235148196138116256391141561032684495807250827343\" + \"176594405409826976526934457986347970974312449827193311386387315963636121862349\" + \"726140955607992062831699942007205481152535339394607685001990988655386143349578\" + \"165008996164907967814290114838764568217491407562376761845377514403147541120676\" + \"016072646055685925779932207033733339891636950434669069482843662998003741452762\" + \"771654762382554617088318981086880684785370553648046935095881802536052974079353\" + \"867651119507937328208314626896007107517552061443378411454995013643244632819334\" + \"638905093654571450690086448344018042836339051357815727397333453728426337217406\" + \"577577107983051755572103679597690188995849413019599957301790124019390868135658\" + \"553966194137179448763207986880037160730322054742357226689680188212342439188598\" + \"416897227765219403249322731479366923400484897605903795809469604175427961378255\" + \"378122394764614783292697654516229028170110043784603875654415173943396004891531\" + \"881757665050095169740241564477129365661425394936888423051740012992055685428985\" + \"389794266995677702708914651373689220610441548166215680421983847673087178759027\" + \"920917590069527345668202651337311151800018143412096260165862982107666352336177\" + \"400783778342370915264406305407180784335806107296110555002041513169637304684921\" + \"335683726540030750982908936461204789111475303704989395283345782408281738644132\" + \"271000296831194020332345642082647327623383029463937899837583655455991934086623\" + \"509096796113400486702712317652666371077872511186035403755448741869351973365662\" + \"177235922939677646325156202348757011379571209623772343137021203100496515211197\" + \"601317641940820343734851285260291333491512508311980285017785571072537314913921\" + \"570910513096505988599993156086365547740355189816673353588004821466509974143376\" + \"118277772335191074121757284159258087259131507460602563490377726337391446137703\" + \"802131834744730111303267029691733504770163210661622783002726928336558401179141\" + \"944780874825336071440329625228577500980859960904093631263562132816207145340610\" + \"422411208301000858726425211226248014264751942618432585338675387405474349107271\" + \"004975428115946601713612259044015899160022982780179603519408004651353475269877\" + \"760952783998436808690898919783969353217998013913544255271791022539701081063214\" + \"304851137829149851138196914304349750018998068164441212327332830719282436240673\" + \"319655469267785119315277511344646890550424811336143498460484905125834568326644\" + \"152848971397237604032821266025351669391408204994732048602162775979177123475109\" + \"750240307893575993771509502175169355582707253391189233407022383207758580213717\" + \"477837877839101523413209848942345961369234049799827930414446316270721479611745\" + \"697571968123929191374098292580556195520743424329598289898052923336641541925636\" + \"738068949420147124134052507220406179435525255522500874879008656831454283516775\" + \"054229480327478304405643858159195266675828292970522612762871104013480178722480\" + \"178968405240792436058274246744307672164527031345135416764966890127478680101029\" + \"513386269864974821211862904033769156857624069929637249309720162870720018983542\" + \"369036414927023696193854737248032985504511208919287982987446786412915941753167\" + \"560253343531062674525450711418148323988060729714023472552071349079839898235526\" + \"872395090936566787899238371257897624875599044322889538837731734894112275707141\" + \"095979004791930104674075041143538178246463079598955563899188477378134134707024\" + \"674736211204898622699188851745625173251934135203811586335012391305444191007362\" + \"844756751416105041097350585276204448919097890198431548528053398577784431393388\" + \"399431044446566924455088594631408175122033139068159659251054685801313383815217\" + \"641821043342978882611963044311138879625874609022613090084997543039577124323061\" + \"690626291940392143974027089477766370248815549932245882597902063125743691094639\" + \"325280624164247686849545532493801763937161563684785982371590238542126584061536\" + \"722860713170267474013114526106376538339031592194346981760535838031061288785205\" + \"154693363924108846763200956708971836749057816308515813816196688222204757043759\" + \"061433804072585386208356517699842677452319582418268369827016023741493836349662\" + \"935157685406139734274647089968561817016055110488097155485911861718966802597354\" + \"170542398513556001872033507906094642127114399319604652742405088222535977348151\" + \"913543857125325854049394601086579379805862014336607882521971780902581737087091\" + \"646045272797715350991034073642502038638671822052287969445838765294795104866071\" + \"739022932745542678566977686593992341683412227466301506215532050265534146099524\" + \"935605085492175654913483095890653617569381763747364418337897422970070354520666\" + \"317092960759198962773242309025239744386101426309868773391388251868431650102796\" + \"491149773758288891345034114886594867021549210108432808078342808941729800898329\" + \"753694064496990312539986391958160146899522088066228540841486427478628197554662\" + \"927881462160717138188018084057208471586890683691939338186427845453795671927239\" + \"797236465166759201105799566396259853551276355876814021340982901629687342985079\" + \"247184605687482833138125916196247615690287590107273310329914062386460833337863\" + \"825792630239159000355760903247728133888733917809696660146961503175422675112599\" + \"331552967421333630022296490648093458200818106180210022766458040027821333675857\" + \"301901137175467276305904435313131903609248909724642792845554991349000518029570\" + \"708291905255678188991389962513866231938005361134622429461024895407240485712325\" + \"662888893172211643294781619055486805494344103409068071608802822795968695013364\" + \"381426825217047287086301013730115523686141690837567574763723976318575703810944\" + \"339056456446852418302814810799837691851212720193504404180460472162693944578837\" + \"709010597469321972055811407877598977207200968938224930323683051586265728111463\" + \"799698313751793762321511125234973430524062210524423435373290565516340666950616\" + \"589287821870775679417608071297378133518711793165003315552382248773065344417945\" + \"341539520242444970341012087407218810938826816751204229940494817944947273289477\" + \"011157413944122845552182842492224065875268917227278060711675404697300803703961\" + \"878779669488255561467438439257011582954666135867867189766129731126720007297155\" + \"361302750355616781776544228744211472988161480270524380681765357327557860250584\" + \"708401320883793281600876908130049249147368251703538221961903901499952349538710\" + \"599735114347829233949918793660869230137559636853237380670359114424326856151210\" + \"940425958263930167801712866923928323105765885171402021119695706479981403150563\" + \"304514156441462316376380990440281625691757648914256971416359843931743327023781\" + \"233693804301289262637538266779503416933432360750024817574180875038847509493945\" + \"489620974048544263563716499594992098088429479036366629752600324385635294584472\" + \"894454716620929749549661687741412088213047702281611645604400723635158114972973\" + \"921896673738264720472264222124201656015028497130633279581430251601369482556701\" + \"478093579088965713492615816134690180696508955631012121849180584792272069187169\" + \"631633004485802010286065785859126997463766174146393415956953955420331462802651\" + \"895116793807457331575984608617370268786760294367778050024467339133243166988035\" + \"407323238828184750105164133118953703648842269027047805274249060349208295475505\" + \"400345716018407257453693814553117535421072655783561549987444748042732345788006\" + \"187314934156604635297977945507535930479568720931672453654720838168585560604380\" + \"197703076424608348987610134570939487700294617579206195254925575710903852517148\" + \"852526567104534981341980339064152987634369542025608027761442191431892139390883\" + \"454313176968510184010384447234894886952098194353190650655535461733581404554483\" + \"788475252625394966586999205841765278012534103389646981864243003414679138061902\" + \"805960785488801078970551694621522877309010446746249797999262712095168477956848\" + \"258334140226647721084336243759374161053673404195473896419789542533503630186140\" + \"095153476696147625565187382329246854735693580289601153679178730355315937836308\" + \"224861517777054157757656175935851201669294311113886358215966761883032610416465\" + \"171484697938542262168716140012237821377977413126897726671299202592201740877007\" + \"695628347393220108815935628628192856357189338495885060385315817976067947984087\" + \"836097596014973342057270460352179060564760328556927627349518220323614411258418\" + \"242624771201203577638889597431823282787131460805353357449429762179678903456816\" + \"988955351850447832561638070947695169908624710001974880920500952194363237871976\" + \"487033922381154036347548862684595615975519376541011501406700122692747439388858\" + \"994385973024541480106123590803627458528849356325158538438324249325266608758890\" + \"831870070910023737710657698505643392885433765834259675065371500533351448990829\" + \"388773735205145933304962653141514138612443793588507094468804548697535817021290\" + \"849078734780681436632332281941582734567135644317153796781805819585246484008403\" + \"290998194378171817730231700398973305049538735611626102399943325978012689343260\" + \"558471027876490107092344388463401173555686590358524491937018104162620850429925\" + \"869743581709813389404593447193749387762423240985283276226660494238512970945324\" + \"558625210360082928664972417491914198896612955807677097959479530601311915901177\" + \"394310420904907942444886851308684449370590902600612064942574471035354765785924\" + \"270813041061854621988183009063458818703875585627491158737542106466795134648758\" + \"677154383801852134828191581246259933516019893559516796893285220582479942103451\" + \"271587716334522299541883968044883552975336128683722593539007920166694133909116\" + \"875880398882886921600237325736158820716351627133281051818760210485218067552664\" + \"867390890090719513805862673512431221569163790227732870541084203784152568328871\" + \"804698795251307326634027851905941733892035854039567703561132935448258562828761\" + \"061069822972142096199350933131217118789107876687204454887608941017479864713788\" + \"246215395593333327556200943958043453791978228059039595992743691379377866494096\" + \"404877784174833643268402628293240626008190808180439091455635193685606304508914\" + \"228964521998779884934747772913279726602765840166789013649050874114212686196986\" + \"204412696528298108704547986155954533802120115564697997678573892018624359932677\" + \"768945406050821883822790983362716712449002676117849826437703300208184459000971\" + \"723520433199470824209877151444975101705564302954282181967000920251561584417420\" + \"593365814813490269311151709387226002645863056132560579256092733226557934628080\" + \"568344392137368840565043430739657406101777937014142461549307074136080544210029\" + \"560009566358897789926763051771878194370676149821756418659011616086540863539151\" + \"303920131680576903417259645369235080641744656235152392905040947995318407486215\" + \"121056183385456617665260639371365880252166622357613220194170137266496607325201\" + \"077194793126528276330241380516490717456596485374835466919452358031530196916048\" + \"099460681490403781982973236093008713576079862142542209641900436790547904993007\" + \"837242158195453541837112936865843055384271762803527912882112930835157565659994\" + \"474178843838156514843422985870424559243469329523282180350833372628379183021659\" + \"183618155421715744846577842013432998259456688455826617197901218084948033244878\" + \"725818377480552226815101137174536841787028027445244290547451823467491956418855\" + \"124442133778352142386597992598820328708510933838682990657199461490629025742768\" + \"603885051103263854454041918495886653854504057132362968106914681484786965916686\" + \"184275679846004186876229805556296304595322792305161672159196867584952363529893\" + \"578850774608153732145464298479231051167635774949462295256949766035947396243099\" + \"534331040499420967788382700271447849406903707324910644415169605325656058677875\" + \"741747211082743577431519406075798356362914332639781221894628744779811980722564\" + \"671466405485013100965678631488009030374933887536418316513498254669467331611812\" + \"336485439764932502617954935720430540218297487125110740401161140589991109306249\" + \"231281311634054926257135672181862893278613883371802853505650359195274140086951\" + \"092616754147679266803210923746708721360627833292238641361959412133927803611827\" + \"632410600474097111104814000362334271451448333464167546635469973149475664342365\" + \"949349684588455152415075637660508663282742479413606287604129064491382851945640\" + \"264315322585862404314183866959063324506300039221319264762596269151090445769530\" + \"144405461803785750303668621246227863975274666787012100339298487337501447560032\" + \"210062235802934377495503203701273846816306102657030087227546296679688089058712\" + \"767636106622572235222973920644309352432722810085997309513252863060110549791564\" + \"479184500461804676240892892568091293059296064235702106152464620502324896659398\" + \"732493396737695202399176089847457184353193664652912584806448019652016283879518\" + \"949933675924148562613699594530728725453246329152911012876377060557060953137752\" + \"775186792329213495524513308986796916512907384130216757323863757582008036357572\" + \"800275449032795307990079944254110872569318801466793559583467643286887696661009\" + \"739574996783659339784634695994895061049038364740950469522606385804675807306991\" + \"229047408987916687211714752764471160440195271816950828973353714853092893704638\" + \"442089329977112585684084660833993404568902678751600877546126798801546585652206\" + \"121095349079670736553970257619943137663996060606110640695933082817187642604357\" + \"342536175694378484849525010826648839515970049059838081210522111109194332395113\" + \"605144645983421079905808209371646452312770402316007213854372346126726099787038\" + \"565709199850759563461324846018840985019428768790226873455650051912154654406382\" + \"925385127631766392205093834520430077301702994036261543400132276391091298832786\" + \"392041230044555168405488980908077917463609243933491264116424009388074635660726\" + \"233669584276458369826873481588196105857183576746200965052606592926354829149904\" + \"576830721089324585707370166071739819448502884260396366074603118478622583105658\" + \"087087030556759586134170074540296568763477417643105175103673286924555858208237\" + \"203860178173940517513043799486882232004437804310317092103426167499800007301609\" + \"481458637448877852227307633049538394434538277060876076354209844500830624763025\" + \"357278103278346176697054428715531534001649707665719598504174819908720149087568\" + \"603778359199471934335277294728553792578768483230110185936580071729118696761765\" + \"505377503029303383070644891281141202550615089641100762382457448865518258105814\" + \"034532012475472326908754750707857765973254284445935304499207001453874894822655\" + \"644222369636554419422544133821222547749753549462482768053333698328415613869236\" + \"344335855386847111143049824839899180316545863828935379913053522283343013795337\" + \"295401625762322808113849949187614414132293376710656349252881452823950620902235\" + \"787668465011666009738275366040544694165342223905210831458584703552935221992827\" + \"276057482126606529138553034554974455147034493948686342945965843102419078592368\" + \"022456076393678416627051855517870290407355730462063969245330779578224594971042\" + \"018804300018388142900817303945050734278701312446686009277858181104091151172937\" + \"487362788787490746528556543474888683106411005102302087510776891878152562273525\" + \"155037953244485778727761700196485370355516765520911933934376286628461984402629\" + \"525218367852236747510880978150709897841308624588152266096355140187449583692691\" + \"779904712072649490573726428600521140358123107600669951853612486274675637589622\" + \"529911649606687650826173417848478933729505673900787861792535144062104536625064\" + \"046372881569823231750059626108092195521115085930295565496753886261297233991462\" + \"835847604862762702730973920200143224870758233735491524608560821032888297418390\" + \"647886992327369136004883743661522351705843770554521081551336126214291181561530\" + \"175888257359489250710887926212864139244330938379733386780613179523731526677382\" + \"085802470143352700924380326695174211950767088432634644274912755890774686358216\" + \"216604274131517021245858605623363149316464691394656249747174195835421860774871\" + \"105733845843368993964591374060338215935224359475162623918868530782282176398323\" + \"730618020424656047752794310479618972429953302979249748168405289379104494700459\" + \"086499187272734541350810198388186467360939257193051196864560185578245021823106\" + \"588943798652243205067737996619695547244058592241795300682045179537004347245176\" + \"289356677050849021310773662575169733552746230294303120359626095342357439724965\" + \"921101065781782610874531887480318743082357369919515634095716270099244492974910\" + \"548985151965866474014822510633536794973714251022934188258511737199449911509758\" + \"374613010550506419772153192935487537119163026203032858865852848019350922587577\" + \"559742527658401172134232364808402714335636754204637518255252494432965704386138\" + \"786590196573880286840189408767281671413703366173265012057865391578070308871426\" + \"151907500149257611292767519309672845397116021360630309054224396632067432358279\" + \"788933232440577919927848463333977773765590187057480682867834796562414610289950\" + \"848739969297075043275302997287229732793444298864641272534816060377970729829917\" + \"302929630869580199631241330493935049332541235507105446118259114111645453471032\" + \"988104784406778013807713146540009938630648126661433085820681139583831916954555\" + \"825942689576984142889374346708410794631893253910696395578070602124597489829356\" + \"461356078898347241997947856436204209461341238761319886535235831299686226894860\" + \"840845665560687695450127448663140505473535174687300980632278046891224682146080\" + \"672762770840240226615548502400895289165711761743902033758487784291128962324705\" + \"919187469104200584832614067733375102719565399469716251724831223063391932870798\" + \"380074848572651612343493327335666447335855643023528088392434827876088616494328\" + \"939916639921048830784777704804572849145630335326507002958890626591549850940797\" + \"276756712979501009822947622896189159144152003228387877348513097908101912926722\" + \"710377889805396415636236416915498576840839846886168437540706512103906250612810\" + \"766379904790887967477806973847317047525344215639038720123880632368803701794930\" + \"895490077633152306354837425681665336160664198003018828712376748189833024683637\" + \"148830925928337590227894258806008728603885916884973069394802051122176635913825\" + \"152427867009440694235512020156837777885182467002565170850924962374772681369428\" + \"435006293881442998790530105621737545918267997321773502936892806521002539626880\" + \"749809264345801165571588670044350397650532347828732736884086354000274067678382\" + \"196352222653929093980736739136408289872201777674716811819585613372158311905468\" + \"293608323697611345028175783020293484598292500089568263027126329586629214765314\" + \"223335179309338795135709534637718368409244442209631933129562030557551734006797\" + \"374061416210792363342380564685009203716715264255637185388957141641977238742261\" + \"059666739699717316816941543509528319355641770566862221521799115135563970714331\" + \"289365755384464832620120642433801695586269856102246064606933079384785881436740\" + \"700059976970364901927332882613532936311240365069865216063898725026723808740339\" + \"674439783025829689425689674186433613497947524552629142652284241924308338810358\" + \"005378702399954217211368655027534136221169314069466951318692810257479598560514\" + \"500502171591331775160995786555198188619321128211070944228724044248115340605589\" + \"595835581523201218460582056359269930347885113206862662758877144603599665610843\" + \"072569650056306448918759946659677284717153957361210818084154727314266174893313\" + \"417463266235422207260014601270120693463952056444554329166298666078308906811879\" + \"009081529506362678207561438881578135113469536630387841209234694286873083932043\" + \"233387277549680521030282154432472338884521534372725012858974769146080831440412\" + \"586818154004918777228786980185345453700652665564917091542952275670922221747411\" + \"206272065662298980603289167206874365494824610869736722554740481288924247185432\" + \"360575341167285075755205713115669795458488739874222813588798584078313506054829\" + \"055148278529489112190538319562422871948475940785939804790109419407067176443903\" + \"273071213588738504999363883820550168340277749607027684488028191222063688863681\" + \"104356952930065219552826152699127163727738841899328713056346468822739828876319\" + \"864570983630891778648708667618548568004767255267541474285102814580740315299219\" + \"781455775684368111018531749816701642664788409026268282444825802753209454991510\" + \"451851771654631180490456798571325752811791365627815811128881656228587603087597\" + \"496384943527567661216895926148503078536204527450775295063101248034180458405943\" + \"292607985443562009370809182152392037179067812199228049606973823874331262673030\" + \"679594396095495718957721791559730058869364684557667609245090608820221223571925\" + \"453671519183487258742391941089044411595993276004450655620646116465566548759424\" + \"736925233695599303035509581762617623184956190649483967300203776387436934399982\" + \"943020914707361894793269276244518656023955905370512897816345542332011497599489\" + \"627842432748378803270141867695262118097500640514975588965029300486760520801049\" + \"153788541390942453169171998762894127722112946456829486028149318156024967788794\" + \"981377721622935943781100444806079767242927624951078415344642915084276452000204\" + \"276947069804177583220909702029165734725158290463091035903784297757265172087724\" + \"474095226716630600546971638794317119687348468873818665675127929857501636341131\" + \"462753049901913564682380432997069577015078933772865803571279091376742080565549\" + \"362541\").toString(); } ``` Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge 123456 allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor. Suchen Sie die 4-stellige Ziffernfolge, die am h\u00e4ufigsten in den ersten 100 000 Nachkommastellen von \u03c0 vorkommt. Tipps Schauen Sie sich dazu die Klasse String genauer an! \u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also \"0000\", \"0001\", \"0002\", ... \"9999\" ) Schreiben Sie sich eine Methode int nrOfOccurences(String sub, String str) , die die Anzahl des Vorkommens von sub in str z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie sub=\"0000\" setzen und str=pi \u2192 \"0000\" kommt 9 Mal in pi vor. Testen Sie auch sub=\"2541\" und str=pi , denn \"2541\" ist der allerletzte substring in unserem pi und kommt 8 Mal vor. Merken Sie sich das bisherige maximale Vorkommen eines bestimmten substrings in pi \u2192 Sie merken sich den String und wie oft er vorkam (wenn er h\u00e4ufiger vorkam als der, den Sie sich bis dahin als h\u00e4ufigstes Vorkommen gemerkt hatten). Am Ende haben Sie sich dann den String gemerkt, der am h\u00e4ufigsten vorkommt und auch die Anzahl der Vorkommen. Viel Spa\u00df! m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 Uebung4.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package uebungen.uebung4 ; public class Uebung4 { public static int nrOfOccurrences ( String sub , String str ) { int nrOfOccurrences = 0 ; final int LENGTH_OF_SUBSTRING = sub . length (); for ( int index = 0 ; index <= str . length () - LENGTH_OF_SUBSTRING ; index ++ ) { if ( str . substring ( index , index + LENGTH_OF_SUBSTRING ). equals ( sub )) { nrOfOccurrences ++ ; } } return nrOfOccurrences ; } public static void testAllCombinations ( String str ) { String sub = \"\" ; int maxOcc = 0 ; String maxSub = \"\" ; for ( int i1 = 0 ; i1 < 10 ; i1 ++ ) { for ( int i2 = 0 ; i2 < 10 ; i2 ++ ) { for ( int i3 = 0 ; i3 < 10 ; i3 ++ ) { for ( int i4 = 0 ; i4 < 10 ; i4 ++ ) { sub = String . valueOf ( i1 ) + String . valueOf ( i2 ) + String . valueOf ( i3 ) + String . valueOf ( i4 ); int nrOfOccurrences = nrOfOccurrences ( sub , str ); if ( nrOfOccurrences >= maxOcc ) { maxOcc = nrOfOccurrences ; maxSub = sub ; System . out . println ( maxOcc + \" \" + maxSub ); } } } } } } public static void main ( String [] args ) { String pi = StringPi . PI ; int nrOO = nrOfOccurrences ( \"2541\" , pi ); System . out . println ( nrOO ); testAllCombinations ( pi ); } } \u00dcbung 5 (enum und zweidimensionale Arrays) \u00b6 \u00dcbung 5 (10. + 12.5.) Gegeben ist die folgende Klasse TicTacToe : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package uebungen.uebung5 ; public class TicTacToe { ??? hier soll ein enum definiert werden ??? State [][] field ; public TicTacToe () { field = new ??? welcher Typ ???[ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } public void makeMove ( int i , int j , ??? welcher Typ ??? player ) { if ( field [ i ][ j ]==??? was kommt hier hin ??? && player !=??? was kommt hier hin ??? ) field [ i ][ j ]= player ; } } F\u00fcgen Sie die ??? ... ??? korrekt aus. F\u00fcgen Sie alle notwendigen Klammern { } ein, so dass die Anweisungsbl\u00f6cke korrekt geklammert sind. Erweitern Sie die Klasse TicTacToe um eine print() -Methode, die das Spielfeld auf die Konsole ausgibt (Setzen Sie z.B. f\u00fcr den Player RED ein x und f\u00fcr den Player Black ein o und f\u00fcr EMPTY ein Leerzeichen oder ein - ). Die Ausgabe nach jeweils 2 Z\u00fcgen von RED und BLACK k\u00f6nnte dann z.B. so aussehen: - o o - x - - - x Erweitern Sie die Klasse TicTacToe um eine gewonnen() -Methode ( true , wenn ein Spieler drei Felder horizontal, diagonal oder vertikal belegt hat; ansonsten false ). Erweitern Sie die Klasse TicTacToe um eine unentschieden() -Methode ( true , wenn alle Felder besetzt sind, aber kein Spieler gewonnen hat; ansonsten false ). Erstellen Sie eine Test-Klasse mit main() -Methode. Erstellen sie darin ein Objekt der Klasse TicTacToe . F\u00fchren Sie Z\u00fcge aus ( makeMove() ) und pr\u00fcfen Sie, ob gewonnen wurde oder unentschieden ist (mit entsprechenden Ausgaben). F\u00fcr 7. m\u00fcssen Sie in der Testklasse Ihr enum State importieren. Warum ist das so? Was k\u00f6nnten Sie machen, damit das nicht notwendig ist? Zusatz: Sie k\u00f6nnen die Klasse TicTacToe beliebig erweitern, z.B.: um Ausgaben, wenn gewonnen bzw. es unentschieden ist, um Fehler in den Indizes i und j bei der makeMove() -Methode abzufangen, eine Methode spielen() implementieren, die zuf\u00e4llig f\u00fcr die Spieler die Steine setzt usw. Viel Spa\u00df! m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 package uebungen.uebung5 ; import java.util.Random ; public class TicTacToe { State [][] field ; public TicTacToe () { this . field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < this . field . length ; i ++ ) { for ( int j = 0 ; j < this . field [ i ] . length ; j ++ ) { field [ i ][ j ]= State . EMPTY ; } } } public void makeMove ( int row , int col , State player ) { if ( row >= 0 && row < this . field . length && col >= 0 && col < this . field [ row ] . length && this . field [ row ][ col ] == State . EMPTY ) { if ( player != State . EMPTY ) { this . field [ row ][ col ]= player ; } } } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { System . out . print ( \"- \" ); } else if ( field [ row ][ col ]== State . RED ) { System . out . print ( \"x \" ); } else // BLACK { System . out . print ( \"o \" ); } } System . out . println (); } System . out . println (); } public boolean gewonnen ( State player ) { if ( player == State . EMPTY ) return false ; // alle drei Zeilen pruefen for ( int row = 0 ; row < this . field . length ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { return true ; } } // alle drei Spalten pruefen for ( int col = 0 ; col < this . field . length ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { return true ; } } // Diagonale von links oben nach rechts unten if ( this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { return true ; } // Diagonale von rechts oben nach links unten if ( this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { return true ; } return false ; } public void printResultat () { if ( this . gewonnen ( State . RED )) { System . out . println ( \"Rot hat gewonnen!!!\" ); } else if ( this . gewonnen ( State . BLACK )) { System . out . println ( \"Schwarz hat gewonnen!!!\" ); } else if ( this . unentschieden ()) { System . out . println ( \"Unentschieden!!!\" ); } } public void makeRandomMove ( State player ) { if ( player != State . EMPTY ) { Random r = new Random (); int row = r . nextInt ( 3 ); int col = r . nextInt ( 3 ); while ( this . field [ row ][ col ]!= State . EMPTY ) { row = r . nextInt ( 3 ); col = r . nextInt ( 3 ); } this . field [ row ][ col ]= player ; } } public void spielen () { State player = State . RED ; while ( ! ( this . unentschieden () || this . gewonnen ( State . RED ) || this . gewonnen ( State . BLACK ))) { this . makeRandomMove ( player ); this . print (); this . printResultat (); if ( player == State . RED ) { player = State . BLACK ; } else { player = State . RED ; } // player = (player == State.RED) ? State.BLACK : State.RED; } } public boolean voll () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { return false ; } } } return true ; } public boolean unentschieden () { return ( this . voll () && ! this . gewonnen ( State . RED ) && ! this . gewonnen ( State . BLACK )); } } State.java 1 2 3 4 5 package uebungen.uebung5 ; public enum State { EMPTY , RED , BLACK } TestTicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package uebungen.uebung5 ; public class TestTicTacToe { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe (); ttt . print (); /* ttt.makeMove(1, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 2, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, -1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 0, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 2, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 2, State.RED); ttt.printResultat(); ttt.print(); */ ttt . spielen (); // ttt.makeRandomMove(State.RED); // ttt.print(); } } \u00dcbung 6 (Listen und Mengen) \u00b6 \u00dcbung 6 (17. + 19.5.) Erstellen Sie eine Klasse Uebung6 mit main() -Methode. Definieren Sie in der main() -Methode eine Variable words vom Typ String[] und weisen Sie dieser Variablen folgende Werte zu: String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; A. Listen ( List ) Erstellen Sie eine Methode public static List<String> createArrayList(String[] words) . In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Liste ( List ) zur\u00fcck. Erstellen Sie eine Methode public static void printList(List<String> list) . Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. Erstellen Sie in der main() -Methode mithilfe der Methode createArrayList(words) eine Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String> . Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. Studieren Sie alle Methoden f\u00fcr List unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html . Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox L\u00f6schen Sie die Werte \"Apple\" , \"Google\" und \"Facebook\" . Geben Sie die Liste erneut mithilfe der printList(list) -Methode aus. B. Mengen ( Set ) Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words) . In dieser Methode soll eine HashSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie eine Methode public static void printSet(Set<String> set) . Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. Erstellen Sie in der main() -Methode mithilfe der Methode createHashSet(words) eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String> . Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so? Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words) . In dieser Methode soll eine TreeSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Menge ( Set ) mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie in der main() -Methode mithilfe der Methode createTreeSet(words) eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet ? Zusatz Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list) . Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der printList() -Methode in der main() -Methode aus. M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) Liste mit 16 Elementen : -------------------------- Linux Apple Facebook Amazon IBM Lenovo Google IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Index des ersten Auftretens von Apple : 1 Index des letzten Auftretens von Apple : 9 erstes Element in der Liste : Linux letztes Element in der Liste : Firefox Liste mit 13 Elementen : -------------------------- Linux Amazon IBM Lenovo IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Doublets- Liste mit 4 Elementen : -------------------------- Linux IBM IBM Linux ohne Doublets- Liste mit 9 Elementen : -------------------------- Amazon Lenovo Microsoft Apple Google Twitter Skype Chrome Firefox Menge mit 12 Elementen : -------------------------- Lenovo Google Apple Skype Linux IBM Twitter Chrome Microsoft Amazon Facebook Firefox Menge mit 12 Elementen : -------------------------- Amazon Apple Chrome Facebook Firefox Google IBM Lenovo Linux Microsoft Skype Twitter m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Uebung6.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 package uebungen.uebung5.loesung ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Uebung6 { //A1. Erstellen Sie eine Methode public static List<String> createArrayList(String[] words). //In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. Die Methode gibt die bef\u00fcllte Liste (List) zur\u00fcck. public static List < String > createArrayList ( String [] words ){ // neue ArrayList mit String als Type anlegen List < String > list = new ArrayList <> (); // jedes Element aus words in die Liste einf\u00fcgen for ( int i = 0 ; i < words . length ; i ++ ) { list . add ( words [ i ] ); } return list ; } //A2. Erstellen Sie eine Methode public static void printList(List<String> list). //Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Liste aus. public static void printList ( List < String > list ) { //Variante 1: Iterator System . out . println ( \"--Iterator--\" ); Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } //Variante 2: for-Schleife System . out . println ( \"--Schleife--\" ); for ( String s : list ) { System . out . println ( s ); } //Anzahl der Elemente ausgeben System . out . println ( \"Die Liste hat \" + list . size () + \" Elemente.\" ); } //B1. Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words). //In dieser Methode soll eine HashSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createHashSet ( String [] words ) { Set < String > set = new HashSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //B2. Erstellen Sie eine Methode public static void printSet(Set<String> set). //Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Menge aus. public static void printSet ( Set < String > set ) { for ( String s : set ) { System . out . println ( s ); } System . out . println ( \"Das Set hat \" + set . size () + \" Elemente.\" ); } //B4. Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words). //In dieser Methode soll eine TreeSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Menge (Set) mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createTreeSet ( String [] words ) { Set < String > set = new TreeSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //Zusatz: Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list). //Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. //Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. //Geben Sie diese Liste mithilfe der printList()-Methode in der main()-Methode aus. public static List < String > findDoublets ( List < String > list ) { //Grundidee //Beispiel-Liste: \"a\" \"b\" \"a\" \"c\" \"a\" //Index: 0 1 2 3 4 //Inhalt: a b a c a //erster Index von \"a\": 0 //letzter Index von \"a\":4 //0 != 4 -> es gibt Duplikate //erster Index von \"b\":1 //letzter Index von \"b\":1 //1 == 1 -> keine Duplikate, also diesen Eintrag als Einzeleintrag merken //... //leere Liste \"singles\" f\u00fcr Einzeleintr\u00e4ge anlegen List < String > singles = new ArrayList <> (); //durch list iterieren und testen ob das Element Duplikate hat, //wenn nicht in \"singles\" speichern Iterator < String > it = list . iterator (); //it = copy.iterator(); while ( it . hasNext ()) { String s = it . next (); if ( list . indexOf ( s ) == list . lastIndexOf ( s )) singles . add ( s ); } //Kopie von list anlegen List < String > copy = new ArrayList <> (); it = list . iterator (); while ( it . hasNext ()) copy . add ( it . next ()); //alle singles aus der kopierten Liste entfernen copy . removeAll ( singles ); return copy ; //um zu testen, warum die Kopie n\u00f6tig ist: //copy.removeAll(singles); und return copy; ersetzen durch //list.removeAll(singles); //return list; //und dann die Ausgabe von l2 in der main anschauen } public static void main ( String [] args ) { String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; System . out . println ( \"---------- A ----------\" ); //A3. Erstellen Sie in der main()-Methode mithilfe der Methode createArrayList(words) eine //Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String>. List < String > l1 = createArrayList ( words ); //Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. printList ( l1 ); //A4. Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 System . out . println ( \"Index des ersten Auftretens von Apple: \" + l1 . indexOf ( \"Apple\" )); //Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 System . out . println ( \"Index des letzten Auftretens von Apple: \" + l1 . lastIndexOf ( \"Apple\" )); //Geben Sie den Wert des ersten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux System . out . println ( \"erstes Element der Liste: \" + l1 . get ( 0 )); //Geben Sie den Wert des letzten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox System . out . println ( \"letztes Element der Liste: \" + l1 . get ( l1 . size () - 1 )); //L\u00f6schen Sie die Werte \"Apple\", \"Google\" und \"Facebook\". //Geben Sie die Liste erneut mithilfe der printList(list)-Methode aus. //1. M\u00f6glichkeit: nur 1. Vorkommen l\u00f6schen l1 . remove ( \"Apple\" ); l1 . remove ( \"Google\" ); l1 . remove ( \"Facebook\" ); printList ( l1 ); //2. M\u00f6glichkeit: alle l\u00f6schen while ( l1 . remove ( \"Apple\" )); while ( l1 . remove ( \"Google\" )); while ( l1 . remove ( \"Facebook\" )); printList ( l1 ); System . out . println ( \"---------- B ----------\" ); System . out . println ( \"-------HashSet------\" ); //B3. Erstellen Sie in der main()-Methode mithilfe der Methode createHashSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String>. Set < String > h1 = createHashSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente //in der Liste? Warum ist das so? printSet ( h1 ); System . out . println ( \"-------TreeSet------\" ); //B5. Erstellen Sie in der main()-Methode mithilfe der Methode createTreeSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen. Set < String > t1 = createTreeSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet? printSet ( t1 ); System . out . println ( \"-------Duplicates------\" ); List < String > l2 = createArrayList ( words ); List < String > d = findDoublets ( l2 ); printList ( d ); printList ( l2 ); } } \u00dcbung 7 (Maps) \u00b6 \u00dcbung 7 (31.5. - 2.6.) Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: String name; List<Integer> bevoelkerung; float flaeche; Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor public Stadt(String name, List<Integer> bevoelkerung, float flaeche) , der die Objektvariablen initialisiert. Erstellen Sie f\u00fcr die Klasse Stadt eine print() -Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Erstellen Sie eine Klasse StadtTest mit main() -Methode. Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } Liste Erstellen Sie in der main() -Methode eine List<Stadt> staedteListe = new ArrayList<>(); . F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Menge Erstellen Sie in der main() -Methode eine Set<Stadt> staedteMenge = new HashSet<>(); . F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? Stadt - Teil 2 Implementieren Sie in der Klasse Stadt die equals(Object) - und die hashCode() -Methode. F\u00fchren Sie danach die StadtTest -Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? Maps Erstellen Sie in der main() -Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>(); . F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer -Wert beginnend mit 1 als Key sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array als Value hinzu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys . Ausgaben ------------ Liste -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 ------------ Menge -------------- Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 von Frau Busjahn vorkommentierten Klassen Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Objektvariablen initialisieren this . ??? = ??? ; ... } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //import //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package uebungen.uebung7 ; import java.util.* ; //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt implements Comparable //Der Teil mit \"implements\" wird nicht von Anfang an ben\u00f6tigt, es kann also auch erstmal mit \"public class Stadt\" begonnen werden. //W\u00e4hrend es bei primitiven Datentypen meist eindeutig ist, ob ein Wert gr\u00f6\u00dfer, kleiner oder gleich gro\u00df ist wie ein anderer Wert, ist die Ordnung bei Objekten nicht so klar. //Daher muss Stadt Klasse ein bestimmtes Interface implementieren, um festzulegen, was verglichen werden soll. { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen System . out . printf ( \"%-15s %9.2f km2 \" , this . name , this . flaeche ); for ( Integer el : this . bevoelkerung ) { System . out . printf ( \"%,10d\" , el ); } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben Stadt stadt = ( Stadt ) o ; return this . name . equals ( stadt . name ); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } //Festlegen, dass der Name des \u00fcbergebenen Stadt-Objekts o mit dem Namen des aktuellen Stadt-Objekts verglichen werden soll @Override public int compareTo ( Object o ) { Stadt stadt = ( Stadt ) o ; return this . name . compareTo ( stadt . name ); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package uebungen.uebung7 ; //import import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Liste -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen Stadt [] staedte = staedte (); for ( Stadt stadt : staedte ) { staedteListe . add ( stadt ); } //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. for ( Stadt stadt : staedteListe ) { stadt . print (); } //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n%n------------------------- Menge -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge1 = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt stadt : staedte ()) { staedteMenge1 . add ( stadt ); } //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben for ( Stadt stadt : staedteMenge1 ) { stadt . print (); } //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? //Notieren Sie sich die Reihenfolge, in der St\u00e4dte ausgegeben werden. //\u00c4ndern Sie den Konstruktor von HashSet<>() in TreeSet<>(). Was passiert und warum? Set < Stadt > staedteMenge2 = new TreeSet <> (); //analog zu oben System . out . printf ( \"%n%n------------------------- Maps -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); Integer number = 1 ; for ( Stadt stadt : staedte ()) { staedteMap . put ( number , stadt ); number ++ ; } // Stadt berlin = staedte[0]; // staedteMap.put(2, berlin); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . printf ( \"%-3d\" , eintrag . getKey ()); Stadt stadt = eintrag . getValue (); stadt . print (); } //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte System . out . printf ( \"%n%n------------------------- Test compareTo -------------------------%n%n\" ); System . out . println ( \"Berlin\" . compareTo ( \"Anton\" )); System . out . println ( \"Anton\" . compareTo ( \"Berlin\" )); System . out . println ( \"Berlin\" . compareTo ( \"Berlin\" )); System . out . println ( \"Anton\" . compareTo ( \"Zeppelin\" )); } } MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package uebungen.uebung8 ; public class MyInteger implements Comparable < MyInteger > { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public int compareTo ( MyInteger o ) { return - ( this . value - o . value ); } } \u00dcbung 8 (Interfaces) \u00b6 \u00dcbung 8 (7.6. - 9.6.) Wir besch\u00e4ftigen uns nochmal mit der \u00dcbung 7, d.h. mit Stadt und StadtTest . Dieses Mal geht es uns aber mehr um die Verwendung des Interfaces Comparable . Zun\u00e4chst sind die beiden Klassen Stadt und StadtTest wie folgt gegeben (das haben wir so in \u00dcbung 7 erarbeitet - es gibt eine \u00c4nderung in StadtTest , dort benutzen wir jetzt ): Stadt.java import java.util.* ; public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } } StadtTest.java public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); Set < Stadt > staedteMenge = new HashSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); Map < MyInteger , Stadt > staedteMap = new HashMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { staedteMap . put ( new MyInteger ( i ++ ), s ); } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } F\u00fcr die Schl\u00fcssel in der Map benutzen wir die selbstgeschriebne Klasse MyInteger : MyInteger.java public class MyInteger { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } } \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Set von HashSet nach TreeSet und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen ( Stadt cannot be cast to class java.lang.Comparable ). Implementieren Sie f\u00fcr Stadt das Interface Comparable<Stadt> so, dass nach den Namen der St\u00e4dte sortiert wird. F\u00fchren Sie dann erneut StadtTest.java aus. Es sollte folgende Ausgabe f\u00fcr die Set erzeugt werden: ------------ Menge -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 \u00c4ndern Sie compareTo() in Stadt so, dass die Namen der St\u00e4dte absteigend sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Menge -------------- Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 \u00c4ndern Sie compareTo() in Stadt so, dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Menge -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Map von HashMap nach TreeMap und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen ( MyInteger cannot be cast to class java.lang.Comparable ). Implementieren Sie f\u00fcr MyInteger das Interface Comparable<MyInteger> so, dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. F\u00fchren Sie dann erneut StadtTest.java aus. Es sollte folgende Ausgabe f\u00fcr die Map erzeugt werden: ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 \u00c4ndern Sie compareTo() in MyInteger so, dass die Werte der Schl\u00fcssel absteigend sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Maps -------------- 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Zusatz : Schreiben Sie in StadtTest.java eine Methode public static boolean contains(Map<MyInteger, Stadt> staedteMap, Stadt stadt) , die ein true zur\u00fcckgibt, wenn die Stadt stadt bereits in der staedteMap als ein value existiert. Tipp : Die Methode get(Object key) aus Map gibt den zu key geh\u00f6rigen value zur\u00fcck und mit keySet() bekommt man die Menge aller keys aus der Map ermittelt. Testen Sie die Methode, indem Sie zur Menge nur dann die stadt hinzuf\u00fcgen, wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. Sie sollten folgende Ausgabe erhalten: ------------ Maps -------------- 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Vorkommentierte Klassen : Stadt.java import java.util.* ; //3. Implementieren Sie f\u00fcr Stadt das Interface Comparable<Stadt> so, //dass nach den Namen der St\u00e4dte sortiert wird. public class Stadt implements ?/ extends ? Comparable < Stadt > { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } //3. \u00c4ndern Sie compareTo() in Stadt so, dass nach den Namen der //St\u00e4dte sortiert werden kann. //4. \u00c4ndern Sie compareTo() in Stadt so, dass die Namen der //St\u00e4dte absteigend sortiert werden //5. \u00c4ndern Sie compareTo() in Stadt so, //dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden. //Beispiel aus dem Script //@Override //public int compareTo(Circle o) { // if(this.radius > o.radius) return 1; // else if(this.radius < o.radius) return -1; // else return 0; // this.radius == o.radius //} @Override public int compareTo ( ??? ??? ) { } } StadtTest.java import java.util.* ; public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } //Zusatz: Schreiben Sie in StadtTest.java eine Methode //public static boolean contains(Map<MyInteger, Stadt> staedteMap, Stadt stadt), //die ein true zur\u00fcckgibt, wenn die Stadt stadt bereits in der staedteMap als ein //value existiert. //Tipp: Die Methode get(Object key) aus Map gibt den zu key geh\u00f6rigen value zur\u00fcck //und mit keySet() bekommt man die Menge aller keys aus der Map ermittelt. //Testen Sie die Methode, indem Sie zur Menge nur dann die stadt hinzuf\u00fcgen, //wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. public static boolean contains ( Map < MyInteger , Stadt > staedteMap , Stadt stadt ) { //alle Schl\u00fcssel ermitteln mit keySet() //durch alle Schl\u00fcssel iterieren und testen ob der jeweilige Schl\u00fcssel //gleich der \u00fcbergebenen Stadt ist //wird die Stadt gefunden -> return true, sonst false } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); //3. \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der //Set von HashSet nach TreeSet und f\u00fchren Sie die Klasse aus - //es wird eine Exception geworfen (Stadt cannot be cast to //class java.lang.Comparable). Set < Stadt > staedteMenge = new HashSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); //6. \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Map von //HashMap nach TreeMap und f\u00fchren Sie die Klasse aus - es wird eine Exception // geworfen (MyInteger cannot be cast to class java.lang.Comparable). Map < MyInteger , Stadt > staedteMap = new HashMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { //f\u00fcr die Zusatzaufgabe muss hier noch gepr\u00fcft werden, ob s bereits in //der Map vorhanden ist, daf\u00fcr wird die contains-Methode ben\u00f6tigt staedteMap . put ( new MyInteger ( i ++ ), s ); } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } MyInteger.java //6. Implementieren Sie f\u00fcr MyInteger das Interface Comparable<MyInteger> so, //dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. public class MyInteger implements ?/ extends ? ???<???> { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } //7. \u00c4ndern Sie compareTo() in MyInteger so, dass //die Werte der Schl\u00fcssel absteigend sortiert werden. //Beispiel aus dem Script f\u00fcr AUFsteigend sortiert: //public int compareTo(Rectangle o) { // int diff = (this.height+this.width) - (o.height+o.width); // return diff; //} @Override public int compareTo ( ??? ??? ) { } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 8 Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package uebungen.uebung8 ; import java.util.* ; public class Stadt implements Comparable < Stadt > { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } @Override public int compareTo ( Stadt o ) { if ( this . flaeche < o . flaeche ) return 1 ; else if ( this . flaeche > o . flaeche ) return - 1 ; else return 0 ; } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package uebungen.uebung8 ; import java.util.* ; public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static boolean contains ( Map < MyInteger , Stadt > staedteMap , Stadt stadt ) { Set < MyInteger > allKeys = staedteMap . keySet (); for ( MyInteger key : allKeys ) { if ( staedteMap . get ( key ). equals ( stadt )) return true ; } return false ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); Set < Stadt > staedteMenge = new TreeSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); Map < MyInteger , Stadt > staedteMap = new TreeMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { if ( ! contains ( staedteMap , s )) { staedteMap . put ( new MyInteger ( i ++ ), s ); } } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package uebungen.uebung8 ; public class MyInteger implements Comparable < MyInteger > { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public int compareTo ( MyInteger o ) { return - ( this . value - o . value ); } } \u00dcbung 9 (GUI) \u00b6 \u00dcbung 9 (21.6. - 23.6.) Erstellen Sie folgende GUI: vorkommentierte Klasse GUIUebung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //import public class GUIUebung extends JFrame { public GUIUebung () { super (); //Titel //Verhalten beim Schlie\u00dfen //Gr\u00f6\u00dfe //Sichtbarkeit //... //gute Vorlage: //https://freiheit.f4.htw-berlin.de/prog2/gui/#erweitern-des-fensters-um-ein-jpanel } private JPanel initContent () { //Ein paar Tipps: //mehrere Panels verwenden //JTextField hat verschiedene Konstruktoren, nicht nur JTextField(int columns) //Rahmen k\u00f6nnen mit BorderFactory erzeugt werden //Beim FlowLayout \u00e4ndert sich die Gr\u00f6\u00dfe der Steuerelemente nicht, //bei GridLayout passt sich die Gr\u00f6\u00dfe an den Container an } public static void main ( String [] args ) { new GUIUebung (); } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 9 Uebung9.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package uebungen.uebung9 ; import java.awt.* ; import javax.swing.* ; import javax.swing.border.Border ; public class Uebung9 extends JFrame { public Uebung9 () { super (); this . setTitle ( \"GUI \u00dcbung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); Border redline = BorderFactory . createLineBorder ( Color . RED ); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ()); JLabel text1 = new JLabel ( \"Text\" ); text1 . setForeground ( Color . WHITE ); oben . add ( text1 ); oben . setBackground ( Color . BLUE ); oben . setBorder ( redline ); JPanel links = new JPanel (); links . setLayout ( new FlowLayout ( FlowLayout . CENTER , 50 , 50 )); JLabel text2 = new JLabel ( \"Weiterer Text\" ); links . add ( text2 ); JTextField input = new JTextField ( \"Feld\" , 10 ); links . add ( input ); links . setBackground ( Color . LIGHT_GRAY ); JPanel rechts = new JPanel (); rechts . setLayout ( new GridLayout ( 2 , 1 , 20 , 20 )); rechts . add ( new JButton ( \"Button 1\" )); rechts . add ( new JButton ( \"Button 2\" )); rechts . setBackground ( Color . LIGHT_GRAY ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( links , BorderLayout . CENTER ); mainPanel . add ( rechts , BorderLayout . EAST ); return mainPanel ; } public static void main ( String [] args ) { new Uebung9 (); } } sehr hilfreiche Grafiken zur \u00dcbung von Frau Busjahn Unterscheidung zwischen Containern und Steuerelementen: Visualisierung der Panels (Container) in der GUI der \u00dcbung \u00dcbung 10 (JUnit) \u00b6 \u00dcbung 10 (15.6.) Probieren Sie sich mit JUnit aus! Schreiben Sie Unit-Tests f\u00fcr Ihre MyInteger -Klasse aus Aufgabe 2 . m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 10 - Testklasse nicht vollst\u00e4ndig, aber einige Testf\u00e4lle MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package uebungen.uebung10.loesung ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 48 bis 9 ist 57 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { if ( s == null ) throw new IllegalArgumentException ( \"kein String\" ); if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leerer String\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest boolean negativ = false ; if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne fuehrende Nullen while ( s . length () > 0 && s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } if ( s . length () == 0 ) return 0 ; // String bestand nur aus Nullen --> 0 for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int zahl = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { int ziffer = charToInt ( s . charAt ( i )); if (( ! negativ && ( MyInteger . MAX_VALUE - ziffer ) / 10 < zahl ) || ( negativ && ( MyInteger . MAX_VALUE + 1 - ziffer ) / 10 < zahl )) { if ( negativ ) throw new IllegalArgumentException ( \"Zahl zu klein!\" ); else throw new IllegalArgumentException ( \"Zahl zu gross!\" ); } zahl = zahl * 10 + ziffer ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 package uebungen.uebung10.loesung ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.DisplayName ; import org.junit.jupiter.api.Test ; class MyIntegerTest { static MyInteger mi1 , mi2 , mi3 , mi4 , mi5 , mi6 , mi7 ; @BeforeAll public static void setUpBeforeClass () throws Exception { mi1 = new MyInteger ( \"-2147483648\" ); mi2 = new MyInteger ( \"+2147483647\" ); mi3 = new MyInteger ( - 1 ); mi4 = new MyInteger ( 1 ); mi5 = new MyInteger ( 0 ); mi6 = new MyInteger ( \"-1\" ); mi7 = new MyInteger ( 2147483647 ); } /* * parseInt-Testfaelle: * null -> Exception (IAE) kein String * \"\" -> Exception (IAE) leerer String * \"+\" -> Exception (IAE) nur '+' bzw. '-' --> keine Zahl * \"-\" -> Exception (IAE) nur '+' bzw. '-' --> keine Zahl * \"-00000000\" -> 0 * \"+00000000\" -> 0 * \"-00000001\" -> -1 * \"+00000001\" -> 1 * \"123456a\" -> Exception (IAE) keine Zahl! * \"-123456a\" -> Exception (IAE) keine Zahl! * \"+123456a\" -> Exception (IAE) keine Zahl! * \"2147483648\" -> Exception (IAE) Zahl zu gross! * \"-2147483649\" -> Exception (IAE) Zahl zu klein! * */ @Test void testParseIntPositiveInt () { assertEquals ( 1234 , MyInteger . parseInt ( \"1234\" ), \"\\\"1234\\\" should be 1234\" ); assertEquals ( 1234 , MyInteger . parseInt ( \"+1234\" ), \"\\\"+1234\\\" should be 1234\" ); assertEquals ( 1234 , MyInteger . parseInt ( \"01234\" ), \"\\\"01234\\\" should be 1234\" ); } @Test void testParseIntNegativeInt () { assertEquals ( - 1234 , MyInteger . parseInt ( \"-1234\" ), \"\\\"-1234\\\" should be -1234\" ); assertEquals ( - 1234 , MyInteger . parseInt ( \"-01234\" ), \"\\\"-01234\\\" should be -1234\" ); } @Test void testValueOfPositiveInt () { MyInteger m = MyInteger . valueOf ( 1234 ); assertNotNull ( m , \"shoul be an object\" ); assertEquals ( 1234 , m . intValue (), \"1234 should be 1234\" ); } @Test @DisplayName ( \"Input-String is null\" ) void testParseIntNull () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( null )); assertEquals ( \"kein String\" , exception . getMessage ()); } @Test @DisplayName ( \"Input-String is leer\" ) void testParseIntLeer () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"\" )); assertEquals ( \"leerer String\" , exception . getMessage ()); } @Test @DisplayName ( \"Nur Plus oder Minus\" ) void testParseIntNurPlusOderMinus () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"+\" )); assertEquals ( \"nur '+' bzw. '-' --> keine Zahl\" , exception . getMessage ()); exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"-\" )); assertEquals ( \"nur '+' bzw. '-' --> keine Zahl\" , exception . getMessage ()); } @Test @DisplayName ( \"Keine Zahl\" ) void testParseIntKeineZahl () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"+1234a\" )); assertEquals ( \"keine Zahl!\" , exception . getMessage ()); } @Test @DisplayName ( \"Zahl zu gross\" ) void testParseIntZahlZuGross () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"2147483648\" )); assertEquals ( \"Zahl zu gross!\" , exception . getMessage ()); } @Test @DisplayName ( \"Zahl zu klein\" ) void testParseIntZahlZuKlein () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"-2147483649\" )); assertEquals ( \"Zahl zu klein!\" , exception . getMessage ()); } @Test void testParseIntNurNullen () { assertEquals ( 0 , MyInteger . parseInt ( \"-000000000000\" ), \"\\\"-000000000000\\\" should be 0\" ); assertEquals ( 0 , MyInteger . parseInt ( \"+000000000000\" ), \"\\\"+000000000000\\\" should be 0\" ); assertEquals ( 0 , MyInteger . parseInt ( \"0000000000000\" ), \"\\\"0000000000000\\\" should be 0\" ); } @Test void testHashCode () { assertTrue ( mi2 . hashCode () == mi7 . hashCode (), \"hashCode of mi2 and mi7 should be equal\" ); assertEquals ( - 2147483648 , mi1 . hashCode (), \"hashCode of mi1 should be -2147483648\" ); assertEquals ( 0 , mi5 . hashCode (), \"hashCode of mi5 should be 0\" ); } @Test void testMyIntegerInt () { assertNotNull ( mi4 , \"mi4 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testMyIntegerString () { assertNotNull ( mi1 , \"mi1 should be not null\" ); assertNotNull ( mi2 , \"mi2 should be not null\" ); assertNotNull ( mi6 , \"mi6 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testParseInt () { assertEquals ( - 2147483648 , MyInteger . parseInt ( \"-2147483648\" ), \"should be -2147483648\" ); assertEquals ( + 2147483647 , MyInteger . parseInt ( \"+00002147483647\" ), \"should be +2147483647\" ); assertEquals ( - 1 , MyInteger . parseInt ( \"-0000001\" ), \"should be -1\" ); } @Test void testIntValue () { assertEquals ( - 2147483648 , mi1 . intValue (), \"should be -2147483648\" ); assertEquals ( + 2147483647 , mi2 . intValue (), \"should be +2147483647\" ); assertEquals ( + 2147483647 , mi7 . intValue (), \"should be +2147483647\" ); } @Test void testDoubleValue () { assertEquals ( - 2147483648.0 , mi1 . doubleValue (), \"should be -2147483648.0\" ); assertEquals ( + 2147483647.0 , mi2 . doubleValue (), \"should be +2147483647.0\" ); assertEquals ( + 2147483647.0 , mi7 . doubleValue (), \"should be +2147483647.0\" ); } @Test void testValueOfString () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( \"-2147483648\" )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi7\" ); } @Test void testValueOfInt () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( - 2147483648 )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi7\" ); } @Test void testEqualsObject () { assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); assertFalse ( mi3 . equals ( mi4 ), \"mi3 and mi4 should not be equal\" ); assertFalse ( mi3 . equals ( mi5 ), \"mi3 and mi5 should not be equal\" ); } @Test void testToString () { assertEquals ( \"-2147483648\" , mi1 . toString (), \"should be '-2147483648'\" ); assertEquals ( \"2147483647\" , mi2 . toString (), \"should be '2147483647' mi2\" ); assertEquals ( \"2147483647\" , mi7 . toString (), \"should be '2147483647' mi7\" ); } @Test void testCompare () { assertTrue ( MyInteger . compare ( 5 , 4 ) > 0 , \"5,4 should be > 0\" ); assertTrue ( MyInteger . compare ( 4 , 4 ) == 0 , \"4,4 should be == 0\" ); assertTrue ( MyInteger . compare ( 4 , 5 ) < 0 , \"4,5 should be < 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MIN_VALUE ) > 0 , \"MAX,MIN should be > 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MAX_VALUE ) == 0 , \"MAX,MAX should be == 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MIN_VALUE , MyInteger . MAX_VALUE ) < 0 , \"MIN,MAX should be > 0\" ); } @Test void testCompareTo () { assertTrue ( mi1 . compareTo ( mi2 ) < 0 , \"mi1, mi2 should be < 0\" ); assertTrue ( mi2 . compareTo ( mi1 ) > 0 , \"mi2, mi1 should be > 0\" ); assertTrue ( mi2 . compareTo ( mi7 ) == 0 , \"mi2, mi7 should be == 0\" ); assertTrue ( mi3 . compareTo ( mi6 ) == 0 , \"mi3, mi6 should be == 0\" ); } } \u00dcbung 11 (Ereignisbehandlung - ActionListener) \u00b6 \u00dcbung 11 (28.6. - 30.6.) Erstellen Sie ein Fenster mit einem Textfeld und zwei Buttons add und remove . Sowohl das Textfeld als auch die beiden Buttons sollen Objektvariablen (und somit zugreifbar von allen Methoden der Klasse) sein. Unterteilen Sie das main - JPanel zun\u00e4chst in zwei JPanel s unten und oben . Dem JPanel oben werden das Textfeld und die beiden Buttons hinzugef\u00fcgt. Setzen Sie die Hintergrundfarbe des JPanels oben auf YELLOW . Setzen Sie die Hintergrundfarbe des JPanels unten auf CYAN . Das JPanel unten soll ebenfalls eine Objektvariable sein. Setzen Sie die Gr\u00f6\u00dfe des Fensters auf Werte, so dass es wie folgt erscheint: F\u00fcgen Sie folgende Objektvariable hinzu: List<JLabel> labels = new ArrayList<>(); Implementieren Sie den ActionListener wie folgt: Wird der add -Button gedr\u00fcckt, wird der Liste labels ein JLabel hinzugef\u00fcgt, wobei der Text des JLabels dem Text im Textfeld entspricht (der Text des Textfeldes kann \u00fcber die Objektmethode getText() von JTextField ausgelesen werden). Die Liste labels wird vollst\u00e4ndig ausgelesen und jedes JLabel aus labels wird dem JPanel unten mithilfe der add() -Methode von JPanel hinzugef\u00fcgt. Rufen Sie this.unten.revalidate(); auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels unten an. Wird der \u201eremove\u201c-Button gedr\u00fcckt, wird das JLabel aus der Liste labels gel\u00f6scht, das den gleichen Text hat wie der Text, der im Textfeld eingegeben wurde. Au\u00dferdem wird das JLabel aus den JPanel unten entfernt (Objektmethode remove() von JPanel ). Rufen Sie this.unten.revalidate(); auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels unten an. Tipp : wenn Sie einem JLabel eine Hintergrundfarbe mit setBackground(Color c) setzen, dann sieht man diese nur, wenn Sie f\u00fcr dieses JLabel die Methode setOpaque(true) aufrufen. Nur dadurch werden f\u00fcr dieses JLabel alle Pixel gezeichnet, die in dessen Grenzen sind, d.h. das komplette Rechteck, das das JLabel ausf\u00fcllt. Ansonsten w\u00fcrde nur der Text \"gezeichnet\" und die Hintergrundfarbe w\u00e4re hinter dem Text versteckt. vorkommentierte Klasse Uebung11.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //import public class Uebung11 // es werden JFrame und ActionListener ben\u00f6tigt { //Objektvariablen: //1. Textfeld, zwei Buttons (add und remove) //2. unteres Panel //4. Liste mit Labeln public Uebung11 () { super ( \"TITEL\" ); //Verhalten beim Schlie\u00dfen //Gr\u00f6\u00dfe //Sichtbarkeit //... //2. main-JPanel in JPanels unten und oben unterteilen //Dem Panel oben werden das Textfeld und die beiden Buttons hinzugef\u00fcgt, //das lagern wir in die Methode createOben() aus //oben: Hintergrundfarbe ist YELLOW //unten: Hintergrundfarbe ist CYAN //Das Panel unten soll ebenfalls eine Objektvariable sein. //4. neue ArrayList f\u00fcr die Label anlegen } private JPanel createOben () { //... return panel ; } @Override public void actionPerformed ( ActionEvent e ) { //Quelle des Events ermitteln //Falls es der \"add\"-Button ist // - Text aus dem Textfeld \u00fcbernehmen // - neues Label mit dem Text anlegen // - das Label formatieren (Hintergrundfarbe RED) // Tipp: wenn Sie einem JLabel eine Hintergrundfarbe mit setBackground(Color c) // setzen, dann sieht man diese nur, wenn Sie f\u00fcr dieses JLabel die Methode // setOpaque(true) aufrufen. Nur dadurch werden f\u00fcr dieses JLabel alle Pixel // gezeichnet, die in dessen Grenzen sind, d.h. das komplette Rechteck, // das das JLabel ausf\u00fcllt. Ansonsten w\u00fcrde nur der Text \"gezeichnet\" und // die Hintergrundfarbe w\u00e4re hinter dem Text versteckt. // - das Label in Label-Liste einf\u00fcgen // - das Label dem unteren Panel hinzuf\u00fcgen //Falls es der \"remove\"-Button ist // - Text aus dem Textfeld \u00fcbernehmen // - durch die Label-Liste iterieren, um das zu entfernende Label zu finden // Tipp: Iterator nehmen // Iterator<Typ> it = variable.iterator(); // while(it.hasNext()){ // mach irgendwas mit it.next() // } // das Label muss sowohl aus der Liste als auch aus dem Panel entfernt werden //Text im Textfeld l\u00f6schen //weitere n\u00f6tige Schritte requestFocus(), revalidate(), repaint() } public static void main ( String [] args ) { new Uebung11 (); } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 11 Uebung11.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.ArrayList ; import java.util.Iterator ; import java.util.List ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; import javax.swing.JTextField ; public class Uebung11 extends JFrame implements ActionListener { JPanel unten ; JTextField input ; List < JLabel > labels ; JButton addBtn ; JButton removeBtn ; public Uebung11 () { super ( \"Elemente hinzufuegen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setSize ( 400 , 100 ); this . setLocation ( 500 , 500 ); JPanel oben = this . createOben (); this . getContentPane (). add ( oben , BorderLayout . NORTH ); this . unten = new JPanel (); this . unten . setBackground ( Color . CYAN ); this . getContentPane (). add ( unten , BorderLayout . CENTER ); this . setVisible ( true ); this . labels = new ArrayList <> (); } private JPanel createOben () { JPanel panel = new JPanel (); panel . setBackground ( Color . YELLOW ); this . input = new JTextField ( 10 ); this . addBtn = new JButton ( \"add\" ); this . addBtn . addActionListener ( this ); this . removeBtn = new JButton ( \"remove\" ); this . removeBtn . addActionListener ( this ); panel . add ( this . input ); panel . add ( this . addBtn ); panel . add ( this . removeBtn ); return panel ; } @Override public void actionPerformed ( ActionEvent e ){ Object src = e . getSource (); if ( src instanceof JButton ){ JButton srcBtn = ( JButton ) src ; if ( srcBtn == this . addBtn ) { // geht wegen Objektvariable und gleiches Objekt String inputText = this . input . getText (); JLabel newLabel = new JLabel ( inputText ); newLabel . setOpaque ( true ); newLabel . setBackground ( Color . RED ); this . labels . add ( newLabel ); this . unten . add ( newLabel ); } else if ( srcBtn == this . removeBtn ) { String inputText = this . input . getText (); Iterator < JLabel > it = this . labels . iterator (); while ( it . hasNext ()) { JLabel aktLabel = it . next (); if ( aktLabel . getText (). equals ( inputText )){ it . remove (); this . unten . remove ( aktLabel ); } } } this . input . setText ( \"\" ); this . input . requestFocus (); this . unten . revalidate (); this . unten . repaint (); } } public static void main ( String [] args ) { new Uebung11 (); } } \u00dcbung 12 (TicTacToe) \u00b6 \u00dcbung 12 (5.7. - 7.7.) Gegeben sind die folgenden Klassen: Model.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 package uebungen.uebung12.loesung ; import java.util.Random ; /* * Implementierung von TicTacToe * */ public class Model { private Player [][] field ; public enum Player { RED , BLACK , EMPTY }; private Player player ; private int size ; /* * erzeugt Objekt vom Model * Parameter size fuer field: size x size * alle Felder in field am Anfang leer (EMPTY) * player BLACK beginnt */ public Model ( int size ) { this . size = size ; this . field = new Player [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = Player . EMPTY ; } } this . player = Player . BLACK ; // BLACK faengt an } /* * field wieder alle Felder EMPTY * player ist BLACK */ public void restart () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = Player . EMPTY ; } } this . player = Player . BLACK ; } /* * Rueckgabe von size * z.B. 3 bei 3 x 3 field */ public int getSize () { return this . size ; } /* * Rueckgabe deep copy von field */ public Player [][] getField () { Player [][] copy = new Player [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { copy [ row ][ col ] = this . field [ row ][ col ] ; } } return copy ; } /* * Ausgabe von field auf Konsole */ public void printField () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == Player . EMPTY ) { System . out . print ( \"- \" ); } else if ( this . field [ row ][ col ] == Player . BLACK ) { System . out . print ( \"x \" ); } else if ( this . field [ row ][ col ] == Player . RED ) { System . out . print ( \"o \" ); } } System . out . println (); // Ende der Zeile } System . out . println (); // nach Ausgabe des Feldes } /* * Spielerinnenwechsel * von BLACK zu RED oder * von RED zu BLACK * */ public void switchPlayer () { this . player = ( this . player == Player . BLACK ) ? Player . RED : Player . BLACK ; } /* * setzt player in field, wenn moeglich * gibt true zurueck, wenn Zug moeglich war * false, wenn Zug nicht moeglich war (z.B. falsche row oder col * oder field[row][col] bereits besetzt) */ public boolean move ( int row , int col ) { boolean movePossible = this . movePossible ( row , col ); if ( movePossible ) { this . field [ row ][ col ] = this . player ; } return movePossible ; } /* * Rueckgabe aktueller player */ public Player curPlayer () { return this . player ; } /* * Hilfsmethode, um zu ermitteln, ob Zug moeglich * gibt true zurueck, wenn Zug moeglich war * false, wenn Zug nicht moeglich war (z.B. falsche row oder col * oder field[row][col] bereits besetzt) */ public boolean movePossible ( int row , int col ) { boolean movePossible = false ; // row und col jeweils koorekter Index ? if ( row >= 0 && row < this . size && col >= 0 && col < this . size ) { // ist das Feld ueberhaupt leer ? if ( this . field [ row ][ col ] == Player . EMPTY ) { movePossible = true ; } } return movePossible ; } /* * true, wenn gewonnen * false, wenn nicht */ public boolean won () { return this . won ( Player . BLACK ) || this . won ( Player . RED ); } /* * Hilfsmethode fuer won(), um zu ueberpruefen, * ob BLACK oder RED gewonnen hat */ private boolean won ( Player player ) { boolean won = false ; if ( player == Player . BLACK || player == Player . RED ) { // 3 nebeneinander ??? for ( int row = 0 ; row < this . size && ! won ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { won = true ; } } // 3 untereinander ??? for ( int col = 0 ; col < this . size && ! won ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { won = true ; } } // von links oben nach rechts unten - Diagonale if ( ! won && this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { won = true ; } // von rechts oben nach links unten - Diagonale if ( ! won && this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { won = true ; } } return won ; } /* * Ausgabe auf die Konsole * player, die gewonnen hat */ public void printWon () { if ( this . player == Player . BLACK ) { System . out . println ( \"Spielerin x hat gewonnen !!!\" ); } else { System . out . println ( \"Spielerin o hat gewonnen !!!\" ); } } /* * Hilfsmethode, um zu uberpruefen, ob alle Felder besetzt * wird fuer draw() benoetigt */ private boolean fieldFilled () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == Player . EMPTY ) { return false ; } } } return true ; } /* * true, wenn unentschieden * false, wenn nicht * unentschieden ist, wenn field voll ist (fieldFilled()), * aber niemand gewonnen hat */ public boolean draw () { return this . fieldFilled () && ! this . won (); } /* * true, wenn Spiel zu Ende * entweder unentschieden oder gewonnen */ public boolean finished () { return this . draw () || this . won (); } /* * zufaelliger Zug * wird ausgefuehrt, aber keine Pruefung, ob * gewonnen oder unentschieden * nach dem Zug switschPlayer() */ public void automaticMove () { Random r = new Random (); int row = r . nextInt ( this . size ); int col = r . nextInt ( this . size ); while ( ! this . movePossible ( row , col )) { row = r . nextInt ( this . size ); col = r . nextInt ( this . size ); } this . move ( row , col ); } /* * automatischer (zufaelliger) Zug mit * anschliessender Pruefung, ob gewonnen * oder nicht * neuer Stand von field Ausgabe auf die Konsole * bei Gewinn oder Unentschieden Ausgabe auf die Konsole */ public void automaticMoveAndCheck () { this . automaticMove (); this . printField (); if ( this . finished ()) { if ( this . won ()) { this . printWon (); } else // draw { System . out . println ( \"Unentschieden !!!\" ); } } else { this . switchPlayer (); } } /* * so lange automatisch ziehen bis Spiel zu Ende * inkl. Ausgabe auf die Konsole */ public void playGame () { while ( ! this . finished ()) { this . automaticMoveAndCheck (); } } } View.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package uebungen.uebung12 ; import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.GridLayout ; import javax.swing.* ; public class View extends JFrame { JButton [] buttons ; JLabel labelStatus ; JButton btnStart ; Model model ; View ( Model model ) { super (); this . model = model ; setTitle ( \"TicTacToe\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // center panel JPanel hauptPanel = init (); this . getContentPane (). add ( hauptPanel , BorderLayout . CENTER ); // label panel JPanel labelPanel = new JPanel (); this . labelStatus = new JLabel (); this . labelStatus . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); this . labelStatus . setText ( \"X beginnt\" ); labelPanel . add ( this . labelStatus ); this . getContentPane (). add ( labelPanel , BorderLayout . NORTH ); // button panel this . btnStart = new JButton ( \"Start\" ); this . getContentPane (). add ( this . btnStart , BorderLayout . SOUTH ); setSize ( 400 , 400 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new GridLayout ( 3 , 3 , 10 , 10 )); this . buttons = new JButton [ 9 ] ; for ( int i = 0 ; i < this . buttons . length ; i ++ ) { this . buttons [ i ]= new JButton (); this . buttons [ i ] . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . buttons [ i ] . setActionCommand ( Integer . toString ( i )); panel . add ( buttons [ i ] ); } return panel ; } public void restart () { for ( int i = 0 ; i < this . buttons . length ; i ++ ) { this . buttons [ i ] . setText ( \"\" ); this . revalidate (); this . repaint (); } } } Controller.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package uebungen.uebung12 ; import java.awt.Color ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.JButton ; public class Controller implements ActionListener { Model model ; View view ; Controller ( Model model , View view ) { this . model = model ; this . model . restart (); this . view = view ; for ( int i = 0 ; i < this . view . buttons . length ; i ++ ) { this . view . buttons [ i ] . addActionListener ( this ); } this . view . btnStart . addActionListener ( this ); } @Override public void actionPerformed ( ActionEvent e ) { // TODO } } Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package uebungen.uebung12 ; public class Programclass { public static void main ( String [] args ) { Model model = new Model ( 3 ); model . playGame (); // einmal ein Spiel auf Konsole ausgeben View view = new View ( model ); Controller controller = new Controller ( model , view ); } } Aufgabe: Implementieren Sie die actionPerformed() -Methode in der Controller -Klasse. m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 12 actionPerformed() aus Controller.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Override public void actionPerformed ( ActionEvent e ) { Object src = e . getSource (); if ( src instanceof JButton ) { JButton buttonPressed = ( JButton ) src ; if ( buttonPressed . getActionCommand (). equals ( \"Start\" )) { System . out . println ( \"Start-Button\" ); this . model . restart (); this . view . restart (); } else { String command = buttonPressed . getActionCommand (); int index = Integer . valueOf ( command ). intValue (); System . out . println ( \"Button \" + index + \" geklickt\" ); int row = index / this . model . getSize (); int col = index % this . model . getSize (); if ( ! this . model . finished () && this . model . movePossible ( row , col )) { if ( this . model . curPlayer () == Model . Player . BLACK ) { buttonPressed . setForeground ( Color . BLACK ); buttonPressed . setText ( \"X\" ); this . view . labelStatus . setForeground ( Color . RED ); this . view . labelStatus . setText ( \"O ist dran\" ); } else if ( this . model . curPlayer () == Model . Player . RED ) { buttonPressed . setForeground ( Color . RED ); buttonPressed . setText ( \"O\" ); this . view . labelStatus . setForeground ( Color . BLACK ); this . view . labelStatus . setText ( \"X ist dran\" ); } this . model . move ( row , col ); if ( this . model . won ()) { if ( this . model . curPlayer () == Model . Player . BLACK ) { this . view . labelStatus . setForeground ( Color . BLACK ); this . view . labelStatus . setText ( \"X hat gewonnen!\" ); } else { this . view . labelStatus . setForeground ( Color . RED ); this . view . labelStatus . setText ( \"O hat gewonnen!\" ); } } else if ( this . model . draw ()) { this . view . labelStatus . setForeground ( Color . GRAY ); this . view . labelStatus . setText ( \"Unentschieden!\" ); } if ( ! this . model . won ()) this . model . switchPlayer (); } } } } Klausurvorbereitung (Klicks z\u00e4hlen) \u00b6 Klausurvorbereitung (Klicks z\u00e4hlen) Erstellen Sie eine solche GUI: Es handelt sich im Prinzip um ein Gitter aus JPanel s (siehe auch Tipps unten). Beachten Sie: Dem Konstruktor f\u00fcr das Fenster wird eine hoehe (int) und eine breite (int) \u00fcbergeben. Aus der hoehe und der breite ergibt sich die Anzahl der JPanels. In der Abbildung ist also hoehe=4 und breite=3 . Jedes JPanel soll ein JLabel enthalten, das der Anzahl der (Maus-)Klicks auf dieses JPanel entspricht. Am Anfang sind die Anzahl der Klicks f\u00fcr alle JPanels 0. Implementieren Sie den MouseListener so, dass bei Klick auf ein JPanel automatisch die Anzahl der Klicks um 1 erh\u00f6ht und die neue Anzahl im JLabel dargestellt wird. Au\u00dferdem soll das (oder die) JPanel(s) mit den meisten Klicks rot dargestellt werden. Die Abbildung zeigt das Fenster nach einigen Mausklicks auf die einzelnen Panels. Es gibt drei Panels mit den meisten Klicks. Nach einem weiteren Klick gibt es nur noch ein Panel mit dem meisten Klicks. Wird auf den reset -Button geklickt, ist alles wieder auf 0 (und grau) gestellt. Tipps: F\u00fcr die \"JPanels\" eigenen sich tats\u00e4chlich JPanels , da diese ja eine Hintergrundfarbe haben, einen Rand ( Border ) haben k\u00f6nnen, ein JLabel aufnehmen k\u00f6nnen usw. Es w\u00e4re ja aber auch sinnvoll, dass jedes JPanel z.B. auch eine Eigenschaft anzahlKlicks o.\u00e4. hat. Insofern w\u00e4re der Vorschlag, eine eigene Klasse MyPanel zu erstellen, die von JPanel erbt, somit alle Eigenschaften eines JPanel hat und aber auch noch zus\u00e4tzliche Eigenschaften haben kann. Als Datenstruktur f\u00fcr das Model bietet sich sicherlich ein zweidimensionales Array an. Wenn Sie jedes MyPanel an den MouseListener anmelden, dann m\u00fcssen Sie gar nicht die Koordinaten des Mausklicks betrachten, sondern nur abfragen, welches der MyPanel das Mausereignis ausgel\u00f6st hat (oder Sie verwenden sogar f\u00fcr jedes dieser MyPanel eine anonyme Klasse des MouseListener ). Probieren Sie mal ein wenig herum, es gibt sehr viele verschiedene L\u00f6sungsm\u00f6glichkeiten hier. m\u00f6gliche L\u00f6sung f\u00fcr Klicks Z\u00e4hlen KlicksZaehlen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class KlicksZaehlen extends JFrame { MyPanel [][] panels ; int meistenClicks ; KlicksZaehlen ( int hoehe , int breite ) { super ( \"Klicks zaehlen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( createMainPanel ( hoehe , breite ), BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); this . meistenClicks = 0 ; } JPanel createMainPanel ( int hoehe , int breite ) { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new GridLayout ( hoehe , breite , 2 , 2 )); mainPanel . setBackground ( Color . DARK_GRAY ); this . panels = new MyPanel [ hoehe ][ breite ] ; for ( int zeile = 0 ; zeile < this . panels . length ; zeile ++ ) { for ( int spalte = 0 ; spalte < this . panels [ zeile ] . length ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return mainPanel ; } class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; int nrClicks ; JLabel label ; MyPanel ( int zeile , int spalte ) { this . zeile = zeile ; this . spalte = spalte ; this . nrClicks = 0 ; this . label = new JLabel ( \"0\" ); this . setLayout ( new GridLayout ()); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . add ( label ); this . setBackground ( Color . LIGHT_GRAY ); this . addMouseListener ( this ); } @Override public void mouseClicked ( MouseEvent e ) { MyPanel mp = ( MyPanel ) e . getSource (); mp . nrClicks ++ ; mp . label . setText ( String . valueOf ( nrClicks )); if ( mp . nrClicks > KlicksZaehlen . this . meistenClicks ) KlicksZaehlen . this . meistenClicks = mp . nrClicks ; for ( int zeile = 0 ; zeile < KlicksZaehlen . this . panels . length ; zeile ++ ) { for ( int spalte = 0 ; spalte < KlicksZaehlen . this . panels [ zeile ] . length ; spalte ++ ) { if ( KlicksZaehlen . this . panels [ zeile ][ spalte ] . nrClicks == KlicksZaehlen . this . meistenClicks ) { KlicksZaehlen . this . panels [ zeile ][ spalte ] . setBackground ( Color . RED ); } else { KlicksZaehlen . this . panels [ zeile ][ spalte ] . setBackground ( Color . LIGHT_GRAY ); } } } } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new KlicksZaehlen ( 4 , 3 ); } } Klausurvorbereitung (Schiebepuzzle) \u00b6 Die folgenden \u00dcbungen besch\u00e4ftigen sich alle mit Zeichnen, d.h. Graphics. Da wir das dieses Semester nicht hatten, m\u00fcssen Sie sich die folgenden \u00dcbungen nicht anschauen! K\u00f6nnen Sie aber ;-) Klausurvorbereitung (Zeichnen) \u00b6 Klausurvorbereitung (Zeichnen) Zeichnen Sie ein Quadrat. Passen Sie dieses Quadrat m\u00f6glichst passend in das Fenster. Da es sich um ein Quadrat handelt, kann es sich nur der H\u00f6he oder der Breite des Fensters anpassen, je nachdem, was kleiner ist. Wenn die H\u00f6he kleiner ist, als die Breite, dann soll das Quadrat ausgef\u00fcllt sein. Wenn die Breite kleiner als die H\u00f6he ist, dann soll das Quadrat nicht ausgef\u00fcllt sein, aber die Linienst\u00e4rke auf 5.0f gesetzt werden. Die Zeichenfarbe soll zuf\u00e4llig erzeugt werden - jedes Mal, wenn die paintComponent() -Methode aufgerufen wird. Beobachten Sie anhand des Farbwechsels, wie oft die paintComponent() -Methode aufgerufen wird. eine m\u00f6gliche L\u00f6sung Zeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package uebungen.zeichnen ; import java.awt.BasicStroke ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.util.Random ; import javax.swing.* ; public class Uebung10 extends JFrame { public Uebung10 () { super (); this . setTitle ( \"\u00dcbung10\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; //g2.drawRect(20, 130, 200, 100); int abstand = this . getHeight () / 20 ; int hoehe = this . getHeight () - 2 * abstand ; int breite = this . getWidth () - 2 * abstand ; //Random Farben erzeugen: Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Color c = new Color ( rot , gruen , blau ); g2 . setColor ( c ); //rot-Gr\u00fcn-Blau 0 bis 255 // Quadrat zeichnen if ( hoehe < breite ) { int abstandLinks = ( this . getWidth () - hoehe ) / 2 ; g2 . fillRect ( abstandLinks , abstand , hoehe , hoehe ); } else { int abstandOben = ( this . getHeight () - breite ) / 2 ; g2 . setStroke ( new BasicStroke ( 5.0f )); //dicke Linien g2 . drawRect ( abstand , abstandOben , breite , breite ); } } } public static void main ( String [] args ) { new Zeichnen (); } } sehr hilfreiche Erl\u00e4uterungen zur \u00dcbung von Frau Busjahn Wenn man keine Abst\u00e4nde definiert und die gesamte H\u00f6he als Seitenl\u00e4nge nimmt: g2 . fillRect ( 0 , 0 , this . getHeight (), this . getHeight ()); Beispiel f\u00fcr H\u00f6he < Breite Um oben und unten gleich gro\u00dfe Abst\u00e4nde einzufu\u0308gen: int abstandOben = this . getHeight () / 20 ; int abstandUnten = this . getHeight () / 20 ; int seitenLaenge = this . getHeight () - abstandOben - abstandUnten ; g2 . fillRect ( 0 , abstandOben , seitenLaenge , seitenLaenge ); ``` Da abstandOben und abstandUnten gleich sein sollen, l\u00e4sst sich das verku\u0308rzen zu: int abstandObenUnten = this . getHeight () / 20 ; int seitenLaenge = this . getHeight () - ( 2 * abstandObenUnten ); g2 . fillRect ( 0 , abstandObenUnten , seitenLaenge , seitenLaenge ); Um das Quadrat auch horizontal mittig auszurichten, braucht man noch den Abstand links int rest = this . getWidth () - seitenLaenge ; int links = rest / 2 ; oder zusammengefasst: int links = ( this . getWidth () - seitenLaenge ) / 2 ; g2 . fillRect ( links , abstandObenUnten , seitenLaenge , seitenLaenge ); Klausurvorbereitung (Mausereignisse) \u00b6 Klausurvorbereitung (Mausereignisse) Zeichnen Sie mithilfe der Maus farbige Rechtecke. Das Zeichnen soll folgenderma\u00dfen funktionieren: dort, wo sie mit der Maus in die Zeichenfl\u00e4che klicken, ist ein Eckpunkt des Rechtecks mit gedr\u00fcckter Maustaste ziehen Sie das Rechteck gro\u00df (w\u00e4hrenddessen soll das Rechteck dargestellt werden) durch Loslassen der Maustaste legen Sie die endg\u00fcltige Gr\u00f6\u00dfe des Rechtecks fest und speichern das Rechteck durch wiederholtes Zeichnen werden mehrere Rechtecke gezeichnet. Die zuvor gezeichneten Rechtecke bleiben dargestellt jedes Rechteck hat eine zuf\u00e4llig erzeugte Farbe beachten Sie, dass das Zeichnen eines Rechtecks nicht nur von links oben nach rechts unten, sondern in alle Richtungen m\u00f6glich sein soll Tipps: studieren Sie dieses Beispiel behandeln Sie die Mausereignisse in den Methoden mousePressed() , mouseReleased() ( MouseListener ) sowie aus dem MouseMotionListener mouseDragged() erstellen Sie sich zun\u00e4chst eine Klasse, die Rechtecke repr\u00e4sentiert (Objektvariablen x , y , width , height , jweils int ) speichern Sie die Rechtecke zusammen mit ihrer Farbe in einer Map (untersuchen Sie den Unterschied zwischen HashMap und LinkedHashMap ) zeichnen Sie in paintComponent() alle Rechtecke aus der Map und das aktuelle Rechteck (das Sie gerade zeichnen) vorkommentierte Klassen RechteckeZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.HashMap ; import java.util.Map ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class RechteckeZeichnen extends ... implements ... { // Objektvariablen public RechteckeZeichnen () { super (); this . setTitle (...); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); //Collection f\u00fcr die Rechtecke anlegen //Leinwand anlegen und die Listener f\u00fcr Mausereignisse hinzuf\u00fcgen this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; //aktuelles Rechteck zeichnen (falls es aktuell eins gibt) //gespecherte Rechtecke aus der Collection zeichnen } } public static void main ( String [] args ) { new RechteckeZeichnen (); } @Override public void mousePressed ( MouseEvent e ) { //neues Rechteck erzeugen //zuf\u00e4llige Farbe erzeugen - hatten wir letzte Woche } @Override public void mouseDragged ( MouseEvent e ) { //H\u00f6he und Breite des aktuellen Rechtecks setzen //je nachdem ob die Maus gerade nach rechts, links, oben oder unten gezogen wird //Leinwand neu zeichnen } @Override public void mouseReleased ( MouseEvent e ) { //aktuelles Rechteck speichern } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 public class Rechteck { //private Objektvariablen f\u00fcr x, y, H\u00f6he und Breite public Rechteck ( int x , int y , int width , int height ) { //Koordinaten und Gr\u00f6\u00dfe des Rechtecks } // Getter und Setter f\u00fcr x, y, H\u00f6he und Breite } eine m\u00f6gliche L\u00f6sung f\u00fcr Rechtecke Zeichnen RechteckeZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 package uebungen.uebung11 ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.HashMap ; import java.util.Map ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class RechteckeZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Rechteck aktRechteck ; Color aktColor ; Map < Rechteck , Color > rechtecke ; public RechteckeZeichnen () { super (); this . setTitle ( \"Rechtecke zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . rechtecke = new HashMap <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( RechteckeZeichnen . this . aktRechteck != null ) { g2 . setColor ( aktColor ); int x = RechteckeZeichnen . this . aktRechteck . getX (); int y = RechteckeZeichnen . this . aktRechteck . getY (); int width = RechteckeZeichnen . this . aktRechteck . getWidth (); int height = RechteckeZeichnen . this . aktRechteck . getHeight (); g2 . fillRect ( x , y , width , height ); } for ( Map . Entry < Rechteck , Color > eintrag : RechteckeZeichnen . this . rechtecke . entrySet ()) { Rechteck r = eintrag . getKey (); Color c = eintrag . getValue (); g2 . setColor ( c ); int x = r . getX (); int y = r . getY (); int width = r . getWidth (); int height = r . getHeight (); g2 . fillRect ( x , y , width , height ); } } } public static void main ( String [] args ) { new RechteckeZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktRechteck = new Rechteck ( p . x , p . y , 0 , 0 ); Random zuf = new Random (); int r = zuf . nextInt ( 256 ); int g = zuf . nextInt ( 256 ); int b = zuf . nextInt ( 256 ); this . aktColor = new Color ( r , g , b ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); if ( p . x > this . aktRechteck . getX ()) // Maus nach rechts { int width = p . x - this . aktRechteck . getX (); this . aktRechteck . setWidth ( width ); } else // Maus nach links { int width = ( this . aktRechteck . getX () - p . x ) + this . aktRechteck . getWidth (); this . aktRechteck . setWidth ( width ); this . aktRechteck . setX ( p . x ); } if ( p . y > this . aktRechteck . getY ()) // Maus nach unten { int height = p . y - this . aktRechteck . getY (); this . aktRechteck . setHeight ( height ); } else // Maus nach oben { int height = ( this . aktRechteck . getY () - p . y ) + this . aktRechteck . getHeight (); this . aktRechteck . setHeight ( height ); this . aktRechteck . setY ( p . y ); } this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); this . rechtecke . put ( this . aktRechteck , this . aktColor ); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package uebungen.uebung11 ; public class Rechteck { private int x ; private int y ; private int width ; private int height ; public Rechteck ( int x , int y , int width , int height ) { this . x = x ; this . y = y ; this . width = width ; this . height = height ; } public int getX () { return x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } public int getWidth () { return width ; } public void setWidth ( int width ) { this . width = width ; } public int getHeight () { return height ; } public void setHeight ( int height ) { this . height = height ; } } sehr hilfreiche Erl\u00e4uterungen zur \u00dcbung von Frau Busjahn Klausurvorbereitung (Graphen) \u00b6 Klausurvorbereitung (Graphen) Erstellen Sie ein Fenster zum Zeichnen. Implementieren Sie den Mauslistener so, dass f\u00fcr jeden Mausklick an der Stelle des Mausklicks ein schwarzer ausgef\u00fcllter Kreis mit dem DURCHMESSER = 30 angezeigt wird: F\u00fcr das Model gen\u00fcgt es, sich die Punkte in einer Collection zu merken (am einfachsten ist wohl eine ArrayList ). F\u00fcr den Controller h\u00e4tten wir hier die Wahl zwischen mouseClicked() und mousePressed() . Wegen der sp\u00e4teren Erweiterung (Bewegen der Punkte), sollten wir hier mouseClicked() w\u00e4hlen. Passen Sie die View nun so an, dass die Punkte durch Linien der Strichst\u00e4rke 2.0f miteinander verbunden werden. Sie k\u00f6nnen auch gleich (oder sp\u00e4ter) den ersten und letzten Punkt mit einer Linie verbinden (so wie in der Abbildung). Implementieren sie den MouseMotionListener so, dass wenn Sie mit der Maus auf einen Punkt (Kreis) klicken (oder knapp daneben) und bei gedr\u00fcckter Maustaste die Maus bewegen, sich auch der Punkt mitbewegt. Zur Erinnerung: die Methode mouseClicked() wird aufgerufen, nachdem mousePressed() und mouseReleased() aufgerufen wurden. \u00c4ndert sich die Mausposition zwischen den Aufrufen von mousePressed() und mouseReleased() , wird mouseClicked() gar nicht aufgerufen. Es empfiehlt sich also, in mousePressed() zu bestimmen, ob durch den Mausklick ein Kreis getroffen wurde. Das muss nat\u00fcrlich kein genauer \"Treffer\" sein, bauen Sie ruhig eine Toleranz von z.B. 20 ein. Den Punkt, den Sie \"getroffen\" haben, sollten Sie sich merken, denn seine Koordinaten werden ja durch die Mausbewegung ver\u00e4ndert. Wenn Sie in mousePressed() einen Punkt \"getroffen\" haben, dann sollten Sie das Verschieben des Punktes in mouseDragged() behandeln. Beachten Sie, dass mouseDragged() (bei gedr\u00fcckter Maustaste) permanent aufgerufen wird. Wir k\u00f6nnen Sie die \u00c4nderung der Mausposition zwischen zwei Aufrufen von mouseDragged() ermitteln? eine m\u00f6gliche L\u00f6sung f\u00fcr Klausurvorbereitung (Graphen) GraphenZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package uebungen.uebung13 ; import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GraphenZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; List < Point > points ; //f\u00fcr uns = Java.util! Point movepoint ; Point remember ; public GraphenZeichnen () { super (); this . setTitle ( \"Uebung13\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . canvas . addMouseListener ( this ); //MOUSELISTENER ANMELDEN NICHT VERGESSEN!!!! this . canvas . addMouseMotionListener ( this ); //MOUSEMOTIONLISTENER ANMELDEN NICHT VERGESSEN!!!! this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); this . points = new ArrayList <> (); } private class Canvas extends JPanel { final static int DURCHM = 30 ; final static int RADIUS = DURCHM / 2 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier zeichnen wir die Punkte: for ( Point p : Uebung13 . this . points ) // anstatt \"points\" = Uebung13.this.points { int x = p . x ; int y = p . y ; g2 . fillOval ( x , y , DURCHM , DURCHM ); } for ( int i = 0 ; i < Uebung13 . this . points . size () - 1 ; i ++ ) //.size wegen Liste { Point p1 = Uebung13 . this . points . get ( i ); Point p2 = Uebung13 . this . points . get ( i + 1 ); // \"i+1\" => Nachbarpunkt von p1 g2 . drawLine ( p1 . x + RADIUS , p1 . y + RADIUS , p2 . x + RADIUS , p2 . y + RADIUS ); // \"+ Radius\" -> damit die Linien ab der Mitte des Punktes beginnen if ( i == Uebung13 . this . points . size () - 2 ) // vorletzte Position=> HIER verbinden wir den ersten und letzten Punkt { Point p = Uebung13 . this . points . get ( 0 ); g2 . drawLine ( p2 . x + RADIUS , p2 . y + RADIUS , p . x + RADIUS , p . y + RADIUS ); } } } } public static void main ( String [] args ) { new GraphenZeichnen (); } @Override public void mouseClicked ( MouseEvent e ) //wir klicken -> Kreis wird gezeichnet -> Liste wird bef\u00fcllt { Point p = e . getPoint (); // speichern den Punkt beim Ort des Klickens this . points . add ( p ); // in der Liste speichern this . canvas . repaint (); // canvas wird nochmal gezeichnet-- wichtig!! } @Override public void mousePressed ( MouseEvent e ) //ermitteln, ob wir punkt getroffen haben { int x = e . getX (); int y = e . getY (); final int ABSTAND = 20 ; //Abstand festlegen for ( Point p : this . points ) { if ( Math . abs ( x - p . x ) < ABSTAND && Math . abs ( y - p . y ) < ABSTAND ) // Abstand von Punkt ermitteln // MINUS den Punkt, den wir betrachten { this . movepoint = p ; this . remember = e . getPoint (); // Speichern die Koordinate des Mausklicks } } } @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseDragged ( MouseEvent e ) //Kreise bewegen: { int x = e . getX (); int y = e . getY (); int x1 = this . remember . x ; int y1 = this . remember . y ; int xDif = x - x1 ; //Wohin und um wie viel haben wir uns bewegt? int yDif = y - y1 ; this . movepoint . x = this . movepoint . x + xDif ; // wir verschieben den Punkt um die Differenz, this . movepoint . y = this . movepoint . y + yDif ; // die wir ermittelt haben this . canvas . repaint (); //WICHTIG this . remember = e . getPoint (); // rememberPunkt wird gespeichert } } sehr hilfreiche Erl\u00e4uterungen zu this von Frau Busjahn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //Achtung, dieser Code dient nur dazu, zu zeigen, wie man an //verschiedenen Stellen auf die Methoden und Variablen zugreifen //kann und ist nicht unbedingt der beste Stil public class A { int variableInA ; B bInA ; A ( int wertA ) { this . variableInA = wertA ; this . bInA = new B ( wertA + 10 ); this . printA ( \"Konstruktor A\" ); this . bInA . printB ( \"Konstruktor A\" ); } void printA ( String aufrufIn ) { System . out . println ( \"printA - \" + aufrufIn + \" - Variable der Klasse A: \" + this . variableInA ); System . out . println ( \"printA - \" + aufrufIn + \" - Variable der Klasse B: \" + this . bInA . variableInB ); } class B { int variableInB ; B ( int wertB ) { this . variableInB = wertB ; this . printB ( \"Konstruktor B\" ); } void printB ( String aufrufIn ) { System . out . println ( \"printB - \" + aufrufIn + \" - Variable der Klasse A: \" + A . this . variableInA ); System . out . println ( \"printB - \" + aufrufIn + \" - Variable der Klasse B: \" + this . variableInB ); } } public static void main ( String [] args ) { A a1 = new A ( 2 ); a1 . variableInA = 6 ; a1 . printA ( \"main\" ); a1 . bInA . variableInB = 16 ; a1 . bInA . printB ( \"main\" ); } } Klausurvorbereitung (Quadrat) \u00b6 Klausurvorbereitung (Quadrat) Erstellen Sie ein Fenster zum Zeichnen. Passen Sie zun\u00e4chst ein Quadrat mit Strichst\u00e4rke 3.0f in das Fenster ein und zwar so, dass es \u2153 von entweder der Breite der canvas oder der H\u00f6he der canvas gro\u00df ist, je nachdem, was kleiner ist. Es muss aber nicht mittig sein: In der folgenden Abbildung ist die H\u00f6he kleiner als die Breite. Also ist die H\u00f6he korrekt gedrittelt, aber die gleiche L\u00e4nge wurde f\u00fcr x verwendet, also f\u00fcr den Abstand vom linken Rand zum Quadrat. Deshalb ist der Abstand vom Quadrat zum rechten Rand gr\u00f6\u00dfer. Sie k\u00f6nnen aber das Quadrat auch gerne komplett in die Mitte setzen. Wenn der create square -Button gedr\u00fcckt wird, erscheint ein farbiges Quadrat, das genau so gro\u00df ist, wie das zuvor gezeichnete nichtausgef\u00fcllte schwarze Quadrat. Die Position des Quadrates wird zuf\u00e4llig bestimmt. Es passt aber auf jeden Fall vollst\u00e4ndig in die Canvas! Auch die Farbe des Quadrates wird zuf\u00e4llig bestimmt. Es beh\u00e4lt die ganze Zeit \u00fcber seine Farbe. Das farbige Quadrat kann nun durch Bewegen der Maus bei gedr\u00fcckter Maustaste bewegt werden. Wenn das Quadrat (fast) vollst\u00e4ndig in dem schwarzen Quadrat ist, dann bleibt es genau dort und kann nicht weiter bewegt werden. eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat) QuadratZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class QuadratZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Point posSquare ; Color colorSquare ; boolean move = false ; Point remember ; boolean fixiert = false ; public QuadratZeichnen () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int width = this . getWidth (); int height = this . getHeight (); // int smaller = (width < height) ? width : height; int smaller = 0 ; int length = 0 ; int x = 0 ; int y = 0 ; if ( width < height ) { smaller = width ; length = smaller / 3 ; x = smaller / 3 ; y = ( height - length ) / 2 ; } else { smaller = height ; length = smaller / 3 ; y = smaller / 3 ; x = ( width - length ) / 2 ; } g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawRect ( x , y , length , length ); if ( Uebung14 . this . posSquare != null && Uebung14 . this . colorSquare != null ) { int xSquare = Uebung14 . this . posSquare . x ; int ySquare = Uebung14 . this . posSquare . y ; Color cSquare = Uebung14 . this . colorSquare ; g2 . setColor ( cSquare ); g2 . fillRect ( xSquare , ySquare , length , length ); } } } // ende innere Klasse private JPanel initSouth () { JPanel south = new JPanel (); JButton btnCreate = new JButton ( \"create square\" ); btnCreate . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Random r = new Random (); int widthCanvas = Uebung14 . this . canvas . getWidth (); int heightCanvas = Uebung14 . this . canvas . getHeight (); int lengthSquare = ( widthCanvas < heightCanvas ) ? widthCanvas / 3 : heightCanvas / 3 ; int x = r . nextInt ( widthCanvas - lengthSquare ); int y = r . nextInt ( heightCanvas - lengthSquare ); Uebung14 . this . posSquare = new Point ( x , y ); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Uebung14 . this . colorSquare = new Color ( rot , gruen , blau ); Uebung14 . this . canvas . repaint (); } }); south . add ( btnCreate ); return south ; } public static void main ( String [] args ) { new QuadratZeichnen (); } @Override public void mouseDragged ( MouseEvent e ) { if ( move ) { int xMouse = e . getX (); int yMouse = e . getY (); int xLast = this . remember . x ; int yLast = this . remember . y ; int xDiff = xMouse - xLast ; int yDiff = yMouse - yLast ; this . posSquare . x = this . posSquare . x + xDiff ; this . posSquare . y = this . posSquare . y + yDiff ; // ab hier: im schwarzen Quadrat? int widthCanvas = this . canvas . getWidth (); int heightCanvas = this . canvas . getHeight (); int xBlack , yBlack ; if ( widthCanvas < heightCanvas ) { int lengthSquare = widthCanvas / 3 ; xBlack = widthCanvas / 3 ; yBlack = ( heightCanvas - lengthSquare ) / 2 ; } else { int lengthSquare = heightCanvas / 3 ; yBlack = heightCanvas / 3 ; xBlack = ( widthCanvas - lengthSquare ) / 2 ; } int xSquare = this . posSquare . x ; int ySquare = this . posSquare . y ; final int ABSTAND = 20 ; if ( Math . abs ( xSquare - xBlack ) < ABSTAND && Math . abs ( ySquare - yBlack ) < ABSTAND ) { // farbiges Quadrat genau im schwarzen System . out . println ( \"im schwarzen\" ); this . move = false ; this . posSquare . x = xBlack ; this . posSquare . y = yBlack ; } this . canvas . repaint (); this . remember = e . getPoint (); } } @Override public void mouseMoved ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { int xMouse = e . getX (); int yMouse = e . getY (); if ( ! this . fixiert && this . posSquare != null ) { int xSquare = this . posSquare . x ; int ySquare = this . posSquare . y ; int widthCanvas = this . canvas . getWidth (); int heightCanvas = this . canvas . getHeight (); int lengthSquare = ( widthCanvas < heightCanvas ) ? widthCanvas / 3 : heightCanvas / 3 ; if ( xMouse >= xSquare && xMouse <= ( xSquare + lengthSquare ) && yMouse >= ySquare && yMouse <= ( ySquare + lengthSquare )) { this . move = true ; this . remember = e . getPoint (); System . out . println ( \"im Quadrat\" ); } } } @Override public void mouseReleased ( MouseEvent e ) { this . move = false ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } } Klausurvorbereitung (Quadrat und Kreis) \u00b6 Klausurvorbereitung (Quadrat und Kreis) Erstellen Sie folgendes Fenster zum Zeichnen: Dabei sind folgende Dinge zu beachten: Oben im Fenster ist ein JPanel dessen Hintergrundfarbe LIGHT_GRAY ist und das ein JLabel enth\u00e4lt. Die Beschriftung des JLabels sollten Sie in der paintComponent() -Methode vornehmen, denn das JLabel zeigt an, ob die Zeichenfl\u00e4che (Canvas) breiter als hoch ist ( breiter ) oder umgedreht ( hoeher ) und die Breite der Canvas sowie die H\u00f6he ( breite, hoehe ). Es gibt also diese beiden M\u00f6glichkeiten: Achten Sie auch darauf, dass der Text des JLabels angepasst wird, wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern (ergibt sich aber automatisch, wenn Sie den Text des JLabels in der paintComponent() -Methode setzen). In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas). Es wird eine Linie dargestellt. Diese Linie ist in Strichst\u00e4rke 2.0f . Wenn die Canvas breiter als hoch ist, dann verl\u00e4uft die Linie in der Mitte der Breite vertikal. Wenn die Canvas h\u00f6her als breit ist, dann verl\u00e4uft die Linie in der Mitte der H\u00f6he horizontal. Der Fall H\u00f6he==Breite muss nicht extra behandelt werden. Es gibt also diese beiden M\u00f6glichkeiten: Unten im Fenster ist ein JPanel , dessen Hintergrundfarbe LIGHT_GRAY ist und das ein JButton mit dem Text new enth\u00e4lt. Implementieren Sie eine Klasse Figure mit drei privaten Objektvariablen int x int y int length Schreiben Sie einen parametrisierten Konstruktor Figure(int x, int y, int length) , der die Objektvariablen mit den Parameterwerten initialisiert. Schreiben Sie f\u00fcr alle drei Objektvariablen jeweils Getter und Setter . Implementieren Sie f\u00fcr den Button den ActionListener so, dass durch den Klick auf den Button in die eine H\u00e4lfte der Canvas ein gelbes Quadrat (Farbe ist YELLOW ) und in die andere H\u00e4lfte der Canvas ein gr\u00fcner Kreis (Farbe ist GREEN ) gezeichnet wird. Beide Objekte sind vom Typ Figure . length des Quadrates entspricht der Seitenl\u00e4nge, length des Kreises entspricht dem Durchmesser. x und y sind jeweils die Koordinaten der linken oberen \u201eEcke\u201c. Beachten Sie, dass length bei Kreis und Quadrat gleich sind und dass sich die L\u00e4nge m\u00f6glichst gut (ca. 90%) in die H\u00e4lfte der Canvas einpasst, d.h. Sie m\u00fcssen schauen, dass das Quadrat und der Kreis stets vollst\u00e4ndig in ihre H\u00e4lfte passen, aber bestm\u00f6glich. Au\u00dferdem sollen die beiden Figuren m\u00f6glichst mittig in ihrer jeweiligen H\u00e4lfte angeordnet sein. Wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern, dann m\u00fcssen sich Quadrat und Kreis nicht mit\u00e4ndern! Wenn Sie dann aber wieder auf den new -Button klicken, dann werden die beiden Figuren wieder an die neuen Canvas-Dimensionen angepasst. Implementieren Sie MouseListener und MouseMotionListener so, dass Sie entweder den Kreis oder das Quadrat bei gedr\u00fcckter Maustaste bewegen k\u00f6nnen, je nachdem, ob Sie auf das Quadrat oder auf den Kreis mit der Maus geklickt haben. Wenn Sie weder das Quadrat noch den Kreis durch den Mausklick getroffen haben, dann soll sich auch nichts bewegen. Bei Kreis betrachten Sie das Tangentenquadrat um den Kreis, um zu pr\u00fcfen, ob Sie den Kreis getroffen haben (also genauso, wie beim Quadrat). Sie k\u00f6nnen Kreis und Quadrat jeweils auch mehrmals hintereinander bewegen und/oder abwechselnd. Sie k\u00f6nnen nur nie beide Figuren zugleich bewegen (selbst wenn sie \u00fcbereinander sind). In der folgenden Abbildung wurde sowohl der Kreis als auch das Quadrat bereits (evtl. mehrfach) bewegt: Wenn Sie den Kreis fast vollst\u00e4ndig \u00fcber das Quadrat bewegt haben oder das Quadrat fast vollst\u00e4ndig \u00fcber den Kreis, dann wird das erkannt und der Kreis wird exakt in das Quadrat fixiert. Das bedeutet, es entsteht z.B. folgendes Bild: Fast vollst\u00e4ndig bedeutet, dass sich die x - und y -Koordinaten der beiden Figuren um jeweils h\u00f6chsten 30 Punkte unterscheiden. Sind die Figuren innerhalb dieses Abstandes, dann werden Sie automatisch exakt \u00fcbereinandergelegt. Sind die beiden Figuren exakt \u00fcbereinander, kann keine der beiden Figuren mehr bewegt werden. Es kann nur noch der Button new geklickt werden, um die Ausgangssituation wieder herzustellen. Im Label oben erscheint fixiert . Der Text ist fettgedruckt (bold). eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat und Kreis) Figure.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Figure { private int x ; private int y ; private int length ; public Figure ( int x , int y , int length ) { this . x = x ; this . y = y ; this . length = length ; } public int getX () { return this . x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return this . y ; } public void setY ( int y ) { this . y = y ; } public int getLength () { return this . length ; } public void setLength ( int length ) { this . length = length ; } } QuadratUndKreis.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.* ; public class QuadratUndKreis extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; JLabel lOben ; Figure circle ; Figure square ; boolean circleMoved = false ; boolean squareMoved = false ; Point rememberLastPoint ; boolean fixed = false ; public QuadratUndKreis () { super (); this . setTitle ( \"Klausur\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int width = this . getWidth (); int height = this . getHeight (); g2 . setStroke ( new BasicStroke ( 2.0f )); if ( width < height ) { int mitteY = height / 2 ; g2 . drawLine ( 0 , mitteY , width , mitteY ); } else { int mitteX = width / 2 ; g2 . drawLine ( mitteX , 0 , mitteX , height ); } String message = ( width < height ) ? \"hoeher : \" : \"breiter : \" ; message = message + \"( \" + width + \", \" + height + \" )\" ; if ( QuadratUndKreis . this . fixed ) { message = \"fixiert\" ; QuadratUndKreis . this . lOben . setFont ( new Font ( \"Verdana\" , Font . BOLD , 14 )); } QuadratUndKreis . this . lOben . setText ( message ); if ( QuadratUndKreis . this . square != null ) { g2 . setColor ( Color . YELLOW ); int x = QuadratUndKreis . this . square . getX (); int y = QuadratUndKreis . this . square . getY (); int length = QuadratUndKreis . this . square . getLength (); g2 . fillRect ( x , y , length , length ); } if ( QuadratUndKreis . this . circle != null ) { g2 . setColor ( Color . GREEN ); int x = QuadratUndKreis . this . circle . getX (); int y = QuadratUndKreis . this . circle . getY (); int length = QuadratUndKreis . this . circle . getLength (); g2 . fillOval ( x , y , length , length ); } } } // ende innere Klasse private JPanel initNorth () { JPanel north = new JPanel (); north . setBackground ( Color . LIGHT_GRAY ); this . lOben = new JLabel (); north . add ( this . lOben ); return north ; } private JPanel initSouth () { JPanel south = new JPanel (); south . setBackground ( Color . LIGHT_GRAY ); JButton btnNew = new JButton ( \"new\" ); btnNew . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { int width = QuadratUndKreis . this . canvas . getWidth (); int height = QuadratUndKreis . this . canvas . getHeight (); if ( width < height ) // hoeher --> untereinander { int height2 = height / 2 ; int smallest = ( height2 < width ) ? height2 : width ; int length = ( int )( smallest * 0.9 ); int oben = ( height2 - length ) / 2 ; int links = ( width - length ) / 2 ; QuadratUndKreis . this . square = new Figure ( links , oben , length ); QuadratUndKreis . this . circle = new Figure ( links , height2 + oben , length ); } else // breiter --> nebeneinander { int width2 = width / 2 ; int smallest = ( width2 < height ) ? width2 : height ; int length = ( int )( smallest * 0.9 ); int links = ( width2 - length ) / 2 ; int oben = ( height - length ) / 2 ; QuadratUndKreis . this . square = new Figure ( links , oben , length ); QuadratUndKreis . this . circle = new Figure ( width2 + links , oben , length ); } QuadratUndKreis . this . canvas . repaint (); QuadratUndKreis . this . squareMoved = false ; QuadratUndKreis . this . circleMoved = false ; QuadratUndKreis . this . fixed = false ; QuadratUndKreis . this . rememberLastPoint = null ; } }); south . add ( btnNew ); return south ; } public static void main ( String [] args ) { new QuadratUndKreis (); } @Override public void mouseDragged ( MouseEvent e ) { if (( QuadratUndKreis . this . circleMoved || QuadratUndKreis . this . squareMoved ) && ! QuadratUndKreis . this . fixed ) { int x = e . getX (); int y = e . getY (); int x1 = QuadratUndKreis . this . rememberLastPoint . x ; int y1 = QuadratUndKreis . this . rememberLastPoint . y ; int xDiff = x - x1 ; int yDiff = y - y1 ; if ( QuadratUndKreis . this . circleMoved ) { int newX = QuadratUndKreis . this . circle . getX () + xDiff ; int newY = QuadratUndKreis . this . circle . getY () + yDiff ; QuadratUndKreis . this . circle . setX ( newX ); QuadratUndKreis . this . circle . setY ( newY ); } else if ( QuadratUndKreis . this . squareMoved ) { int newX = QuadratUndKreis . this . square . getX () + xDiff ; int newY = QuadratUndKreis . this . square . getY () + yDiff ; QuadratUndKreis . this . square . setX ( newX ); QuadratUndKreis . this . square . setY ( newY ); } // ab hier erkennen, ob uebereinander final int ABSTAND = 30 ; int xAbstand = Math . abs ( QuadratUndKreis . this . square . getX () - QuadratUndKreis . this . circle . getX ()); int yAbstand = Math . abs ( QuadratUndKreis . this . square . getY () - QuadratUndKreis . this . circle . getY ()); if ( xAbstand <= ABSTAND && yAbstand <= ABSTAND ) { if ( QuadratUndKreis . this . circleMoved ) { int newX = QuadratUndKreis . this . square . getX (); int newY = QuadratUndKreis . this . square . getY (); QuadratUndKreis . this . circle . setX ( newX ); QuadratUndKreis . this . circle . setY ( newY ); } else if ( QuadratUndKreis . this . squareMoved ) { int newX = QuadratUndKreis . this . circle . getX (); int newY = QuadratUndKreis . this . circle . getY (); QuadratUndKreis . this . square . setX ( newX ); QuadratUndKreis . this . square . setY ( newY ); } QuadratUndKreis . this . fixed = true ; } QuadratUndKreis . this . canvas . repaint (); QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } } @Override public void mouseMoved ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { if ( ! QuadratUndKreis . this . fixed ) { int x = e . getX (); int y = e . getY (); int xC = QuadratUndKreis . this . circle . getX (); int yC = QuadratUndKreis . this . circle . getY (); int xS = QuadratUndKreis . this . square . getX (); int yS = QuadratUndKreis . this . square . getY (); int length = QuadratUndKreis . this . square . getLength (); if ( x >= xC && x <= xC + length && y >= yC && y <= yC + length ) { QuadratUndKreis . this . circleMoved = true ; QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } else if ( x >= xS && x <= xS + length && y >= yS && y <= yS + length ) { QuadratUndKreis . this . squareMoved = true ; QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } } } @Override public void mouseReleased ( MouseEvent e ) { QuadratUndKreis . this . squareMoved = false ; QuadratUndKreis . this . circleMoved = false ; QuadratUndKreis . this . rememberLastPoint = null ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } } Klausurvorbereitung (Figure) \u00b6 Klausurvorbereitung (Figure) Erstellen Sie folgendes Fenster zum Zeichnen: Dabei ist zu beachten, dass es sich bei Ellipse , - , + , L\u00f6schen und Farbe aendern um Buttons handelt. W\u00e4hlen Sie die Layoutmanager der jeweiligen JPanels so, dass das gleiche Aussehen entsteht, also z.B. der Button Ellipse \u00fcber die gesamte Breite des Fensters geht und die Buttons \u2013 und + jeweils die angezeigte H\u00f6he ausf\u00fcllen. Abst\u00e4nde zwischen den Buttons m\u00fcssen nicht beachtet werden. In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas). Implementieren Sie eine Klasse Figure mit folgenden 5 Objektvariablen (m\u00fcssen hier nicht private sein \u2013 Paketsichtbarkeit ist gut; wenn Sie sie private machen, ben\u00f6tigen Sie noch Getter`!!!) Shape shape Color color Point start int width int height Shape ist dabei ein enum , das sie gleich in der Klasse erstellen k\u00f6nnen (oder separat). Dieses enum hat folgende Werte: OVAL und RECTANGLE . Die Idee der Objektvariablen ist in der folgenden Abbildung dargestellt ( color ist nicht gezeigt, damit soll die Figure ausgef\u00fcllt werden): Implementieren Sie eine Objektmethode public void changeColor() , in der der Wert von color zuf\u00e4llig (mithilfe von Random ) auf einen neuen Wert gesetzt wird. Implementieren Sie eine Objektmethode public void setStartPoint(Point point) , in der der Wert der Objektvariablen point auf den Parameterwert gesetzt wird. Implementieren Sie eine Objektmethode public void changeShape() , in der der Wert der Objektvariablen shape auf den jeweils anderen Wert aus dem Shape - enum gesetzt wird (d.h. wenn der Wert OVAL war, dann soll er auf RECTANGLE gesetzt werden und andersherum). Implementieren Sie eine Objektmethode public void addSideLength(int xDiff, int yDiff) . Die Werte von xDiff und yDiff geben an, um wieviel sich die Seitenl\u00e4ngen \u00e4ndern. Erkl\u00e4rung: Diese Methode wird sp\u00e4ter aufgerufen, wenn Sie die Figure mit der Maus zeichnen (bei gedr\u00fcckter Maustaste). Entweder Sie ziehen nach rechts unten (dann sind xDiff und yDiff postiv) oder Sie ziehen nach links und/oder nach oben (dann sind xDiff und/oder yDiff entsprechend negativ). Beachten Sie(!): Wenn xDiff und yDiff postiv sind, dann verh\u00e4lt sich die Sache relativ einfach, denn dann werden die Werte einfach auf die jeweiligen Seitenl\u00e4ngen addiert (siehe folgende Abbildung): Wenn xDiff und/oder yDiff negativ sind/ist, dann ist es komplizierter, denn dann \u00e4ndern sich nicht nur die Seitenl\u00e4ngen, sondern es verschiebt sich auch der Startpunkt der Figure (siehe folgende Abbildung f\u00fcr den Fall, dass xDiff und yDiff negativ sind): Implementieren Sie eine Objektmethode public void bigger() , in der die Figure gr\u00f6\u00dfer skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten): Implementieren Sie eine Objektmethode public void smaller() , in der die Figure kleiner skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten): Implementieren Sie MouseListener und MouseMotionListener so, dass Sie bei gedr\u00fcckter Maustaste ein Objekt der Klasse Figure zeichnen k\u00f6nnen, d.h. bei Mausklick in die Canvas wird der start -Punkt der Figure erzeugt und bei gedr\u00fcckter Maustaste vergr\u00f6\u00dfern Sie die Figure . In der folgenden Abbildung steht der Pfeil f\u00fcr die gedr\u00fcckte Maus: Wenn Sie die Maustaste loslassen, ist die Figure fertig gezeichnet. Am Anfang handelt es sich bei der Figure um ein RECTANGLE`. Implementieren Sie das Klick-Ereignis des Buttons Ellipse so, dass aus dem Rechteck eine Ellipse wird. Die Farbe der Figure bleibt gleich. Nutzen Sie dazu die Methode changeShape() aus der Figure -Klasse. Die Beschriftung des Buttons wechselt auf Rechteck . Wenn Sie den Button erneut dr\u00fccken, erscheint wieder das Rechteck und auf dem Button erscheint Ellipse . Implementieren Sie das Klick-Ereignis des Buttons + so, dass sich die Figure vergr\u00f6\u00dfert. Nutzen Sie dazu die Methode bigger() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons - so, dass sich die Figure verkleinert. Nutzen Sie dazu die Methode smaller() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons Farbe aendern so, dass sich die Farbe der Figure \u00e4ndert. Nutzen Sie dazu die Methode changeColor() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons Loeschen so, dass keine Figure mehr existiert und angezeigt wird. eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Figure) Figure.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.awt.Color ; import java.awt.Point ; import java.util.Random ; public class Figure { enum Shape { OVAL , RECTANGLE } Shape shape ; Color color ; Point start ; int width ; int height ; public Figure ( Shape shape , Point start ) { this . shape = shape ; this . start = start ; this . width = 0 ; this . height = 0 ; Random r = new Random (); int gelb = r . nextInt ( 256 ); int rot = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); this . color = new Color ( rot , gelb , blau ); } public void changeColor () { Random r = new Random (); int gelb = r . nextInt ( 256 ); int rot = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); this . color = new Color ( rot , gelb , blau ); } public void addSideLengths ( int xDiff , int yDiff ) { if ( xDiff < 0 && yDiff < 0 ) { Point start = this . start ; start . x += xDiff ; start . y += yDiff ; this . width -= xDiff ; this . height -= yDiff ; this . setStartPoint ( start ); } else if ( xDiff < 0 && yDiff >= 0 ) { Point start = this . start ; start . x += xDiff ; this . width -= xDiff ; this . height += yDiff ; this . setStartPoint ( start ); } else if ( xDiff >= 0 && yDiff < 0 ) { Point start = this . start ; start . y += yDiff ; this . width += xDiff ; this . height -= yDiff ; this . setStartPoint ( start ); } else { this . width += xDiff ; this . height += yDiff ; } } public void setStartPoint ( Point start ) { this . start = start ; } public void bigger () { int xScale = ( int )( this . width * 0.1 ); int yScale = ( int )( this . height * 0.1 ); Point start = this . start ; start . x -= xScale ; start . y -= yScale ; this . width += 2 * xScale ; this . height += 2 * yScale ; this . setStartPoint ( start ); } public void smaller () { int xScale = ( int )( this . width * 0.1 ); int yScale = ( int )( this . height * 0.1 ); Point start = this . start ; start . x += xScale ; start . y += yScale ; this . width -= 2 * xScale ; this . height -= 2 * yScale ; this . setStartPoint ( start ); } public void changeShape () { if ( this . shape == Shape . OVAL ) this . shape = Shape . RECTANGLE ; else this . shape = Shape . OVAL ; } } FigureZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.GridLayout ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.* ; public class FigureZeichnen extends JFrame { Canvas canvas ; public FigureZeichnen () { super (); this . setTitle ( \"Klausur\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this . canvas ); this . canvas . addMouseMotionListener ( this . canvas ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . setSize ( 800 , 600 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel implements MouseListener , MouseMotionListener { Figure figure ; Point remember ; boolean finishedCreating = false ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( this . figure != null ) { g2 . setColor ( this . figure . color ); Point start = this . figure . start ; int width = this . figure . width ; int height = this . figure . height ; if ( this . figure . shape == Figure . Shape . RECTANGLE ) { g2 . fillRect ( start . x , start . y , width , height ); } else if ( this . figure . shape == Figure . Shape . OVAL ) { g2 . fillOval ( start . x , start . y , width , height ); } } } @Override public void mouseDragged ( MouseEvent e ) { if ( this . figure != null && ! this . finishedCreating ) { Point here = e . getPoint (); int xDiff = here . x - this . remember . x ; int yDiff = here . y - this . remember . y ; this . figure . addSideLengths ( xDiff , yDiff ); this . remember = here ; } System . out . println ( this . figure . width + \", \" + this . figure . height ); this . repaint (); } @Override public void mouseMoved ( MouseEvent e ) { } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { Point here = e . getPoint (); if ( this . figure == null ) { this . figure = new Figure ( Figure . Shape . RECTANGLE , here ); this . remember = here ; } this . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { if ( ! this . finishedCreating ) this . finishedCreating = true ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } } // ende innere Klasse private JPanel initNorth () { JPanel north = new JPanel (); north . setLayout ( new GridLayout ( 1 , 1 )); JButton circle = new JButton ( \"Ellipse\" ); circle . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . changeShape (); JButton circle = ( JButton ) e . getSource (); if ( circle . getActionCommand (). equals ( \"Ellipse\" )) circle . setText ( \"Rechteck\" ); else circle . setText ( \"Ellipse\" ); Klausur2PZ . this . canvas . repaint (); } }); north . add ( circle ); return north ; } private JPanel initSouth () { JPanel south = new JPanel (); south . setLayout ( new GridLayout ( 1 , 2 , 10 , 10 )); JButton delete = new JButton ( \"L\u00f6schen\" ); delete . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure = null ; Klausur2PZ . this . canvas . finishedCreating = false ; Klausur2PZ . this . canvas . remember = null ; Klausur2PZ . this . canvas . repaint (); } }); south . add ( delete ); JButton farbe = new JButton ( \"Farbe aendern\" ); farbe . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . changeColor ();; Klausur2PZ . this . canvas . repaint (); } }); south . add ( farbe ); return south ; } private JPanel initWest () { JPanel west = new JPanel (); west . setLayout ( new GridLayout ( 1 , 1 )); JButton minus = new JButton ( \"-\" ); minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . smaller (); Klausur2PZ . this . canvas . repaint (); } }); west . add ( minus ); return west ; } private JPanel initEast () { JPanel east = new JPanel (); east . setLayout ( new GridLayout ( 1 , 1 )); JButton plus = new JButton ( \"+\" ); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . bigger (); Klausur2PZ . this . canvas . repaint (); } }); east . add ( plus ); return east ; } public static void main ( String [] args ) { new Klausur2PZ (); } } Zusatz \u00b6 Test-driven development \u00b6 parseDouble(String) In der Aufgabe 2 sollen Sie f\u00fcr die Klasse MyInteger eine Methode parseInt(String s) schreiben, die einen String s in eine int -Zahl umwandelt, wenn dies m\u00f6glich ist. In dieser \u00dcbung wollen wir eine solche (statische) Methode parseDouble(String s) f\u00fcr eine Klasse MyDouble testgetrieben entwickeln. \u00dcberlegen Sie sich dazu einige Strings, die Sie umwandeln wollen und die dazugeh\u00f6rigen erwarteten Ergebnisse. Es muss nicht vollst\u00e4ndig implementiert werden. Es geht ums Prinzip. Mithilfe von assertThrows() k\u00f6nnen Sie \u00fcbrigens pr\u00fcfen, ob eine Exception geworfen wird (wenn s keiner Zahl entspricht) - siehe dazu z.B. hier oder hier . Viel Spa\u00df!","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubung-1-wiederholung-und-codereview","text":"\u00dcbung 1 (12. + 14.4.) \u00dcbung bringt Frau Busjahn mit in die \u00dcbung","title":"\u00dcbung 1 (Wiederholung und Codereview)"},{"location":"uebungen/#ubung-2-string-und-algorithmisches-denken","text":"\u00dcbung 2 (19. + 21.4.) Erstellen Sie im Paket uebungen.uebung2 eine Java-Klasse Uebung2 mit main() -Methode. In diese Klasse implementieren wir statische Methoden. \u00d6ffnen Sie zum L\u00f6sen der \u00dcbung am besten die JavaDoc-Dokumentation der Klasse String . \u00dcberlegen Sie sich, bevor Sie jeweils anfangen zu implementieren, genau, wie Sie vorgehen m\u00f6chten. Implementieren Sie eine Methode static boolean isBinaryNumber(String s) . Diese Methode \u00fcberpr\u00fcft, ob der String s einer Bin\u00e4rzahl entspricht, d.h. ob er nur 0 und 1 enth\u00e4lt. Testen Sie die Methode isBinaryNumber(String s) z.B. mit den folgenden Aufrufen: System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false Implementieren Sie eine Methode static int binaryToDecimal(String s) . Diese Methode wandelt den String s in eine Dezimalzahl um, wenn s einer Bin\u00e4rzahl entspricht. Wenn s keiner Bin\u00e4rzahl entspricht, wird -1 zur\u00fcckgegeben. Testen Sie die Methode binaryToDecimal(String s) z.B. mit den folgenden Aufrufen: System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 Implementieren Sie eine Methode static String toLowerCase(String input) . Diese Methode wandelt alle Gro\u00dfbuchstaben ('A'...'Z') in Kleinbuchstaben um (und nur diese - alle anderen Zeichen bleiben erhalten). Schauen Sie sich dazu auch nochmal die ASCII-Tabelle an. Testen Sie die Methode toLowerCase(String input) z.B. mit den folgenden Aufrufen: System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% Zusatz: Implementieren Sie eine Methode static boolean isPalindrome(String input) . Diese Methode pr\u00fcft, ob es sich bei input um ein Palindrom handelt (also von vorne nach hinten genauso gelesen werden kann, wie von hinten nach vorne). Gro\u00df- und Kleinschreibung wird nicht ber\u00fccksichtigt! Die Methode substring(int,int) aus String ist dabei wahrscheinlich n\u00fctzlich! Testen Sie die Methode isPalindrome(String input) z.B. mit den folgenden Aufrufen: System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false Angenommen, Sie sollen f\u00fcr einen gegebenen String angeben, ob er korrekt geklammerte Ausdr\u00fccke enth\u00e4lt (nur die Klammern betrachten). Wie w\u00fcrden Sie vorgehen? Nicht implementieren, nur nachdenken. Folgende Beispiele: ((()))()(()) // korrekt ((()) // nicht korrekt (())) // nicht korrekt ())( // nicht korrekt Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 package uebungen.uebung2.loesung ; public class Uebung2 { public static boolean isBinaryNumber ( String s ) { for ( int index = 0 ; index < s . length (); index ++ ) { char c = s . charAt ( index ); if ( ! ( c == '0' || c == '1' )) { return false ; } } return true ; } public static int binaryToDecimal ( String s ) { if ( isBinaryNumber ( s )) { int decimalValue = 0 ; for ( int index = 0 ; index < s . length (); index ++ ) { char c = s . charAt ( index ); int value = c - '0' ; decimalValue = decimalValue * 2 + value ; } return decimalValue ; } else return - 1 ; } public static String toLowerCase ( String input ) { String output = \"\" ; for ( int index = 0 ; index < input . length (); index ++ ) { char c = input . charAt ( index ); if ( c >= 'A' && c <= 'Z' ) { c = ( char )( c + 32 ); } output += c ; } return output ; } public static boolean isPalindrome ( String input ) { String s = toLowerCase ( input ); boolean palindrome = true ; while ( palindrome && s . length () > 1 ) { char c1 = s . charAt ( 0 ); char c2 = s . charAt ( s . length () - 1 ); if ( c1 == c2 ) { s = s . substring ( 1 , s . length () - 1 ); } else { palindrome = false ; } } return palindrome ; } public static boolean checkBraces ( String input ) { int nrOpening = 0 ; // man koennte auch fuer jede oeffnende ++ und int nrClosing = 0 ; // jede schliessende -- und dann nur eine Variable boolean correct = true ; for ( int index = 0 ; correct && index < input . length (); index ++ ) { char c = input . charAt ( index ); if ( c == '(' ) { nrOpening ++ ; } else if ( c == ')' ) { nrClosing ++ ; } if ( nrClosing > nrOpening ) // dann waere hier < 0 { correct = false ; } } if ( nrOpening != nrClosing ) // dann waere hier == 0 { correct = false ; } return correct ; } public static void main ( String [] args ) { System . out . println ( isBinaryNumber ( \"101101\" )); // true System . out . println ( isBinaryNumber ( \"0\" )); // true System . out . println ( isBinaryNumber ( \"101a01\" )); // false System . out . println ( isBinaryNumber ( \"101201\" )); // false System . out . println ( binaryToDecimal ( \"101101\" )); // 45 System . out . println ( binaryToDecimal ( \"0\" )); // 0 System . out . println ( binaryToDecimal ( \"000001\" )); // 1 System . out . println ( binaryToDecimal ( \"100000\" )); // 32 System . out . println ( binaryToDecimal ( \"101a01\" )); // -1 System . out . println ( binaryToDecimal ( \"101201\" )); // -1 System . out . println ( toLowerCase ( \"abcdEFG\" )); // abcdefg System . out . println ( toLowerCase ( \"abcd123EFG\" )); // abcd123efg System . out . println ( toLowerCase ( \"ABC XYZ !%\" )); // abc xyz !% System . out . println ( isPalindrome ( \"Otto\" )); // true System . out . println ( isPalindrome ( \"abc_CBA\" )); // true System . out . println ( isPalindrome ( \"abc_-CBA\" )); // false System . out . println ( isPalindrome ( \"-\" )); // true System . out . println ( isPalindrome ( \"Dreh mal am Herd\" )); // false // das letzte waere okay, wenn man bei der Pruefung // die Leerzeichen ignorieren wuerde, waere auch moeglich } }","title":"\u00dcbung 2 (String und algorithmisches Denken)"},{"location":"uebungen/#ubung-3-exceptions","text":"\u00dcbung 3 (26. + 28.4.) Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse JOptionPane aus dem und deren Division! Fangen Sie folgende Ausnahmen ab: Falls die Eingabe keiner Zahl entspricht. Falls die zweite Zahl eine 0 ist. Scenario : Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich: falsche Eingabe - keine Zahl: Fenster \u00f6ffnet sich erneut (andere Nachricht!): Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich: die Division Zahl1/Zahl2 schl\u00e4gt fehl ( ArithmeticException ), deshalb (andere Nachricht!): Ergebnis Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. public int inputInt(int min, int max) , welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich [min, max] liegen muss. Lesen Sie eine Zahl ein und geben Sie die Zahl umgedreht (r\u00fcckw\u00e4rts gelesen) wieder aus (f\u00fchrende Nullen entfallen): 3456789 --> 9876543 1000 --> 1 Lesen Sie eine Zahl ein und geben Sie die Quersumme der Zahl aus. 123456 --> 21 1000 --> 1 Viel Spa\u00df! Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 package uebungen.uebung3.loesung ; import javax.swing.JOptionPane ; public class Uebung3 { public static int inputInt ( String message ) { int number = 0 ; boolean notANumber = true ; while ( notANumber ) { String input = JOptionPane . showInputDialog ( message ); try { number = Integer . parseInt ( input ); notANumber = false ; } catch ( NumberFormatException e ) { message = \"Ihre Eingabe war keine Zahl!\" ; } } return number ; } public static int inputInt ( String message , int min , int max ) { int number = 0 ; boolean notANumber = true ; while ( notANumber ) { String input = JOptionPane . showInputDialog ( message ); try { number = Integer . parseInt ( input ); if ( number >= min && number <= max ) { notANumber = false ; } else { message = \"Zahl nicht zwischen \" + min + \" und \" + max + \" !\" ; } } catch ( NumberFormatException e ) { message = \"Ihre Eingabe war keine Zahl!\" ; } } return number ; } public static void printDivide () { int number1 = inputInt ( \"Zahl 1:\" ); int number2 = 0 ; double result = 0.0 ; boolean isZero = true ; String message = \"Zahl 2:\" ; while ( isZero ) { number2 = inputInt ( message ); try { result = number1 / number2 ; isZero = false ; } catch ( ArithmeticException e ) { message = \"Zahl darf nicht 0 sein\" ; } } String output = number1 + \" / \" + number2 + \" = \" + result ; JOptionPane . showMessageDialog ( null , output ); } public static void printReverse () { int number = inputInt ( \"Zahl : \" ); int copyNumber = number ; // fuer spaetere Ausgabe int reverse = 0 ; while ( number != 0 ) { int last = number % 10 ; reverse = reverse * 10 + last ; number = number / 10 ; } String output = copyNumber + \" --> \" + reverse ; JOptionPane . showMessageDialog ( null , output ); } public static void printChecksum () { int number = inputInt ( \"Zahl : \" ); int copyNumber = number ; // fuer spaetere Ausgabe int checksum = 0 ; while ( number != 0 ) { int last = number % 10 ; checksum = checksum + last ; number = number / 10 ; } String output = \"Die Quersumme von \" + copyNumber + \" ist \" + checksum ; JOptionPane . showMessageDialog ( null , output ); } public static void main ( String [] args ) { int number1 = inputInt ( \"Geben Sie eine Zahl ein :\" ); System . out . println ( number1 ); int choice = JOptionPane . showConfirmDialog ( null , \"Wollen Sie weiterspielen?\" , \"Abfrage\" , JOptionPane . YES_NO_OPTION ); System . out . println ( choice ); if ( choice == JOptionPane . YES_OPTION ) { System . out . println ( \"yes geklickt\" ); } if ( choice == JOptionPane . NO_OPTION ) { System . out . println ( \"no geklickt\" ); } if ( choice == JOptionPane . CANCEL_OPTION ) { System . out . println ( \"no geklickt\" ); } printDivide (); printReverse (); printChecksum (); } }","title":"\u00dcbung 3 (Exceptions)"},{"location":"uebungen/#ubung-4-string","text":"\u00dcbung 4 (3. + 5.5.) Gegeben ist die Klasse StringPi . Sie enth\u00e4lt nur eine einzige Konstante PI vom Typ String . Dieser String enth\u00e4lt die ersten 100 000 Nachkommastellen von \u03c0. Die Klasse StringPi.java k\u00f6nnen Sie hier herunterladen . Klasse StringPi mit der Konstanten PI ```java public class StringPi { public static final String PI = new StringBuilder(\"3\" + \"141592653589793238462643383279502884197169399375105820974944592307816406286\" + \"208998628034825342117067982148086513282306647093844609550582231725359408128481\" + \"117450284102701938521105559644622948954930381964428810975665933446128475648233\" + \"786783165271201909145648566923460348610454326648213393607260249141273724587006\" + \"606315588174881520920962829254091715364367892590360011330530548820466521384146\" + \"951941511609433057270365759591953092186117381932611793105118548074462379962749\" + \"567351885752724891227938183011949129833673362440656643086021394946395224737190\" + \"702179860943702770539217176293176752384674818467669405132000568127145263560827\" + \"785771342757789609173637178721468440901224953430146549585371050792279689258923\" + \"542019956112129021960864034418159813629774771309960518707211349999998372978049\" + \"951059731732816096318595024459455346908302642522308253344685035261931188171010\" + \"003137838752886587533208381420617177669147303598253490428755468731159562863882\" + \"353787593751957781857780532171226806613001927876611195909216420198938095257201\" + \"065485863278865936153381827968230301952035301852968995773622599413891249721775\" + \"283479131515574857242454150695950829533116861727855889075098381754637464939319\" + \"255060400927701671139009848824012858361603563707660104710181942955596198946767\" + \"837449448255379774726847104047534646208046684259069491293313677028989152104752\" + \"162056966024058038150193511253382430035587640247496473263914199272604269922796\" + \"782354781636009341721641219924586315030286182974555706749838505494588586926995\" + \"690927210797509302955321165344987202755960236480665499119881834797753566369807\" + \"426542527862551818417574672890977772793800081647060016145249192173217214772350\" + \"141441973568548161361157352552133475741849468438523323907394143334547762416862\" + \"518983569485562099219222184272550254256887671790494601653466804988627232791786\" + \"085784383827967976681454100953883786360950680064225125205117392984896084128488\" + \"626945604241965285022210661186306744278622039194945047123713786960956364371917\" + \"287467764657573962413890865832645995813390478027590099465764078951269468398352\" + \"595709825822620522489407726719478268482601476990902640136394437455305068203496\" + \"252451749399651431429809190659250937221696461515709858387410597885959772975498\" + \"930161753928468138268683868942774155991855925245953959431049972524680845987273\" + \"644695848653836736222626099124608051243884390451244136549762780797715691435997\" + \"700129616089441694868555848406353422072225828488648158456028506016842739452267\" + \"467678895252138522549954666727823986456596116354886230577456498035593634568174\" + \"324112515076069479451096596094025228879710893145669136867228748940560101503308\" + \"617928680920874760917824938589009714909675985261365549781893129784821682998948\" + \"722658804857564014270477555132379641451523746234364542858444795265867821051141\" + \"354735739523113427166102135969536231442952484937187110145765403590279934403742\" + \"007310578539062198387447808478489683321445713868751943506430218453191048481005\" + \"370614680674919278191197939952061419663428754440643745123718192179998391015919\" + \"561814675142691239748940907186494231961567945208095146550225231603881930142093\" + \"762137855956638937787083039069792077346722182562599661501421503068038447734549\" + \"202605414665925201497442850732518666002132434088190710486331734649651453905796\" + \"268561005508106658796998163574736384052571459102897064140110971206280439039759\" + \"515677157700420337869936007230558763176359421873125147120532928191826186125867\" + \"321579198414848829164470609575270695722091756711672291098169091528017350671274\" + \"858322287183520935396572512108357915136988209144421006751033467110314126711136\" + \"990865851639831501970165151168517143765761835155650884909989859982387345528331\" + \"635507647918535893226185489632132933089857064204675259070915481416549859461637\" + \"180270981994309924488957571282890592323326097299712084433573265489382391193259\" + \"746366730583604142813883032038249037589852437441702913276561809377344403070746\" + \"921120191302033038019762110110044929321516084244485963766983895228684783123552\" + \"658213144957685726243344189303968642624341077322697802807318915441101044682325\" + \"271620105265227211166039666557309254711055785376346682065310989652691862056476\" + \"931257058635662018558100729360659876486117910453348850346113657686753249441668\" + \"039626579787718556084552965412665408530614344431858676975145661406800700237877\" + \"659134401712749470420562230538994561314071127000407854733269939081454664645880\" + \"797270826683063432858785698305235808933065757406795457163775254202114955761581\" + \"400250126228594130216471550979259230990796547376125517656751357517829666454779\" + \"174501129961489030463994713296210734043751895735961458901938971311179042978285\" + \"647503203198691514028708085990480109412147221317947647772622414254854540332157\" + \"185306142288137585043063321751829798662237172159160771669254748738986654949450\" + \"114654062843366393790039769265672146385306736096571209180763832716641627488880\" + \"078692560290228472104031721186082041900042296617119637792133757511495950156604\" + \"963186294726547364252308177036751590673502350728354056704038674351362222477158\" + \"915049530984448933309634087807693259939780541934144737744184263129860809988868\" + \"741326047215695162396586457302163159819319516735381297416772947867242292465436\" + \"680098067692823828068996400482435403701416314965897940924323789690706977942236\" + \"250822168895738379862300159377647165122893578601588161755782973523344604281512\" + \"627203734314653197777416031990665541876397929334419521541341899485444734567383\" + \"162499341913181480927777103863877343177207545654532207770921201905166096280490\" + \"926360197598828161332316663652861932668633606273567630354477628035045077723554\" + \"710585954870279081435624014517180624643626794561275318134078330336254232783944\" + \"975382437205835311477119926063813346776879695970309833913077109870408591337464\" + \"144282277263465947047458784778720192771528073176790770715721344473060570073349\" + \"243693113835049316312840425121925651798069411352801314701304781643788518529092\" + \"854520116583934196562134914341595625865865570552690496520985803385072242648293\" + \"972858478316305777756068887644624824685792603953527734803048029005876075825104\" + \"747091643961362676044925627420420832085661190625454337213153595845068772460290\" + \"161876679524061634252257719542916299193064553779914037340432875262888963995879\" + \"475729174642635745525407909145135711136941091193932519107602082520261879853188\" + \"770584297259167781314969900901921169717372784768472686084900337702424291651300\" + \"500516832336435038951702989392233451722013812806965011784408745196012122859937\" + \"162313017114448464090389064495444006198690754851602632750529834918740786680881\" + \"833851022833450850486082503930213321971551843063545500766828294930413776552793\" + \"975175461395398468339363830474611996653858153842056853386218672523340283087112\" + \"328278921250771262946322956398989893582116745627010218356462201349671518819097\" + \"303811980049734072396103685406643193950979019069963955245300545058068550195673\" + \"022921913933918568034490398205955100226353536192041994745538593810234395544959\" + \"778377902374216172711172364343543947822181852862408514006660443325888569867054\" + \"315470696574745855033232334210730154594051655379068662733379958511562578432298\" + \"827372319898757141595781119635833005940873068121602876496286744604774649159950\" + \"549737425626901049037781986835938146574126804925648798556145372347867330390468\" + \"838343634655379498641927056387293174872332083760112302991136793862708943879936\" + \"201629515413371424892830722012690147546684765357616477379467520049075715552781\" + \"965362132392640616013635815590742202020318727760527721900556148425551879253034\" + \"351398442532234157623361064250639049750086562710953591946589751413103482276930\" + \"624743536325691607815478181152843667957061108615331504452127473924544945423682\" + \"886061340841486377670096120715124914043027253860764823634143346235189757664521\" + \"641376796903149501910857598442391986291642193994907236234646844117394032659184\" + \"044378051333894525742399508296591228508555821572503107125701266830240292952522\" + \"011872676756220415420516184163484756516999811614101002996078386909291603028840\" + \"026910414079288621507842451670908700069928212066041837180653556725253256753286\" + \"129104248776182582976515795984703562226293486003415872298053498965022629174878\" + \"820273420922224533985626476691490556284250391275771028402799806636582548892648\" + \"802545661017296702664076559042909945681506526530537182941270336931378517860904\" + \"070866711496558343434769338578171138645587367812301458768712660348913909562009\" + \"939361031029161615288138437909904231747336394804575931493140529763475748119356\" + \"709110137751721008031559024853090669203767192203322909433467685142214477379393\" + \"751703443661991040337511173547191855046449026365512816228824462575916333039107\" + \"225383742182140883508657391771509682887478265699599574490661758344137522397096\" + \"834080053559849175417381883999446974867626551658276584835884531427756879002909\" + \"517028352971634456212964043523117600665101241200659755851276178583829204197484\" + \"423608007193045761893234922927965019875187212726750798125547095890455635792122\" + \"103334669749923563025494780249011419521238281530911407907386025152274299581807\" + \"247162591668545133312394804947079119153267343028244186041426363954800044800267\" + \"049624820179289647669758318327131425170296923488962766844032326092752496035799\" + \"646925650493681836090032380929345958897069536534940603402166544375589004563288\" + \"225054525564056448246515187547119621844396582533754388569094113031509526179378\" + \"002974120766514793942590298969594699556576121865619673378623625612521632086286\" + \"922210327488921865436480229678070576561514463204692790682120738837781423356282\" + \"360896320806822246801224826117718589638140918390367367222088832151375560037279\" + \"839400415297002878307667094447456013455641725437090697939612257142989467154357\" + \"846878861444581231459357198492252847160504922124247014121478057345510500801908\" + \"699603302763478708108175450119307141223390866393833952942578690507643100638351\" + \"983438934159613185434754649556978103829309716465143840700707360411237359984345\" + \"225161050702705623526601276484830840761183013052793205427462865403603674532865\" + \"105706587488225698157936789766974220575059683440869735020141020672358502007245\" + \"225632651341055924019027421624843914035998953539459094407046912091409387001264\" + \"560016237428802109276457931065792295524988727584610126483699989225695968815920\" + \"560010165525637567856672279661988578279484885583439751874454551296563443480396\" + \"642055798293680435220277098429423253302257634180703947699415979159453006975214\" + \"829336655566156787364005366656416547321704390352132954352916941459904160875320\" + \"186837937023488868947915107163785290234529244077365949563051007421087142613497\" + \"459561513849871375704710178795731042296906667021449863746459528082436944578977\" + \"233004876476524133907592043401963403911473202338071509522201068256342747164602\" + \"433544005152126693249341967397704159568375355516673027390074972973635496453328\" + \"886984406119649616277344951827369558822075735517665158985519098666539354948106\" + \"887320685990754079234240230092590070173196036225475647894064754834664776041146\" + \"323390565134330684495397907090302346046147096169688688501408347040546074295869\" + \"913829668246818571031887906528703665083243197440477185567893482308943106828702\" + \"722809736248093996270607472645539925399442808113736943388729406307926159599546\" + \"262462970706259484556903471197299640908941805953439325123623550813494900436427\" + \"852713831591256898929519642728757394691427253436694153236100453730488198551706\" + \"594121735246258954873016760029886592578662856124966552353382942878542534048308\" + \"330701653722856355915253478445981831341129001999205981352205117336585640782648\" + \"494276441137639386692480311836445369858917544264739988228462184490087776977631\" + \"279572267265556259628254276531830013407092233436577916012809317940171859859993\" + \"384923549564005709955856113498025249906698423301735035804408116855265311709957\" + \"089942732870925848789443646005041089226691783525870785951298344172953519537885\" + \"534573742608590290817651557803905946408735061232261120093731080485485263572282\" + \"576820341605048466277504500312620080079980492548534694146977516493270950493463\" + \"938243222718851597405470214828971117779237612257887347718819682546298126868581\" + \"705074027255026332904497627789442362167411918626943965067151577958675648239939\" + \"176042601763387045499017614364120469218237076488783419689686118155815873606293\" + \"860381017121585527266830082383404656475880405138080163363887421637140643549556\" + \"186896411228214075330265510042410489678352858829024367090488711819090949453314\" + \"421828766181031007354770549815968077200947469613436092861484941785017180779306\" + \"810854690009445899527942439813921350558642219648349151263901280383200109773868\" + \"066287792397180146134324457264009737425700735921003154150893679300816998053652\" + \"027600727749674584002836240534603726341655425902760183484030681138185510597970\" + \"566400750942608788573579603732451414678670368809880609716425849759513806930944\" + \"940151542222194329130217391253835591503100333032511174915696917450271494331515\" + \"588540392216409722910112903552181576282328318234254832611191280092825256190205\" + \"263016391147724733148573910777587442538761174657867116941477642144111126358355\" + \"387136101102326798775641024682403226483464176636980663785768134920453022408197\" + \"278564719839630878154322116691224641591177673225326433568614618654522268126887\" + \"268445968442416107854016768142080885028005414361314623082102594173756238994207\" + \"571362751674573189189456283525704413354375857534269869947254703165661399199968\" + \"262824727064133622217892390317608542894373393561889165125042440400895271983787\" + \"386480584726895462438823437517885201439560057104811949884239060613695734231559\" + \"079670346149143447886360410318235073650277859089757827273130504889398900992391\" + \"350337325085598265586708924261242947367019390772713070686917092646254842324074\" + \"855036608013604668951184009366860954632500214585293095000090715105823626729326\" + \"453738210493872499669933942468551648326113414611068026744663733437534076429402\" + \"668297386522093570162638464852851490362932019919968828517183953669134522244470\" + \"804592396602817156551565666111359823112250628905854914509715755390024393153519\" + \"090210711945730024388017661503527086260253788179751947806101371500448991721002\" + \"220133501310601639154158957803711779277522597874289191791552241718958536168059\" + \"474123419339842021874564925644346239253195313510331147639491199507285843065836\" + \"193536932969928983791494193940608572486396883690326556436421664425760791471086\" + \"998431573374964883529276932822076294728238153740996154559879825989109371712621\" + \"828302584811238901196822142945766758071865380650648702613389282299497257453033\" + \"283896381843944770779402284359883410035838542389735424395647555684095224844554\" + \"139239410001620769363684677641301781965937997155746854194633489374843912974239\" + \"143365936041003523437770658886778113949861647874714079326385873862473288964564\" + \"359877466763847946650407411182565837887845485814896296127399841344272608606187\" + \"245545236064315371011274680977870446409475828034876975894832824123929296058294\" + \"861919667091895808983320121031843034012849511620353428014412761728583024355983\" + \"003204202451207287253558119584014918096925339507577840006746552603144616705082\" + \"768277222353419110263416315714740612385042584598841990761128725805911393568960\" + \"143166828317632356732541707342081733223046298799280490851409479036887868789493\" + \"054695570307261900950207643349335910602454508645362893545686295853131533718386\" + \"826561786227363716975774183023986006591481616404944965011732131389574706208847\" + \"480236537103115089842799275442685327797431139514357417221975979935968525228574\" + \"526379628961269157235798662057340837576687388426640599099350500081337543245463\" + \"596750484423528487470144354541957625847356421619813407346854111766883118654489\" + \"377697956651727966232671481033864391375186594673002443450054499539974237232871\" + \"249483470604406347160632583064982979551010954183623503030945309733583446283947\" + \"630477564501500850757894954893139394489921612552559770143685894358587752637962\" + \"559708167764380012543650237141278346792610199558522471722017772370041780841942\" + \"394872540680155603599839054898572354674564239058585021671903139526294455439131\" + \"663134530893906204678438778505423939052473136201294769187497519101147231528932\" + \"677253391814660730008902776896311481090220972452075916729700785058071718638105\" + \"496797310016787085069420709223290807038326345345203802786099055690013413718236\" + \"837099194951648960075504934126787643674638490206396401976668559233565463913836\" + \"318574569814719621084108096188460545603903845534372914144651347494078488442377\" + \"217515433426030669883176833100113310869042193903108014378433415137092435301367\" + \"763108491351615642269847507430329716746964066653152703532546711266752246055119\" + \"958183196376370761799191920357958200759560530234626775794393630746305690108011\" + \"494271410093913691381072581378135789400559950018354251184172136055727522103526\" + \"803735726527922417373605751127887218190844900617801388971077082293100279766593\" + \"583875890939568814856026322439372656247277603789081445883785501970284377936240\" + \"782505270487581647032458129087839523245323789602984166922548964971560698119218\" + \"658492677040395648127810217991321741630581055459880130048456299765112124153637\" + \"451500563507012781592671424134210330156616535602473380784302865525722275304999\" + \"883701534879300806260180962381516136690334111138653851091936739383522934588832\" + \"255088706450753947395204396807906708680644509698654880168287434378612645381583\" + \"428075306184548590379821799459968115441974253634439960290251001588827216474500\" + \"682070419376158454712318346007262933955054823955713725684023226821301247679452\" + \"264482091023564775272308208106351889915269288910845557112660396503439789627825\" + \"001611015323516051965590421184494990778999200732947690586857787872098290135295\" + \"661397888486050978608595701773129815531495168146717695976099421003618355913877\" + \"781769845875810446628399880600616229848616935337386578773598336161338413385368\" + \"421197893890018529569196780455448285848370117096721253533875862158231013310387\" + \"766827211572694951817958975469399264219791552338576623167627547570354699414892\" + \"904130186386119439196283887054367774322427680913236544948536676800000106526248\" + \"547305586159899914017076983854831887501429389089950685453076511680333732226517\" + \"566220752695179144225280816517166776672793035485154204023817460892328391703275\" + \"425750867655117859395002793389592057668278967764453184040418554010435134838953\" + \"120132637836928358082719378312654961745997056745071833206503455664403449045362\" + \"756001125018433560736122276594927839370647842645676338818807565612168960504161\" + \"139039063960162022153684941092605387688714837989559999112099164646441191856827\" + \"700457424343402167227644558933012778158686952506949936461017568506016714535431\" + \"581480105458860564550133203758645485840324029871709348091055621167154684847780\" + \"394475697980426318099175642280987399876697323769573701580806822904599212366168\" + \"902596273043067931653114940176473769387351409336183321614280214976339918983548\" + \"487562529875242387307755955595546519639440182184099841248982623673771467226061\" + \"633643296406335728107078875816404381485018841143188598827694490119321296827158\" + \"884133869434682859006664080631407775772570563072940049294030242049841656547973\" + \"670548558044586572022763784046682337985282710578431975354179501134727362577408\" + \"021347682604502285157979579764746702284099956160156910890384582450267926594205\" + \"550395879229818526480070683765041836562094555434613513415257006597488191634135\" + \"955671964965403218727160264859304903978748958906612725079482827693895352175362\" + \"185079629778514618843271922322381015874445052866523802253284389137527384589238\" + \"442253547265309817157844783421582232702069028723233005386216347988509469547200\" + \"479523112015043293226628272763217790884008786148022147537657810581970222630971\" + \"749507212724847947816957296142365859578209083073323356034846531873029302665964\" + \"501371837542889755797144992465403868179921389346924474198509733462679332107268\" + \"687076806263991936196504409954216762784091466985692571507431574079380532392523\" + \"947755744159184582156251819215523370960748332923492103451462643744980559610330\" + \"799414534778457469999212859999939961228161521931488876938802228108300198601654\" + \"941654261696858678837260958774567618250727599295089318052187292461086763995891\" + \"614585505839727420980909781729323930106766386824040111304024700735085782872462\" + \"713494636853181546969046696869392547251941399291465242385776255004748529547681\" + \"479546700705034799958886769501612497228204030399546327883069597624936151010243\" + \"655535223069061294938859901573466102371223547891129254769617600504797492806072\" + \"126803922691102777226102544149221576504508120677173571202718024296810620377657\" + \"883716690910941807448781404907551782038565390991047759414132154328440625030180\" + \"275716965082096427348414695726397884256008453121406593580904127113592004197598\" + \"513625479616063228873618136737324450607924411763997597461938358457491598809766\" + \"744709300654634242346063423747466608043170126005205592849369594143408146852981\" + \"505394717890045183575515412522359059068726487863575254191128887737176637486027\" + \"660634960353679470269232297186832771739323619200777452212624751869833495151019\" + \"864269887847171939664976907082521742336566272592844062043021411371992278526998\" + \"469884770232382384005565551788908766136013047709843861168705231055314916251728\" + \"373272867600724817298763756981633541507460883866364069347043720668865127568826\" + \"614973078865701568501691864748854167915459650723428773069985371390430026653078\" + \"398776385032381821553559732353068604301067576083890862704984188859513809103042\" + \"359578249514398859011318583584066747237029714978508414585308578133915627076035\" + \"639076394731145549583226694570249413983163433237897595568085683629725386791327\" + \"505554252449194358912840504522695381217913191451350099384631177401797151228378\" + \"546011603595540286440590249646693070776905548102885020808580087811577381719174\" + \"177601733073855475800605601433774329901272867725304318251975791679296996504146\" + \"070664571258883469797964293162296552016879730003564630457930884032748077181155\" + \"533090988702550520768046303460865816539487695196004408482065967379473168086415\" + \"645650530049881616490578831154345485052660069823093157776500378070466126470602\" + \"145750579327096204782561524714591896522360839664562410519551052235723973951288\" + \"181640597859142791481654263289200428160913693777372229998332708208296995573772\" + \"737566761552711392258805520189887620114168005468736558063347160373429170390798\" + \"639652296131280178267971728982293607028806908776866059325274637840539769184808\" + \"204102194471971386925608416245112398062011318454124478205011079876071715568315\" + \"407886543904121087303240201068534194723047666672174986986854707678120512473679\" + \"247919315085644477537985379973223445612278584329684664751333657369238720146472\" + \"367942787004250325558992688434959287612400755875694641370562514001179713316620\" + \"715371543600687647731867558714878398908107429530941060596944315847753970094398\" + \"839491443235366853920994687964506653398573888786614762944341401049888993160051\" + \"207678103588611660202961193639682134960750111649832785635316145168457695687109\" + \"002999769841263266502347716728657378579085746646077228341540311441529418804782\" + \"543876177079043000156698677679576090996693607559496515273634981189641304331166\" + \"277471233881740603731743970540670310967676574869535878967003192586625941051053\" + \"358438465602339179674926784476370847497833365557900738419147319886271352595462\" + \"518160434225372996286326749682405806029642114638643686422472488728343417044157\" + \"348248183330164056695966886676956349141632842641497453334999948000266998758881\" + \"593507357815195889900539512085351035726137364034367534714104836017546488300407\" + \"846416745216737190483109676711344349481926268111073994825060739495073503169019\" + \"731852119552635632584339099822498624067031076831844660729124874754031617969941\" + \"139738776589986855417031884778867592902607004321266617919223520938227878880988\" + \"633599116081923535557046463491132085918979613279131975649097600013996234445535\" + \"014346426860464495862476909434704829329414041114654092398834443515913320107739\" + \"441118407410768498106634724104823935827401944935665161088463125678529776973468\" + \"430306146241803585293315973458303845541033701091676776374276210213701354854450\" + \"926307190114731848574923318167207213727935567952844392548156091372812840633303\" + \"937356242001604566455741458816605216660873874804724339121295587776390696903707\" + \"882852775389405246075849623157436917113176134783882719416860662572103685132156\" + \"647800147675231039357860689611125996028183930954870905907386135191459181951029\" + \"732787557104972901148717189718004696169777001791391961379141716270701895846921\" + \"434369676292745910994006008498356842520191559370370101104974733949387788598941\" + \"743303178534870760322198297057975119144051099423588303454635349234982688362404\" + \"332726741554030161950568065418093940998202060999414021689090070821330723089662\" + \"119775530665918814119157783627292746156185710372172471009521423696483086410259\" + \"288745799932237495519122195190342445230753513380685680735446499512720317448719\" + \"540397610730806026990625807602029273145525207807991418429063884437349968145827\" + \"337207266391767020118300464819000241308350884658415214899127610651374153943565\" + \"721139032857491876909441370209051703148777346165287984823533829726013611098451\" + \"484182380812054099612527458088109948697221612852489742555551607637167505489617\" + \"301680961380381191436114399210638005083214098760459930932485102516829446726066\" + \"613815174571255975495358023998314698220361338082849935670557552471290274539776\" + \"214049318201465800802156653606776550878380430413431059180460680083459113664083\" + \"488740800574127258670479225831912741573908091438313845642415094084913391809684\" + \"025116399193685322555733896695374902662092326131885589158083245557194845387562\" + \"878612885900410600607374650140262782402734696252821717494158233174923968353013\" + \"617865367376064216677813773995100658952887742766263684183068019080460984980946\" + \"976366733566228291513235278880615776827815958866918023894033307644191240341202\" + \"231636857786035727694154177882643523813190502808701857504704631293335375728538\" + \"660588890458311145077394293520199432197117164223500564404297989208159430716701\" + \"985746927384865383343614579463417592257389858800169801475742054299580124295810\" + \"545651083104629728293758416116253256251657249807849209989799062003593650993472\" + \"158296517413579849104711166079158743698654122234834188772292944633517865385673\" + \"196255985202607294767407261676714557364981210567771689348491766077170527718760\" + \"119990814411305864557791052568430481144026193840232247093924980293355073184589\" + \"035539713308844617410795916251171486487446861124760542867343670904667846867027\" + \"409188101424971114965781772427934707021668829561087779440504843752844337510882\" + \"826477197854000650970403302186255614733211777117441335028160884035178145254196\" + \"432030957601869464908868154528562134698835544456024955666843660292219512483091\" + \"060537720198021831010327041783866544718126039719068846237085751808003532704718\" + \"565949947612424811099928867915896904956394762460842406593094862150769031498702\" + \"067353384834955083636601784877106080980426924713241000946401437360326564518456\" + \"679245666955100150229833079849607994988249706172367449361226222961790814311414\" + \"660941234159359309585407913908720832273354957208075716517187659944985693795623\" + \"875551617575438091780528029464200447215396280746360211329425591600257073562812\" + \"638733106005891065245708024474937543184149401482119996276453106800663118382376\" + \"163966318093144467129861552759820145141027560068929750246304017351489194576360\" + \"789352855505317331416457050499644389093630843874484783961684051845273288403234\" + \"520247056851646571647713932377551729479512613239822960239454857975458651745878\" + \"771331813875295980941217422730035229650808917770506825924882232215493804837145\" + \"478164721397682096332050830564792048208592047549985732038887639160199524091893\" + \"894557676874973085695595801065952650303626615975066222508406742889826590751063\" + \"756356996821151094966974458054728869363102036782325018232370845979011154847208\" + \"761821247781326633041207621658731297081123075815982124863980721240786887811450\" + \"165582513617890307086087019897588980745664395515741536319319198107057533663373\" + \"803827215279884935039748001589051942087971130805123393322190346624991716915094\" + \"854140187106035460379464337900589095772118080446574396280618671786101715674096\" + \"766208029576657705129120990794430463289294730615951043090222143937184956063405\" + \"618934251305726829146578329334052463502892917547087256484260034962961165413823\" + \"007731332729830500160256724014185152041890701154288579920812198449315699905918\" + \"201181973350012618772803681248199587707020753240636125931343859554254778196114\" + \"293516356122349666152261473539967405158499860355295332924575238881013620234762\" + \"466905581643896786309762736550472434864307121849437348530060638764456627218666\" + \"170123812771562137974614986132874411771455244470899714452288566294244023018479\" + \"120547849857452163469644897389206240194351831008828348024924908540307786387516\" + \"591130287395878709810077271827187452901397283661484214287170553179654307650453\" + \"432460053636147261818096997693348626407743519992868632383508875668359509726557\" + \"481543194019557685043724800102041374983187225967738715495839971844490727914196\" + \"584593008394263702087563539821696205532480321226749891140267852859967340524203\" + \"109179789990571882194939132075343170798002373659098537552023891164346718558290\" + \"685371189795262623449248339249634244971465684659124891855662958932990903523923\" + \"333364743520370770101084388003290759834217018554228386161721041760301164591878\" + \"053936744747205998502358289183369292233732399948043710841965947316265482574809\" + \"948250999183300697656936715968936449334886474421350084070066088359723503953234\" + \"017958255703601693699098867113210979889707051728075585519126993067309925070407\" + \"024556850778679069476612629808225163313639952117098452809263037592242674257559\" + \"989289278370474445218936320348941552104459726188380030067761793138139916205806\" + \"270165102445886924764924689192461212531027573139084047000714356136231699237169\" + \"484813255420091453041037135453296620639210547982439212517254013231490274058589\" + \"206321758949434548906846399313757091034633271415316223280552297297953801880162\" + \"859073572955416278867649827418616421878988574107164906919185116281528548679417\" + \"363890665388576422915834250067361245384916067413734017357277995634104332688356\" + \"950781493137800736235418007061918026732855119194267609122103598746924117283749\" + \"312616339500123959924050845437569850795704622266461900010350049018303415354584\" + \"283376437811198855631877779253720116671853954183598443830520376281944076159410\" + \"682071697030228515225057312609304689842343315273213136121658280807521263154773\" + \"060442377475350595228717440266638914881717308643611138906942027908814311944879\" + \"941715404210341219084709408025402393294294549387864023051292711909751353600092\" + \"197110541209668311151632870542302847007312065803262641711616595761327235156666\" + \"253667271899853419989523688483099930275741991646384142707798870887422927705389\" + \"122717248632202889842512528721782603050099451082478357290569198855546788607946\" + \"280537122704246654319214528176074148240382783582971930101788834567416781139895\" + \"475044833931468963076339665722672704339321674542182455706252479721997866854279\" + \"897799233957905758189062252547358220523642485078340711014498047872669199018643\" + \"882293230538231855973286978092225352959101734140733488476100556401824239219269\" + \"506208318381454698392366461363989101210217709597670490830508185470419466437131\" + \"229969235889538493013635657618610606222870559942337163102127845744646398973818\" + \"856674626087948201864748767272722206267646533809980196688368099415907577685263\" + \"986514625333631245053640261056960551318381317426118442018908885319635698696279\" + \"503673842431301133175330532980201668881748134298868158557781034323175306478498\" + \"321062971842518438553442762012823457071698853051832617964117857960888815032960\" + \"229070561447622091509473903594664691623539680920139457817589108893199211226007\" + \"392814916948161527384273626429809823406320024402449589445612916704950823581248\" + \"739179964864113348032475777521970893277226234948601504665268143987705161531702\" + \"669692970492831628550421289814670619533197026950721437823047687528028735412616\" + \"639170824592517001071418085480063692325946201900227808740985977192180515853214\" + \"739265325155903541020928466592529991435379182531454529059841581763705892790690\" + \"989691116438118780943537152133226144362531449012745477269573939348154691631162\" + \"492887357471882407150399500944673195431619385548520766573882513963916357672315\" + \"100555603726339486720820780865373494244011579966750736071115935133195919712094\" + \"896471755302453136477094209463569698222667377520994516845064362382421185353488\" + \"798939567318780660610788544000550827657030558744854180577889171920788142335113\" + \"866292966717964346876007704799953788338787034871802184243734211227394025571769\" + \"081960309201824018842705704609262256417837526526335832424066125331152942345796\" + \"556950250681001831090041124537901533296615697052237921032570693705109083078947\" + \"999900499939532215362274847660361367769797856738658467093667958858378879562594\" + \"646489137665219958828693380183601193236857855855819555604215625088365020332202\" + \"451376215820461810670519533065306060650105488716724537794283133887163139559690\" + \"583208341689847606560711834713621812324622725884199028614208728495687963932546\" + \"428534307530110528571382964370999035694888528519040295604734613113826387889755\" + \"178856042499874831638280404684861893818959054203988987265069762020199554841265\" + \"000539442820393012748163815853039643992547020167275932857436666164411096256633\" + \"730540921951967514832873480895747777527834422109107311135182804603634719818565\" + \"557295714474768255285786334934285842311874944000322969069775831590385803935352\" + \"135886007960034209754739229673331064939560181223781285458431760556173386112673\" + \"478074585067606304822940965304111830667108189303110887172816751957967534718853\" + \"722930961614320400638132246584111115775835858113501856904781536893813771847281\" + \"475199835050478129771859908470762197460588742325699582889253504193795826061621\" + \"184236876851141831606831586799460165205774052942305360178031335726326705479033\" + \"840125730591233960188013782542192709476733719198728738524805742124892118347087\" + \"662966720727232565056512933312605950577772754247124164831283298207236175057467\" + \"387012820957554430596839555568686118839713552208445285264008125202766555767749\" + \"596962661260456524568408613923826576858338469849977872670655519185446869846947\" + \"849573462260629421962455708537127277652309895545019303773216664918257815467729\" + \"200521266714346320963789185232321501897612603437368406719419303774688099929687\" + \"758244104787812326625318184596045385354383911449677531286426092521153767325886\" + \"672260404252349108702695809964759580579466397341906401003636190404203311357933\" + \"654242630356145700901124480089002080147805660371015412232889146572239314507607\" + \"167064355682743774396578906797268743847307634645167756210309860409271709095128\" + \"086309029738504452718289274968921210667008164858339553773591913695015316201890\" + \"888748421079870689911480466927065094076204650277252865072890532854856143316081\" + \"269300569378541786109696920253886503457718317668688592368148847527649846882194\" + \"973972970773718718840041432312763650481453112285099002074240925585925292610302\" + \"106736815434701525234878635164397623586041919412969769040526483234700991115424\" + \"260127343802208933109668636789869497799400126016422760926082349304118064382913\" + \"834735467972539926233879158299848645927173405922562074910530853153718291168163\" + \"721939518870095778818158685046450769934394098743351443162633031724774748689791\" + \"820923948083314397084067308407958935810896656477585990556376952523265361442478\" + \"023082681183103773588708924061303133647737101162821461466167940409051861526036\" + \"009252194721889091810733587196414214447865489952858234394705007983038853886083\" + \"103571930600277119455802191194289992272235345870756624692617766317885514435021\" + \"828702668561066500353105021631820601760921798468493686316129372795187307897263\" + \"735371715025637873357977180818487845886650433582437700414771041493492743845758\" + \"710715973155943942641257027096512510811554824793940359768118811728247215825010\" + \"949609662539339538092219559191818855267806214992317276316321833989693807561685\" + \"591175299845013206712939240414459386239880938124045219148483164621014738918251\" + \"010909677386906640415897361047643650006807710565671848628149637111883219244566\" + \"394581449148616550049567698269030891118568798692947051352481609174324301538368\" + \"470729289898284602223730145265567989862776796809146979837826876431159883210904\" + \"371561129976652153963546442086919756737000573876497843768628768179249746943842\" + \"746525631632300555130417422734164645512781278457777245752038654375428282567141\" + \"288583454443513256205446424101103795546419058116862305964476958705407214198521\" + \"210673433241075676757581845699069304604752277016700568454396923404171108988899\" + \"341635058515788735343081552081177207188037910404698306957868547393765643363197\" + \"978680367187307969392423632144845035477631567025539006542311792015346497792906\" + \"624150832885839529054263768766896880503331722780018588506973623240389470047189\" + \"761934734430843744375992503417880797223585913424581314404984770173236169471976\" + \"571535319775499716278566311904691260918259124989036765417697990362375528652637\" + \"573376352696934435440047306719886890196814742876779086697968852250163694985673\" + \"021752313252926537589641517147955953878427849986645630287883196209983049451987\" + \"439636907068276265748581043911223261879405994155406327013198989570376110532360\" + \"629867480377915376751158304320849872092028092975264981256916342500052290887264\" + \"692528466610466539217148208013050229805263783642695973370705392278915351056888\" + \"393811324975707133102950443034671598944878684711643832805069250776627450012200\" + \"352620370946602341464899839025258883014867816219677519458316771876275720050543\" + \"979441245990077115205154619930509838698254284640725554092740313257163264079293\" + \"418334214709041254253352324802193227707535554679587163835875018159338717423606\" + \"155117101312352563348582036514614187004920570437201826173319471570086757853933\" + \"607862273955818579758725874410254207710547536129404746010009409544495966288148\" + \"691590389907186598056361713769222729076419775517772010427649694961105622059250\" + \"242021770426962215495872645398922769766031052498085575947163107587013320886146\" + \"326641259114863388122028444069416948826152957762532501987035987067438046982194\" + \"205638125583343642194923227593722128905642094308235254408411086454536940496927\" + \"149400331978286131818618881111840825786592875742638445005994422956858646048103\" + \"301538891149948693543603022181094346676400002236255057363129462629609619876056\" + \"425996394613869233083719626595473923462413459779574852464783798079569319865081\" + \"597767535055391899115133525229873611277918274854200868953965835942196333150286\" + \"956119201229888988700607999279541118826902307891310760361763477948943203210277\" + \"335941690865007193280401716384064498787175375678118532132840821657110754952829\" + \"497493621460821558320568723218557406516109627487437509809223021160998263303391\" + \"546949464449100451528092508974507489676032409076898365294065792019831526541065\" + \"813682379198409064571246894847020935776119313998024681340520039478194986620262\" + \"400890215016616381353838151503773502296607462795291038406868556907015751662419\" + \"298724448271942933100485482445458071889763300323252582158128032746796200281476\" + \"243182862217105435289834820827345168018613171959332471107466222850871066611770\" + \"346535283957762599774467218571581612641114327179434788599089280848669491413909\" + \"771673690027775850268664654056595039486784111079011610400857274456293842549416\" + \"759460548711723594642910585090995021495879311219613590831588262068233215615308\" + \"683373083817327932819698387508708348388046388478441884003184712697454370937329\" + \"836240287519792080232187874488287284372737801782700805878241074935751488997891\" + \"173974612932035108143270325140903048746226294234432757126008664250833318768865\" + \"075642927160552528954492153765175149219636718104943531785838345386525565664065\" + \"725136357506435323650893679043170259787817719031486796384082881020946149007971\" + \"513771709906195496964007086766710233004867263147551053723175711432231741141168\" + \"062286420638890621019235522354671166213749969326932173704310598722503945657492\" + \"461697826097025335947502091383667377289443869640002811034402608471289900074680\" + \"776484408871134135250336787731679770937277868216611786534423173226463784769787\" + \"514433209534000165069213054647689098505020301504488083426184520873053097318949\" + \"291642532293361243151430657826407028389840984160295030924189712097160164926561\" + \"341343342229882790992178604267981245728534580133826099587717811310216734025656\" + \"274400729683406619848067661580502169183372368039902793160642043681207990031626\" + \"444914619021945822969099212278855394878353830564686488165556229431567312827439\" + \"082645061162894280350166133669782405177015521962652272545585073864058529983037\" + \"918035043287670380925216790757120406123759632768567484507915114731344000183257\" + \"034492090971243580944790046249431345502890068064870429353403743603262582053579\" + \"011839564908935434510134296961754524957396062149028872893279252069653538639644\" + \"322538832752249960598697475988232991626354597332444516375533437749292899058117\" + \"578635555562693742691094711700216541171821975051983178713710605106379555858890\" + \"556885288798908475091576463907469361988150781468526213325247383765119299015610\" + \"918977792200870579339646382749068069876916819749236562422608715417610043060890\" + \"437797667851966189140414492527048088197149880154205778700652159400928977760133\" + \"075684796699295543365613984773806039436889588764605498387147896848280538470173\" + \"087111776115966350503997934386933911978988710915654170913308260764740630571141\" + \"109883938809548143782847452883836807941888434266622207043872288741394780101772\" + \"139228191199236540551639589347426395382482960903690028835932774585506080131798\" + \"840716244656399794827578365019551422155133928197822698427863839167971509126241\" + \"054872570092407004548848569295044811073808799654748156891393538094347455697212\" + \"891982717702076661360248958146811913361412125878389557735719498631721084439890\" + \"142394849665925173138817160266326193106536653504147307080441493916936326237376\" + \"777709585031325599009576273195730864804246770121232702053374266705314244820816\" + \"813030639737873664248367253983748769098060218278578621651273856351329014890350\" + \"988327061725893257536399397905572917516009761545904477169226580631511102803843\" + \"601737474215247608515209901615858231257159073342173657626714239047827958728150\" + \"509563309280266845893764964977023297364131906098274063353108979246424213458374\" + \"090116939196425045912881340349881063540088759682005440836438651661788055760895\" + \"689672753153808194207733259791727843762566118431989102500749182908647514979400\" + \"316070384554946538594602745244746681231468794344161099333890899263841184742525\" + \"704457251745932573898956518571657596148126602031079762825416559050604247911401\" + \"695790033835657486925280074302562341949828646791447632277400552946090394017753\" + \"633565547193100017543004750471914489984104001586794617924161001645471655133707\" + \"407395026044276953855383439755054887109978520540117516974758134492607943368954\" + \"378322117245068734423198987884412854206474280973562580706698310697993526069339\" + \"213568588139121480735472846322778490808700246777630360555123238665629517885371\" + \"967303463470122293958160679250915321748903084088651606111901149844341235012464\" + \"692802880599613428351188471544977127847336176628506216977871774382436256571177\" + \"945006447771837022199910669502165675764404499794076503799995484500271066598781\" + \"360380231412683690578319046079276529727769404361302305178708054651154246939526\" + \"512710105292707030667302444712597393995051462840476743136373997825918454117641\" + \"332790646063658415292701903027601733947486696034869497654175242930604072700505\" + \"903950314852292139257559484507886797792525393176515641619716844352436979444735\" + \"596426063339105512682606159572621703669850647328126672452198906054988028078288\" + \"142979633669674412480598219214633956574572210229867759974673812606936706913408\" + \"155941201611596019023775352555630060624798326124988128819293734347686268921923\" + \"977783391073310658825681377717232831532908252509273304785072497713944833389255\" + \"208117560845296659055394096556854170600117985729381399825831929367910039184409\" + \"928657560599359891000296986446097471471847010153128376263114677420914557404181\" + \"590880006494323785583930853082830547607679952435739163122188605754967383224319\" + \"565065546085288120190236364471270374863442172725787950342848631294491631847534\" + \"753143504139209610879605773098720135248407505763719925365047090858251393686346\" + \"386336804289176710760211115982887553994012007601394703366179371539630613986365\" + \"549221374159790511908358829009765664730073387931467891318146510931676157582135\" + \"142486044229244530411316065270097433008849903467540551864067734260358340960860\" + \"553374736276093565885310976099423834738222208729246449768456057956251676557408\" + \"841032173134562773585605235823638953203853402484227337163912397321599544082842\" + \"166663602329654569470357718487344203422770665383738750616921276801576618109542\" + \"009770836360436111059240911788954033802142652394892968643980892611463541457153\" + \"519434285072135345301831587562827573389826889852355779929572764522939156747756\" + \"667605108788764845349363606827805056462281359888587925994094644604170520447004\" + \"631513797543173718775603981596264750141090665886616218003826698996196558058720\" + \"863972117699521946678985701179833244060181157565807428418291061519391763005919\" + \"431443460515404771057005433900018245311773371895585760360718286050635647997900\" + \"413976180895536366960316219311325022385179167205518065926351803625121457592623\" + \"836934822266589557699466049193811248660909979812857182349400661555219611220720\" + \"309227764620099931524427358948871057662389469388944649509396033045434084210246\" + \"240104872332875008174917987554387938738143989423801176270083719605309438394006\" + \"375611645856094312951759771393539607432279248922126704580818331376416581826956\" + \"210587289244774003594700926866265965142205063007859200248829186083974373235384\" + \"908396432614700053242354064704208949921025040472678105908364400746638002087012\" + \"666420945718170294675227854007450855237772089058168391844659282941701828823301\" + \"497155423523591177481862859296760504820386434310877956289292540563894662194826\" + \"871104282816389397571175778691543016505860296521745958198887868040811032843273\" + \"986719862130620555985526603640504628215230615459447448990883908199973874745296\" + \"981077620148713400012253552224669540931521311533791579802697955571050850747387\" + \"475075806876537644578252443263804614304288923593485296105826938210349800040524\" + \"840708440356116781717051281337880570564345061611933042444079826037795119854869\" + \"455915205196009304127100727784930155503889536033826192934379708187432094991415\" + \"959339636811062755729527800425486306005452383915106899891357882001941178653568\" + \"214911852820785213012551851849371150342215954224451190020739353962740020811046\" + \"553020793286725474054365271759589350071633607632161472581540764205302004534018\" + \"357233829266191530835409512022632916505442612361919705161383935732669376015691\" + \"442994494374485680977569630312958871916112929468188493633864739274760122696415\" + \"884890096571708616059814720446742866420876533479985822209061980217321161423041\" + \"947775499073873856794118982466091309169177227420723336763503267834058630193019\" + \"324299639720444517928812285447821195353089891012534297552472763573022628138209\" + \"180743974867145359077863353016082155991131414420509144729353502223081719366350\" + \"934686585865631485557586244781862010871188976065296989926932817870557643514338\" + \"206014107732926106343152533718224338526352021773544071528189813769875515757454\" + \"693972715048846979361950047772097056179391382898984532742622728864710888327017\" + \"372325881824465843624958059256033810521560620615571329915608489206434030339526\" + \"226345145428367869828807425142256745180618414956468611163540497189768215422772\" + \"247947403357152743681940989205011365340012384671429655186734415374161504256325\" + \"671343024765512521921803578016924032669954174608759240920700466934039651017813\" + \"485783569444076047023254075555776472845075182689041829396611331016013111907739\" + \"863246277821902365066037404160672496249013743321724645409741299557052914243820\" + \"807609836482346597388669134991978401310801558134397919485283043673901248208244\" + \"481412809544377389832005986490915950532285791457688496257866588599917986752055\" + \"455809900455646117875524937012455321717019428288461740273664997847550829422802\" + \"023290122163010230977215156944642790980219082668986883426307160920791408519769\" + \"523555348865774342527753119724743087304361951139611908003025587838764420608504\" + \"473063129927788894272918972716989057592524467966018970748296094919064876469370\" + \"275077386643239191904225429023531892337729316673608699622803255718530891928440\" + \"380507103006477684786324319100022392978525537237556621364474009676053943983823\" + \"576460699246526008909062410590421545392790441152958034533450025624410100635953\" + \"003959886446616959562635187806068851372346270799732723313469397145628554261546\" + \"765063246567662027924520858134771760852169134094652030767339184114750414016892\" + \"412131982688156866456148538028753933116023229255561894104299533564009578649534\" + \"093511526645402441877594931693056044868642086275720117231952640502309977456764\" + \"783848897346431721598062678767183800524769688408498918508614900343240347674268\" + \"624595239589035858213500645099817824463608731775437885967767291952611121385919\" + \"472545140030118050343787527766440276261894101757687268042817662386068047788524\" + \"288743025914524707395054652513533945959878961977891104189029294381856720507096\" + \"460626354173294464957661265195349570186001541262396228641389779673332907056737\" + \"696215649818450684226369036784955597002607986799626101903933126376855696876702\" + \"929537116252800554310078640872893922571451248113577862766490242516199027747109\" + \"033593330930494838059785662884478744146984149906712376478958226329490467981208\" + \"998485716357108783119184863025450162092980582920833481363840542172005612198935\" + \"366937133673339246441612522319694347120641737549121635700857369439730597970971\" + \"972666664226743111776217640306868131035189911227133972403688700099686292254646\" + \"500638528862039380050477827691283560337254825579391298525150682996910775425764\" + \"748832534141213280062671709400909822352965795799780301828242849022147074811112\" + \"401860761341515038756983091865278065889668236252393784527263453042041880250844\" + \"236319038331838455052236799235775292910692504326144695010986108889991465855188\" + \"187358252816430252093928525807796973762084563748211443398816271003170315133440\" + \"230952635192958868069082135585368016100021374085115448491268584126869589917414\" + \"913382057849280069825519574020181810564129725083607035685105533178784082900004\" + \"155251186577945396331753853209214972052660783126028196116485809868458752512999\" + \"740409279768317663991465538610893758795221497173172813151793290443112181587102\" + \"351874075722210012376872194474720934931232410706508061856237252673254073332487\" + \"575448296757345001932190219911996079798937338367324257610393898534927877747398\" + \"050808001554476406105352220232540944356771879456543040673589649101761077594836\" + \"454082348613025471847648518957583667439979150851285802060782055446299172320202\" + \"822291488695939972997429747115537185892423849385585859540743810488262464878805\" + \"330427146301194158989632879267832732245610385219701113046658710050008328517731\" + \"177648973523092666123458887310288351562644602367199664455472760831011878838915\" + \"114934093934475007302585581475619088139875235781233134227986650352272536717123\" + \"075686104500454897036007956982762639234410714658489578024140815840522953693749\" + \"971066559489445924628661996355635065262340533943914211127181069105229002465742\" + \"360413009369188925586578466846121567955425660541600507127664176605687427420032\" + \"957716064344860620123982169827172319782681662824993871499544913730205184366907\" + \"672357740005393266262276032365975171892590180110429038427418550789488743883270\" + \"306328327996300720069801224436511639408692222074532024462412115580435454206421\" + \"512158505689615735641431306888344318528085397592773443365538418834030351782294\" + \"625370201578215737326552318576355409895403323638231921989217117744946940367829\" + \"618592080340386757583411151882417743914507736638407188048935825686854201164503\" + \"135763335550944031923672034865101056104987272647213198654343545040913185951314\" + \"518127643731043897250700498198705217627249406521461995923214231443977654670835\" + \"171474936798618655279171582408065106379950018429593879915835017158075988378496\" + \"225739851212981032637937621832245659423668537679911314010804313973233544909082\" + \"491049914332584329882103398469814171575601082970658306521134707680368069532297\" + \"199059990445120908727577622535104090239288877942463048328031913271049547859918\" + \"019696783532146444118926063152661816744319355081708187547705080265402529410921\" + \"826485821385752668815558411319856002213515888721036569608751506318753300294211\" + \"868222189377554602722729129050429225978771066787384000061677215463844129237119\" + \"352182849982435092089180168557279815642185819119749098573057033266764646072875\" + \"743056537260276898237325974508447964954564803077159815395582777913937360171742\" + \"299602735310276871944944491793978514463159731443535185049141394155732938204854\" + \"212350817391254974981930871439661513294204591938010623142177419918406018034794\" + \"988769105155790555480695387854006645337598186284641990522045280330626369562649\" + \"091082762711590385699505124652999606285544383833032763859980079292284665950355\" + \"121124528408751622906026201185777531374794936205549640107300134885315073548735\" + \"390560290893352640071327473262196031177343394367338575912450814933573691166454\" + \"128178817145402305475066713651825828489809951213919399563324133655677709800308\" + \"191027204099714868741813466700609405102146269028044915964654533010775469541308\" + \"871416531254481306119240782118869005602778182423502269618934435254763357353648\" + \"561936325441775661398170393063287216690572225974520919291726219984440964615826\" + \"945638023950283712168644656178523556516412771282691868861557271620147493405227\" + \"694659571219831494338162211400693630743044417328478610177774383797703723179525\" + \"543410722344551255558999864618387676490397246116795901810003509892864120419516\" + \"355110876320426761297982652942588295114127584126273279079880755975185157684126\" + \"474220947972184330935297266521001566251455299474512763155091763673025946213293\" + \"019040283795424632325855030109670692272022707486341900543830265068121414213505\" + \"715417505750863990767394633514620908288893493837643939925690060406731142209331\" + \"219593620298297235116325938677224147791162957278075239505625158160313335938231\" + \"150051862689053065836812998810866326327198061127154885879809348791291370749823\" + \"057592909186293919501472119758606727009254771802575033773079939713453953264619\" + \"526999659638565491759045833358579910201271320458390320085387888163363768518208\" + \"372788513117522776960978796214237216254521459128183179821604411131167140691482\" + \"717098101545778193920231156387195080502467972579249760577262591332855972637121\" + \"120190572077140914864507409492671803581515757151405039761096384675556929897038\" + \"354731410022380258346876735012977541327953206097115450648421218593649099791776\" + \"687477448188287063231551586503289816422828823274686610659273219790716238464215\" + \"348985247621678905026099804526648392954235728734397768049577409144953839157556\" + \"548545905897649519851380100795801078375994577529919670054760225255203445398871\" + \"253878017196071816407812484784725791240782454436168234523957068951427226975043\" + \"187363326301110305342333582160933319121880660826834142891041517324721605335584\" + \"999322454873077882290525232423486153152097693846104258284971496347534183756200\" + \"301491570327968530186863157248840152663983568956363465743532178349319982554211\" + \"730846774529708583950761645822963032442432823773745051702856069806788952176819\" + \"815671078163340526675953942492628075696832610749532339053622309080708145591983\" + \"735537774874202903901814293731152933464446815121294509759653430628421531944572\" + \"711861490001765055817709530246887526325011970520947615941676872778447200019278\" + \"913725184162285778379228443908430118112149636642465903363419454065718354477191\" + \"244662125939265662030688852005559912123536371822692253178145879259375044144893\" + \"398160865790087616502463519704582889548179375668104647461410514249887025213993\" + \"687050937230544773411264135489280684105910771667782123833281026218558775131272\" + \"117934444820144042574508306394473836379390628300897330624138061458941422769474\" + \"793166571762318247216835067807648757342049155762821758397297513447899069658953\" + \"254894033561561316740327647246921250575911625152965456854463349811431767025729\" + \"566184477548746937846423373723898192066204851189437886822480727935202250179654\" + \"534375727416391079197295295081294292220534771730418447791567399173841831171036\" + \"252439571615271466900581470000263301045264354786590329073320546833887207873544\" + \"476264792529769017091200787418373673508771337697768349634425241994995138831507\" + \"487753743384945825976556099655595431804092017849718468549737069621208852437701\" + \"385375768141663272241263442398215294164537800049250726276515078908507126599703\" + \"670872669276430837722968598516912230503746274431085293430527307886528397733524\" + \"601746352770320593817912539691562106363762588293757137384075440646896478310070\" + \"458061344673127159119460843593582598778283526653115106504162329532904777217408\" + \"355934972375855213804830509000964667608830154061282430874064559443185341375522\" + \"016630581211103345312074508682433943215904359443031243122747138584203039010607\" + \"094031523555617276799416002039397509989762933532585557562480899669182986422267\" + \"750236019325797472674257821111973470940235745722227121252685238429587427350156\" + \"366009318804549333898974157149054418255973808087156528143010267046028431681923\" + \"039253529779576586241439270154974087927313105163611913757700892956482332364829\" + \"826302460797587576774537716010249080462430185652416175665560016085912153455626\" + \"760219268998285537787258314514408265458348440947846317877737479465358016996077\" + \"940556870119232860804113090462935087182712593466871276669487389982459852778649\" + \"956916546402945893506496433580982476596516514209098675520380830920323048734270\" + \"346828875160407154665383461961122301375945157925269674364253192739003603860823\" + \"645076269882749761872357547676288995075211480485252795084503395857083813047693\" + \"788132112367428131948795022806632017002246033198967197064916374117585485187848\" + \"401205484467258885140156272501982171906696081262778548596481836962141072171421\" + \"498636191877475450965030895709947093433785698167446582826791194061195603784539\" + \"785583924076127634410576675102430755981455278616781594965706255975507430652108\" + \"530159790807334373607943286675789053348366955548680391343372015649883422089339\" + \"997164147974693869690548008919306713805717150585730714881564992071408675825960\" + \"287605645978242377024246980532805663278704192676846711626687946348695046450742\" + \"021937394525926266861355294062478136120620263649819999949840514386828525895634\" + \"226432870766329930489172340072547176418868535137233266787792173834754148002280\" + \"339299735793615241275582956927683723123479898944627433045456679006203242051639\" + \"628258844308543830720149567210646053323853720314324211260742448584509458049408\" + \"182092763914000854042202355626021856434899414543995041098059181794888262805206\" + \"644108631900168856815516922948620301073889718100770929059048074909242714101893\" + \"354281842999598816966099383696164438152887721408526808875748829325873580990567\" + \"075581701794916190611400190855374488272620093668560447559655747648567400817738\" + \"170330738030547697360978654385938218722058390234444350886749986650604064587434\" + \"600533182743629617786251808189314436325120510709469081358644051922951293245007\" + \"883339878842933934243512634336520438581291283434529730865290978330067126179813\" + \"031679438553572629699874035957045845223085639009891317947594875212639707837594\" + \"486113945196028675121056163897600888009274611586080020780334159145179707303683\" + \"519697776607637378533301202412011204698860920933908536577322239241244905153278\" + \"095095586645947763448226998607481329730263097502881210351772312446509534965369\" + \"309001863776409409434983731325132186208021480992268550294845466181471555744470\" + \"966953017769043427203189277060471778452793916047228153437980353967986142437095\" + \"668322149146543801459382927739339603275404800955223181666738035718393275707714\" + \"204672383862461780397629237713120958078936384144792980258806552212926209362393\" + \"063731349664018661951081158347117331202580586672763999276357907806381881306915\" + \"636627412543125958993611964762610140556350339952314032311381965623632719896183\" + \"725484533370206256346422395276694356837676136871196292181875457608161705303159\" + \"072882870071231366630872275491866139577373054606599743781098764980241401124214\" + \"277366808275139095931340415582626678951084677611866595766016599817808941498575\" + \"497628438785610026379654317831363402513581416115190209649913354873313111502270\" + \"068193013592959597164019719605362503355847998096348871803911161281359596856547\" + \"886832585643789617315976200241962155289629790481982219946226948713746244472909\" + \"345647002853769495885959160678928249105441251599630078136836749020937491573289\" + \"627002865682934443134234735123929825916673950342599586897069726733258273590312\" + \"128874666045146148785034614282776599160809039865257571726308183349444182019353\" + \"338507129234577437557934406217871133006310600332405399169368260374617663856575\" + \"887758020122936635327026710068126182517291460820254189288593524449107013820621\" + \"155382779356529691457650204864328286555793470720963480737269214118689546732276\" + \"775133569019015372366903686538916129168888787640752549349424973342718117889275\" + \"993159671935475898809792452526236365903632007085444078454479734829180208204492\" + \"667063442043755532505052752283377888704080403353192340768563010934777212563908\" + \"864041310107381785333831603813528082811904083256440184205374679299262203769871\" + \"801806112262449090924264198582086175117711378905160914038157500336642415609521\" + \"632819712233502316742260056794128140621721964184270578432895980288233505982820\" + \"819666624903585778994033315227481777695284368163008853176969478369058067106482\" + \"808359804669884109813515865490693331952239436328792399053481098783027450017206\" + \"543369906611778455436468772363184446476806914282800455107468664539280539940910\" + \"875493916609573161971503316696830992946634914279878084225722069714887558063748\" + \"030886299511847318712477729191007022758889348693945628951580296537215040960310\" + \"776128983126358996489341024703603664505868728758905140684123812424738638542790\" + \"828273382797332688550493587430316027474906312957234974261122151741715313361862\" + \"241091386950068883589896234927631731647834007746088665559873338211382992877691\" + \"149549218419208777160606847287467368188616750722101726110383067178785669481294\" + \"878504894306308616994879870316051588410828235127415353851336589533294862949449\" + \"506186851477910580469603906937266267038651290520113781085861618888694795760741\" + \"358553458515176805197333443349523012039577073962377131603024288720053732099825\" + \"300897761897312981788194467173116064723147624845755192873278282512718244680782\" + \"421521646956781929409823892628494376024885227900362021938669648221562809360537\" + \"317804086372726842669642192994681921490870170753336109479138180406328738759384\" + \"826953558307739576144799727000347288018278528138950321798634521611106660883931\" + \"405322694490545552786789441757920244002145078019209980446138254780585804844241\" + \"640477503153605490659143007815837243012313751156228401583864427089071828481675\" + \"752712384678245953433444962201009607105137060846180118754312072549133499424761\" + \"711563332140893460915656155060031738421870157022610310191660388706466143889773\" + \"631878094071152752817468957640158104701696524755774089164456867771715850058326\" + \"994340167720215676772406812836656526412298243946513319735919970940327593850266\" + \"955747023181320324371642058614103360652453693916005064495306016126782264894243\" + \"739716671766123104897503188573216555498834212180284691252908610148552781527762\" + \"562375045637576949773433684601560772703550962904939248708840628106794362241870\" + \"474700836884267102255830240359984164595112248527263363264511401739524808619463\" + \"584078375355688562231711552094722306543709260679735100056554938122457548372854\" + \"571179739361575616764169289580525729752233855861138832217110736226581621884244\" + \"317885748879810902665379342666421699091405653643224930133486798815488662866505\" + \"234699723557473842483059042367714327879231642240387776433019260019228477831383\" + \"763253612102533693581262408686669973827597736568222790721583247888864236934639\" + \"616436330873013981421143030600873066616480367898409133592629340230432497492688\" + \"783164360268101130957071614191283068657732353263965367739031766136131596555358\" + \"499939860056515592193675997771793301974468814837110320650369319289452140265091\" + \"546518430993655349333718342529843367991593941746622390038952767381333061774762\" + \"957494386871697845376721949350659087571191772087547710718993796089477451265475\" + \"750187119487073873678589020061737332107569330221632062843206567119209695058576\" + \"117396163232621770894542621460985841023781321581772760222273813349541048100307\" + \"327510779994899197796388353073444345753297591426376840544226478421606312276964\" + \"696715647399904371590332390656072664411643860540483884716191210900870101913072\" + \"607104411414324197679682854788552477947648180295973604943970047959604029274629\" + \"920357209976195014034831538094771460105633344699882082212058728151072918297121\" + \"191787642488035467231691654185225672923442918712816323259696541354858957713320\" + \"833991128877591722611527337901034136208561457799239877832508355073019981845902\" + \"595835598926055329967377049172245493532968330000223018151722657578752405883224\" + \"908582128008974790932610076257877042865600699617621217684547899644070506624171\" + \"021332748679623743022915535820078014116534806564748823061500339206898379476625\" + \"503654982280532966286211793062843017049240230198571997894883689718304380518217\" + \"441914766042975243725168343541121703863137941142209529588579806015293875275379\" + \"903093887168357209576071522190027937929278630363726876582268124199338480816602\" + \"160372215471014300737753779269906958712128928801905203160128586182549441335382\" + \"078488346531163265040764242839087012101519423196165226842200371123046430067344\" + \"206474771802135307012409886035339915266792387110170622186588357378121093517977\" + \"560442563469499978725112544085452227481091487430725986960204027594117894258128\" + \"188215995235965897918114407765335432175759525553615812800116384672031934650729\" + \"680799079396371496177431211940202129757312516525376801735910155733815377200195\" + \"244454362007184847566341540744232862106099761324348754884743453966598133871746\" + \"609302053507027195298394327142537115576660002578442303107342955153394506048622\" + \"276496668762407932435319299263925373107689213535257232108088981933916866827894\" + \"828117047262450194840970097576092098372409007471797334078814182519584259809624\" + \"174761013825264395513525931188504563626418830033853965243599741693132289471987\" + \"830842760040136807470390409723847394583489618653979059411859931035616843686921\" + \"948538205578039577388136067954990008512325944252972448666676683464140218991594\" + \"456530942344065066785194841776677947047204195882204329538032631053749488312218\" + \"039127967844610013972675389219511911783658766252808369005324900459741094706877\" + \"291232821430463533728351995364827432583311914445901780960778288358373011185754\" + \"365995898272453192531058811502630754257149394302445393187017992360816661130542\" + \"625399583389794297160207033876781503301028012009599725222228080142357109476035\" + \"192554443492998676781789104555906301595380976187592035893734197896235893112598\" + \"390259831026719330418921510968915622506965911982832345550305908173073519550372\" + \"166587028805399213857603703537710517802128012956684198414036287272562321442875\" + \"430221090947272107347413497551419073704331827662617727599688882602722524713368\" + \"335345281669277959132886138176634985772893690096574956228710302436259077241221\" + \"909430087175569262575806570991201665962243608024287002454736203639484125595488\" + \"172727247365346778364720191830399871762703751572464992228946793232269361917764\" + \"161461879561395669956778306829031658969943076733350823499079062410020250613405\" + \"734430069574547468217569044165154063658468046369262127421107539904218871612761\" + \"778701425886482577522388918459952337629237791558574454947736129552595222657863\" + \"646211837759847370034797140820699414558071908021359073226923310083175951065901\" + \"912129479540860364075735875020589020870457967000705526250581142066390745921527\" + \"330940682364944159089100922029668052332526619891131184201629163107689408472356\" + \"436680818216865721968826835840278550078280404345371018365109695178233574303050\" + \"485265373807353107418591770561039739506264035544227515610110726177937063472380\" + \"499066692216197119425912044508464174638358993823994651739550900085947999013602\" + \"667426149429006646711506717542217703877450767356374215478290591101261915755587\" + \"023895700140511782264698994491790830179547587676016809410013583761357859135692\" + \"445564776446417866711539195135769610486492249008344671548638305447791433009768\" + \"048687834818467273375843689272431044740680768527862558516509208826381323362314\" + \"873333671476452045087662761495038994950480956046098960432912335834885999029452\" + \"640028499428087862403981181488476730121675416110662999555366819312328742570206\" + \"373835202008686369131173346973174121915363324674532563087134730279217495622701\" + \"468732586789173455837996435135880095935087755635624881049385299900767513551352\" + \"779241242927748856588856651324730251471021057535251651181485090275047684551825\" + \"209633189906852761443513821366215236889057878669943228881602837748203550601602\" + \"989400911971385017987168363374413927597364401700701476370665570350433812111357\" + \"641501845182141361982349515960106475271257593518530433287553778305750956742544\" + \"268471221961870917856078393614451138333564910325640573389866717812397223751931\" + \"643061701385953947436784339267098671245221118969084023632741149660124348309892\" + \"994173803058841716661307304006758838043211155537944060549772170594282151488616\" + \"567277124090338772774562909711013488518437411869565544974573684521806698291104\" + \"505800429988795389902780438359628240942186055628778842880212755388480372864001\" + \"944161425749990427200959520465417059810498996750451193647117277222043610261407\" + \"975080968697517660023718774834801612031023468056711264476612374762785219024120\" + \"256994353471622666089367521983311181351114650385489502512065577263614547360442\" + \"685949807439693233129712737715734709971395229118265348515558713733662912024271\" + \"430250376326950135091161295299378586468130722648600827088133353819370368259886\" + \"789332123832705329762585738279009782646054559855513183668884462826513379849166\" + \"783940976135376625179825824966345877195012438404035914084920973375464247448817\" + \"618407002356958017741017769692507781489338667255789856458985105689196092439884\" + \"156928069698335224022563457049731224526935419383700484318335719651662672157552\" + \"419340193309901831930919658292096965624766768365964701959575473934551433741370\" + \"876151732367720422738567427917069820454995309591887243493952409444167899884631\" + \"984550485239366297207977745281439941825678945779571255242682608994086331737153\" + \"889626288962940211210888442737656862452761213037101730078513571540453304150795\" + \"944777614359743780374243664697324713841049212431413890357909241603640631403814\" + \"983148190525172093710396402680899483257229795456404270175772290417323479607361\" + \"878788991331830584306939482596131871381642346721873084513387721908697510494284\" + \"376932502498165667381626061594176825250999374167288395174406693254965340310145\" + \"222531618900923537648637848288134420987004809622717122640748957193900291857330\" + \"746010436072919094576799461492929042798168772942648772995285843464777538690695\" + \"014898413392454039414468026362540211861431703125111757764282991464453340892097\" + \"696169909837265236176874560589470496817013697490952307208268288789073019001825\" + \"342580534342170592871393173799314241085264739094828459641809361413847583113613\" + \"057610846236683723769591349261582451622155213487924414504175684806412063652017\" + \"038633012953277769902311864802006755690568229501635493199230591424639621702532\" + \"974757311409422018019936803502649563695586642590676268568737211033915679383989\" + \"576556519317788300024161353956243777784080174881937309502069990089089932808839\" + \"743036773659552489130015663329407790713961546453408879151030065132193448667324\" + \"827590794680787981942501958262232039513125201410996053126069655540424867054998\" + \"678692302174698900954785072567297879476988883109348746442640071818316033165551\" + \"153427615562240547447337804924621495213325852769884733626918264917433898782478\" + \"927846891882805466998230368993978341374758702580571634941356843392939606819206\" + \"177333179173820856243643363535986349449689078106401967407443658366707158692452\" + \"118299789380407713750129085864657890577142683358276897855471768718442772612050\" + \"926648610205153564284063236848180728794071712796682006072755955590404023317874\" + \"944734645476062818954151213916291844429765106694796935401686601005519607768733\" + \"539651161493093757096855455938151378956903925101495326562814701199832699220006\" + \"639287537471313523642158926512620407288771657835840521964605410543544364216656\" + \"224456504299901025658692727914275293117208279393775132610605288123537345106837\" + \"293989358087124386938593438917571337630072031976081660446468393772580690923729\" + \"752348670291691042636926209019960520412102407764819031601408586355842760953708\" + \"655816427399534934654631450404019952853725200495780525465625115410925243799132\" + \"626271360909940290226206283675213230506518393405745011209934146491843332364656\" + \"937172591448932415900624202061288573292613359680872650004562828455757459659212\" + \"053034131011182750130696150983551563200431078460190656549380654252522916199181\" + \"995960275232770224985573882489988270746593635576858256051806896428537685077201\" + \"222034792099393617926820659014216561592530673794456894907085326356819683186177\" + \"226824991147261573203580764629811624401331673789278868922903259334986179702199\" + \"498192573961767307583441709855922217017182571277753449150820527843090461946083\" + \"521740200583867284970941102326695392144546106621500641067474020700918991195137\" + \"646690448126725369153716229079138540393756007783515337416774794210038400230895\" + \"185099454877903934612222086506016050035177626483161115332558770507354127924990\" + \"985937347378708119425305512143697974991495186053592040383023571635272763087469\" + \"321962219006426088618367610334600225547747781364101269190656968649501268837629\" + \"690723396127628722304114181361006026404403003599698891994582739762411461374480\" + \"405969706257676472376606554161857469052722923822827518679915698339074767114610\" + \"302277660602006124687647772881909679161335401988140275799217416767879923160396\" + \"356949285151363364721954061117176738737255572852294005436178517650230754469386\" + \"930787349911035218253292972604455321079788771144989887091151123725060423875373\" + \"484125708606406905205845212275453384800820530245045651766951857691320004281675\" + \"805492481178051983264603244579282973012910531838563682120621553128866856495651\" + \"261389226136706409395333457052698695969235035309422454386527867767302754040270\" + \"224638448355323991475136344104405009233036127149608135549053153902100229959575\" + \"658370538126196568314428605795669662215472169562087001372776853696084070483332\" + \"513279311223250714863020695124539500373572334680709465648308920980153487870563\" + \"349109236605755405086411152144148143463043727327104502776866195310785832333485\" + \"784029716092521532609255893265560067212435946425506599677177038844539618163287\" + \"961446081778927217183690888012677820743010642252463480745430047649288555340906\" + \"218515365435547412547615276977266776977277705831580141218568801170502836527554\" + \"321480348800444297999806215790456416195721278450892848980642649742709057912906\" + \"921780729876947797511244730599140605062994689428093103421641662993561482813099\" + \"887074529271604843363081840412646963792584309418544221635908457614607855856247\" + \"381493142707826621518554160387020687698046174740080832434366538235455510944949\" + \"843109349475994467267366535251766270677219418319197719637801570216993367508376\" + \"005716345464367177672338758864340564487156696432104128259564534984138841289042\" + \"068204700761559691684303899934836679354254921032811336318472259230555438305820\" + \"694167562999201337317548912203723034907268106853445403599356182357631283776764\" + \"063101312533521214199461186935083317658785204711236433122676512996417132521751\" + \"355326186768194233879036546890800182713528358488844411176123410117991870923650\" + \"718485785622102110400977699445312179502247957806950653296594038398736990724079\" + \"767904082679400761872954783596349279390457697366164340535979221928587057495748\" + \"169669406233427261973351813662606373598257555249650980726012366828360592834185\" + \"584802695841377255897088378994291054980033111388460340193916612218669605849157\" + \"148573356828614950001909759112521880039641976216355937574371801148055944229873\" + \"041819680808564726571354761283162920044988031540210553059707666636274932830891\" + \"688093235929008178741198573831719261672883491840242972129043496552694272640255\" + \"964146352591434840067586769035038232057293413298159353304444649682944136732344\" + \"215838076169483121933311981906109614295220153617029857510559432646146850545268\" + \"497576480780800922133581137819774927176854507553832876887447459159373116247060\" + \"109124460982942484128752022446259447763874949199784044682925736096853454984326\" + \"653686284448936570411181779380644161653122360021491876876946739840751717630751\" + \"684985635920148689294310594020245796962292456664488196757629434953532638217161\" + \"339575779076637076456957025973880043841580589433613710655185998760075492418721\" + \"171488929522173772114608115434498266547987258005667472405112200738345927157572\" + \"771521858994694811794064446639943237004429114074721818022482583773601734668530\" + \"074498556471542003612359339731291445859152288740871950870863221883728826282288\" + \"463184371726190330577714765156414382230679184738603914768310814135827575585364\" + \"359772165002827780371342286968878734979509603110889919614338666406845069742078\" + \"770028050936720338723262963785603865321643234881555755701846908907464787912243\" + \"637555666867806761054495501726079114293083128576125448194444947324481909379536\" + \"900820638463167822506480953181040657025432760438570350592281891987806586541218\" + \"429921727372095510324225107971807783304260908679427342895573555925272380551144\" + \"043800123904168771644518022649168164192740110645162243110170005669112173318942\" + \"340054795968466980429801736257040673328212996215368488140410219446342464622074\" + \"557564396045298531307140908460849965376780379320189914086581466217531933766597\" + \"011433060862500982956691763884605676297293146491149370462446935198403953444913\" + \"514119366793330193661766365255514917498230798707228086085962611266050428929696\" + \"653565251668888557211227680277274370891738963977225756489053340103885593112567\" + \"999151658902501648696142720700591605616615970245198905183296927893555030393468\" + \"121976158218398048396056252309146263844738629603984892438618729850777592879272\" + \"206855480721049781765328621018747676689724884113956034948037672703631692100735\" + \"083407386526168450748249644859742813493648037242611670426687083192504099761531\" + \"907685577032742178501000644198412420739640013960360158381056592841368457411910\" + \"273642027416372348821452410134771652960312840865841978795111651152982781462037\" + \"913985500639996032659124852530849369031313010079997719136223086601109992914287\" + \"124938854161203802041134018888721969347790449752745428807280350930582875442075\" + \"513481666092787935356652125562013998824962847872621443236285367650259145046837\" + \"763528258765213915648097214192967554938437558260025316853635673137926247587804\" + \"944594418342917275698837622626184636545274349766241113845130548144983631178978\" + \"448973207671950878415861887969295581973325069995140260151167552975057543781024\" + \"223895792578656212843273120220071673057406928686936393018676595825132649914595\" + \"026091706934751940897535746401683081179884645247361895605647942635807056256328\" + \"118926966302647953595109712765913623318086692153578860781275991053717140220450\" + \"618607537486630635059148391646765672320571451688617079098469593223672494673758\" + \"309960704258922048155079913275208858378111768521426933478692189524062265792104\" + \"362034885292626798401395321645879115157905046057971083898337186403802441751134\" + \"722647254701079479399695355466961972676325522991465493349966323418595145036098\" + \"034409221220671256769872342794070885707047429317332918852389672197135392449242\" + \"617864118863779096281448691786946817759171715066911148002075943201206196963779\" + \"510322708902956608556222545260261046073613136886900928172106819861855378098201\" + \"847115416363032626569928342415502360097804641710852553761272890533504550613568\" + \"414377585442967797701466029438768722511536380119175815402812081825560648541078\" + \"793359892106442724489861896162941341800129513068363860929410008313667337215300\" + \"835269623573717533073865333820484219030818644918409372394403340524490955455801\" + \"640646076158101030176748847501766190869294609876920169120218168829104087070956\" + \"095147041692114702741339005225334083481287035303102391969997859741390859360543\" + \"359969707560446013424245368249609877258131102473279856207212657249900346829388\" + \"687230489556225320446360263985422525841646432427161141981780248259556354490721\" + \"922658386366266375083594431487763515614571074552801615967704844271419443518327\" + \"569840755267792641126176525061596523545718795667317091331935876162825592078308\" + \"018520689015150471334038610031005591481785211038475454293338918844412051794396\" + \"997019411269511952656491959418997541839323464742429070271887522353439367363366\" + \"320030723274703740712398256202466265197409019976245205619855762576000870817308\" + \"328834438183107005451449354588542267857855191537229237955549433341017442016960\" + \"009069641561273229777022121795186837635908225512881647002199234886404395915301\" + \"846400471432118636062252701154112228380277853891109849020134274101412155976996\" + \"543887719748537643115822983853312307175113296190455900793806427669581901484262\" + \"799122179294798734890186847167650382732855205908298452980625925035212845192592\" + \"798659350613296194679625237397256558415785374456755899803240549218696288849033\" + \"256085145534439166022625777551291620077279685262938793753045418108072928589198\" + \"971538179734349618723292761474785019261145041327487324297058340847111233374627\" + \"461727462658241532427105932250625530231473875925172478732288149145591560503633\" + \"457542423377916037495250249302235148196138116256391141561032684495807250827343\" + \"176594405409826976526934457986347970974312449827193311386387315963636121862349\" + \"726140955607992062831699942007205481152535339394607685001990988655386143349578\" + \"165008996164907967814290114838764568217491407562376761845377514403147541120676\" + \"016072646055685925779932207033733339891636950434669069482843662998003741452762\" + \"771654762382554617088318981086880684785370553648046935095881802536052974079353\" + \"867651119507937328208314626896007107517552061443378411454995013643244632819334\" + \"638905093654571450690086448344018042836339051357815727397333453728426337217406\" + \"577577107983051755572103679597690188995849413019599957301790124019390868135658\" + \"553966194137179448763207986880037160730322054742357226689680188212342439188598\" + \"416897227765219403249322731479366923400484897605903795809469604175427961378255\" + \"378122394764614783292697654516229028170110043784603875654415173943396004891531\" + \"881757665050095169740241564477129365661425394936888423051740012992055685428985\" + \"389794266995677702708914651373689220610441548166215680421983847673087178759027\" + \"920917590069527345668202651337311151800018143412096260165862982107666352336177\" + \"400783778342370915264406305407180784335806107296110555002041513169637304684921\" + \"335683726540030750982908936461204789111475303704989395283345782408281738644132\" + \"271000296831194020332345642082647327623383029463937899837583655455991934086623\" + \"509096796113400486702712317652666371077872511186035403755448741869351973365662\" + \"177235922939677646325156202348757011379571209623772343137021203100496515211197\" + \"601317641940820343734851285260291333491512508311980285017785571072537314913921\" + \"570910513096505988599993156086365547740355189816673353588004821466509974143376\" + \"118277772335191074121757284159258087259131507460602563490377726337391446137703\" + \"802131834744730111303267029691733504770163210661622783002726928336558401179141\" + \"944780874825336071440329625228577500980859960904093631263562132816207145340610\" + \"422411208301000858726425211226248014264751942618432585338675387405474349107271\" + \"004975428115946601713612259044015899160022982780179603519408004651353475269877\" + \"760952783998436808690898919783969353217998013913544255271791022539701081063214\" + \"304851137829149851138196914304349750018998068164441212327332830719282436240673\" + \"319655469267785119315277511344646890550424811336143498460484905125834568326644\" + \"152848971397237604032821266025351669391408204994732048602162775979177123475109\" + \"750240307893575993771509502175169355582707253391189233407022383207758580213717\" + \"477837877839101523413209848942345961369234049799827930414446316270721479611745\" + \"697571968123929191374098292580556195520743424329598289898052923336641541925636\" + \"738068949420147124134052507220406179435525255522500874879008656831454283516775\" + \"054229480327478304405643858159195266675828292970522612762871104013480178722480\" + \"178968405240792436058274246744307672164527031345135416764966890127478680101029\" + \"513386269864974821211862904033769156857624069929637249309720162870720018983542\" + \"369036414927023696193854737248032985504511208919287982987446786412915941753167\" + \"560253343531062674525450711418148323988060729714023472552071349079839898235526\" + \"872395090936566787899238371257897624875599044322889538837731734894112275707141\" + \"095979004791930104674075041143538178246463079598955563899188477378134134707024\" + \"674736211204898622699188851745625173251934135203811586335012391305444191007362\" + \"844756751416105041097350585276204448919097890198431548528053398577784431393388\" + \"399431044446566924455088594631408175122033139068159659251054685801313383815217\" + \"641821043342978882611963044311138879625874609022613090084997543039577124323061\" + \"690626291940392143974027089477766370248815549932245882597902063125743691094639\" + \"325280624164247686849545532493801763937161563684785982371590238542126584061536\" + \"722860713170267474013114526106376538339031592194346981760535838031061288785205\" + \"154693363924108846763200956708971836749057816308515813816196688222204757043759\" + \"061433804072585386208356517699842677452319582418268369827016023741493836349662\" + \"935157685406139734274647089968561817016055110488097155485911861718966802597354\" + \"170542398513556001872033507906094642127114399319604652742405088222535977348151\" + \"913543857125325854049394601086579379805862014336607882521971780902581737087091\" + \"646045272797715350991034073642502038638671822052287969445838765294795104866071\" + \"739022932745542678566977686593992341683412227466301506215532050265534146099524\" + \"935605085492175654913483095890653617569381763747364418337897422970070354520666\" + \"317092960759198962773242309025239744386101426309868773391388251868431650102796\" + \"491149773758288891345034114886594867021549210108432808078342808941729800898329\" + \"753694064496990312539986391958160146899522088066228540841486427478628197554662\" + \"927881462160717138188018084057208471586890683691939338186427845453795671927239\" + \"797236465166759201105799566396259853551276355876814021340982901629687342985079\" + \"247184605687482833138125916196247615690287590107273310329914062386460833337863\" + \"825792630239159000355760903247728133888733917809696660146961503175422675112599\" + \"331552967421333630022296490648093458200818106180210022766458040027821333675857\" + \"301901137175467276305904435313131903609248909724642792845554991349000518029570\" + \"708291905255678188991389962513866231938005361134622429461024895407240485712325\" + \"662888893172211643294781619055486805494344103409068071608802822795968695013364\" + \"381426825217047287086301013730115523686141690837567574763723976318575703810944\" + \"339056456446852418302814810799837691851212720193504404180460472162693944578837\" + \"709010597469321972055811407877598977207200968938224930323683051586265728111463\" + \"799698313751793762321511125234973430524062210524423435373290565516340666950616\" + \"589287821870775679417608071297378133518711793165003315552382248773065344417945\" + \"341539520242444970341012087407218810938826816751204229940494817944947273289477\" + \"011157413944122845552182842492224065875268917227278060711675404697300803703961\" + \"878779669488255561467438439257011582954666135867867189766129731126720007297155\" + \"361302750355616781776544228744211472988161480270524380681765357327557860250584\" + \"708401320883793281600876908130049249147368251703538221961903901499952349538710\" + \"599735114347829233949918793660869230137559636853237380670359114424326856151210\" + \"940425958263930167801712866923928323105765885171402021119695706479981403150563\" + \"304514156441462316376380990440281625691757648914256971416359843931743327023781\" + \"233693804301289262637538266779503416933432360750024817574180875038847509493945\" + \"489620974048544263563716499594992098088429479036366629752600324385635294584472\" + \"894454716620929749549661687741412088213047702281611645604400723635158114972973\" + \"921896673738264720472264222124201656015028497130633279581430251601369482556701\" + \"478093579088965713492615816134690180696508955631012121849180584792272069187169\" + \"631633004485802010286065785859126997463766174146393415956953955420331462802651\" + \"895116793807457331575984608617370268786760294367778050024467339133243166988035\" + \"407323238828184750105164133118953703648842269027047805274249060349208295475505\" + \"400345716018407257453693814553117535421072655783561549987444748042732345788006\" + \"187314934156604635297977945507535930479568720931672453654720838168585560604380\" + \"197703076424608348987610134570939487700294617579206195254925575710903852517148\" + \"852526567104534981341980339064152987634369542025608027761442191431892139390883\" + \"454313176968510184010384447234894886952098194353190650655535461733581404554483\" + \"788475252625394966586999205841765278012534103389646981864243003414679138061902\" + \"805960785488801078970551694621522877309010446746249797999262712095168477956848\" + \"258334140226647721084336243759374161053673404195473896419789542533503630186140\" + \"095153476696147625565187382329246854735693580289601153679178730355315937836308\" + \"224861517777054157757656175935851201669294311113886358215966761883032610416465\" + \"171484697938542262168716140012237821377977413126897726671299202592201740877007\" + \"695628347393220108815935628628192856357189338495885060385315817976067947984087\" + \"836097596014973342057270460352179060564760328556927627349518220323614411258418\" + \"242624771201203577638889597431823282787131460805353357449429762179678903456816\" + \"988955351850447832561638070947695169908624710001974880920500952194363237871976\" + \"487033922381154036347548862684595615975519376541011501406700122692747439388858\" + \"994385973024541480106123590803627458528849356325158538438324249325266608758890\" + \"831870070910023737710657698505643392885433765834259675065371500533351448990829\" + \"388773735205145933304962653141514138612443793588507094468804548697535817021290\" + \"849078734780681436632332281941582734567135644317153796781805819585246484008403\" + \"290998194378171817730231700398973305049538735611626102399943325978012689343260\" + \"558471027876490107092344388463401173555686590358524491937018104162620850429925\" + \"869743581709813389404593447193749387762423240985283276226660494238512970945324\" + \"558625210360082928664972417491914198896612955807677097959479530601311915901177\" + \"394310420904907942444886851308684449370590902600612064942574471035354765785924\" + \"270813041061854621988183009063458818703875585627491158737542106466795134648758\" + \"677154383801852134828191581246259933516019893559516796893285220582479942103451\" + \"271587716334522299541883968044883552975336128683722593539007920166694133909116\" + \"875880398882886921600237325736158820716351627133281051818760210485218067552664\" + \"867390890090719513805862673512431221569163790227732870541084203784152568328871\" + \"804698795251307326634027851905941733892035854039567703561132935448258562828761\" + \"061069822972142096199350933131217118789107876687204454887608941017479864713788\" + \"246215395593333327556200943958043453791978228059039595992743691379377866494096\" + \"404877784174833643268402628293240626008190808180439091455635193685606304508914\" + \"228964521998779884934747772913279726602765840166789013649050874114212686196986\" + \"204412696528298108704547986155954533802120115564697997678573892018624359932677\" + \"768945406050821883822790983362716712449002676117849826437703300208184459000971\" + \"723520433199470824209877151444975101705564302954282181967000920251561584417420\" + \"593365814813490269311151709387226002645863056132560579256092733226557934628080\" + \"568344392137368840565043430739657406101777937014142461549307074136080544210029\" + \"560009566358897789926763051771878194370676149821756418659011616086540863539151\" + \"303920131680576903417259645369235080641744656235152392905040947995318407486215\" + \"121056183385456617665260639371365880252166622357613220194170137266496607325201\" + \"077194793126528276330241380516490717456596485374835466919452358031530196916048\" + \"099460681490403781982973236093008713576079862142542209641900436790547904993007\" + \"837242158195453541837112936865843055384271762803527912882112930835157565659994\" + \"474178843838156514843422985870424559243469329523282180350833372628379183021659\" + \"183618155421715744846577842013432998259456688455826617197901218084948033244878\" + \"725818377480552226815101137174536841787028027445244290547451823467491956418855\" + \"124442133778352142386597992598820328708510933838682990657199461490629025742768\" + \"603885051103263854454041918495886653854504057132362968106914681484786965916686\" + \"184275679846004186876229805556296304595322792305161672159196867584952363529893\" + \"578850774608153732145464298479231051167635774949462295256949766035947396243099\" + \"534331040499420967788382700271447849406903707324910644415169605325656058677875\" + \"741747211082743577431519406075798356362914332639781221894628744779811980722564\" + \"671466405485013100965678631488009030374933887536418316513498254669467331611812\" + \"336485439764932502617954935720430540218297487125110740401161140589991109306249\" + \"231281311634054926257135672181862893278613883371802853505650359195274140086951\" + \"092616754147679266803210923746708721360627833292238641361959412133927803611827\" + \"632410600474097111104814000362334271451448333464167546635469973149475664342365\" + \"949349684588455152415075637660508663282742479413606287604129064491382851945640\" + \"264315322585862404314183866959063324506300039221319264762596269151090445769530\" + \"144405461803785750303668621246227863975274666787012100339298487337501447560032\" + \"210062235802934377495503203701273846816306102657030087227546296679688089058712\" + \"767636106622572235222973920644309352432722810085997309513252863060110549791564\" + \"479184500461804676240892892568091293059296064235702106152464620502324896659398\" + \"732493396737695202399176089847457184353193664652912584806448019652016283879518\" + \"949933675924148562613699594530728725453246329152911012876377060557060953137752\" + \"775186792329213495524513308986796916512907384130216757323863757582008036357572\" + \"800275449032795307990079944254110872569318801466793559583467643286887696661009\" + \"739574996783659339784634695994895061049038364740950469522606385804675807306991\" + \"229047408987916687211714752764471160440195271816950828973353714853092893704638\" + \"442089329977112585684084660833993404568902678751600877546126798801546585652206\" + \"121095349079670736553970257619943137663996060606110640695933082817187642604357\" + \"342536175694378484849525010826648839515970049059838081210522111109194332395113\" + \"605144645983421079905808209371646452312770402316007213854372346126726099787038\" + \"565709199850759563461324846018840985019428768790226873455650051912154654406382\" + \"925385127631766392205093834520430077301702994036261543400132276391091298832786\" + \"392041230044555168405488980908077917463609243933491264116424009388074635660726\" + \"233669584276458369826873481588196105857183576746200965052606592926354829149904\" + \"576830721089324585707370166071739819448502884260396366074603118478622583105658\" + \"087087030556759586134170074540296568763477417643105175103673286924555858208237\" + \"203860178173940517513043799486882232004437804310317092103426167499800007301609\" + \"481458637448877852227307633049538394434538277060876076354209844500830624763025\" + \"357278103278346176697054428715531534001649707665719598504174819908720149087568\" + \"603778359199471934335277294728553792578768483230110185936580071729118696761765\" + \"505377503029303383070644891281141202550615089641100762382457448865518258105814\" + \"034532012475472326908754750707857765973254284445935304499207001453874894822655\" + \"644222369636554419422544133821222547749753549462482768053333698328415613869236\" + \"344335855386847111143049824839899180316545863828935379913053522283343013795337\" + \"295401625762322808113849949187614414132293376710656349252881452823950620902235\" + \"787668465011666009738275366040544694165342223905210831458584703552935221992827\" + \"276057482126606529138553034554974455147034493948686342945965843102419078592368\" + \"022456076393678416627051855517870290407355730462063969245330779578224594971042\" + \"018804300018388142900817303945050734278701312446686009277858181104091151172937\" + \"487362788787490746528556543474888683106411005102302087510776891878152562273525\" + \"155037953244485778727761700196485370355516765520911933934376286628461984402629\" + \"525218367852236747510880978150709897841308624588152266096355140187449583692691\" + \"779904712072649490573726428600521140358123107600669951853612486274675637589622\" + \"529911649606687650826173417848478933729505673900787861792535144062104536625064\" + \"046372881569823231750059626108092195521115085930295565496753886261297233991462\" + \"835847604862762702730973920200143224870758233735491524608560821032888297418390\" + \"647886992327369136004883743661522351705843770554521081551336126214291181561530\" + \"175888257359489250710887926212864139244330938379733386780613179523731526677382\" + \"085802470143352700924380326695174211950767088432634644274912755890774686358216\" + \"216604274131517021245858605623363149316464691394656249747174195835421860774871\" + \"105733845843368993964591374060338215935224359475162623918868530782282176398323\" + \"730618020424656047752794310479618972429953302979249748168405289379104494700459\" + \"086499187272734541350810198388186467360939257193051196864560185578245021823106\" + \"588943798652243205067737996619695547244058592241795300682045179537004347245176\" + \"289356677050849021310773662575169733552746230294303120359626095342357439724965\" + \"921101065781782610874531887480318743082357369919515634095716270099244492974910\" + \"548985151965866474014822510633536794973714251022934188258511737199449911509758\" + \"374613010550506419772153192935487537119163026203032858865852848019350922587577\" + \"559742527658401172134232364808402714335636754204637518255252494432965704386138\" + \"786590196573880286840189408767281671413703366173265012057865391578070308871426\" + \"151907500149257611292767519309672845397116021360630309054224396632067432358279\" + \"788933232440577919927848463333977773765590187057480682867834796562414610289950\" + \"848739969297075043275302997287229732793444298864641272534816060377970729829917\" + \"302929630869580199631241330493935049332541235507105446118259114111645453471032\" + \"988104784406778013807713146540009938630648126661433085820681139583831916954555\" + \"825942689576984142889374346708410794631893253910696395578070602124597489829356\" + \"461356078898347241997947856436204209461341238761319886535235831299686226894860\" + \"840845665560687695450127448663140505473535174687300980632278046891224682146080\" + \"672762770840240226615548502400895289165711761743902033758487784291128962324705\" + \"919187469104200584832614067733375102719565399469716251724831223063391932870798\" + \"380074848572651612343493327335666447335855643023528088392434827876088616494328\" + \"939916639921048830784777704804572849145630335326507002958890626591549850940797\" + \"276756712979501009822947622896189159144152003228387877348513097908101912926722\" + \"710377889805396415636236416915498576840839846886168437540706512103906250612810\" + \"766379904790887967477806973847317047525344215639038720123880632368803701794930\" + \"895490077633152306354837425681665336160664198003018828712376748189833024683637\" + \"148830925928337590227894258806008728603885916884973069394802051122176635913825\" + \"152427867009440694235512020156837777885182467002565170850924962374772681369428\" + \"435006293881442998790530105621737545918267997321773502936892806521002539626880\" + \"749809264345801165571588670044350397650532347828732736884086354000274067678382\" + \"196352222653929093980736739136408289872201777674716811819585613372158311905468\" + \"293608323697611345028175783020293484598292500089568263027126329586629214765314\" + \"223335179309338795135709534637718368409244442209631933129562030557551734006797\" + \"374061416210792363342380564685009203716715264255637185388957141641977238742261\" + \"059666739699717316816941543509528319355641770566862221521799115135563970714331\" + \"289365755384464832620120642433801695586269856102246064606933079384785881436740\" + \"700059976970364901927332882613532936311240365069865216063898725026723808740339\" + \"674439783025829689425689674186433613497947524552629142652284241924308338810358\" + \"005378702399954217211368655027534136221169314069466951318692810257479598560514\" + \"500502171591331775160995786555198188619321128211070944228724044248115340605589\" + \"595835581523201218460582056359269930347885113206862662758877144603599665610843\" + \"072569650056306448918759946659677284717153957361210818084154727314266174893313\" + \"417463266235422207260014601270120693463952056444554329166298666078308906811879\" + \"009081529506362678207561438881578135113469536630387841209234694286873083932043\" + \"233387277549680521030282154432472338884521534372725012858974769146080831440412\" + \"586818154004918777228786980185345453700652665564917091542952275670922221747411\" + \"206272065662298980603289167206874365494824610869736722554740481288924247185432\" + \"360575341167285075755205713115669795458488739874222813588798584078313506054829\" + \"055148278529489112190538319562422871948475940785939804790109419407067176443903\" + \"273071213588738504999363883820550168340277749607027684488028191222063688863681\" + \"104356952930065219552826152699127163727738841899328713056346468822739828876319\" + \"864570983630891778648708667618548568004767255267541474285102814580740315299219\" + \"781455775684368111018531749816701642664788409026268282444825802753209454991510\" + \"451851771654631180490456798571325752811791365627815811128881656228587603087597\" + \"496384943527567661216895926148503078536204527450775295063101248034180458405943\" + \"292607985443562009370809182152392037179067812199228049606973823874331262673030\" + \"679594396095495718957721791559730058869364684557667609245090608820221223571925\" + \"453671519183487258742391941089044411595993276004450655620646116465566548759424\" + \"736925233695599303035509581762617623184956190649483967300203776387436934399982\" + \"943020914707361894793269276244518656023955905370512897816345542332011497599489\" + \"627842432748378803270141867695262118097500640514975588965029300486760520801049\" + \"153788541390942453169171998762894127722112946456829486028149318156024967788794\" + \"981377721622935943781100444806079767242927624951078415344642915084276452000204\" + \"276947069804177583220909702029165734725158290463091035903784297757265172087724\" + \"474095226716630600546971638794317119687348468873818665675127929857501636341131\" + \"462753049901913564682380432997069577015078933772865803571279091376742080565549\" + \"362541\").toString(); } ``` Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge 123456 allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor. Suchen Sie die 4-stellige Ziffernfolge, die am h\u00e4ufigsten in den ersten 100 000 Nachkommastellen von \u03c0 vorkommt. Tipps Schauen Sie sich dazu die Klasse String genauer an! \u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also \"0000\", \"0001\", \"0002\", ... \"9999\" ) Schreiben Sie sich eine Methode int nrOfOccurences(String sub, String str) , die die Anzahl des Vorkommens von sub in str z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie sub=\"0000\" setzen und str=pi \u2192 \"0000\" kommt 9 Mal in pi vor. Testen Sie auch sub=\"2541\" und str=pi , denn \"2541\" ist der allerletzte substring in unserem pi und kommt 8 Mal vor. Merken Sie sich das bisherige maximale Vorkommen eines bestimmten substrings in pi \u2192 Sie merken sich den String und wie oft er vorkam (wenn er h\u00e4ufiger vorkam als der, den Sie sich bis dahin als h\u00e4ufigstes Vorkommen gemerkt hatten). Am Ende haben Sie sich dann den String gemerkt, der am h\u00e4ufigsten vorkommt und auch die Anzahl der Vorkommen. Viel Spa\u00df! m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 Uebung4.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package uebungen.uebung4 ; public class Uebung4 { public static int nrOfOccurrences ( String sub , String str ) { int nrOfOccurrences = 0 ; final int LENGTH_OF_SUBSTRING = sub . length (); for ( int index = 0 ; index <= str . length () - LENGTH_OF_SUBSTRING ; index ++ ) { if ( str . substring ( index , index + LENGTH_OF_SUBSTRING ). equals ( sub )) { nrOfOccurrences ++ ; } } return nrOfOccurrences ; } public static void testAllCombinations ( String str ) { String sub = \"\" ; int maxOcc = 0 ; String maxSub = \"\" ; for ( int i1 = 0 ; i1 < 10 ; i1 ++ ) { for ( int i2 = 0 ; i2 < 10 ; i2 ++ ) { for ( int i3 = 0 ; i3 < 10 ; i3 ++ ) { for ( int i4 = 0 ; i4 < 10 ; i4 ++ ) { sub = String . valueOf ( i1 ) + String . valueOf ( i2 ) + String . valueOf ( i3 ) + String . valueOf ( i4 ); int nrOfOccurrences = nrOfOccurrences ( sub , str ); if ( nrOfOccurrences >= maxOcc ) { maxOcc = nrOfOccurrences ; maxSub = sub ; System . out . println ( maxOcc + \" \" + maxSub ); } } } } } } public static void main ( String [] args ) { String pi = StringPi . PI ; int nrOO = nrOfOccurrences ( \"2541\" , pi ); System . out . println ( nrOO ); testAllCombinations ( pi ); } }","title":"\u00dcbung 4 (String)"},{"location":"uebungen/#ubung-5-enum-und-zweidimensionale-arrays","text":"\u00dcbung 5 (10. + 12.5.) Gegeben ist die folgende Klasse TicTacToe : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package uebungen.uebung5 ; public class TicTacToe { ??? hier soll ein enum definiert werden ??? State [][] field ; public TicTacToe () { field = new ??? welcher Typ ???[ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } public void makeMove ( int i , int j , ??? welcher Typ ??? player ) { if ( field [ i ][ j ]==??? was kommt hier hin ??? && player !=??? was kommt hier hin ??? ) field [ i ][ j ]= player ; } } F\u00fcgen Sie die ??? ... ??? korrekt aus. F\u00fcgen Sie alle notwendigen Klammern { } ein, so dass die Anweisungsbl\u00f6cke korrekt geklammert sind. Erweitern Sie die Klasse TicTacToe um eine print() -Methode, die das Spielfeld auf die Konsole ausgibt (Setzen Sie z.B. f\u00fcr den Player RED ein x und f\u00fcr den Player Black ein o und f\u00fcr EMPTY ein Leerzeichen oder ein - ). Die Ausgabe nach jeweils 2 Z\u00fcgen von RED und BLACK k\u00f6nnte dann z.B. so aussehen: - o o - x - - - x Erweitern Sie die Klasse TicTacToe um eine gewonnen() -Methode ( true , wenn ein Spieler drei Felder horizontal, diagonal oder vertikal belegt hat; ansonsten false ). Erweitern Sie die Klasse TicTacToe um eine unentschieden() -Methode ( true , wenn alle Felder besetzt sind, aber kein Spieler gewonnen hat; ansonsten false ). Erstellen Sie eine Test-Klasse mit main() -Methode. Erstellen sie darin ein Objekt der Klasse TicTacToe . F\u00fchren Sie Z\u00fcge aus ( makeMove() ) und pr\u00fcfen Sie, ob gewonnen wurde oder unentschieden ist (mit entsprechenden Ausgaben). F\u00fcr 7. m\u00fcssen Sie in der Testklasse Ihr enum State importieren. Warum ist das so? Was k\u00f6nnten Sie machen, damit das nicht notwendig ist? Zusatz: Sie k\u00f6nnen die Klasse TicTacToe beliebig erweitern, z.B.: um Ausgaben, wenn gewonnen bzw. es unentschieden ist, um Fehler in den Indizes i und j bei der makeMove() -Methode abzufangen, eine Methode spielen() implementieren, die zuf\u00e4llig f\u00fcr die Spieler die Steine setzt usw. Viel Spa\u00df! m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 package uebungen.uebung5 ; import java.util.Random ; public class TicTacToe { State [][] field ; public TicTacToe () { this . field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < this . field . length ; i ++ ) { for ( int j = 0 ; j < this . field [ i ] . length ; j ++ ) { field [ i ][ j ]= State . EMPTY ; } } } public void makeMove ( int row , int col , State player ) { if ( row >= 0 && row < this . field . length && col >= 0 && col < this . field [ row ] . length && this . field [ row ][ col ] == State . EMPTY ) { if ( player != State . EMPTY ) { this . field [ row ][ col ]= player ; } } } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { System . out . print ( \"- \" ); } else if ( field [ row ][ col ]== State . RED ) { System . out . print ( \"x \" ); } else // BLACK { System . out . print ( \"o \" ); } } System . out . println (); } System . out . println (); } public boolean gewonnen ( State player ) { if ( player == State . EMPTY ) return false ; // alle drei Zeilen pruefen for ( int row = 0 ; row < this . field . length ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { return true ; } } // alle drei Spalten pruefen for ( int col = 0 ; col < this . field . length ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { return true ; } } // Diagonale von links oben nach rechts unten if ( this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { return true ; } // Diagonale von rechts oben nach links unten if ( this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { return true ; } return false ; } public void printResultat () { if ( this . gewonnen ( State . RED )) { System . out . println ( \"Rot hat gewonnen!!!\" ); } else if ( this . gewonnen ( State . BLACK )) { System . out . println ( \"Schwarz hat gewonnen!!!\" ); } else if ( this . unentschieden ()) { System . out . println ( \"Unentschieden!!!\" ); } } public void makeRandomMove ( State player ) { if ( player != State . EMPTY ) { Random r = new Random (); int row = r . nextInt ( 3 ); int col = r . nextInt ( 3 ); while ( this . field [ row ][ col ]!= State . EMPTY ) { row = r . nextInt ( 3 ); col = r . nextInt ( 3 ); } this . field [ row ][ col ]= player ; } } public void spielen () { State player = State . RED ; while ( ! ( this . unentschieden () || this . gewonnen ( State . RED ) || this . gewonnen ( State . BLACK ))) { this . makeRandomMove ( player ); this . print (); this . printResultat (); if ( player == State . RED ) { player = State . BLACK ; } else { player = State . RED ; } // player = (player == State.RED) ? State.BLACK : State.RED; } } public boolean voll () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { return false ; } } } return true ; } public boolean unentschieden () { return ( this . voll () && ! this . gewonnen ( State . RED ) && ! this . gewonnen ( State . BLACK )); } } State.java 1 2 3 4 5 package uebungen.uebung5 ; public enum State { EMPTY , RED , BLACK } TestTicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package uebungen.uebung5 ; public class TestTicTacToe { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe (); ttt . print (); /* ttt.makeMove(1, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 2, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, -1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 0, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 2, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 2, State.RED); ttt.printResultat(); ttt.print(); */ ttt . spielen (); // ttt.makeRandomMove(State.RED); // ttt.print(); } }","title":"\u00dcbung 5 (enum und zweidimensionale Arrays)"},{"location":"uebungen/#ubung-6-listen-und-mengen","text":"\u00dcbung 6 (17. + 19.5.) Erstellen Sie eine Klasse Uebung6 mit main() -Methode. Definieren Sie in der main() -Methode eine Variable words vom Typ String[] und weisen Sie dieser Variablen folgende Werte zu: String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; A. Listen ( List ) Erstellen Sie eine Methode public static List<String> createArrayList(String[] words) . In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Liste ( List ) zur\u00fcck. Erstellen Sie eine Methode public static void printList(List<String> list) . Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. Erstellen Sie in der main() -Methode mithilfe der Methode createArrayList(words) eine Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String> . Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. Studieren Sie alle Methoden f\u00fcr List unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html . Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox L\u00f6schen Sie die Werte \"Apple\" , \"Google\" und \"Facebook\" . Geben Sie die Liste erneut mithilfe der printList(list) -Methode aus. B. Mengen ( Set ) Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words) . In dieser Methode soll eine HashSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie eine Methode public static void printSet(Set<String> set) . Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. Erstellen Sie in der main() -Methode mithilfe der Methode createHashSet(words) eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String> . Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so? Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words) . In dieser Methode soll eine TreeSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Menge ( Set ) mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie in der main() -Methode mithilfe der Methode createTreeSet(words) eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet ? Zusatz Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list) . Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der printList() -Methode in der main() -Methode aus. M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) Liste mit 16 Elementen : -------------------------- Linux Apple Facebook Amazon IBM Lenovo Google IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Index des ersten Auftretens von Apple : 1 Index des letzten Auftretens von Apple : 9 erstes Element in der Liste : Linux letztes Element in der Liste : Firefox Liste mit 13 Elementen : -------------------------- Linux Amazon IBM Lenovo IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Doublets- Liste mit 4 Elementen : -------------------------- Linux IBM IBM Linux ohne Doublets- Liste mit 9 Elementen : -------------------------- Amazon Lenovo Microsoft Apple Google Twitter Skype Chrome Firefox Menge mit 12 Elementen : -------------------------- Lenovo Google Apple Skype Linux IBM Twitter Chrome Microsoft Amazon Facebook Firefox Menge mit 12 Elementen : -------------------------- Amazon Apple Chrome Facebook Firefox Google IBM Lenovo Linux Microsoft Skype Twitter m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Uebung6.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 package uebungen.uebung5.loesung ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Uebung6 { //A1. Erstellen Sie eine Methode public static List<String> createArrayList(String[] words). //In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. Die Methode gibt die bef\u00fcllte Liste (List) zur\u00fcck. public static List < String > createArrayList ( String [] words ){ // neue ArrayList mit String als Type anlegen List < String > list = new ArrayList <> (); // jedes Element aus words in die Liste einf\u00fcgen for ( int i = 0 ; i < words . length ; i ++ ) { list . add ( words [ i ] ); } return list ; } //A2. Erstellen Sie eine Methode public static void printList(List<String> list). //Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Liste aus. public static void printList ( List < String > list ) { //Variante 1: Iterator System . out . println ( \"--Iterator--\" ); Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } //Variante 2: for-Schleife System . out . println ( \"--Schleife--\" ); for ( String s : list ) { System . out . println ( s ); } //Anzahl der Elemente ausgeben System . out . println ( \"Die Liste hat \" + list . size () + \" Elemente.\" ); } //B1. Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words). //In dieser Methode soll eine HashSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createHashSet ( String [] words ) { Set < String > set = new HashSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //B2. Erstellen Sie eine Methode public static void printSet(Set<String> set). //Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Menge aus. public static void printSet ( Set < String > set ) { for ( String s : set ) { System . out . println ( s ); } System . out . println ( \"Das Set hat \" + set . size () + \" Elemente.\" ); } //B4. Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words). //In dieser Methode soll eine TreeSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Menge (Set) mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createTreeSet ( String [] words ) { Set < String > set = new TreeSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //Zusatz: Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list). //Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. //Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. //Geben Sie diese Liste mithilfe der printList()-Methode in der main()-Methode aus. public static List < String > findDoublets ( List < String > list ) { //Grundidee //Beispiel-Liste: \"a\" \"b\" \"a\" \"c\" \"a\" //Index: 0 1 2 3 4 //Inhalt: a b a c a //erster Index von \"a\": 0 //letzter Index von \"a\":4 //0 != 4 -> es gibt Duplikate //erster Index von \"b\":1 //letzter Index von \"b\":1 //1 == 1 -> keine Duplikate, also diesen Eintrag als Einzeleintrag merken //... //leere Liste \"singles\" f\u00fcr Einzeleintr\u00e4ge anlegen List < String > singles = new ArrayList <> (); //durch list iterieren und testen ob das Element Duplikate hat, //wenn nicht in \"singles\" speichern Iterator < String > it = list . iterator (); //it = copy.iterator(); while ( it . hasNext ()) { String s = it . next (); if ( list . indexOf ( s ) == list . lastIndexOf ( s )) singles . add ( s ); } //Kopie von list anlegen List < String > copy = new ArrayList <> (); it = list . iterator (); while ( it . hasNext ()) copy . add ( it . next ()); //alle singles aus der kopierten Liste entfernen copy . removeAll ( singles ); return copy ; //um zu testen, warum die Kopie n\u00f6tig ist: //copy.removeAll(singles); und return copy; ersetzen durch //list.removeAll(singles); //return list; //und dann die Ausgabe von l2 in der main anschauen } public static void main ( String [] args ) { String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; System . out . println ( \"---------- A ----------\" ); //A3. Erstellen Sie in der main()-Methode mithilfe der Methode createArrayList(words) eine //Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String>. List < String > l1 = createArrayList ( words ); //Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. printList ( l1 ); //A4. Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 System . out . println ( \"Index des ersten Auftretens von Apple: \" + l1 . indexOf ( \"Apple\" )); //Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 System . out . println ( \"Index des letzten Auftretens von Apple: \" + l1 . lastIndexOf ( \"Apple\" )); //Geben Sie den Wert des ersten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux System . out . println ( \"erstes Element der Liste: \" + l1 . get ( 0 )); //Geben Sie den Wert des letzten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox System . out . println ( \"letztes Element der Liste: \" + l1 . get ( l1 . size () - 1 )); //L\u00f6schen Sie die Werte \"Apple\", \"Google\" und \"Facebook\". //Geben Sie die Liste erneut mithilfe der printList(list)-Methode aus. //1. M\u00f6glichkeit: nur 1. Vorkommen l\u00f6schen l1 . remove ( \"Apple\" ); l1 . remove ( \"Google\" ); l1 . remove ( \"Facebook\" ); printList ( l1 ); //2. M\u00f6glichkeit: alle l\u00f6schen while ( l1 . remove ( \"Apple\" )); while ( l1 . remove ( \"Google\" )); while ( l1 . remove ( \"Facebook\" )); printList ( l1 ); System . out . println ( \"---------- B ----------\" ); System . out . println ( \"-------HashSet------\" ); //B3. Erstellen Sie in der main()-Methode mithilfe der Methode createHashSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String>. Set < String > h1 = createHashSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente //in der Liste? Warum ist das so? printSet ( h1 ); System . out . println ( \"-------TreeSet------\" ); //B5. Erstellen Sie in der main()-Methode mithilfe der Methode createTreeSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen. Set < String > t1 = createTreeSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet? printSet ( t1 ); System . out . println ( \"-------Duplicates------\" ); List < String > l2 = createArrayList ( words ); List < String > d = findDoublets ( l2 ); printList ( d ); printList ( l2 ); } }","title":"\u00dcbung 6 (Listen und Mengen)"},{"location":"uebungen/#ubung-7-maps","text":"\u00dcbung 7 (31.5. - 2.6.) Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: String name; List<Integer> bevoelkerung; float flaeche; Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor public Stadt(String name, List<Integer> bevoelkerung, float flaeche) , der die Objektvariablen initialisiert. Erstellen Sie f\u00fcr die Klasse Stadt eine print() -Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Erstellen Sie eine Klasse StadtTest mit main() -Methode. Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } Liste Erstellen Sie in der main() -Methode eine List<Stadt> staedteListe = new ArrayList<>(); . F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Menge Erstellen Sie in der main() -Methode eine Set<Stadt> staedteMenge = new HashSet<>(); . F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? Stadt - Teil 2 Implementieren Sie in der Klasse Stadt die equals(Object) - und die hashCode() -Methode. F\u00fchren Sie danach die StadtTest -Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? Maps Erstellen Sie in der main() -Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>(); . F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer -Wert beginnend mit 1 als Key sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array als Value hinzu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys . Ausgaben ------------ Liste -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 ------------ Menge -------------- Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 von Frau Busjahn vorkommentierten Klassen Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Objektvariablen initialisieren this . ??? = ??? ; ... } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //import //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package uebungen.uebung7 ; import java.util.* ; //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt implements Comparable //Der Teil mit \"implements\" wird nicht von Anfang an ben\u00f6tigt, es kann also auch erstmal mit \"public class Stadt\" begonnen werden. //W\u00e4hrend es bei primitiven Datentypen meist eindeutig ist, ob ein Wert gr\u00f6\u00dfer, kleiner oder gleich gro\u00df ist wie ein anderer Wert, ist die Ordnung bei Objekten nicht so klar. //Daher muss Stadt Klasse ein bestimmtes Interface implementieren, um festzulegen, was verglichen werden soll. { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen System . out . printf ( \"%-15s %9.2f km2 \" , this . name , this . flaeche ); for ( Integer el : this . bevoelkerung ) { System . out . printf ( \"%,10d\" , el ); } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben Stadt stadt = ( Stadt ) o ; return this . name . equals ( stadt . name ); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } //Festlegen, dass der Name des \u00fcbergebenen Stadt-Objekts o mit dem Namen des aktuellen Stadt-Objekts verglichen werden soll @Override public int compareTo ( Object o ) { Stadt stadt = ( Stadt ) o ; return this . name . compareTo ( stadt . name ); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package uebungen.uebung7 ; //import import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Liste -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen Stadt [] staedte = staedte (); for ( Stadt stadt : staedte ) { staedteListe . add ( stadt ); } //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. for ( Stadt stadt : staedteListe ) { stadt . print (); } //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n%n------------------------- Menge -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge1 = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt stadt : staedte ()) { staedteMenge1 . add ( stadt ); } //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben for ( Stadt stadt : staedteMenge1 ) { stadt . print (); } //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? //Notieren Sie sich die Reihenfolge, in der St\u00e4dte ausgegeben werden. //\u00c4ndern Sie den Konstruktor von HashSet<>() in TreeSet<>(). Was passiert und warum? Set < Stadt > staedteMenge2 = new TreeSet <> (); //analog zu oben System . out . printf ( \"%n%n------------------------- Maps -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); Integer number = 1 ; for ( Stadt stadt : staedte ()) { staedteMap . put ( number , stadt ); number ++ ; } // Stadt berlin = staedte[0]; // staedteMap.put(2, berlin); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . printf ( \"%-3d\" , eintrag . getKey ()); Stadt stadt = eintrag . getValue (); stadt . print (); } //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte System . out . printf ( \"%n%n------------------------- Test compareTo -------------------------%n%n\" ); System . out . println ( \"Berlin\" . compareTo ( \"Anton\" )); System . out . println ( \"Anton\" . compareTo ( \"Berlin\" )); System . out . println ( \"Berlin\" . compareTo ( \"Berlin\" )); System . out . println ( \"Anton\" . compareTo ( \"Zeppelin\" )); } } MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package uebungen.uebung8 ; public class MyInteger implements Comparable < MyInteger > { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public int compareTo ( MyInteger o ) { return - ( this . value - o . value ); } }","title":"\u00dcbung 7 (Maps)"},{"location":"uebungen/#ubung-8-interfaces","text":"\u00dcbung 8 (7.6. - 9.6.) Wir besch\u00e4ftigen uns nochmal mit der \u00dcbung 7, d.h. mit Stadt und StadtTest . Dieses Mal geht es uns aber mehr um die Verwendung des Interfaces Comparable . Zun\u00e4chst sind die beiden Klassen Stadt und StadtTest wie folgt gegeben (das haben wir so in \u00dcbung 7 erarbeitet - es gibt eine \u00c4nderung in StadtTest , dort benutzen wir jetzt ): Stadt.java import java.util.* ; public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } } StadtTest.java public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); Set < Stadt > staedteMenge = new HashSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); Map < MyInteger , Stadt > staedteMap = new HashMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { staedteMap . put ( new MyInteger ( i ++ ), s ); } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } F\u00fcr die Schl\u00fcssel in der Map benutzen wir die selbstgeschriebne Klasse MyInteger : MyInteger.java public class MyInteger { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } } \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Set von HashSet nach TreeSet und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen ( Stadt cannot be cast to class java.lang.Comparable ). Implementieren Sie f\u00fcr Stadt das Interface Comparable<Stadt> so, dass nach den Namen der St\u00e4dte sortiert wird. F\u00fchren Sie dann erneut StadtTest.java aus. Es sollte folgende Ausgabe f\u00fcr die Set erzeugt werden: ------------ Menge -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 \u00c4ndern Sie compareTo() in Stadt so, dass die Namen der St\u00e4dte absteigend sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Menge -------------- Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 \u00c4ndern Sie compareTo() in Stadt so, dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Menge -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Map von HashMap nach TreeMap und f\u00fchren Sie die Klasse aus - es wird eine Exception geworfen ( MyInteger cannot be cast to class java.lang.Comparable ). Implementieren Sie f\u00fcr MyInteger das Interface Comparable<MyInteger> so, dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. F\u00fchren Sie dann erneut StadtTest.java aus. Es sollte folgende Ausgabe f\u00fcr die Map erzeugt werden: ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 \u00c4ndern Sie compareTo() in MyInteger so, dass die Werte der Schl\u00fcssel absteigend sortiert werden und f\u00fchren Sie dann StadtTest.java erneut aus. Es sollte folgende Ausgabe erzeugt werden: ------------ Maps -------------- 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Zusatz : Schreiben Sie in StadtTest.java eine Methode public static boolean contains(Map<MyInteger, Stadt> staedteMap, Stadt stadt) , die ein true zur\u00fcckgibt, wenn die Stadt stadt bereits in der staedteMap als ein value existiert. Tipp : Die Methode get(Object key) aus Map gibt den zu key geh\u00f6rigen value zur\u00fcck und mit keySet() bekommt man die Menge aller keys aus der Map ermittelt. Testen Sie die Methode, indem Sie zur Menge nur dann die stadt hinzuf\u00fcgen, wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. Sie sollten folgende Ausgabe erhalten: ------------ Maps -------------- 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Vorkommentierte Klassen : Stadt.java import java.util.* ; //3. Implementieren Sie f\u00fcr Stadt das Interface Comparable<Stadt> so, //dass nach den Namen der St\u00e4dte sortiert wird. public class Stadt implements ?/ extends ? Comparable < Stadt > { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } //3. \u00c4ndern Sie compareTo() in Stadt so, dass nach den Namen der //St\u00e4dte sortiert werden kann. //4. \u00c4ndern Sie compareTo() in Stadt so, dass die Namen der //St\u00e4dte absteigend sortiert werden //5. \u00c4ndern Sie compareTo() in Stadt so, //dass die St\u00e4dte absteigend nach ihrer Fl\u00e4che sortiert werden. //Beispiel aus dem Script //@Override //public int compareTo(Circle o) { // if(this.radius > o.radius) return 1; // else if(this.radius < o.radius) return -1; // else return 0; // this.radius == o.radius //} @Override public int compareTo ( ??? ??? ) { } } StadtTest.java import java.util.* ; public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } //Zusatz: Schreiben Sie in StadtTest.java eine Methode //public static boolean contains(Map<MyInteger, Stadt> staedteMap, Stadt stadt), //die ein true zur\u00fcckgibt, wenn die Stadt stadt bereits in der staedteMap als ein //value existiert. //Tipp: Die Methode get(Object key) aus Map gibt den zu key geh\u00f6rigen value zur\u00fcck //und mit keySet() bekommt man die Menge aller keys aus der Map ermittelt. //Testen Sie die Methode, indem Sie zur Menge nur dann die stadt hinzuf\u00fcgen, //wenn sie nicht bereits in der Menge aufgef\u00fchrt ist. public static boolean contains ( Map < MyInteger , Stadt > staedteMap , Stadt stadt ) { //alle Schl\u00fcssel ermitteln mit keySet() //durch alle Schl\u00fcssel iterieren und testen ob der jeweilige Schl\u00fcssel //gleich der \u00fcbergebenen Stadt ist //wird die Stadt gefunden -> return true, sonst false } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); //3. \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der //Set von HashSet nach TreeSet und f\u00fchren Sie die Klasse aus - //es wird eine Exception geworfen (Stadt cannot be cast to //class java.lang.Comparable). Set < Stadt > staedteMenge = new HashSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); //6. \u00c4ndern Sie in der StadtTest.java den Konstruktoraufruf der Map von //HashMap nach TreeMap und f\u00fchren Sie die Klasse aus - es wird eine Exception // geworfen (MyInteger cannot be cast to class java.lang.Comparable). Map < MyInteger , Stadt > staedteMap = new HashMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { //f\u00fcr die Zusatzaufgabe muss hier noch gepr\u00fcft werden, ob s bereits in //der Map vorhanden ist, daf\u00fcr wird die contains-Methode ben\u00f6tigt staedteMap . put ( new MyInteger ( i ++ ), s ); } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } MyInteger.java //6. Implementieren Sie f\u00fcr MyInteger das Interface Comparable<MyInteger> so, //dass nach den Gr\u00f6\u00dfen der Werte sortiert wird. public class MyInteger implements ?/ extends ? ???<???> { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } //7. \u00c4ndern Sie compareTo() in MyInteger so, dass //die Werte der Schl\u00fcssel absteigend sortiert werden. //Beispiel aus dem Script f\u00fcr AUFsteigend sortiert: //public int compareTo(Rectangle o) { // int diff = (this.height+this.width) - (o.height+o.width); // return diff; //} @Override public int compareTo ( ??? ??? ) { } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 8 Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package uebungen.uebung8 ; import java.util.* ; public class Stadt implements Comparable < Stadt > { String name ; List < Integer > bevoelkerung ; float flaeche ; public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { super (); this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } void print () { System . out . printf ( \"%-15s %9.2f km2 \" , name , flaeche ); for ( Integer i : bevoelkerung ) { System . out . printf ( \"%,12d\" , i ); } System . out . println (); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Stadt other = ( Stadt ) o ; return ( this . name . equals ( other . name )); } @Override public int hashCode () { return this . name . hashCode (); } @Override public int compareTo ( Stadt o ) { if ( this . flaeche < o . flaeche ) return 1 ; else if ( this . flaeche > o . flaeche ) return - 1 ; else return 0 ; } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package uebungen.uebung8 ; import java.util.* ; public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static boolean contains ( Map < MyInteger , Stadt > staedteMap , Stadt stadt ) { Set < MyInteger > allKeys = staedteMap . keySet (); for ( MyInteger key : allKeys ) { if ( staedteMap . get ( key ). equals ( stadt )) return true ; } return false ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Menge --------------%n\" ); Set < Stadt > staedteMenge = new TreeSet <> (); for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); Map < MyInteger , Stadt > staedteMap = new TreeMap <> (); int i = 1 ; for ( Stadt s : staedte ()) { if ( ! contains ( staedteMap , s )) { staedteMap . put ( new MyInteger ( i ++ ), s ); } } for ( Map . Entry < MyInteger , Stadt > entry : staedteMap . entrySet ()) { MyInteger key = entry . getKey (); System . out . printf ( \"%-3d\" , key . intValue ()); entry . getValue (). print (); } } } MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package uebungen.uebung8 ; public class MyInteger implements Comparable < MyInteger > { private int value ; public MyInteger ( int value ) { this . value = value ; } public int intValue () { return this . value ; } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public int compareTo ( MyInteger o ) { return - ( this . value - o . value ); } }","title":"\u00dcbung 8 (Interfaces)"},{"location":"uebungen/#ubung-9-gui","text":"\u00dcbung 9 (21.6. - 23.6.) Erstellen Sie folgende GUI: vorkommentierte Klasse GUIUebung.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //import public class GUIUebung extends JFrame { public GUIUebung () { super (); //Titel //Verhalten beim Schlie\u00dfen //Gr\u00f6\u00dfe //Sichtbarkeit //... //gute Vorlage: //https://freiheit.f4.htw-berlin.de/prog2/gui/#erweitern-des-fensters-um-ein-jpanel } private JPanel initContent () { //Ein paar Tipps: //mehrere Panels verwenden //JTextField hat verschiedene Konstruktoren, nicht nur JTextField(int columns) //Rahmen k\u00f6nnen mit BorderFactory erzeugt werden //Beim FlowLayout \u00e4ndert sich die Gr\u00f6\u00dfe der Steuerelemente nicht, //bei GridLayout passt sich die Gr\u00f6\u00dfe an den Container an } public static void main ( String [] args ) { new GUIUebung (); } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 9 Uebung9.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package uebungen.uebung9 ; import java.awt.* ; import javax.swing.* ; import javax.swing.border.Border ; public class Uebung9 extends JFrame { public Uebung9 () { super (); this . setTitle ( \"GUI \u00dcbung\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JPanel content = this . initContent (); this . getContentPane (). add ( content ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private JPanel initContent () { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new BorderLayout ()); Border redline = BorderFactory . createLineBorder ( Color . RED ); JPanel oben = new JPanel (); oben . setLayout ( new FlowLayout ()); JLabel text1 = new JLabel ( \"Text\" ); text1 . setForeground ( Color . WHITE ); oben . add ( text1 ); oben . setBackground ( Color . BLUE ); oben . setBorder ( redline ); JPanel links = new JPanel (); links . setLayout ( new FlowLayout ( FlowLayout . CENTER , 50 , 50 )); JLabel text2 = new JLabel ( \"Weiterer Text\" ); links . add ( text2 ); JTextField input = new JTextField ( \"Feld\" , 10 ); links . add ( input ); links . setBackground ( Color . LIGHT_GRAY ); JPanel rechts = new JPanel (); rechts . setLayout ( new GridLayout ( 2 , 1 , 20 , 20 )); rechts . add ( new JButton ( \"Button 1\" )); rechts . add ( new JButton ( \"Button 2\" )); rechts . setBackground ( Color . LIGHT_GRAY ); mainPanel . add ( oben , BorderLayout . NORTH ); mainPanel . add ( links , BorderLayout . CENTER ); mainPanel . add ( rechts , BorderLayout . EAST ); return mainPanel ; } public static void main ( String [] args ) { new Uebung9 (); } } sehr hilfreiche Grafiken zur \u00dcbung von Frau Busjahn Unterscheidung zwischen Containern und Steuerelementen: Visualisierung der Panels (Container) in der GUI der \u00dcbung","title":"\u00dcbung 9 (GUI)"},{"location":"uebungen/#ubung-10-junit","text":"\u00dcbung 10 (15.6.) Probieren Sie sich mit JUnit aus! Schreiben Sie Unit-Tests f\u00fcr Ihre MyInteger -Klasse aus Aufgabe 2 . m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 10 - Testklasse nicht vollst\u00e4ndig, aber einige Testf\u00e4lle MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package uebungen.uebung10.loesung ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 48 bis 9 ist 57 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { if ( s == null ) throw new IllegalArgumentException ( \"kein String\" ); if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leerer String\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest boolean negativ = false ; if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne fuehrende Nullen while ( s . length () > 0 && s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } if ( s . length () == 0 ) return 0 ; // String bestand nur aus Nullen --> 0 for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int zahl = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { int ziffer = charToInt ( s . charAt ( i )); if (( ! negativ && ( MyInteger . MAX_VALUE - ziffer ) / 10 < zahl ) || ( negativ && ( MyInteger . MAX_VALUE + 1 - ziffer ) / 10 < zahl )) { if ( negativ ) throw new IllegalArgumentException ( \"Zahl zu klein!\" ); else throw new IllegalArgumentException ( \"Zahl zu gross!\" ); } zahl = zahl * 10 + ziffer ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 package uebungen.uebung10.loesung ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.DisplayName ; import org.junit.jupiter.api.Test ; class MyIntegerTest { static MyInteger mi1 , mi2 , mi3 , mi4 , mi5 , mi6 , mi7 ; @BeforeAll public static void setUpBeforeClass () throws Exception { mi1 = new MyInteger ( \"-2147483648\" ); mi2 = new MyInteger ( \"+2147483647\" ); mi3 = new MyInteger ( - 1 ); mi4 = new MyInteger ( 1 ); mi5 = new MyInteger ( 0 ); mi6 = new MyInteger ( \"-1\" ); mi7 = new MyInteger ( 2147483647 ); } /* * parseInt-Testfaelle: * null -> Exception (IAE) kein String * \"\" -> Exception (IAE) leerer String * \"+\" -> Exception (IAE) nur '+' bzw. '-' --> keine Zahl * \"-\" -> Exception (IAE) nur '+' bzw. '-' --> keine Zahl * \"-00000000\" -> 0 * \"+00000000\" -> 0 * \"-00000001\" -> -1 * \"+00000001\" -> 1 * \"123456a\" -> Exception (IAE) keine Zahl! * \"-123456a\" -> Exception (IAE) keine Zahl! * \"+123456a\" -> Exception (IAE) keine Zahl! * \"2147483648\" -> Exception (IAE) Zahl zu gross! * \"-2147483649\" -> Exception (IAE) Zahl zu klein! * */ @Test void testParseIntPositiveInt () { assertEquals ( 1234 , MyInteger . parseInt ( \"1234\" ), \"\\\"1234\\\" should be 1234\" ); assertEquals ( 1234 , MyInteger . parseInt ( \"+1234\" ), \"\\\"+1234\\\" should be 1234\" ); assertEquals ( 1234 , MyInteger . parseInt ( \"01234\" ), \"\\\"01234\\\" should be 1234\" ); } @Test void testParseIntNegativeInt () { assertEquals ( - 1234 , MyInteger . parseInt ( \"-1234\" ), \"\\\"-1234\\\" should be -1234\" ); assertEquals ( - 1234 , MyInteger . parseInt ( \"-01234\" ), \"\\\"-01234\\\" should be -1234\" ); } @Test void testValueOfPositiveInt () { MyInteger m = MyInteger . valueOf ( 1234 ); assertNotNull ( m , \"shoul be an object\" ); assertEquals ( 1234 , m . intValue (), \"1234 should be 1234\" ); } @Test @DisplayName ( \"Input-String is null\" ) void testParseIntNull () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( null )); assertEquals ( \"kein String\" , exception . getMessage ()); } @Test @DisplayName ( \"Input-String is leer\" ) void testParseIntLeer () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"\" )); assertEquals ( \"leerer String\" , exception . getMessage ()); } @Test @DisplayName ( \"Nur Plus oder Minus\" ) void testParseIntNurPlusOderMinus () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"+\" )); assertEquals ( \"nur '+' bzw. '-' --> keine Zahl\" , exception . getMessage ()); exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"-\" )); assertEquals ( \"nur '+' bzw. '-' --> keine Zahl\" , exception . getMessage ()); } @Test @DisplayName ( \"Keine Zahl\" ) void testParseIntKeineZahl () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"+1234a\" )); assertEquals ( \"keine Zahl!\" , exception . getMessage ()); } @Test @DisplayName ( \"Zahl zu gross\" ) void testParseIntZahlZuGross () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"2147483648\" )); assertEquals ( \"Zahl zu gross!\" , exception . getMessage ()); } @Test @DisplayName ( \"Zahl zu klein\" ) void testParseIntZahlZuKlein () { Exception exception = assertThrows ( IllegalArgumentException . class , () -> MyInteger . parseInt ( \"-2147483649\" )); assertEquals ( \"Zahl zu klein!\" , exception . getMessage ()); } @Test void testParseIntNurNullen () { assertEquals ( 0 , MyInteger . parseInt ( \"-000000000000\" ), \"\\\"-000000000000\\\" should be 0\" ); assertEquals ( 0 , MyInteger . parseInt ( \"+000000000000\" ), \"\\\"+000000000000\\\" should be 0\" ); assertEquals ( 0 , MyInteger . parseInt ( \"0000000000000\" ), \"\\\"0000000000000\\\" should be 0\" ); } @Test void testHashCode () { assertTrue ( mi2 . hashCode () == mi7 . hashCode (), \"hashCode of mi2 and mi7 should be equal\" ); assertEquals ( - 2147483648 , mi1 . hashCode (), \"hashCode of mi1 should be -2147483648\" ); assertEquals ( 0 , mi5 . hashCode (), \"hashCode of mi5 should be 0\" ); } @Test void testMyIntegerInt () { assertNotNull ( mi4 , \"mi4 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testMyIntegerString () { assertNotNull ( mi1 , \"mi1 should be not null\" ); assertNotNull ( mi2 , \"mi2 should be not null\" ); assertNotNull ( mi6 , \"mi6 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testParseInt () { assertEquals ( - 2147483648 , MyInteger . parseInt ( \"-2147483648\" ), \"should be -2147483648\" ); assertEquals ( + 2147483647 , MyInteger . parseInt ( \"+00002147483647\" ), \"should be +2147483647\" ); assertEquals ( - 1 , MyInteger . parseInt ( \"-0000001\" ), \"should be -1\" ); } @Test void testIntValue () { assertEquals ( - 2147483648 , mi1 . intValue (), \"should be -2147483648\" ); assertEquals ( + 2147483647 , mi2 . intValue (), \"should be +2147483647\" ); assertEquals ( + 2147483647 , mi7 . intValue (), \"should be +2147483647\" ); } @Test void testDoubleValue () { assertEquals ( - 2147483648.0 , mi1 . doubleValue (), \"should be -2147483648.0\" ); assertEquals ( + 2147483647.0 , mi2 . doubleValue (), \"should be +2147483647.0\" ); assertEquals ( + 2147483647.0 , mi7 . doubleValue (), \"should be +2147483647.0\" ); } @Test void testValueOfString () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( \"-2147483648\" )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi7\" ); } @Test void testValueOfInt () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( - 2147483648 )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi7\" ); } @Test void testEqualsObject () { assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); assertFalse ( mi3 . equals ( mi4 ), \"mi3 and mi4 should not be equal\" ); assertFalse ( mi3 . equals ( mi5 ), \"mi3 and mi5 should not be equal\" ); } @Test void testToString () { assertEquals ( \"-2147483648\" , mi1 . toString (), \"should be '-2147483648'\" ); assertEquals ( \"2147483647\" , mi2 . toString (), \"should be '2147483647' mi2\" ); assertEquals ( \"2147483647\" , mi7 . toString (), \"should be '2147483647' mi7\" ); } @Test void testCompare () { assertTrue ( MyInteger . compare ( 5 , 4 ) > 0 , \"5,4 should be > 0\" ); assertTrue ( MyInteger . compare ( 4 , 4 ) == 0 , \"4,4 should be == 0\" ); assertTrue ( MyInteger . compare ( 4 , 5 ) < 0 , \"4,5 should be < 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MIN_VALUE ) > 0 , \"MAX,MIN should be > 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MAX_VALUE ) == 0 , \"MAX,MAX should be == 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MIN_VALUE , MyInteger . MAX_VALUE ) < 0 , \"MIN,MAX should be > 0\" ); } @Test void testCompareTo () { assertTrue ( mi1 . compareTo ( mi2 ) < 0 , \"mi1, mi2 should be < 0\" ); assertTrue ( mi2 . compareTo ( mi1 ) > 0 , \"mi2, mi1 should be > 0\" ); assertTrue ( mi2 . compareTo ( mi7 ) == 0 , \"mi2, mi7 should be == 0\" ); assertTrue ( mi3 . compareTo ( mi6 ) == 0 , \"mi3, mi6 should be == 0\" ); } }","title":"\u00dcbung 10 (JUnit)"},{"location":"uebungen/#ubung-11-ereignisbehandlung-actionlistener","text":"\u00dcbung 11 (28.6. - 30.6.) Erstellen Sie ein Fenster mit einem Textfeld und zwei Buttons add und remove . Sowohl das Textfeld als auch die beiden Buttons sollen Objektvariablen (und somit zugreifbar von allen Methoden der Klasse) sein. Unterteilen Sie das main - JPanel zun\u00e4chst in zwei JPanel s unten und oben . Dem JPanel oben werden das Textfeld und die beiden Buttons hinzugef\u00fcgt. Setzen Sie die Hintergrundfarbe des JPanels oben auf YELLOW . Setzen Sie die Hintergrundfarbe des JPanels unten auf CYAN . Das JPanel unten soll ebenfalls eine Objektvariable sein. Setzen Sie die Gr\u00f6\u00dfe des Fensters auf Werte, so dass es wie folgt erscheint: F\u00fcgen Sie folgende Objektvariable hinzu: List<JLabel> labels = new ArrayList<>(); Implementieren Sie den ActionListener wie folgt: Wird der add -Button gedr\u00fcckt, wird der Liste labels ein JLabel hinzugef\u00fcgt, wobei der Text des JLabels dem Text im Textfeld entspricht (der Text des Textfeldes kann \u00fcber die Objektmethode getText() von JTextField ausgelesen werden). Die Liste labels wird vollst\u00e4ndig ausgelesen und jedes JLabel aus labels wird dem JPanel unten mithilfe der add() -Methode von JPanel hinzugef\u00fcgt. Rufen Sie this.unten.revalidate(); auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels unten an. Wird der \u201eremove\u201c-Button gedr\u00fcckt, wird das JLabel aus der Liste labels gel\u00f6scht, das den gleichen Text hat wie der Text, der im Textfeld eingegeben wurde. Au\u00dferdem wird das JLabel aus den JPanel unten entfernt (Objektmethode remove() von JPanel ). Rufen Sie this.unten.revalidate(); auf \u2013 dies st\u00f6\u00dft ein Neuzeichnen des JPanels unten an. Tipp : wenn Sie einem JLabel eine Hintergrundfarbe mit setBackground(Color c) setzen, dann sieht man diese nur, wenn Sie f\u00fcr dieses JLabel die Methode setOpaque(true) aufrufen. Nur dadurch werden f\u00fcr dieses JLabel alle Pixel gezeichnet, die in dessen Grenzen sind, d.h. das komplette Rechteck, das das JLabel ausf\u00fcllt. Ansonsten w\u00fcrde nur der Text \"gezeichnet\" und die Hintergrundfarbe w\u00e4re hinter dem Text versteckt. vorkommentierte Klasse Uebung11.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //import public class Uebung11 // es werden JFrame und ActionListener ben\u00f6tigt { //Objektvariablen: //1. Textfeld, zwei Buttons (add und remove) //2. unteres Panel //4. Liste mit Labeln public Uebung11 () { super ( \"TITEL\" ); //Verhalten beim Schlie\u00dfen //Gr\u00f6\u00dfe //Sichtbarkeit //... //2. main-JPanel in JPanels unten und oben unterteilen //Dem Panel oben werden das Textfeld und die beiden Buttons hinzugef\u00fcgt, //das lagern wir in die Methode createOben() aus //oben: Hintergrundfarbe ist YELLOW //unten: Hintergrundfarbe ist CYAN //Das Panel unten soll ebenfalls eine Objektvariable sein. //4. neue ArrayList f\u00fcr die Label anlegen } private JPanel createOben () { //... return panel ; } @Override public void actionPerformed ( ActionEvent e ) { //Quelle des Events ermitteln //Falls es der \"add\"-Button ist // - Text aus dem Textfeld \u00fcbernehmen // - neues Label mit dem Text anlegen // - das Label formatieren (Hintergrundfarbe RED) // Tipp: wenn Sie einem JLabel eine Hintergrundfarbe mit setBackground(Color c) // setzen, dann sieht man diese nur, wenn Sie f\u00fcr dieses JLabel die Methode // setOpaque(true) aufrufen. Nur dadurch werden f\u00fcr dieses JLabel alle Pixel // gezeichnet, die in dessen Grenzen sind, d.h. das komplette Rechteck, // das das JLabel ausf\u00fcllt. Ansonsten w\u00fcrde nur der Text \"gezeichnet\" und // die Hintergrundfarbe w\u00e4re hinter dem Text versteckt. // - das Label in Label-Liste einf\u00fcgen // - das Label dem unteren Panel hinzuf\u00fcgen //Falls es der \"remove\"-Button ist // - Text aus dem Textfeld \u00fcbernehmen // - durch die Label-Liste iterieren, um das zu entfernende Label zu finden // Tipp: Iterator nehmen // Iterator<Typ> it = variable.iterator(); // while(it.hasNext()){ // mach irgendwas mit it.next() // } // das Label muss sowohl aus der Liste als auch aus dem Panel entfernt werden //Text im Textfeld l\u00f6schen //weitere n\u00f6tige Schritte requestFocus(), revalidate(), repaint() } public static void main ( String [] args ) { new Uebung11 (); } } m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 11 Uebung11.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.util.ArrayList ; import java.util.Iterator ; import java.util.List ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; import javax.swing.JTextField ; public class Uebung11 extends JFrame implements ActionListener { JPanel unten ; JTextField input ; List < JLabel > labels ; JButton addBtn ; JButton removeBtn ; public Uebung11 () { super ( \"Elemente hinzufuegen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . setSize ( 400 , 100 ); this . setLocation ( 500 , 500 ); JPanel oben = this . createOben (); this . getContentPane (). add ( oben , BorderLayout . NORTH ); this . unten = new JPanel (); this . unten . setBackground ( Color . CYAN ); this . getContentPane (). add ( unten , BorderLayout . CENTER ); this . setVisible ( true ); this . labels = new ArrayList <> (); } private JPanel createOben () { JPanel panel = new JPanel (); panel . setBackground ( Color . YELLOW ); this . input = new JTextField ( 10 ); this . addBtn = new JButton ( \"add\" ); this . addBtn . addActionListener ( this ); this . removeBtn = new JButton ( \"remove\" ); this . removeBtn . addActionListener ( this ); panel . add ( this . input ); panel . add ( this . addBtn ); panel . add ( this . removeBtn ); return panel ; } @Override public void actionPerformed ( ActionEvent e ){ Object src = e . getSource (); if ( src instanceof JButton ){ JButton srcBtn = ( JButton ) src ; if ( srcBtn == this . addBtn ) { // geht wegen Objektvariable und gleiches Objekt String inputText = this . input . getText (); JLabel newLabel = new JLabel ( inputText ); newLabel . setOpaque ( true ); newLabel . setBackground ( Color . RED ); this . labels . add ( newLabel ); this . unten . add ( newLabel ); } else if ( srcBtn == this . removeBtn ) { String inputText = this . input . getText (); Iterator < JLabel > it = this . labels . iterator (); while ( it . hasNext ()) { JLabel aktLabel = it . next (); if ( aktLabel . getText (). equals ( inputText )){ it . remove (); this . unten . remove ( aktLabel ); } } } this . input . setText ( \"\" ); this . input . requestFocus (); this . unten . revalidate (); this . unten . repaint (); } } public static void main ( String [] args ) { new Uebung11 (); } }","title":"\u00dcbung 11 (Ereignisbehandlung - ActionListener)"},{"location":"uebungen/#ubung-12-tictactoe","text":"\u00dcbung 12 (5.7. - 7.7.) Gegeben sind die folgenden Klassen: Model.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 package uebungen.uebung12.loesung ; import java.util.Random ; /* * Implementierung von TicTacToe * */ public class Model { private Player [][] field ; public enum Player { RED , BLACK , EMPTY }; private Player player ; private int size ; /* * erzeugt Objekt vom Model * Parameter size fuer field: size x size * alle Felder in field am Anfang leer (EMPTY) * player BLACK beginnt */ public Model ( int size ) { this . size = size ; this . field = new Player [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = Player . EMPTY ; } } this . player = Player . BLACK ; // BLACK faengt an } /* * field wieder alle Felder EMPTY * player ist BLACK */ public void restart () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = Player . EMPTY ; } } this . player = Player . BLACK ; } /* * Rueckgabe von size * z.B. 3 bei 3 x 3 field */ public int getSize () { return this . size ; } /* * Rueckgabe deep copy von field */ public Player [][] getField () { Player [][] copy = new Player [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { copy [ row ][ col ] = this . field [ row ][ col ] ; } } return copy ; } /* * Ausgabe von field auf Konsole */ public void printField () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == Player . EMPTY ) { System . out . print ( \"- \" ); } else if ( this . field [ row ][ col ] == Player . BLACK ) { System . out . print ( \"x \" ); } else if ( this . field [ row ][ col ] == Player . RED ) { System . out . print ( \"o \" ); } } System . out . println (); // Ende der Zeile } System . out . println (); // nach Ausgabe des Feldes } /* * Spielerinnenwechsel * von BLACK zu RED oder * von RED zu BLACK * */ public void switchPlayer () { this . player = ( this . player == Player . BLACK ) ? Player . RED : Player . BLACK ; } /* * setzt player in field, wenn moeglich * gibt true zurueck, wenn Zug moeglich war * false, wenn Zug nicht moeglich war (z.B. falsche row oder col * oder field[row][col] bereits besetzt) */ public boolean move ( int row , int col ) { boolean movePossible = this . movePossible ( row , col ); if ( movePossible ) { this . field [ row ][ col ] = this . player ; } return movePossible ; } /* * Rueckgabe aktueller player */ public Player curPlayer () { return this . player ; } /* * Hilfsmethode, um zu ermitteln, ob Zug moeglich * gibt true zurueck, wenn Zug moeglich war * false, wenn Zug nicht moeglich war (z.B. falsche row oder col * oder field[row][col] bereits besetzt) */ public boolean movePossible ( int row , int col ) { boolean movePossible = false ; // row und col jeweils koorekter Index ? if ( row >= 0 && row < this . size && col >= 0 && col < this . size ) { // ist das Feld ueberhaupt leer ? if ( this . field [ row ][ col ] == Player . EMPTY ) { movePossible = true ; } } return movePossible ; } /* * true, wenn gewonnen * false, wenn nicht */ public boolean won () { return this . won ( Player . BLACK ) || this . won ( Player . RED ); } /* * Hilfsmethode fuer won(), um zu ueberpruefen, * ob BLACK oder RED gewonnen hat */ private boolean won ( Player player ) { boolean won = false ; if ( player == Player . BLACK || player == Player . RED ) { // 3 nebeneinander ??? for ( int row = 0 ; row < this . size && ! won ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { won = true ; } } // 3 untereinander ??? for ( int col = 0 ; col < this . size && ! won ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { won = true ; } } // von links oben nach rechts unten - Diagonale if ( ! won && this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { won = true ; } // von rechts oben nach links unten - Diagonale if ( ! won && this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { won = true ; } } return won ; } /* * Ausgabe auf die Konsole * player, die gewonnen hat */ public void printWon () { if ( this . player == Player . BLACK ) { System . out . println ( \"Spielerin x hat gewonnen !!!\" ); } else { System . out . println ( \"Spielerin o hat gewonnen !!!\" ); } } /* * Hilfsmethode, um zu uberpruefen, ob alle Felder besetzt * wird fuer draw() benoetigt */ private boolean fieldFilled () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == Player . EMPTY ) { return false ; } } } return true ; } /* * true, wenn unentschieden * false, wenn nicht * unentschieden ist, wenn field voll ist (fieldFilled()), * aber niemand gewonnen hat */ public boolean draw () { return this . fieldFilled () && ! this . won (); } /* * true, wenn Spiel zu Ende * entweder unentschieden oder gewonnen */ public boolean finished () { return this . draw () || this . won (); } /* * zufaelliger Zug * wird ausgefuehrt, aber keine Pruefung, ob * gewonnen oder unentschieden * nach dem Zug switschPlayer() */ public void automaticMove () { Random r = new Random (); int row = r . nextInt ( this . size ); int col = r . nextInt ( this . size ); while ( ! this . movePossible ( row , col )) { row = r . nextInt ( this . size ); col = r . nextInt ( this . size ); } this . move ( row , col ); } /* * automatischer (zufaelliger) Zug mit * anschliessender Pruefung, ob gewonnen * oder nicht * neuer Stand von field Ausgabe auf die Konsole * bei Gewinn oder Unentschieden Ausgabe auf die Konsole */ public void automaticMoveAndCheck () { this . automaticMove (); this . printField (); if ( this . finished ()) { if ( this . won ()) { this . printWon (); } else // draw { System . out . println ( \"Unentschieden !!!\" ); } } else { this . switchPlayer (); } } /* * so lange automatisch ziehen bis Spiel zu Ende * inkl. Ausgabe auf die Konsole */ public void playGame () { while ( ! this . finished ()) { this . automaticMoveAndCheck (); } } } View.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package uebungen.uebung12 ; import java.awt.BorderLayout ; import java.awt.Font ; import java.awt.GridLayout ; import javax.swing.* ; public class View extends JFrame { JButton [] buttons ; JLabel labelStatus ; JButton btnStart ; Model model ; View ( Model model ) { super (); this . model = model ; setTitle ( \"TicTacToe\" ); setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // center panel JPanel hauptPanel = init (); this . getContentPane (). add ( hauptPanel , BorderLayout . CENTER ); // label panel JPanel labelPanel = new JPanel (); this . labelStatus = new JLabel (); this . labelStatus . setFont ( new Font ( \"Verdana\" , Font . BOLD , 24 )); this . labelStatus . setText ( \"X beginnt\" ); labelPanel . add ( this . labelStatus ); this . getContentPane (). add ( labelPanel , BorderLayout . NORTH ); // button panel this . btnStart = new JButton ( \"Start\" ); this . getContentPane (). add ( this . btnStart , BorderLayout . SOUTH ); setSize ( 400 , 400 ); setVisible ( true ); } private JPanel init () { JPanel panel = new JPanel (); panel . setLayout ( new GridLayout ( 3 , 3 , 10 , 10 )); this . buttons = new JButton [ 9 ] ; for ( int i = 0 ; i < this . buttons . length ; i ++ ) { this . buttons [ i ]= new JButton (); this . buttons [ i ] . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . buttons [ i ] . setActionCommand ( Integer . toString ( i )); panel . add ( buttons [ i ] ); } return panel ; } public void restart () { for ( int i = 0 ; i < this . buttons . length ; i ++ ) { this . buttons [ i ] . setText ( \"\" ); this . revalidate (); this . repaint (); } } } Controller.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package uebungen.uebung12 ; import java.awt.Color ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import javax.swing.JButton ; public class Controller implements ActionListener { Model model ; View view ; Controller ( Model model , View view ) { this . model = model ; this . model . restart (); this . view = view ; for ( int i = 0 ; i < this . view . buttons . length ; i ++ ) { this . view . buttons [ i ] . addActionListener ( this ); } this . view . btnStart . addActionListener ( this ); } @Override public void actionPerformed ( ActionEvent e ) { // TODO } } Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package uebungen.uebung12 ; public class Programclass { public static void main ( String [] args ) { Model model = new Model ( 3 ); model . playGame (); // einmal ein Spiel auf Konsole ausgeben View view = new View ( model ); Controller controller = new Controller ( model , view ); } } Aufgabe: Implementieren Sie die actionPerformed() -Methode in der Controller -Klasse. m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 12 actionPerformed() aus Controller.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @Override public void actionPerformed ( ActionEvent e ) { Object src = e . getSource (); if ( src instanceof JButton ) { JButton buttonPressed = ( JButton ) src ; if ( buttonPressed . getActionCommand (). equals ( \"Start\" )) { System . out . println ( \"Start-Button\" ); this . model . restart (); this . view . restart (); } else { String command = buttonPressed . getActionCommand (); int index = Integer . valueOf ( command ). intValue (); System . out . println ( \"Button \" + index + \" geklickt\" ); int row = index / this . model . getSize (); int col = index % this . model . getSize (); if ( ! this . model . finished () && this . model . movePossible ( row , col )) { if ( this . model . curPlayer () == Model . Player . BLACK ) { buttonPressed . setForeground ( Color . BLACK ); buttonPressed . setText ( \"X\" ); this . view . labelStatus . setForeground ( Color . RED ); this . view . labelStatus . setText ( \"O ist dran\" ); } else if ( this . model . curPlayer () == Model . Player . RED ) { buttonPressed . setForeground ( Color . RED ); buttonPressed . setText ( \"O\" ); this . view . labelStatus . setForeground ( Color . BLACK ); this . view . labelStatus . setText ( \"X ist dran\" ); } this . model . move ( row , col ); if ( this . model . won ()) { if ( this . model . curPlayer () == Model . Player . BLACK ) { this . view . labelStatus . setForeground ( Color . BLACK ); this . view . labelStatus . setText ( \"X hat gewonnen!\" ); } else { this . view . labelStatus . setForeground ( Color . RED ); this . view . labelStatus . setText ( \"O hat gewonnen!\" ); } } else if ( this . model . draw ()) { this . view . labelStatus . setForeground ( Color . GRAY ); this . view . labelStatus . setText ( \"Unentschieden!\" ); } if ( ! this . model . won ()) this . model . switchPlayer (); } } } }","title":"\u00dcbung 12 (TicTacToe)"},{"location":"uebungen/#klausurvorbereitung-klicks-zahlen","text":"Klausurvorbereitung (Klicks z\u00e4hlen) Erstellen Sie eine solche GUI: Es handelt sich im Prinzip um ein Gitter aus JPanel s (siehe auch Tipps unten). Beachten Sie: Dem Konstruktor f\u00fcr das Fenster wird eine hoehe (int) und eine breite (int) \u00fcbergeben. Aus der hoehe und der breite ergibt sich die Anzahl der JPanels. In der Abbildung ist also hoehe=4 und breite=3 . Jedes JPanel soll ein JLabel enthalten, das der Anzahl der (Maus-)Klicks auf dieses JPanel entspricht. Am Anfang sind die Anzahl der Klicks f\u00fcr alle JPanels 0. Implementieren Sie den MouseListener so, dass bei Klick auf ein JPanel automatisch die Anzahl der Klicks um 1 erh\u00f6ht und die neue Anzahl im JLabel dargestellt wird. Au\u00dferdem soll das (oder die) JPanel(s) mit den meisten Klicks rot dargestellt werden. Die Abbildung zeigt das Fenster nach einigen Mausklicks auf die einzelnen Panels. Es gibt drei Panels mit den meisten Klicks. Nach einem weiteren Klick gibt es nur noch ein Panel mit dem meisten Klicks. Wird auf den reset -Button geklickt, ist alles wieder auf 0 (und grau) gestellt. Tipps: F\u00fcr die \"JPanels\" eigenen sich tats\u00e4chlich JPanels , da diese ja eine Hintergrundfarbe haben, einen Rand ( Border ) haben k\u00f6nnen, ein JLabel aufnehmen k\u00f6nnen usw. Es w\u00e4re ja aber auch sinnvoll, dass jedes JPanel z.B. auch eine Eigenschaft anzahlKlicks o.\u00e4. hat. Insofern w\u00e4re der Vorschlag, eine eigene Klasse MyPanel zu erstellen, die von JPanel erbt, somit alle Eigenschaften eines JPanel hat und aber auch noch zus\u00e4tzliche Eigenschaften haben kann. Als Datenstruktur f\u00fcr das Model bietet sich sicherlich ein zweidimensionales Array an. Wenn Sie jedes MyPanel an den MouseListener anmelden, dann m\u00fcssen Sie gar nicht die Koordinaten des Mausklicks betrachten, sondern nur abfragen, welches der MyPanel das Mausereignis ausgel\u00f6st hat (oder Sie verwenden sogar f\u00fcr jedes dieser MyPanel eine anonyme Klasse des MouseListener ). Probieren Sie mal ein wenig herum, es gibt sehr viele verschiedene L\u00f6sungsm\u00f6glichkeiten hier. m\u00f6gliche L\u00f6sung f\u00fcr Klicks Z\u00e4hlen KlicksZaehlen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.GridLayout ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import javax.swing.* ; public class KlicksZaehlen extends JFrame { MyPanel [][] panels ; int meistenClicks ; KlicksZaehlen ( int hoehe , int breite ) { super ( \"Klicks zaehlen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( createMainPanel ( hoehe , breite ), BorderLayout . CENTER ); this . setSize ( 400 , 400 ); this . setVisible ( true ); this . meistenClicks = 0 ; } JPanel createMainPanel ( int hoehe , int breite ) { JPanel mainPanel = new JPanel (); mainPanel . setLayout ( new GridLayout ( hoehe , breite , 2 , 2 )); mainPanel . setBackground ( Color . DARK_GRAY ); this . panels = new MyPanel [ hoehe ][ breite ] ; for ( int zeile = 0 ; zeile < this . panels . length ; zeile ++ ) { for ( int spalte = 0 ; spalte < this . panels [ zeile ] . length ; spalte ++ ) { this . panels [ zeile ][ spalte ] = new MyPanel ( zeile , spalte ); mainPanel . add ( this . panels [ zeile ][ spalte ] ); } } return mainPanel ; } class MyPanel extends JPanel implements MouseListener { int zeile ; int spalte ; int nrClicks ; JLabel label ; MyPanel ( int zeile , int spalte ) { this . zeile = zeile ; this . spalte = spalte ; this . nrClicks = 0 ; this . label = new JLabel ( \"0\" ); this . setLayout ( new GridLayout ()); this . label . setFont ( new Font ( \"Verdana\" , Font . BOLD , 48 )); this . label . setHorizontalAlignment ( JLabel . CENTER ); this . label . setForeground ( Color . WHITE ); this . add ( label ); this . setBackground ( Color . LIGHT_GRAY ); this . addMouseListener ( this ); } @Override public void mouseClicked ( MouseEvent e ) { MyPanel mp = ( MyPanel ) e . getSource (); mp . nrClicks ++ ; mp . label . setText ( String . valueOf ( nrClicks )); if ( mp . nrClicks > KlicksZaehlen . this . meistenClicks ) KlicksZaehlen . this . meistenClicks = mp . nrClicks ; for ( int zeile = 0 ; zeile < KlicksZaehlen . this . panels . length ; zeile ++ ) { for ( int spalte = 0 ; spalte < KlicksZaehlen . this . panels [ zeile ] . length ; spalte ++ ) { if ( KlicksZaehlen . this . panels [ zeile ][ spalte ] . nrClicks == KlicksZaehlen . this . meistenClicks ) { KlicksZaehlen . this . panels [ zeile ][ spalte ] . setBackground ( Color . RED ); } else { KlicksZaehlen . this . panels [ zeile ][ spalte ] . setBackground ( Color . LIGHT_GRAY ); } } } } @Override public void mousePressed ( MouseEvent e ) {} @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} } public static void main ( String [] args ) { new KlicksZaehlen ( 4 , 3 ); } }","title":"Klausurvorbereitung (Klicks z\u00e4hlen)"},{"location":"uebungen/#klausurvorbereitung-schiebepuzzle","text":"Die folgenden \u00dcbungen besch\u00e4ftigen sich alle mit Zeichnen, d.h. Graphics. Da wir das dieses Semester nicht hatten, m\u00fcssen Sie sich die folgenden \u00dcbungen nicht anschauen! K\u00f6nnen Sie aber ;-)","title":"Klausurvorbereitung (Schiebepuzzle)"},{"location":"uebungen/#klausurvorbereitung-zeichnen","text":"Klausurvorbereitung (Zeichnen) Zeichnen Sie ein Quadrat. Passen Sie dieses Quadrat m\u00f6glichst passend in das Fenster. Da es sich um ein Quadrat handelt, kann es sich nur der H\u00f6he oder der Breite des Fensters anpassen, je nachdem, was kleiner ist. Wenn die H\u00f6he kleiner ist, als die Breite, dann soll das Quadrat ausgef\u00fcllt sein. Wenn die Breite kleiner als die H\u00f6he ist, dann soll das Quadrat nicht ausgef\u00fcllt sein, aber die Linienst\u00e4rke auf 5.0f gesetzt werden. Die Zeichenfarbe soll zuf\u00e4llig erzeugt werden - jedes Mal, wenn die paintComponent() -Methode aufgerufen wird. Beobachten Sie anhand des Farbwechsels, wie oft die paintComponent() -Methode aufgerufen wird. eine m\u00f6gliche L\u00f6sung Zeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package uebungen.zeichnen ; import java.awt.BasicStroke ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.util.Random ; import javax.swing.* ; public class Uebung10 extends JFrame { public Uebung10 () { super (); this . setTitle ( \"\u00dcbung10\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . getContentPane (). add ( new Canvas ()); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; //g2.drawRect(20, 130, 200, 100); int abstand = this . getHeight () / 20 ; int hoehe = this . getHeight () - 2 * abstand ; int breite = this . getWidth () - 2 * abstand ; //Random Farben erzeugen: Random r = new Random (); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Color c = new Color ( rot , gruen , blau ); g2 . setColor ( c ); //rot-Gr\u00fcn-Blau 0 bis 255 // Quadrat zeichnen if ( hoehe < breite ) { int abstandLinks = ( this . getWidth () - hoehe ) / 2 ; g2 . fillRect ( abstandLinks , abstand , hoehe , hoehe ); } else { int abstandOben = ( this . getHeight () - breite ) / 2 ; g2 . setStroke ( new BasicStroke ( 5.0f )); //dicke Linien g2 . drawRect ( abstand , abstandOben , breite , breite ); } } } public static void main ( String [] args ) { new Zeichnen (); } } sehr hilfreiche Erl\u00e4uterungen zur \u00dcbung von Frau Busjahn Wenn man keine Abst\u00e4nde definiert und die gesamte H\u00f6he als Seitenl\u00e4nge nimmt: g2 . fillRect ( 0 , 0 , this . getHeight (), this . getHeight ()); Beispiel f\u00fcr H\u00f6he < Breite Um oben und unten gleich gro\u00dfe Abst\u00e4nde einzufu\u0308gen: int abstandOben = this . getHeight () / 20 ; int abstandUnten = this . getHeight () / 20 ; int seitenLaenge = this . getHeight () - abstandOben - abstandUnten ; g2 . fillRect ( 0 , abstandOben , seitenLaenge , seitenLaenge ); ``` Da abstandOben und abstandUnten gleich sein sollen, l\u00e4sst sich das verku\u0308rzen zu: int abstandObenUnten = this . getHeight () / 20 ; int seitenLaenge = this . getHeight () - ( 2 * abstandObenUnten ); g2 . fillRect ( 0 , abstandObenUnten , seitenLaenge , seitenLaenge ); Um das Quadrat auch horizontal mittig auszurichten, braucht man noch den Abstand links int rest = this . getWidth () - seitenLaenge ; int links = rest / 2 ; oder zusammengefasst: int links = ( this . getWidth () - seitenLaenge ) / 2 ; g2 . fillRect ( links , abstandObenUnten , seitenLaenge , seitenLaenge );","title":"Klausurvorbereitung (Zeichnen)"},{"location":"uebungen/#klausurvorbereitung-mausereignisse","text":"Klausurvorbereitung (Mausereignisse) Zeichnen Sie mithilfe der Maus farbige Rechtecke. Das Zeichnen soll folgenderma\u00dfen funktionieren: dort, wo sie mit der Maus in die Zeichenfl\u00e4che klicken, ist ein Eckpunkt des Rechtecks mit gedr\u00fcckter Maustaste ziehen Sie das Rechteck gro\u00df (w\u00e4hrenddessen soll das Rechteck dargestellt werden) durch Loslassen der Maustaste legen Sie die endg\u00fcltige Gr\u00f6\u00dfe des Rechtecks fest und speichern das Rechteck durch wiederholtes Zeichnen werden mehrere Rechtecke gezeichnet. Die zuvor gezeichneten Rechtecke bleiben dargestellt jedes Rechteck hat eine zuf\u00e4llig erzeugte Farbe beachten Sie, dass das Zeichnen eines Rechtecks nicht nur von links oben nach rechts unten, sondern in alle Richtungen m\u00f6glich sein soll Tipps: studieren Sie dieses Beispiel behandeln Sie die Mausereignisse in den Methoden mousePressed() , mouseReleased() ( MouseListener ) sowie aus dem MouseMotionListener mouseDragged() erstellen Sie sich zun\u00e4chst eine Klasse, die Rechtecke repr\u00e4sentiert (Objektvariablen x , y , width , height , jweils int ) speichern Sie die Rechtecke zusammen mit ihrer Farbe in einer Map (untersuchen Sie den Unterschied zwischen HashMap und LinkedHashMap ) zeichnen Sie in paintComponent() alle Rechtecke aus der Map und das aktuelle Rechteck (das Sie gerade zeichnen) vorkommentierte Klassen RechteckeZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.HashMap ; import java.util.Map ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class RechteckeZeichnen extends ... implements ... { // Objektvariablen public RechteckeZeichnen () { super (); this . setTitle (...); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); //Collection f\u00fcr die Rechtecke anlegen //Leinwand anlegen und die Listener f\u00fcr Mausereignisse hinzuf\u00fcgen this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; //aktuelles Rechteck zeichnen (falls es aktuell eins gibt) //gespecherte Rechtecke aus der Collection zeichnen } } public static void main ( String [] args ) { new RechteckeZeichnen (); } @Override public void mousePressed ( MouseEvent e ) { //neues Rechteck erzeugen //zuf\u00e4llige Farbe erzeugen - hatten wir letzte Woche } @Override public void mouseDragged ( MouseEvent e ) { //H\u00f6he und Breite des aktuellen Rechtecks setzen //je nachdem ob die Maus gerade nach rechts, links, oben oder unten gezogen wird //Leinwand neu zeichnen } @Override public void mouseReleased ( MouseEvent e ) { //aktuelles Rechteck speichern } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 public class Rechteck { //private Objektvariablen f\u00fcr x, y, H\u00f6he und Breite public Rechteck ( int x , int y , int width , int height ) { //Koordinaten und Gr\u00f6\u00dfe des Rechtecks } // Getter und Setter f\u00fcr x, y, H\u00f6he und Breite } eine m\u00f6gliche L\u00f6sung f\u00fcr Rechtecke Zeichnen RechteckeZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 package uebungen.uebung11 ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.HashMap ; import java.util.Map ; import java.util.Random ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class RechteckeZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Rechteck aktRechteck ; Color aktColor ; Map < Rechteck , Color > rechtecke ; public RechteckeZeichnen () { super (); this . setTitle ( \"Rechtecke zeichnen\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . rechtecke = new HashMap <> (); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } private class Canvas extends JPanel { // die View @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); Graphics2D g2 = ( Graphics2D ) g ; if ( RechteckeZeichnen . this . aktRechteck != null ) { g2 . setColor ( aktColor ); int x = RechteckeZeichnen . this . aktRechteck . getX (); int y = RechteckeZeichnen . this . aktRechteck . getY (); int width = RechteckeZeichnen . this . aktRechteck . getWidth (); int height = RechteckeZeichnen . this . aktRechteck . getHeight (); g2 . fillRect ( x , y , width , height ); } for ( Map . Entry < Rechteck , Color > eintrag : RechteckeZeichnen . this . rechtecke . entrySet ()) { Rechteck r = eintrag . getKey (); Color c = eintrag . getValue (); g2 . setColor ( c ); int x = r . getX (); int y = r . getY (); int width = r . getWidth (); int height = r . getHeight (); g2 . fillRect ( x , y , width , height ); } } } public static void main ( String [] args ) { new RechteckeZeichnen (); } // der Controller @Override public void mousePressed ( MouseEvent e ) { Point p = e . getPoint (); this . aktRechteck = new Rechteck ( p . x , p . y , 0 , 0 ); Random zuf = new Random (); int r = zuf . nextInt ( 256 ); int g = zuf . nextInt ( 256 ); int b = zuf . nextInt ( 256 ); this . aktColor = new Color ( r , g , b ); } @Override public void mouseDragged ( MouseEvent e ) { Point p = e . getPoint (); if ( p . x > this . aktRechteck . getX ()) // Maus nach rechts { int width = p . x - this . aktRechteck . getX (); this . aktRechteck . setWidth ( width ); } else // Maus nach links { int width = ( this . aktRechteck . getX () - p . x ) + this . aktRechteck . getWidth (); this . aktRechteck . setWidth ( width ); this . aktRechteck . setX ( p . x ); } if ( p . y > this . aktRechteck . getY ()) // Maus nach unten { int height = p . y - this . aktRechteck . getY (); this . aktRechteck . setHeight ( height ); } else // Maus nach oben { int height = ( this . aktRechteck . getY () - p . y ) + this . aktRechteck . getHeight (); this . aktRechteck . setHeight ( height ); this . aktRechteck . setY ( p . y ); } this . canvas . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { Point p = e . getPoint (); this . rechtecke . put ( this . aktRechteck , this . aktColor ); } @Override public void mouseClicked ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseMoved ( MouseEvent e ) {} } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package uebungen.uebung11 ; public class Rechteck { private int x ; private int y ; private int width ; private int height ; public Rechteck ( int x , int y , int width , int height ) { this . x = x ; this . y = y ; this . width = width ; this . height = height ; } public int getX () { return x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return y ; } public void setY ( int y ) { this . y = y ; } public int getWidth () { return width ; } public void setWidth ( int width ) { this . width = width ; } public int getHeight () { return height ; } public void setHeight ( int height ) { this . height = height ; } } sehr hilfreiche Erl\u00e4uterungen zur \u00dcbung von Frau Busjahn","title":"Klausurvorbereitung (Mausereignisse)"},{"location":"uebungen/#klausurvorbereitung-graphen","text":"Klausurvorbereitung (Graphen) Erstellen Sie ein Fenster zum Zeichnen. Implementieren Sie den Mauslistener so, dass f\u00fcr jeden Mausklick an der Stelle des Mausklicks ein schwarzer ausgef\u00fcllter Kreis mit dem DURCHMESSER = 30 angezeigt wird: F\u00fcr das Model gen\u00fcgt es, sich die Punkte in einer Collection zu merken (am einfachsten ist wohl eine ArrayList ). F\u00fcr den Controller h\u00e4tten wir hier die Wahl zwischen mouseClicked() und mousePressed() . Wegen der sp\u00e4teren Erweiterung (Bewegen der Punkte), sollten wir hier mouseClicked() w\u00e4hlen. Passen Sie die View nun so an, dass die Punkte durch Linien der Strichst\u00e4rke 2.0f miteinander verbunden werden. Sie k\u00f6nnen auch gleich (oder sp\u00e4ter) den ersten und letzten Punkt mit einer Linie verbinden (so wie in der Abbildung). Implementieren sie den MouseMotionListener so, dass wenn Sie mit der Maus auf einen Punkt (Kreis) klicken (oder knapp daneben) und bei gedr\u00fcckter Maustaste die Maus bewegen, sich auch der Punkt mitbewegt. Zur Erinnerung: die Methode mouseClicked() wird aufgerufen, nachdem mousePressed() und mouseReleased() aufgerufen wurden. \u00c4ndert sich die Mausposition zwischen den Aufrufen von mousePressed() und mouseReleased() , wird mouseClicked() gar nicht aufgerufen. Es empfiehlt sich also, in mousePressed() zu bestimmen, ob durch den Mausklick ein Kreis getroffen wurde. Das muss nat\u00fcrlich kein genauer \"Treffer\" sein, bauen Sie ruhig eine Toleranz von z.B. 20 ein. Den Punkt, den Sie \"getroffen\" haben, sollten Sie sich merken, denn seine Koordinaten werden ja durch die Mausbewegung ver\u00e4ndert. Wenn Sie in mousePressed() einen Punkt \"getroffen\" haben, dann sollten Sie das Verschieben des Punktes in mouseDragged() behandeln. Beachten Sie, dass mouseDragged() (bei gedr\u00fcckter Maustaste) permanent aufgerufen wird. Wir k\u00f6nnen Sie die \u00c4nderung der Mausposition zwischen zwei Aufrufen von mouseDragged() ermitteln? eine m\u00f6gliche L\u00f6sung f\u00fcr Klausurvorbereitung (Graphen) GraphenZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package uebungen.uebung13 ; import java.awt.BorderLayout ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.ArrayList ; import java.util.List ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class GraphenZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; List < Point > points ; //f\u00fcr uns = Java.util! Point movepoint ; Point remember ; public GraphenZeichnen () { super (); this . setTitle ( \"Uebung13\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); this . canvas . addMouseListener ( this ); //MOUSELISTENER ANMELDEN NICHT VERGESSEN!!!! this . canvas . addMouseMotionListener ( this ); //MOUSEMOTIONLISTENER ANMELDEN NICHT VERGESSEN!!!! this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); this . points = new ArrayList <> (); } private class Canvas extends JPanel { final static int DURCHM = 30 ; final static int RADIUS = DURCHM / 2 ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar // hier zeichnen wir die Punkte: for ( Point p : Uebung13 . this . points ) // anstatt \"points\" = Uebung13.this.points { int x = p . x ; int y = p . y ; g2 . fillOval ( x , y , DURCHM , DURCHM ); } for ( int i = 0 ; i < Uebung13 . this . points . size () - 1 ; i ++ ) //.size wegen Liste { Point p1 = Uebung13 . this . points . get ( i ); Point p2 = Uebung13 . this . points . get ( i + 1 ); // \"i+1\" => Nachbarpunkt von p1 g2 . drawLine ( p1 . x + RADIUS , p1 . y + RADIUS , p2 . x + RADIUS , p2 . y + RADIUS ); // \"+ Radius\" -> damit die Linien ab der Mitte des Punktes beginnen if ( i == Uebung13 . this . points . size () - 2 ) // vorletzte Position=> HIER verbinden wir den ersten und letzten Punkt { Point p = Uebung13 . this . points . get ( 0 ); g2 . drawLine ( p2 . x + RADIUS , p2 . y + RADIUS , p . x + RADIUS , p . y + RADIUS ); } } } } public static void main ( String [] args ) { new GraphenZeichnen (); } @Override public void mouseClicked ( MouseEvent e ) //wir klicken -> Kreis wird gezeichnet -> Liste wird bef\u00fcllt { Point p = e . getPoint (); // speichern den Punkt beim Ort des Klickens this . points . add ( p ); // in der Liste speichern this . canvas . repaint (); // canvas wird nochmal gezeichnet-- wichtig!! } @Override public void mousePressed ( MouseEvent e ) //ermitteln, ob wir punkt getroffen haben { int x = e . getX (); int y = e . getY (); final int ABSTAND = 20 ; //Abstand festlegen for ( Point p : this . points ) { if ( Math . abs ( x - p . x ) < ABSTAND && Math . abs ( y - p . y ) < ABSTAND ) // Abstand von Punkt ermitteln // MINUS den Punkt, den wir betrachten { this . movepoint = p ; this . remember = e . getPoint (); // Speichern die Koordinate des Mausklicks } } } @Override public void mouseReleased ( MouseEvent e ) {} @Override public void mouseEntered ( MouseEvent e ) {} @Override public void mouseExited ( MouseEvent e ) {} @Override public void mouseDragged ( MouseEvent e ) //Kreise bewegen: { int x = e . getX (); int y = e . getY (); int x1 = this . remember . x ; int y1 = this . remember . y ; int xDif = x - x1 ; //Wohin und um wie viel haben wir uns bewegt? int yDif = y - y1 ; this . movepoint . x = this . movepoint . x + xDif ; // wir verschieben den Punkt um die Differenz, this . movepoint . y = this . movepoint . y + yDif ; // die wir ermittelt haben this . canvas . repaint (); //WICHTIG this . remember = e . getPoint (); // rememberPunkt wird gespeichert } } sehr hilfreiche Erl\u00e4uterungen zu this von Frau Busjahn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //Achtung, dieser Code dient nur dazu, zu zeigen, wie man an //verschiedenen Stellen auf die Methoden und Variablen zugreifen //kann und ist nicht unbedingt der beste Stil public class A { int variableInA ; B bInA ; A ( int wertA ) { this . variableInA = wertA ; this . bInA = new B ( wertA + 10 ); this . printA ( \"Konstruktor A\" ); this . bInA . printB ( \"Konstruktor A\" ); } void printA ( String aufrufIn ) { System . out . println ( \"printA - \" + aufrufIn + \" - Variable der Klasse A: \" + this . variableInA ); System . out . println ( \"printA - \" + aufrufIn + \" - Variable der Klasse B: \" + this . bInA . variableInB ); } class B { int variableInB ; B ( int wertB ) { this . variableInB = wertB ; this . printB ( \"Konstruktor B\" ); } void printB ( String aufrufIn ) { System . out . println ( \"printB - \" + aufrufIn + \" - Variable der Klasse A: \" + A . this . variableInA ); System . out . println ( \"printB - \" + aufrufIn + \" - Variable der Klasse B: \" + this . variableInB ); } } public static void main ( String [] args ) { A a1 = new A ( 2 ); a1 . variableInA = 6 ; a1 . printA ( \"main\" ); a1 . bInA . variableInB = 16 ; a1 . bInA . printB ( \"main\" ); } }","title":"Klausurvorbereitung (Graphen)"},{"location":"uebungen/#klausurvorbereitung-quadrat","text":"Klausurvorbereitung (Quadrat) Erstellen Sie ein Fenster zum Zeichnen. Passen Sie zun\u00e4chst ein Quadrat mit Strichst\u00e4rke 3.0f in das Fenster ein und zwar so, dass es \u2153 von entweder der Breite der canvas oder der H\u00f6he der canvas gro\u00df ist, je nachdem, was kleiner ist. Es muss aber nicht mittig sein: In der folgenden Abbildung ist die H\u00f6he kleiner als die Breite. Also ist die H\u00f6he korrekt gedrittelt, aber die gleiche L\u00e4nge wurde f\u00fcr x verwendet, also f\u00fcr den Abstand vom linken Rand zum Quadrat. Deshalb ist der Abstand vom Quadrat zum rechten Rand gr\u00f6\u00dfer. Sie k\u00f6nnen aber das Quadrat auch gerne komplett in die Mitte setzen. Wenn der create square -Button gedr\u00fcckt wird, erscheint ein farbiges Quadrat, das genau so gro\u00df ist, wie das zuvor gezeichnete nichtausgef\u00fcllte schwarze Quadrat. Die Position des Quadrates wird zuf\u00e4llig bestimmt. Es passt aber auf jeden Fall vollst\u00e4ndig in die Canvas! Auch die Farbe des Quadrates wird zuf\u00e4llig bestimmt. Es beh\u00e4lt die ganze Zeit \u00fcber seine Farbe. Das farbige Quadrat kann nun durch Bewegen der Maus bei gedr\u00fcckter Maustaste bewegt werden. Wenn das Quadrat (fast) vollst\u00e4ndig in dem schwarzen Quadrat ist, dann bleibt es genau dort und kann nicht weiter bewegt werden. eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat) QuadratZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import java.util.Random ; import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JPanel ; public class QuadratZeichnen extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; Point posSquare ; Color colorSquare ; boolean move = false ; Point remember ; boolean fixiert = false ; public QuadratZeichnen () { super (); this . setTitle ( \"Quadrat\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int width = this . getWidth (); int height = this . getHeight (); // int smaller = (width < height) ? width : height; int smaller = 0 ; int length = 0 ; int x = 0 ; int y = 0 ; if ( width < height ) { smaller = width ; length = smaller / 3 ; x = smaller / 3 ; y = ( height - length ) / 2 ; } else { smaller = height ; length = smaller / 3 ; y = smaller / 3 ; x = ( width - length ) / 2 ; } g2 . setStroke ( new BasicStroke ( 3.0f )); g2 . drawRect ( x , y , length , length ); if ( Uebung14 . this . posSquare != null && Uebung14 . this . colorSquare != null ) { int xSquare = Uebung14 . this . posSquare . x ; int ySquare = Uebung14 . this . posSquare . y ; Color cSquare = Uebung14 . this . colorSquare ; g2 . setColor ( cSquare ); g2 . fillRect ( xSquare , ySquare , length , length ); } } } // ende innere Klasse private JPanel initSouth () { JPanel south = new JPanel (); JButton btnCreate = new JButton ( \"create square\" ); btnCreate . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Random r = new Random (); int widthCanvas = Uebung14 . this . canvas . getWidth (); int heightCanvas = Uebung14 . this . canvas . getHeight (); int lengthSquare = ( widthCanvas < heightCanvas ) ? widthCanvas / 3 : heightCanvas / 3 ; int x = r . nextInt ( widthCanvas - lengthSquare ); int y = r . nextInt ( heightCanvas - lengthSquare ); Uebung14 . this . posSquare = new Point ( x , y ); int rot = r . nextInt ( 256 ); int gruen = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); Uebung14 . this . colorSquare = new Color ( rot , gruen , blau ); Uebung14 . this . canvas . repaint (); } }); south . add ( btnCreate ); return south ; } public static void main ( String [] args ) { new QuadratZeichnen (); } @Override public void mouseDragged ( MouseEvent e ) { if ( move ) { int xMouse = e . getX (); int yMouse = e . getY (); int xLast = this . remember . x ; int yLast = this . remember . y ; int xDiff = xMouse - xLast ; int yDiff = yMouse - yLast ; this . posSquare . x = this . posSquare . x + xDiff ; this . posSquare . y = this . posSquare . y + yDiff ; // ab hier: im schwarzen Quadrat? int widthCanvas = this . canvas . getWidth (); int heightCanvas = this . canvas . getHeight (); int xBlack , yBlack ; if ( widthCanvas < heightCanvas ) { int lengthSquare = widthCanvas / 3 ; xBlack = widthCanvas / 3 ; yBlack = ( heightCanvas - lengthSquare ) / 2 ; } else { int lengthSquare = heightCanvas / 3 ; yBlack = heightCanvas / 3 ; xBlack = ( widthCanvas - lengthSquare ) / 2 ; } int xSquare = this . posSquare . x ; int ySquare = this . posSquare . y ; final int ABSTAND = 20 ; if ( Math . abs ( xSquare - xBlack ) < ABSTAND && Math . abs ( ySquare - yBlack ) < ABSTAND ) { // farbiges Quadrat genau im schwarzen System . out . println ( \"im schwarzen\" ); this . move = false ; this . posSquare . x = xBlack ; this . posSquare . y = yBlack ; } this . canvas . repaint (); this . remember = e . getPoint (); } } @Override public void mouseMoved ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { int xMouse = e . getX (); int yMouse = e . getY (); if ( ! this . fixiert && this . posSquare != null ) { int xSquare = this . posSquare . x ; int ySquare = this . posSquare . y ; int widthCanvas = this . canvas . getWidth (); int heightCanvas = this . canvas . getHeight (); int lengthSquare = ( widthCanvas < heightCanvas ) ? widthCanvas / 3 : heightCanvas / 3 ; if ( xMouse >= xSquare && xMouse <= ( xSquare + lengthSquare ) && yMouse >= ySquare && yMouse <= ( ySquare + lengthSquare )) { this . move = true ; this . remember = e . getPoint (); System . out . println ( \"im Quadrat\" ); } } } @Override public void mouseReleased ( MouseEvent e ) { this . move = false ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }","title":"Klausurvorbereitung (Quadrat)"},{"location":"uebungen/#klausurvorbereitung-quadrat-und-kreis","text":"Klausurvorbereitung (Quadrat und Kreis) Erstellen Sie folgendes Fenster zum Zeichnen: Dabei sind folgende Dinge zu beachten: Oben im Fenster ist ein JPanel dessen Hintergrundfarbe LIGHT_GRAY ist und das ein JLabel enth\u00e4lt. Die Beschriftung des JLabels sollten Sie in der paintComponent() -Methode vornehmen, denn das JLabel zeigt an, ob die Zeichenfl\u00e4che (Canvas) breiter als hoch ist ( breiter ) oder umgedreht ( hoeher ) und die Breite der Canvas sowie die H\u00f6he ( breite, hoehe ). Es gibt also diese beiden M\u00f6glichkeiten: Achten Sie auch darauf, dass der Text des JLabels angepasst wird, wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern (ergibt sich aber automatisch, wenn Sie den Text des JLabels in der paintComponent() -Methode setzen). In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas). Es wird eine Linie dargestellt. Diese Linie ist in Strichst\u00e4rke 2.0f . Wenn die Canvas breiter als hoch ist, dann verl\u00e4uft die Linie in der Mitte der Breite vertikal. Wenn die Canvas h\u00f6her als breit ist, dann verl\u00e4uft die Linie in der Mitte der H\u00f6he horizontal. Der Fall H\u00f6he==Breite muss nicht extra behandelt werden. Es gibt also diese beiden M\u00f6glichkeiten: Unten im Fenster ist ein JPanel , dessen Hintergrundfarbe LIGHT_GRAY ist und das ein JButton mit dem Text new enth\u00e4lt. Implementieren Sie eine Klasse Figure mit drei privaten Objektvariablen int x int y int length Schreiben Sie einen parametrisierten Konstruktor Figure(int x, int y, int length) , der die Objektvariablen mit den Parameterwerten initialisiert. Schreiben Sie f\u00fcr alle drei Objektvariablen jeweils Getter und Setter . Implementieren Sie f\u00fcr den Button den ActionListener so, dass durch den Klick auf den Button in die eine H\u00e4lfte der Canvas ein gelbes Quadrat (Farbe ist YELLOW ) und in die andere H\u00e4lfte der Canvas ein gr\u00fcner Kreis (Farbe ist GREEN ) gezeichnet wird. Beide Objekte sind vom Typ Figure . length des Quadrates entspricht der Seitenl\u00e4nge, length des Kreises entspricht dem Durchmesser. x und y sind jeweils die Koordinaten der linken oberen \u201eEcke\u201c. Beachten Sie, dass length bei Kreis und Quadrat gleich sind und dass sich die L\u00e4nge m\u00f6glichst gut (ca. 90%) in die H\u00e4lfte der Canvas einpasst, d.h. Sie m\u00fcssen schauen, dass das Quadrat und der Kreis stets vollst\u00e4ndig in ihre H\u00e4lfte passen, aber bestm\u00f6glich. Au\u00dferdem sollen die beiden Figuren m\u00f6glichst mittig in ihrer jeweiligen H\u00e4lfte angeordnet sein. Wenn Sie die Gr\u00f6\u00dfe des Fensters \u00e4ndern, dann m\u00fcssen sich Quadrat und Kreis nicht mit\u00e4ndern! Wenn Sie dann aber wieder auf den new -Button klicken, dann werden die beiden Figuren wieder an die neuen Canvas-Dimensionen angepasst. Implementieren Sie MouseListener und MouseMotionListener so, dass Sie entweder den Kreis oder das Quadrat bei gedr\u00fcckter Maustaste bewegen k\u00f6nnen, je nachdem, ob Sie auf das Quadrat oder auf den Kreis mit der Maus geklickt haben. Wenn Sie weder das Quadrat noch den Kreis durch den Mausklick getroffen haben, dann soll sich auch nichts bewegen. Bei Kreis betrachten Sie das Tangentenquadrat um den Kreis, um zu pr\u00fcfen, ob Sie den Kreis getroffen haben (also genauso, wie beim Quadrat). Sie k\u00f6nnen Kreis und Quadrat jeweils auch mehrmals hintereinander bewegen und/oder abwechselnd. Sie k\u00f6nnen nur nie beide Figuren zugleich bewegen (selbst wenn sie \u00fcbereinander sind). In der folgenden Abbildung wurde sowohl der Kreis als auch das Quadrat bereits (evtl. mehrfach) bewegt: Wenn Sie den Kreis fast vollst\u00e4ndig \u00fcber das Quadrat bewegt haben oder das Quadrat fast vollst\u00e4ndig \u00fcber den Kreis, dann wird das erkannt und der Kreis wird exakt in das Quadrat fixiert. Das bedeutet, es entsteht z.B. folgendes Bild: Fast vollst\u00e4ndig bedeutet, dass sich die x - und y -Koordinaten der beiden Figuren um jeweils h\u00f6chsten 30 Punkte unterscheiden. Sind die Figuren innerhalb dieses Abstandes, dann werden Sie automatisch exakt \u00fcbereinandergelegt. Sind die beiden Figuren exakt \u00fcbereinander, kann keine der beiden Figuren mehr bewegt werden. Es kann nur noch der Button new geklickt werden, um die Ausgangssituation wieder herzustellen. Im Label oben erscheint fixiert . Der Text ist fettgedruckt (bold). eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Quadrat und Kreis) Figure.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Figure { private int x ; private int y ; private int length ; public Figure ( int x , int y , int length ) { this . x = x ; this . y = y ; this . length = length ; } public int getX () { return this . x ; } public void setX ( int x ) { this . x = x ; } public int getY () { return this . y ; } public void setY ( int y ) { this . y = y ; } public int getLength () { return this . length ; } public void setLength ( int length ) { this . length = length ; } } QuadratUndKreis.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 import java.awt.BasicStroke ; import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Font ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.* ; public class QuadratUndKreis extends JFrame implements MouseListener , MouseMotionListener { Canvas canvas ; JLabel lOben ; Figure circle ; Figure square ; boolean circleMoved = false ; boolean squareMoved = false ; Point rememberLastPoint ; boolean fixed = false ; public QuadratUndKreis () { super (); this . setTitle ( \"Klausur\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this ); this . canvas . addMouseMotionListener ( this ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . setSize ( 400 , 300 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel { @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar int width = this . getWidth (); int height = this . getHeight (); g2 . setStroke ( new BasicStroke ( 2.0f )); if ( width < height ) { int mitteY = height / 2 ; g2 . drawLine ( 0 , mitteY , width , mitteY ); } else { int mitteX = width / 2 ; g2 . drawLine ( mitteX , 0 , mitteX , height ); } String message = ( width < height ) ? \"hoeher : \" : \"breiter : \" ; message = message + \"( \" + width + \", \" + height + \" )\" ; if ( QuadratUndKreis . this . fixed ) { message = \"fixiert\" ; QuadratUndKreis . this . lOben . setFont ( new Font ( \"Verdana\" , Font . BOLD , 14 )); } QuadratUndKreis . this . lOben . setText ( message ); if ( QuadratUndKreis . this . square != null ) { g2 . setColor ( Color . YELLOW ); int x = QuadratUndKreis . this . square . getX (); int y = QuadratUndKreis . this . square . getY (); int length = QuadratUndKreis . this . square . getLength (); g2 . fillRect ( x , y , length , length ); } if ( QuadratUndKreis . this . circle != null ) { g2 . setColor ( Color . GREEN ); int x = QuadratUndKreis . this . circle . getX (); int y = QuadratUndKreis . this . circle . getY (); int length = QuadratUndKreis . this . circle . getLength (); g2 . fillOval ( x , y , length , length ); } } } // ende innere Klasse private JPanel initNorth () { JPanel north = new JPanel (); north . setBackground ( Color . LIGHT_GRAY ); this . lOben = new JLabel (); north . add ( this . lOben ); return north ; } private JPanel initSouth () { JPanel south = new JPanel (); south . setBackground ( Color . LIGHT_GRAY ); JButton btnNew = new JButton ( \"new\" ); btnNew . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { int width = QuadratUndKreis . this . canvas . getWidth (); int height = QuadratUndKreis . this . canvas . getHeight (); if ( width < height ) // hoeher --> untereinander { int height2 = height / 2 ; int smallest = ( height2 < width ) ? height2 : width ; int length = ( int )( smallest * 0.9 ); int oben = ( height2 - length ) / 2 ; int links = ( width - length ) / 2 ; QuadratUndKreis . this . square = new Figure ( links , oben , length ); QuadratUndKreis . this . circle = new Figure ( links , height2 + oben , length ); } else // breiter --> nebeneinander { int width2 = width / 2 ; int smallest = ( width2 < height ) ? width2 : height ; int length = ( int )( smallest * 0.9 ); int links = ( width2 - length ) / 2 ; int oben = ( height - length ) / 2 ; QuadratUndKreis . this . square = new Figure ( links , oben , length ); QuadratUndKreis . this . circle = new Figure ( width2 + links , oben , length ); } QuadratUndKreis . this . canvas . repaint (); QuadratUndKreis . this . squareMoved = false ; QuadratUndKreis . this . circleMoved = false ; QuadratUndKreis . this . fixed = false ; QuadratUndKreis . this . rememberLastPoint = null ; } }); south . add ( btnNew ); return south ; } public static void main ( String [] args ) { new QuadratUndKreis (); } @Override public void mouseDragged ( MouseEvent e ) { if (( QuadratUndKreis . this . circleMoved || QuadratUndKreis . this . squareMoved ) && ! QuadratUndKreis . this . fixed ) { int x = e . getX (); int y = e . getY (); int x1 = QuadratUndKreis . this . rememberLastPoint . x ; int y1 = QuadratUndKreis . this . rememberLastPoint . y ; int xDiff = x - x1 ; int yDiff = y - y1 ; if ( QuadratUndKreis . this . circleMoved ) { int newX = QuadratUndKreis . this . circle . getX () + xDiff ; int newY = QuadratUndKreis . this . circle . getY () + yDiff ; QuadratUndKreis . this . circle . setX ( newX ); QuadratUndKreis . this . circle . setY ( newY ); } else if ( QuadratUndKreis . this . squareMoved ) { int newX = QuadratUndKreis . this . square . getX () + xDiff ; int newY = QuadratUndKreis . this . square . getY () + yDiff ; QuadratUndKreis . this . square . setX ( newX ); QuadratUndKreis . this . square . setY ( newY ); } // ab hier erkennen, ob uebereinander final int ABSTAND = 30 ; int xAbstand = Math . abs ( QuadratUndKreis . this . square . getX () - QuadratUndKreis . this . circle . getX ()); int yAbstand = Math . abs ( QuadratUndKreis . this . square . getY () - QuadratUndKreis . this . circle . getY ()); if ( xAbstand <= ABSTAND && yAbstand <= ABSTAND ) { if ( QuadratUndKreis . this . circleMoved ) { int newX = QuadratUndKreis . this . square . getX (); int newY = QuadratUndKreis . this . square . getY (); QuadratUndKreis . this . circle . setX ( newX ); QuadratUndKreis . this . circle . setY ( newY ); } else if ( QuadratUndKreis . this . squareMoved ) { int newX = QuadratUndKreis . this . circle . getX (); int newY = QuadratUndKreis . this . circle . getY (); QuadratUndKreis . this . square . setX ( newX ); QuadratUndKreis . this . square . setY ( newY ); } QuadratUndKreis . this . fixed = true ; } QuadratUndKreis . this . canvas . repaint (); QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } } @Override public void mouseMoved ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { if ( ! QuadratUndKreis . this . fixed ) { int x = e . getX (); int y = e . getY (); int xC = QuadratUndKreis . this . circle . getX (); int yC = QuadratUndKreis . this . circle . getY (); int xS = QuadratUndKreis . this . square . getX (); int yS = QuadratUndKreis . this . square . getY (); int length = QuadratUndKreis . this . square . getLength (); if ( x >= xC && x <= xC + length && y >= yC && y <= yC + length ) { QuadratUndKreis . this . circleMoved = true ; QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } else if ( x >= xS && x <= xS + length && y >= yS && y <= yS + length ) { QuadratUndKreis . this . squareMoved = true ; QuadratUndKreis . this . rememberLastPoint = e . getPoint (); } } } @Override public void mouseReleased ( MouseEvent e ) { QuadratUndKreis . this . squareMoved = false ; QuadratUndKreis . this . circleMoved = false ; QuadratUndKreis . this . rememberLastPoint = null ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } }","title":"Klausurvorbereitung (Quadrat und Kreis)"},{"location":"uebungen/#klausurvorbereitung-figure","text":"Klausurvorbereitung (Figure) Erstellen Sie folgendes Fenster zum Zeichnen: Dabei ist zu beachten, dass es sich bei Ellipse , - , + , L\u00f6schen und Farbe aendern um Buttons handelt. W\u00e4hlen Sie die Layoutmanager der jeweiligen JPanels so, dass das gleiche Aussehen entsteht, also z.B. der Button Ellipse \u00fcber die gesamte Breite des Fensters geht und die Buttons \u2013 und + jeweils die angezeigte H\u00f6he ausf\u00fcllen. Abst\u00e4nde zwischen den Buttons m\u00fcssen nicht beachtet werden. In der Mitte des Fensters ist die Zeichenfl\u00e4che (Canvas). Implementieren Sie eine Klasse Figure mit folgenden 5 Objektvariablen (m\u00fcssen hier nicht private sein \u2013 Paketsichtbarkeit ist gut; wenn Sie sie private machen, ben\u00f6tigen Sie noch Getter`!!!) Shape shape Color color Point start int width int height Shape ist dabei ein enum , das sie gleich in der Klasse erstellen k\u00f6nnen (oder separat). Dieses enum hat folgende Werte: OVAL und RECTANGLE . Die Idee der Objektvariablen ist in der folgenden Abbildung dargestellt ( color ist nicht gezeigt, damit soll die Figure ausgef\u00fcllt werden): Implementieren Sie eine Objektmethode public void changeColor() , in der der Wert von color zuf\u00e4llig (mithilfe von Random ) auf einen neuen Wert gesetzt wird. Implementieren Sie eine Objektmethode public void setStartPoint(Point point) , in der der Wert der Objektvariablen point auf den Parameterwert gesetzt wird. Implementieren Sie eine Objektmethode public void changeShape() , in der der Wert der Objektvariablen shape auf den jeweils anderen Wert aus dem Shape - enum gesetzt wird (d.h. wenn der Wert OVAL war, dann soll er auf RECTANGLE gesetzt werden und andersherum). Implementieren Sie eine Objektmethode public void addSideLength(int xDiff, int yDiff) . Die Werte von xDiff und yDiff geben an, um wieviel sich die Seitenl\u00e4ngen \u00e4ndern. Erkl\u00e4rung: Diese Methode wird sp\u00e4ter aufgerufen, wenn Sie die Figure mit der Maus zeichnen (bei gedr\u00fcckter Maustaste). Entweder Sie ziehen nach rechts unten (dann sind xDiff und yDiff postiv) oder Sie ziehen nach links und/oder nach oben (dann sind xDiff und/oder yDiff entsprechend negativ). Beachten Sie(!): Wenn xDiff und yDiff postiv sind, dann verh\u00e4lt sich die Sache relativ einfach, denn dann werden die Werte einfach auf die jeweiligen Seitenl\u00e4ngen addiert (siehe folgende Abbildung): Wenn xDiff und/oder yDiff negativ sind/ist, dann ist es komplizierter, denn dann \u00e4ndern sich nicht nur die Seitenl\u00e4ngen, sondern es verschiebt sich auch der Startpunkt der Figure (siehe folgende Abbildung f\u00fcr den Fall, dass xDiff und yDiff negativ sind): Implementieren Sie eine Objektmethode public void bigger() , in der die Figure gr\u00f6\u00dfer skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten): Implementieren Sie eine Objektmethode public void smaller() , in der die Figure kleiner skaliert werden soll (ca 10% abh\u00e4ngig von der aktuellen Breite und L\u00e4nge nach allen Seiten): Implementieren Sie MouseListener und MouseMotionListener so, dass Sie bei gedr\u00fcckter Maustaste ein Objekt der Klasse Figure zeichnen k\u00f6nnen, d.h. bei Mausklick in die Canvas wird der start -Punkt der Figure erzeugt und bei gedr\u00fcckter Maustaste vergr\u00f6\u00dfern Sie die Figure . In der folgenden Abbildung steht der Pfeil f\u00fcr die gedr\u00fcckte Maus: Wenn Sie die Maustaste loslassen, ist die Figure fertig gezeichnet. Am Anfang handelt es sich bei der Figure um ein RECTANGLE`. Implementieren Sie das Klick-Ereignis des Buttons Ellipse so, dass aus dem Rechteck eine Ellipse wird. Die Farbe der Figure bleibt gleich. Nutzen Sie dazu die Methode changeShape() aus der Figure -Klasse. Die Beschriftung des Buttons wechselt auf Rechteck . Wenn Sie den Button erneut dr\u00fccken, erscheint wieder das Rechteck und auf dem Button erscheint Ellipse . Implementieren Sie das Klick-Ereignis des Buttons + so, dass sich die Figure vergr\u00f6\u00dfert. Nutzen Sie dazu die Methode bigger() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons - so, dass sich die Figure verkleinert. Nutzen Sie dazu die Methode smaller() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons Farbe aendern so, dass sich die Farbe der Figure \u00e4ndert. Nutzen Sie dazu die Methode changeColor() aus der Figure -Klasse. Implementieren Sie das Klick-Ereignis des Buttons Loeschen so, dass keine Figure mehr existiert und angezeigt wird. eine m\u00f6gliche L\u00f6sung zu Klausurvorbereitung (Figure) Figure.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.awt.Color ; import java.awt.Point ; import java.util.Random ; public class Figure { enum Shape { OVAL , RECTANGLE } Shape shape ; Color color ; Point start ; int width ; int height ; public Figure ( Shape shape , Point start ) { this . shape = shape ; this . start = start ; this . width = 0 ; this . height = 0 ; Random r = new Random (); int gelb = r . nextInt ( 256 ); int rot = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); this . color = new Color ( rot , gelb , blau ); } public void changeColor () { Random r = new Random (); int gelb = r . nextInt ( 256 ); int rot = r . nextInt ( 256 ); int blau = r . nextInt ( 256 ); this . color = new Color ( rot , gelb , blau ); } public void addSideLengths ( int xDiff , int yDiff ) { if ( xDiff < 0 && yDiff < 0 ) { Point start = this . start ; start . x += xDiff ; start . y += yDiff ; this . width -= xDiff ; this . height -= yDiff ; this . setStartPoint ( start ); } else if ( xDiff < 0 && yDiff >= 0 ) { Point start = this . start ; start . x += xDiff ; this . width -= xDiff ; this . height += yDiff ; this . setStartPoint ( start ); } else if ( xDiff >= 0 && yDiff < 0 ) { Point start = this . start ; start . y += yDiff ; this . width += xDiff ; this . height -= yDiff ; this . setStartPoint ( start ); } else { this . width += xDiff ; this . height += yDiff ; } } public void setStartPoint ( Point start ) { this . start = start ; } public void bigger () { int xScale = ( int )( this . width * 0.1 ); int yScale = ( int )( this . height * 0.1 ); Point start = this . start ; start . x -= xScale ; start . y -= yScale ; this . width += 2 * xScale ; this . height += 2 * yScale ; this . setStartPoint ( start ); } public void smaller () { int xScale = ( int )( this . width * 0.1 ); int yScale = ( int )( this . height * 0.1 ); Point start = this . start ; start . x += xScale ; start . y += yScale ; this . width -= 2 * xScale ; this . height -= 2 * yScale ; this . setStartPoint ( start ); } public void changeShape () { if ( this . shape == Shape . OVAL ) this . shape = Shape . RECTANGLE ; else this . shape = Shape . OVAL ; } } FigureZeichnen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 import java.awt.BorderLayout ; import java.awt.Color ; import java.awt.Graphics ; import java.awt.Graphics2D ; import java.awt.GridLayout ; import java.awt.Point ; import java.awt.event.ActionEvent ; import java.awt.event.ActionListener ; import java.awt.event.MouseEvent ; import java.awt.event.MouseListener ; import java.awt.event.MouseMotionListener ; import javax.swing.* ; public class FigureZeichnen extends JFrame { Canvas canvas ; public FigureZeichnen () { super (); this . setTitle ( \"Klausur\" ); this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); this . canvas = new Canvas (); this . canvas . addMouseListener ( this . canvas ); this . canvas . addMouseMotionListener ( this . canvas ); this . getContentPane (). add ( this . canvas , BorderLayout . CENTER ); // von den folgenden vier Zeilen werden eventuell eine oder mehrere oder alle auskommentiert this . getContentPane (). add ( this . initNorth (), BorderLayout . NORTH ); this . getContentPane (). add ( this . initSouth (), BorderLayout . SOUTH ); this . getContentPane (). add ( this . initWest (), BorderLayout . WEST ); this . getContentPane (). add ( this . initEast (), BorderLayout . EAST ); this . setSize ( 800 , 600 ); this . setLocation ( 300 , 200 ); this . setVisible ( true ); } // start inner class private class Canvas extends JPanel implements MouseListener , MouseMotionListener { Figure figure ; Point remember ; boolean finishedCreating = false ; @Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ); // Implementierung von JPanel aufrufen Graphics2D g2 = ( Graphics2D ) g ; // Methoden von Graphics2D nutzbar if ( this . figure != null ) { g2 . setColor ( this . figure . color ); Point start = this . figure . start ; int width = this . figure . width ; int height = this . figure . height ; if ( this . figure . shape == Figure . Shape . RECTANGLE ) { g2 . fillRect ( start . x , start . y , width , height ); } else if ( this . figure . shape == Figure . Shape . OVAL ) { g2 . fillOval ( start . x , start . y , width , height ); } } } @Override public void mouseDragged ( MouseEvent e ) { if ( this . figure != null && ! this . finishedCreating ) { Point here = e . getPoint (); int xDiff = here . x - this . remember . x ; int yDiff = here . y - this . remember . y ; this . figure . addSideLengths ( xDiff , yDiff ); this . remember = here ; } System . out . println ( this . figure . width + \", \" + this . figure . height ); this . repaint (); } @Override public void mouseMoved ( MouseEvent e ) { } @Override public void mouseClicked ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mousePressed ( MouseEvent e ) { Point here = e . getPoint (); if ( this . figure == null ) { this . figure = new Figure ( Figure . Shape . RECTANGLE , here ); this . remember = here ; } this . repaint (); } @Override public void mouseReleased ( MouseEvent e ) { if ( ! this . finishedCreating ) this . finishedCreating = true ; } @Override public void mouseEntered ( MouseEvent e ) { // TODO Auto-generated method stub } @Override public void mouseExited ( MouseEvent e ) { // TODO Auto-generated method stub } } // ende innere Klasse private JPanel initNorth () { JPanel north = new JPanel (); north . setLayout ( new GridLayout ( 1 , 1 )); JButton circle = new JButton ( \"Ellipse\" ); circle . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . changeShape (); JButton circle = ( JButton ) e . getSource (); if ( circle . getActionCommand (). equals ( \"Ellipse\" )) circle . setText ( \"Rechteck\" ); else circle . setText ( \"Ellipse\" ); Klausur2PZ . this . canvas . repaint (); } }); north . add ( circle ); return north ; } private JPanel initSouth () { JPanel south = new JPanel (); south . setLayout ( new GridLayout ( 1 , 2 , 10 , 10 )); JButton delete = new JButton ( \"L\u00f6schen\" ); delete . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure = null ; Klausur2PZ . this . canvas . finishedCreating = false ; Klausur2PZ . this . canvas . remember = null ; Klausur2PZ . this . canvas . repaint (); } }); south . add ( delete ); JButton farbe = new JButton ( \"Farbe aendern\" ); farbe . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . changeColor ();; Klausur2PZ . this . canvas . repaint (); } }); south . add ( farbe ); return south ; } private JPanel initWest () { JPanel west = new JPanel (); west . setLayout ( new GridLayout ( 1 , 1 )); JButton minus = new JButton ( \"-\" ); minus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . smaller (); Klausur2PZ . this . canvas . repaint (); } }); west . add ( minus ); return west ; } private JPanel initEast () { JPanel east = new JPanel (); east . setLayout ( new GridLayout ( 1 , 1 )); JButton plus = new JButton ( \"+\" ); plus . addActionListener ( new ActionListener () { @Override public void actionPerformed ( ActionEvent e ) { Klausur2PZ . this . canvas . figure . bigger (); Klausur2PZ . this . canvas . repaint (); } }); east . add ( plus ); return east ; } public static void main ( String [] args ) { new Klausur2PZ (); } }","title":"Klausurvorbereitung (Figure)"},{"location":"uebungen/#zusatz","text":"","title":"Zusatz"},{"location":"uebungen/#test-driven-development","text":"parseDouble(String) In der Aufgabe 2 sollen Sie f\u00fcr die Klasse MyInteger eine Methode parseInt(String s) schreiben, die einen String s in eine int -Zahl umwandelt, wenn dies m\u00f6glich ist. In dieser \u00dcbung wollen wir eine solche (statische) Methode parseDouble(String s) f\u00fcr eine Klasse MyDouble testgetrieben entwickeln. \u00dcberlegen Sie sich dazu einige Strings, die Sie umwandeln wollen und die dazugeh\u00f6rigen erwarteten Ergebnisse. Es muss nicht vollst\u00e4ndig implementiert werden. Es geht ums Prinzip. Mithilfe von assertThrows() k\u00f6nnen Sie \u00fcbrigens pr\u00fcfen, ob eine Exception geworfen wird (wenn s keiner Zahl entspricht) - siehe dazu z.B. hier oder hier . Viel Spa\u00df!","title":"Test-driven development"},{"location":"wiederholung/","text":"Wiederholung \u00b6 Datentypen \u00b6 Wertetypen \u00b6 es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!! Referenztypen \u00b6 es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? } Datenstrukturen \u00b6 Variablen \u00b6 einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden } Arrays \u00b6 Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0 Literale \u00b6 sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5 Ausdr\u00fccke \u00b6 kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, . Anweisungen \u00b6 Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; } Methoden \u00b6 wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); } Vererbung \u00b6 Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden Konstruktoren \u00b6 besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 } Access Controller (Zugriffsmodifizierer) \u00b6 Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse \"Kleinigkeiten\", die wir nicht betrachtet haben \u00b6 Das Schl\u00fcsselwort static \u00b6 Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen. Die for-each -Schleife \u00b6 Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ). Die Klasse java.util.Arrays \u00b6 Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Wiederholung"},{"location":"wiederholung/#wiederholung","text":"","title":"Wiederholung"},{"location":"wiederholung/#datentypen","text":"","title":"Datentypen"},{"location":"wiederholung/#wertetypen","text":"es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!!","title":"Wertetypen"},{"location":"wiederholung/#referenztypen","text":"es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? }","title":"Referenztypen"},{"location":"wiederholung/#datenstrukturen","text":"","title":"Datenstrukturen"},{"location":"wiederholung/#variablen","text":"einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden }","title":"Variablen"},{"location":"wiederholung/#arrays","text":"Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0","title":"Arrays"},{"location":"wiederholung/#literale","text":"sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5","title":"Literale"},{"location":"wiederholung/#ausdrucke","text":"kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, .","title":"Ausdr\u00fccke"},{"location":"wiederholung/#anweisungen","text":"Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; }","title":"Anweisungen"},{"location":"wiederholung/#methoden","text":"wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); }","title":"Methoden"},{"location":"wiederholung/#vererbung","text":"Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererbung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden","title":"Vererbung"},{"location":"wiederholung/#konstruktoren","text":"besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 }","title":"Konstruktoren"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","text":"Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse","title":"Access Controller (Zugriffsmodifizierer)"},{"location":"wiederholung/#kleinigkeiten-die-wir-nicht-betrachtet-haben","text":"","title":"\"Kleinigkeiten\", die wir nicht betrachtet haben"},{"location":"wiederholung/#das-schlusselwort-static","text":"Mit dem Schl\u00fcsselwort static beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort static kann verwendet werden f\u00fcr Die Deklaration einer ( Klassen- )Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable). Die Deklaration einer ( Klassen- )Methode. Eine statische Methode ( Klassenmethode ) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der main() -Methode) erstellen, um diese in der main() -Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen. Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter. Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen.","title":"Das Schl\u00fcsselwort static"},{"location":"wiederholung/#die-for-each-schleife","text":"Wir haben ein Array stets so durchlaufen, dass wir in einer for -Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int index = 0 ; index < args . length ; index ++ ) { System . out . print ( numbers [ index ] ); } Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen: int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { System . out . print ( number ); } Wir bezeichnen diese Schleifensyntax auch als for-each -Schleife. Die allgemeine Syntax ist for ( TypElement variablenNameElement : nameDesArrays ) { // hier lesende Verwendung von variablenNameElement } Beachten Sie, dass Sie mit der for-each -Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( int number : numbers ) { number = 5 ; } , dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken ( Setter ).","title":"Die for-each-Schleife"},{"location":"wiederholung/#die-klasse-javautilarrays","text":"Die Klasse Arrays aus dem java.util -Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die toString() -Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen toString() -Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse Arrays finden Sie z.B. hier . Beachten Sie, dass Sie zum Verwenden der Klasse das java.util -Paket importieren m\u00fcssen. int [] numbers = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; System . out . println ( Arrays . toString ( numbers )); Weitere interessante Methoden dieser Klasse sind copyOf() , binarySearch() und sort() . \u00dcbung Ist die toString() -Methode der Arrays -Klasse statisch oder handelt es sich um eine Objektmethode?","title":"Die Klasse java.util.Arrays"},{"location":"wrapper/","text":"Wrapper-Klassen \u00b6 Motivation Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen String zu einem int (oder double ) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen . In Programmierung I haben wir am Anfang die Datentypen int , boolean , double , char , long usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen , welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character Objekterzeugung \u00b6 Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen. Verwendung des Kontruktors - deprecated \u00b6 F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden. Die valueOf() -Methoden \u00b6 Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenname.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich. Auto-Boxing \u00b6 Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 ); Werte extrahieren \u00b6 H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse<WrapperTyp> -Methode verwendet wird. Strings in Wertetypen \u00b6 Wir wissen jetzt schon, dass wir uns mithilfe der valueOf(String s) -Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von intValue() k\u00f6nnte man z.B. aus einem Intger -Objekt den int -Wert extrahieren. Das ginge auch mit Auto-Unboxing . F\u00fcr die Umwandlung von String nach int verwendet man aber am besten die parseInt() -Methode. String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); int zahl = Integer . parseInt ( eingabe ); F\u00fcr double steht uns daf\u00fcr Double.parseDouble(String s) zur Verf\u00fcgung usw. Success Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen String in einen int umwandeln! Wir kennen nun Wrapper-Klassen und deren parseXXX(String) -Methoden. Links zu den Java-Docs \u00b6 Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die parseInt(String) -Methode werfen? Ausblick \u00b6 Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?","title":"Wrapperklassen"},{"location":"wrapper/#wrapper-klassen","text":"Motivation Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen String zu einem int (oder double ) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen . In Programmierung I haben wir am Anfang die Datentypen int , boolean , double , char , long usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen , welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character","title":"Wrapper-Klassen"},{"location":"wrapper/#objekterzeugung","text":"Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen.","title":"Objekterzeugung"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","text":"F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden.","title":"Verwendung des Kontruktors - deprecated"},{"location":"wrapper/#die-valueof-methoden","text":"Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenname.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich.","title":"Die valueOf()-Methoden"},{"location":"wrapper/#auto-boxing","text":"Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 );","title":"Auto-Boxing"},{"location":"wrapper/#werte-extrahieren","text":"H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse<WrapperTyp> -Methode verwendet wird.","title":"Werte extrahieren"},{"location":"wrapper/#strings-in-wertetypen","text":"Wir wissen jetzt schon, dass wir uns mithilfe der valueOf(String s) -Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von intValue() k\u00f6nnte man z.B. aus einem Intger -Objekt den int -Wert extrahieren. Das ginge auch mit Auto-Unboxing . F\u00fcr die Umwandlung von String nach int verwendet man aber am besten die parseInt() -Methode. String eingabe = JOptionPane . showInputDialog ( \"Geben Sie eine Zahl ein: \" ); int zahl = Integer . parseInt ( eingabe ); F\u00fcr double steht uns daf\u00fcr Double.parseDouble(String s) zur Verf\u00fcgung usw. Success Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen String in einen int umwandeln! Wir kennen nun Wrapper-Klassen und deren parseXXX(String) -Methoden.","title":"Strings in Wertetypen"},{"location":"wrapper/#links-zu-den-java-docs","text":"Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die parseInt(String) -Methode werfen?","title":"Links zu den Java-Docs"},{"location":"wrapper/#ausblick","text":"Wir wissen nun, wie wir einen String in ein int umwandeln. N\u00e4mlich mithilfe der parseInt(String) -Methode der Klasse Integer . Was aber passiert, wenn der String gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?","title":"Ausblick"}]}